   1              		.file	"main.c"
   2              		.text
   3              	.Ltext0:
   4              		.comm	dataFromCSV,1600080,32
   5              		.globl	numLines
   6              		.bss
   7              		.align 4
  10              	numLines:
  11 0000 00000000 		.zero	4
  12              		.globl	LOG
  15              	LOG:
  16 0004 00       		.zero	1
  17              		.globl	bankID
  18              		.data
  19              		.align 4
  22              	bankID:
  23 0000 FFFFFFFF 		.long	-1
  24              		.globl	maxAmountCanBeDispensed
  25              		.align 4
  28              	maxAmountCanBeDispensed:
  29 0004 FFFFFFFF 		.long	-1
  30              		.globl	max2000Limit
  33              	max2000Limit:
  34 0008 FF       		.byte	-1
  35              		.globl	max1000Limit
  38              	max1000Limit:
  39 0009 FF       		.byte	-1
  40              		.globl	max500Limit
  43              	max500Limit:
  44 000a FF       		.byte	-1
  45              		.globl	max100Limit
  48              	max100Limit:
  49 000b FF       		.byte	-1
  50              		.text
  51              		.globl	decrypt
  53              	decrypt:
  54              	.LFB6:
  55              		.file 1 "main.c"
   1:main.c        **** /*
   2:main.c        ****    If the user is an admin : 
   3:main.c        ****    Original 64 bit -> | User ID 16-bit | Password 16-bit | 2k 8-bit | 1k 8-bit | 500 8-bit | 100 8-
   4:main.c        ****    (in VHDL before encryption)  8 7 6 5 4 3 2 1
   5:main.c        **** 
   6:main.c        ****    If the user is an accountee : 
   7:main.c        ****    Original 64 bit -> | User ID 16-bit | Password 16-bit | Amount in 32 bit |
   8:main.c        ****    (in VHDL before encryption)  8 7 6 5 4 3 2 1
   9:main.c        **** 
  10:main.c        ****    User ID 16-bit -> Least 5 significant bits indicate bankID
  11:main.c        **** */
  12:main.c        **** 
  13:main.c        **** #define _GNU_SOURCE
  14:main.c        **** 
  15:main.c        **** #include <stdint.h>
  16:main.c        **** #include <stdbool.h>
  17:main.c        **** #include <stdio.h>
  18:main.c        **** #include <stdlib.h>
  19:main.c        **** #include <argtable2.h>
  20:main.c        **** #include <string.h>
  21:main.c        **** #include <libfpgalink.h>
  22:main.c        **** #include <errno.h>
  23:main.c        **** #include <makestuff.h>
  24:main.c        **** #include <libbuffer.h>
  25:main.c        **** #include <liberror.h>
  26:main.c        **** #include <libdump.h>
  27:main.c        **** #include <readline/readline.h>
  28:main.c        **** #include <readline/history.h>
  29:main.c        **** 
  30:main.c        **** #ifdef WIN32
  31:main.c        **** #include <Windows.h>
  32:main.c        **** #else
  33:main.c        **** #include <sys/time.h>
  34:main.c        **** #endif
  35:main.c        **** 
  36:main.c        **** #define N 100005
  37:main.c        **** #define M (((ll)1 << 32)-1)
  38:main.c        **** #define maxNotes 255
  39:main.c        **** #define ll long long
  40:main.c        **** 
  41:main.c        **** int dataFromCSV[N][4];
  42:main.c        **** int numLines = 0;
  43:main.c        **** bool LOG = false;
  44:main.c        **** int bankID = -1;
  45:main.c        **** uint32_t maxAmountCanBeDispensed = M;
  46:main.c        **** uint8_t max2000Limit = maxNotes, max1000Limit = maxNotes, max500Limit = maxNotes, max100Limit = max
  47:main.c        **** 
  48:main.c        **** /* Adapted from tiny encryption algorithm wikipedia */
  49:main.c        **** void decrypt(uint32_t *v, uint32_t *k) {
  56              		.loc 1 49 0
  57              		.cfi_startproc
  58 0000 55       		pushq	%rbp
  59              		.cfi_def_cfa_offset 16
  60              		.cfi_offset 6, -16
  61 0001 4889E5   		movq	%rsp, %rbp
  62              		.cfi_def_cfa_register 6
  63 0004 48897DC8 		movq	%rdi, -56(%rbp)
  64 0008 488975C0 		movq	%rsi, -64(%rbp)
  50:main.c        ****     uint32_t v0 = v[0], v1 = v[1], sum = 0xC6EF3720, i;  /* set up */
  65              		.loc 1 50 0
  66 000c 488B45C8 		movq	-56(%rbp), %rax
  67 0010 8B00     		movl	(%rax), %eax
  68 0012 8945DC   		movl	%eax, -36(%rbp)
  69 0015 488B45C8 		movq	-56(%rbp), %rax
  70 0019 8B4004   		movl	4(%rax), %eax
  71 001c 8945E0   		movl	%eax, -32(%rbp)
  72 001f C745E420 		movl	$-957401312, -28(%rbp)
  72      37EFC6
  51:main.c        ****     uint32_t delta = 0x9e3779b9;                     /* a key schedule constant */
  73              		.loc 1 51 0
  74 0026 C745ECB9 		movl	$-1640531527, -20(%rbp)
  74      79379E
  52:main.c        ****     uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3];   /* cache key */
  75              		.loc 1 52 0
  76 002d 488B45C0 		movq	-64(%rbp), %rax
  77 0031 8B00     		movl	(%rax), %eax
  78 0033 8945F0   		movl	%eax, -16(%rbp)
  79 0036 488B45C0 		movq	-64(%rbp), %rax
  80 003a 8B4004   		movl	4(%rax), %eax
  81 003d 8945F4   		movl	%eax, -12(%rbp)
  82 0040 488B45C0 		movq	-64(%rbp), %rax
  83 0044 8B4008   		movl	8(%rax), %eax
  84 0047 8945F8   		movl	%eax, -8(%rbp)
  85 004a 488B45C0 		movq	-64(%rbp), %rax
  86 004e 8B400C   		movl	12(%rax), %eax
  87 0051 8945FC   		movl	%eax, -4(%rbp)
  53:main.c        ****     /* basic cycle start */
  54:main.c        ****     for (i = 0; i < 32; i++) {
  88              		.loc 1 54 0
  89 0054 C745E800 		movl	$0, -24(%rbp)
  89      000000
  90 005b EB62     		jmp	.L2
  91              	.L3:
  55:main.c        ****         v1 -= ((v0 << 4) + k2) ^ (v0 + sum) ^ ((v0 >> 5) + k3);
  92              		.loc 1 55 0 discriminator 2
  93 005d 8B45DC   		movl	-36(%rbp), %eax
  94 0060 C1E004   		sall	$4, %eax
  95 0063 89C2     		movl	%eax, %edx
  96 0065 8B45F8   		movl	-8(%rbp), %eax
  97 0068 8D0C02   		leal	(%rdx,%rax), %ecx
  98 006b 8B45E4   		movl	-28(%rbp), %eax
  99 006e 8B55DC   		movl	-36(%rbp), %edx
 100 0071 01D0     		addl	%edx, %eax
 101 0073 31C1     		xorl	%eax, %ecx
 102 0075 89CA     		movl	%ecx, %edx
 103 0077 8B45DC   		movl	-36(%rbp), %eax
 104 007a C1E805   		shrl	$5, %eax
 105 007d 89C1     		movl	%eax, %ecx
 106 007f 8B45FC   		movl	-4(%rbp), %eax
 107 0082 01C8     		addl	%ecx, %eax
 108 0084 31D0     		xorl	%edx, %eax
 109 0086 2945E0   		subl	%eax, -32(%rbp)
  56:main.c        ****         v0 -= ((v1 << 4) + k0) ^ (v1 + sum) ^ ((v1 >> 5) + k1);
 110              		.loc 1 56 0 discriminator 2
 111 0089 8B45E0   		movl	-32(%rbp), %eax
 112 008c C1E004   		sall	$4, %eax
 113 008f 89C2     		movl	%eax, %edx
 114 0091 8B45F0   		movl	-16(%rbp), %eax
 115 0094 8D0C02   		leal	(%rdx,%rax), %ecx
 116 0097 8B45E4   		movl	-28(%rbp), %eax
 117 009a 8B55E0   		movl	-32(%rbp), %edx
 118 009d 01D0     		addl	%edx, %eax
 119 009f 31C1     		xorl	%eax, %ecx
 120 00a1 89CA     		movl	%ecx, %edx
 121 00a3 8B45E0   		movl	-32(%rbp), %eax
 122 00a6 C1E805   		shrl	$5, %eax
 123 00a9 89C1     		movl	%eax, %ecx
 124 00ab 8B45F4   		movl	-12(%rbp), %eax
 125 00ae 01C8     		addl	%ecx, %eax
 126 00b0 31D0     		xorl	%edx, %eax
 127 00b2 2945DC   		subl	%eax, -36(%rbp)
  57:main.c        ****         sum -= delta;
 128              		.loc 1 57 0 discriminator 2
 129 00b5 8B45EC   		movl	-20(%rbp), %eax
 130 00b8 2945E4   		subl	%eax, -28(%rbp)
  54:main.c        ****         v1 -= ((v0 << 4) + k2) ^ (v0 + sum) ^ ((v0 >> 5) + k3);
 131              		.loc 1 54 0 discriminator 2
 132 00bb 8345E801 		addl	$1, -24(%rbp)
 133              	.L2:
  54:main.c        ****         v1 -= ((v0 << 4) + k2) ^ (v0 + sum) ^ ((v0 >> 5) + k3);
 134              		.loc 1 54 0 is_stmt 0 discriminator 1
 135 00bf 837DE81F 		cmpl	$31, -24(%rbp)
 136 00c3 7698     		jbe	.L3
  58:main.c        ****     }
  59:main.c        ****     /* end cycle */
  60:main.c        ****     v[0] = v0;
 137              		.loc 1 60 0 is_stmt 1
 138 00c5 488B45C8 		movq	-56(%rbp), %rax
 139 00c9 8B55DC   		movl	-36(%rbp), %edx
 140 00cc 8910     		movl	%edx, (%rax)
  61:main.c        ****     v[1] = v1;
 141              		.loc 1 61 0
 142 00ce 488B45C8 		movq	-56(%rbp), %rax
 143 00d2 488D5004 		leaq	4(%rax), %rdx
 144 00d6 8B45E0   		movl	-32(%rbp), %eax
 145 00d9 8902     		movl	%eax, (%rdx)
  62:main.c        **** }
 146              		.loc 1 62 0
 147 00db 5D       		popq	%rbp
 148              		.cfi_def_cfa 7, 8
 149 00dc C3       		ret
 150              		.cfi_endproc
 151              	.LFE6:
 153              		.globl	encrypt
 155              	encrypt:
 156              	.LFB7:
  63:main.c        **** 
  64:main.c        **** /* Adapted from tiny encryption algorithm wikipedia */
  65:main.c        **** void encrypt(uint32_t *v, uint32_t *k) {
 157              		.loc 1 65 0
 158              		.cfi_startproc
 159 00dd 55       		pushq	%rbp
 160              		.cfi_def_cfa_offset 16
 161              		.cfi_offset 6, -16
 162 00de 4889E5   		movq	%rsp, %rbp
 163              		.cfi_def_cfa_register 6
 164 00e1 48897DC8 		movq	%rdi, -56(%rbp)
 165 00e5 488975C0 		movq	%rsi, -64(%rbp)
  66:main.c        ****     uint32_t v0 = v[0], v1 = v[1], sum = 0, i;           /* set up */
 166              		.loc 1 66 0
 167 00e9 488B45C8 		movq	-56(%rbp), %rax
 168 00ed 8B00     		movl	(%rax), %eax
 169 00ef 8945DC   		movl	%eax, -36(%rbp)
 170 00f2 488B45C8 		movq	-56(%rbp), %rax
 171 00f6 8B4004   		movl	4(%rax), %eax
 172 00f9 8945E0   		movl	%eax, -32(%rbp)
 173 00fc C745E400 		movl	$0, -28(%rbp)
 173      000000
  67:main.c        ****     uint32_t delta = 0x9e3779b9;                     /* a key schedule constant */
 174              		.loc 1 67 0
 175 0103 C745ECB9 		movl	$-1640531527, -20(%rbp)
 175      79379E
  68:main.c        ****     uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3];   /* cache key */
 176              		.loc 1 68 0
 177 010a 488B45C0 		movq	-64(%rbp), %rax
 178 010e 8B00     		movl	(%rax), %eax
 179 0110 8945F0   		movl	%eax, -16(%rbp)
 180 0113 488B45C0 		movq	-64(%rbp), %rax
 181 0117 8B4004   		movl	4(%rax), %eax
 182 011a 8945F4   		movl	%eax, -12(%rbp)
 183 011d 488B45C0 		movq	-64(%rbp), %rax
 184 0121 8B4008   		movl	8(%rax), %eax
 185 0124 8945F8   		movl	%eax, -8(%rbp)
 186 0127 488B45C0 		movq	-64(%rbp), %rax
 187 012b 8B400C   		movl	12(%rax), %eax
 188 012e 8945FC   		movl	%eax, -4(%rbp)
  69:main.c        ****     /* basic cycle start */
  70:main.c        ****     for (i = 0; i < 32; i++) {
 189              		.loc 1 70 0
 190 0131 C745E800 		movl	$0, -24(%rbp)
 190      000000
 191 0138 EB62     		jmp	.L5
 192              	.L6:
  71:main.c        ****         sum += delta;
 193              		.loc 1 71 0 discriminator 2
 194 013a 8B45EC   		movl	-20(%rbp), %eax
 195 013d 0145E4   		addl	%eax, -28(%rbp)
  72:main.c        ****         v0 += ((v1 << 4) + k0) ^ (v1 + sum) ^ ((v1 >> 5) + k1);
 196              		.loc 1 72 0 discriminator 2
 197 0140 8B45E0   		movl	-32(%rbp), %eax
 198 0143 C1E004   		sall	$4, %eax
 199 0146 89C2     		movl	%eax, %edx
 200 0148 8B45F0   		movl	-16(%rbp), %eax
 201 014b 8D0C02   		leal	(%rdx,%rax), %ecx
 202 014e 8B45E4   		movl	-28(%rbp), %eax
 203 0151 8B55E0   		movl	-32(%rbp), %edx
 204 0154 01D0     		addl	%edx, %eax
 205 0156 31C1     		xorl	%eax, %ecx
 206 0158 89CA     		movl	%ecx, %edx
 207 015a 8B45E0   		movl	-32(%rbp), %eax
 208 015d C1E805   		shrl	$5, %eax
 209 0160 89C1     		movl	%eax, %ecx
 210 0162 8B45F4   		movl	-12(%rbp), %eax
 211 0165 01C8     		addl	%ecx, %eax
 212 0167 31D0     		xorl	%edx, %eax
 213 0169 0145DC   		addl	%eax, -36(%rbp)
  73:main.c        ****         v1 += ((v0 << 4) + k2) ^ (v0 + sum) ^ ((v0 >> 5) + k3);
 214              		.loc 1 73 0 discriminator 2
 215 016c 8B45DC   		movl	-36(%rbp), %eax
 216 016f C1E004   		sall	$4, %eax
 217 0172 89C2     		movl	%eax, %edx
 218 0174 8B45F8   		movl	-8(%rbp), %eax
 219 0177 8D0C02   		leal	(%rdx,%rax), %ecx
 220 017a 8B45E4   		movl	-28(%rbp), %eax
 221 017d 8B55DC   		movl	-36(%rbp), %edx
 222 0180 01D0     		addl	%edx, %eax
 223 0182 31C1     		xorl	%eax, %ecx
 224 0184 89CA     		movl	%ecx, %edx
 225 0186 8B45DC   		movl	-36(%rbp), %eax
 226 0189 C1E805   		shrl	$5, %eax
 227 018c 89C1     		movl	%eax, %ecx
 228 018e 8B45FC   		movl	-4(%rbp), %eax
 229 0191 01C8     		addl	%ecx, %eax
 230 0193 31D0     		xorl	%edx, %eax
 231 0195 0145E0   		addl	%eax, -32(%rbp)
  70:main.c        ****         sum += delta;
 232              		.loc 1 70 0 discriminator 2
 233 0198 8345E801 		addl	$1, -24(%rbp)
 234              	.L5:
  70:main.c        ****         sum += delta;
 235              		.loc 1 70 0 is_stmt 0 discriminator 1
 236 019c 837DE81F 		cmpl	$31, -24(%rbp)
 237 01a0 7698     		jbe	.L6
  74:main.c        ****     }
  75:main.c        ****     /* end cycle */
  76:main.c        ****     v[0] = v0;
 238              		.loc 1 76 0 is_stmt 1
 239 01a2 488B45C8 		movq	-56(%rbp), %rax
 240 01a6 8B55DC   		movl	-36(%rbp), %edx
 241 01a9 8910     		movl	%edx, (%rax)
  77:main.c        ****     v[1] = v1;
 242              		.loc 1 77 0
 243 01ab 488B45C8 		movq	-56(%rbp), %rax
 244 01af 488D5004 		leaq	4(%rax), %rdx
 245 01b3 8B45E0   		movl	-32(%rbp), %eax
 246 01b6 8902     		movl	%eax, (%rdx)
  78:main.c        **** }
 247              		.loc 1 78 0
 248 01b8 5D       		popq	%rbp
 249              		.cfi_def_cfa 7, 8
 250 01b9 C3       		ret
 251              		.cfi_endproc
 252              	.LFE7:
 254              		.globl	decrypt64
 256              	decrypt64:
 257              	.LFB8:
  79:main.c        **** 
  80:main.c        **** void decrypt64(uint32_t *inpData) {
 258              		.loc 1 80 0
 259              		.cfi_startproc
 260 01ba 55       		pushq	%rbp
 261              		.cfi_def_cfa_offset 16
 262              		.cfi_offset 6, -16
 263 01bb 4889E5   		movq	%rsp, %rbp
 264              		.cfi_def_cfa_register 6
 265 01be 4883EC18 		subq	$24, %rsp
 266 01c2 48897DE8 		movq	%rdi, -24(%rbp)
  81:main.c        ****     uint32_t key[4];
  82:main.c        ****     key[0] = 0x2927c18c;
 267              		.loc 1 82 0
 268 01c6 C745F08C 		movl	$690471308, -16(%rbp)
 268      C12729
  83:main.c        ****     key[1] = 0x75f8c48f;
 269              		.loc 1 83 0
 270 01cd C745F48F 		movl	$1979237519, -12(%rbp)
 270      C4F875
  84:main.c        ****     key[2] = 0x43fd99f7;
 271              		.loc 1 84 0
 272 01d4 C745F8F7 		movl	$1140693495, -8(%rbp)
 272      99FD43
  85:main.c        ****     key[3] = 0xff0f7457;
 273              		.loc 1 85 0
 274 01db C745FC57 		movl	$-15764393, -4(%rbp)
 274      740FFF
  86:main.c        ****     decrypt(inpData, key);
 275              		.loc 1 86 0
 276 01e2 488D55F0 		leaq	-16(%rbp), %rdx
 277 01e6 488B45E8 		movq	-24(%rbp), %rax
 278 01ea 4889D6   		movq	%rdx, %rsi
 279 01ed 4889C7   		movq	%rax, %rdi
 280 01f0 E8000000 		call	decrypt
 280      00
  87:main.c        **** }
 281              		.loc 1 87 0
 282 01f5 C9       		leave
 283              		.cfi_def_cfa 7, 8
 284 01f6 C3       		ret
 285              		.cfi_endproc
 286              	.LFE8:
 288              		.globl	encrypt64
 290              	encrypt64:
 291              	.LFB9:
  88:main.c        **** 
  89:main.c        **** void encrypt64(uint32_t *inpData) {
 292              		.loc 1 89 0
 293              		.cfi_startproc
 294 01f7 55       		pushq	%rbp
 295              		.cfi_def_cfa_offset 16
 296              		.cfi_offset 6, -16
 297 01f8 4889E5   		movq	%rsp, %rbp
 298              		.cfi_def_cfa_register 6
 299 01fb 4883EC18 		subq	$24, %rsp
 300 01ff 48897DE8 		movq	%rdi, -24(%rbp)
  90:main.c        ****     uint32_t key[4];
  91:main.c        ****     key[0] = 0x2927c18c;
 301              		.loc 1 91 0
 302 0203 C745F08C 		movl	$690471308, -16(%rbp)
 302      C12729
  92:main.c        ****     key[1] = 0x75f8c48f;
 303              		.loc 1 92 0
 304 020a C745F48F 		movl	$1979237519, -12(%rbp)
 304      C4F875
  93:main.c        ****     key[2] = 0x43fd99f7;
 305              		.loc 1 93 0
 306 0211 C745F8F7 		movl	$1140693495, -8(%rbp)
 306      99FD43
  94:main.c        ****     key[3] = 0xff0f7457;
 307              		.loc 1 94 0
 308 0218 C745FC57 		movl	$-15764393, -4(%rbp)
 308      740FFF
  95:main.c        ****     encrypt(inpData, key);
 309              		.loc 1 95 0
 310 021f 488D55F0 		leaq	-16(%rbp), %rdx
 311 0223 488B45E8 		movq	-24(%rbp), %rax
 312 0227 4889D6   		movq	%rdx, %rsi
 313 022a 4889C7   		movq	%rax, %rdi
 314 022d E8000000 		call	encrypt
 314      00
  96:main.c        **** }
 315              		.loc 1 96 0
 316 0232 C9       		leave
 317              		.cfi_def_cfa 7, 8
 318 0233 C3       		ret
 319              		.cfi_endproc
 320              	.LFE9:
 322              		.globl	myHash
 324              	myHash:
 325              	.LFB10:
  97:main.c        **** 
  98:main.c        **** uint16_t myHash(uint16_t befHash) {
 326              		.loc 1 98 0
 327              		.cfi_startproc
 328 0234 55       		pushq	%rbp
 329              		.cfi_def_cfa_offset 16
 330              		.cfi_offset 6, -16
 331 0235 4889E5   		movq	%rsp, %rbp
 332              		.cfi_def_cfa_register 6
 333 0238 89F8     		movl	%edi, %eax
 334 023a 668945EC 		movw	%ax, -20(%rbp)
  99:main.c        ****     uint16_t ret = 0;
 335              		.loc 1 99 0
 336 023e 66C745F8 		movw	$0, -8(%rbp)
 336      0000
 337              	.LBB2:
 100:main.c        ****     for (uint16_t i = 0; i <= 15; i++) {
 338              		.loc 1 100 0
 339 0244 66C745FA 		movw	$0, -6(%rbp)
 339      0000
 340 024a EB51     		jmp	.L10
 341              	.L12:
 101:main.c        ****         if ((befHash & (1 << i)) != 0) {
 342              		.loc 1 101 0
 343 024c 0FB755EC 		movzwl	-20(%rbp), %edx
 344 0250 0FB745FA 		movzwl	-6(%rbp), %eax
 345 0254 89C1     		movl	%eax, %ecx
 346 0256 D3FA     		sarl	%cl, %edx
 347 0258 89D0     		movl	%edx, %eax
 348 025a 83E001   		andl	$1, %eax
 349 025d 85C0     		testl	%eax, %eax
 350 025f 7431     		je	.L11
 351              	.LBB3:
 102:main.c        ****             uint16_t leftShift = (uint16_t)bankID % 16;
 352              		.loc 1 102 0
 353 0261 8B050000 		movl	bankID(%rip), %eax
 353      0000
 354 0267 83E00F   		andl	$15, %eax
 355 026a 668945FC 		movw	%ax, -4(%rbp)
 103:main.c        ****             uint16_t j = ((i + leftShift) % 16);
 356              		.loc 1 103 0
 357 026e 0FB745FC 		movzwl	-4(%rbp), %eax
 358 0272 0FB755FA 		movzwl	-6(%rbp), %edx
 359 0276 01D0     		addl	%edx, %eax
 360 0278 83E00F   		andl	$15, %eax
 361 027b 668945FE 		movw	%ax, -2(%rbp)
 104:main.c        ****             ret += (1 << j);
 362              		.loc 1 104 0
 363 027f 0FB745FE 		movzwl	-2(%rbp), %eax
 364 0283 BA010000 		movl	$1, %edx
 364      00
 365 0288 89C1     		movl	%eax, %ecx
 366 028a D3E2     		sall	%cl, %edx
 367 028c 89D0     		movl	%edx, %eax
 368 028e 660145F8 		addw	%ax, -8(%rbp)
 369              	.L11:
 370              	.LBE3:
 100:main.c        ****         if ((befHash & (1 << i)) != 0) {
 371              		.loc 1 100 0
 372 0292 0FB745FA 		movzwl	-6(%rbp), %eax
 373 0296 83C001   		addl	$1, %eax
 374 0299 668945FA 		movw	%ax, -6(%rbp)
 375              	.L10:
 100:main.c        ****         if ((befHash & (1 << i)) != 0) {
 376              		.loc 1 100 0 is_stmt 0 discriminator 1
 377 029d 66837DFA 		cmpw	$15, -6(%rbp)
 377      0F
 378 02a2 76A8     		jbe	.L12
 379              	.LBE2:
 105:main.c        ****         }
 106:main.c        ****     }
 107:main.c        ****     return ret;
 380              		.loc 1 107 0 is_stmt 1
 381 02a4 0FB745F8 		movzwl	-8(%rbp), %eax
 108:main.c        **** }
 382              		.loc 1 108 0
 383 02a8 5D       		popq	%rbp
 384              		.cfi_def_cfa 7, 8
 385 02a9 C3       		ret
 386              		.cfi_endproc
 387              	.LFE10:
 389              		.section	.rodata
 390              	.LC0:
 391 0000 2C00     		.string	","
 392              	.LC1:
 393 0002 256400   		.string	"%d"
 394              		.text
 395              		.globl	format
 397              	format:
 398              	.LFB11:
 109:main.c        **** 
 110:main.c        **** void format(char *line) {
 399              		.loc 1 110 0
 400              		.cfi_startproc
 401 02aa 55       		pushq	%rbp
 402              		.cfi_def_cfa_offset 16
 403              		.cfi_offset 6, -16
 404 02ab 4889E5   		movq	%rsp, %rbp
 405              		.cfi_def_cfa_register 6
 406 02ae 4883EC20 		subq	$32, %rsp
 407 02b2 48897DE8 		movq	%rdi, -24(%rbp)
 111:main.c        ****     char *wordPtr;
 112:main.c        ****     wordPtr = strtok(line, ",");
 408              		.loc 1 112 0
 409 02b6 488B45E8 		movq	-24(%rbp), %rax
 410 02ba BE000000 		movl	$.LC0, %esi
 410      00
 411 02bf 4889C7   		movq	%rax, %rdi
 412 02c2 E8000000 		call	strtok
 412      00
 413 02c7 488945F8 		movq	%rax, -8(%rbp)
 113:main.c        ****     int cnt = 0;
 414              		.loc 1 113 0
 415 02cb C745F400 		movl	$0, -12(%rbp)
 415      000000
 114:main.c        ****     while (wordPtr != NULL) {
 416              		.loc 1 114 0
 417 02d2 EB4D     		jmp	.L15
 418              	.L16:
 115:main.c        ****         sscanf(wordPtr, "%d", &dataFromCSV[numLines][cnt]);
 419              		.loc 1 115 0
 420 02d4 8B150000 		movl	numLines(%rip), %edx
 420      0000
 421 02da 8B45F4   		movl	-12(%rbp), %eax
 422 02dd 4898     		cltq
 423 02df 4863D2   		movslq	%edx, %rdx
 424 02e2 48C1E202 		salq	$2, %rdx
 425 02e6 4801D0   		addq	%rdx, %rax
 426 02e9 48C1E002 		salq	$2, %rax
 427 02ed 488D9000 		leaq	dataFromCSV(%rax), %rdx
 427      000000
 428 02f4 488B45F8 		movq	-8(%rbp), %rax
 429 02f8 BE000000 		movl	$.LC1, %esi
 429      00
 430 02fd 4889C7   		movq	%rax, %rdi
 431 0300 B8000000 		movl	$0, %eax
 431      00
 432 0305 E8000000 		call	sscanf
 432      00
 116:main.c        ****         wordPtr = strtok(NULL, ",");
 433              		.loc 1 116 0
 434 030a BE000000 		movl	$.LC0, %esi
 434      00
 435 030f BF000000 		movl	$0, %edi
 435      00
 436 0314 E8000000 		call	strtok
 436      00
 437 0319 488945F8 		movq	%rax, -8(%rbp)
 117:main.c        ****         cnt++;
 438              		.loc 1 117 0
 439 031d 8345F401 		addl	$1, -12(%rbp)
 440              	.L15:
 114:main.c        ****         sscanf(wordPtr, "%d", &dataFromCSV[numLines][cnt]);
 441              		.loc 1 114 0 discriminator 1
 442 0321 48837DF8 		cmpq	$0, -8(%rbp)
 442      00
 443 0326 75AC     		jne	.L16
 118:main.c        ****     }
 119:main.c        **** }
 444              		.loc 1 119 0
 445 0328 C9       		leave
 446              		.cfi_def_cfa 7, 8
 447 0329 C3       		ret
 448              		.cfi_endproc
 449              	.LFE11:
 451              		.globl	find
 453              	find:
 454              	.LFB12:
 120:main.c        **** 
 121:main.c        **** bool find(uint16_t userID, uint16_t hashedPin, bool *isAdmin, int *bal, int *inLineNum) {
 455              		.loc 1 121 0
 456              		.cfi_startproc
 457 032a 55       		pushq	%rbp
 458              		.cfi_def_cfa_offset 16
 459              		.cfi_offset 6, -16
 460 032b 4889E5   		movq	%rsp, %rbp
 461              		.cfi_def_cfa_register 6
 462 032e 89F0     		movl	%esi, %eax
 463 0330 488955E0 		movq	%rdx, -32(%rbp)
 464 0334 48894DD8 		movq	%rcx, -40(%rbp)
 465 0338 4C8945D0 		movq	%r8, -48(%rbp)
 466 033c 66897DEC 		movw	%di, -20(%rbp)
 467 0340 668945E8 		movw	%ax, -24(%rbp)
 122:main.c        ****     bool pos = false;
 468              		.loc 1 122 0
 469 0344 C645FB00 		movb	$0, -5(%rbp)
 470              	.LBB4:
 123:main.c        ****     for (int i = 1; i <= numLines; i++) {
 471              		.loc 1 123 0
 472 0348 C745FC01 		movl	$1, -4(%rbp)
 472      000000
 473 034f EB75     		jmp	.L18
 474              	.L22:
 124:main.c        ****         if (userID == (uint16_t) dataFromCSV[i][0] && hashedPin == (uint16_t) dataFromCSV[i][1]) {
 475              		.loc 1 124 0
 476 0351 8B45FC   		movl	-4(%rbp), %eax
 477 0354 4898     		cltq
 478 0356 48C1E004 		salq	$4, %rax
 479 035a 48050000 		addq	$dataFromCSV, %rax
 479      0000
 480 0360 8B00     		movl	(%rax), %eax
 481 0362 663B45EC 		cmpw	-20(%rbp), %ax
 482 0366 755A     		jne	.L19
 483              		.loc 1 124 0 is_stmt 0 discriminator 1
 484 0368 8B45FC   		movl	-4(%rbp), %eax
 485 036b 4898     		cltq
 486 036d 48C1E004 		salq	$4, %rax
 487 0371 48050000 		addq	$dataFromCSV+4, %rax
 487      0000
 488 0377 8B00     		movl	(%rax), %eax
 489 0379 663B45E8 		cmpw	-24(%rbp), %ax
 490 037d 7543     		jne	.L19
 125:main.c        ****             pos = true;
 491              		.loc 1 125 0 is_stmt 1
 492 037f C645FB01 		movb	$1, -5(%rbp)
 126:main.c        ****             if (dataFromCSV[i][2] == 1) *isAdmin = true;
 493              		.loc 1 126 0
 494 0383 8B45FC   		movl	-4(%rbp), %eax
 495 0386 4898     		cltq
 496 0388 48C1E004 		salq	$4, %rax
 497 038c 48050000 		addq	$dataFromCSV+8, %rax
 497      0000
 498 0392 8B00     		movl	(%rax), %eax
 499 0394 83F801   		cmpl	$1, %eax
 500 0397 7507     		jne	.L20
 501              		.loc 1 126 0 is_stmt 0 discriminator 1
 502 0399 488B45E0 		movq	-32(%rbp), %rax
 503 039d C60001   		movb	$1, (%rax)
 504              	.L20:
 127:main.c        ****             *bal = dataFromCSV[i][3];
 505              		.loc 1 127 0 is_stmt 1
 506 03a0 8B45FC   		movl	-4(%rbp), %eax
 507 03a3 4898     		cltq
 508 03a5 48C1E004 		salq	$4, %rax
 509 03a9 48050000 		addq	$dataFromCSV+12, %rax
 509      0000
 510 03af 8B10     		movl	(%rax), %edx
 511 03b1 488B45D8 		movq	-40(%rbp), %rax
 512 03b5 8910     		movl	%edx, (%rax)
 128:main.c        ****             *inLineNum = i;
 513              		.loc 1 128 0
 514 03b7 488B45D0 		movq	-48(%rbp), %rax
 515 03bb 8B55FC   		movl	-4(%rbp), %edx
 516 03be 8910     		movl	%edx, (%rax)
 129:main.c        ****             break;
 517              		.loc 1 129 0
 518 03c0 EB0F     		jmp	.L21
 519              	.L19:
 123:main.c        ****         if (userID == (uint16_t) dataFromCSV[i][0] && hashedPin == (uint16_t) dataFromCSV[i][1]) {
 520              		.loc 1 123 0
 521 03c2 8345FC01 		addl	$1, -4(%rbp)
 522              	.L18:
 123:main.c        ****         if (userID == (uint16_t) dataFromCSV[i][0] && hashedPin == (uint16_t) dataFromCSV[i][1]) {
 523              		.loc 1 123 0 is_stmt 0 discriminator 1
 524 03c6 8B050000 		movl	numLines(%rip), %eax
 524      0000
 525 03cc 3945FC   		cmpl	%eax, -4(%rbp)
 526 03cf 7E80     		jle	.L22
 527              	.L21:
 528              	.LBE4:
 130:main.c        ****         }
 131:main.c        ****     }
 132:main.c        ****     return pos;
 529              		.loc 1 132 0 is_stmt 1
 530 03d1 0FB645FB 		movzbl	-5(%rbp), %eax
 133:main.c        **** }
 531              		.loc 1 133 0
 532 03d5 5D       		popq	%rbp
 533              		.cfi_def_cfa 7, 8
 534 03d6 C3       		ret
 535              		.cfi_endproc
 536              	.LFE12:
 538              		.globl	suffBalUser
 540              	suffBalUser:
 541              	.LFB13:
 134:main.c        **** 
 135:main.c        **** bool suffBalUser(int bal, int *reqAmo) {
 542              		.loc 1 135 0
 543              		.cfi_startproc
 544 03d7 55       		pushq	%rbp
 545              		.cfi_def_cfa_offset 16
 546              		.cfi_offset 6, -16
 547 03d8 4889E5   		movq	%rsp, %rbp
 548              		.cfi_def_cfa_register 6
 549 03db 897DEC   		movl	%edi, -20(%rbp)
 550 03de 488975E0 		movq	%rsi, -32(%rbp)
 136:main.c        ****     bool hasSuffBal = true;
 551              		.loc 1 136 0
 552 03e2 C645FF01 		movb	$1, -1(%rbp)
 137:main.c        ****     if (*reqAmo > bal) hasSuffBal = false;
 553              		.loc 1 137 0
 554 03e6 488B45E0 		movq	-32(%rbp), %rax
 555 03ea 8B00     		movl	(%rax), %eax
 556 03ec 3B45EC   		cmpl	-20(%rbp), %eax
 557 03ef 7E04     		jle	.L25
 558              		.loc 1 137 0 is_stmt 0 discriminator 1
 559 03f1 C645FF00 		movb	$0, -1(%rbp)
 560              	.L25:
 138:main.c        ****     return hasSuffBal;
 561              		.loc 1 138 0 is_stmt 1
 562 03f5 0FB645FF 		movzbl	-1(%rbp), %eax
 139:main.c        **** }
 563              		.loc 1 139 0
 564 03f9 5D       		popq	%rbp
 565              		.cfi_def_cfa 7, 8
 566 03fa C3       		ret
 567              		.cfi_endproc
 568              	.LFE13:
 570              		.section	.rodata
 571              	.LC2:
 572 0005 556E7061 		.string	"Unparseable hex number"
 572      72736561 
 572      626C6520 
 572      68657820 
 572      6E756D62 
 573              	.LC3:
 574 001c 4368616E 		.string	"Channel out of range"
 574      6E656C20 
 574      6F757420 
 574      6F662072 
 574      616E6765 
 575              	.LC4:
 576 0031 436F6E64 		.string	"Conduit out of range"
 576      75697420 
 576      6F757420 
 576      6F662072 
 576      616E6765 
 577              	.LC5:
 578 0046 496C6C65 		.string	"Illegal character"
 578      67616C20 
 578      63686172 
 578      61637465 
 578      7200
 579              	.LC6:
 580 0058 556E7465 		.string	"Unterminated string"
 580      726D696E 
 580      61746564 
 580      20737472 
 580      696E6700 
 581              	.LC7:
 582 006c 4E6F206D 		.string	"No memory"
 582      656D6F72 
 582      7900
 583              	.LC8:
 584 0076 456D7074 		.string	"Empty string"
 584      79207374 
 584      72696E67 
 584      00
 585              	.LC9:
 586 0083 4F646420 		.string	"Odd number of digits"
 586      6E756D62 
 586      6572206F 
 586      66206469 
 586      67697473 
 587              	.LC10:
 588 0098 43616E6E 		.string	"Cannot load file"
 588      6F74206C 
 588      6F616420 
 588      66696C65 
 588      00
 589              	.LC11:
 590 00a9 43616E6E 		.string	"Cannot save file"
 590      6F742073 
 590      61766520 
 590      66696C65 
 590      00
 591              	.LC12:
 592 00ba 42616420 		.string	"Bad arguments"
 592      61726775 
 592      6D656E74 
 592      7300
 593 00c8 00000000 		.align 32
 593      00000000 
 593      00000000 
 593      00000000 
 593      00000000 
 596              	errMessages:
 597 00e0 00000000 		.quad	0
 597      00000000 
 598 00e8 00000000 		.quad	0
 598      00000000 
 599 00f0 00000000 		.quad	.LC2
 599      00000000 
 600 00f8 00000000 		.quad	.LC3
 600      00000000 
 601 0100 00000000 		.quad	.LC4
 601      00000000 
 602 0108 00000000 		.quad	.LC5
 602      00000000 
 603 0110 00000000 		.quad	.LC6
 603      00000000 
 604 0118 00000000 		.quad	.LC7
 604      00000000 
 605 0120 00000000 		.quad	.LC8
 605      00000000 
 606 0128 00000000 		.quad	.LC9
 606      00000000 
 607 0130 00000000 		.quad	.LC10
 607      00000000 
 608 0138 00000000 		.quad	.LC11
 608      00000000 
 609 0140 00000000 		.quad	.LC12
 609      00000000 
 610              		.align 8
 611              	.LC13:
 612 0148 20202020 		.string	"            vendor ID and product ID (e.g 04B4:8613)"
 612      20202020 
 612      20202020 
 612      76656E64 
 612      6F722049 
 613              	.LC14:
 614 017d 3C564944 		.string	"<VID:PID>"
 614      3A504944 
 614      3E00
 615              	.LC15:
 616 0187 69767000 		.string	"ivp"
 617              	.LC16:
 618 018b 6900     		.string	"i"
 619 018d 000000   		.align 8
 620              	.LC17:
 621 0190 20202020 		.string	"       VID, PID and opt. dev ID (e.g 1D50:602B:0001)"
 621      20202056 
 621      49442C20 
 621      50494420 
 621      616E6420 
 622              	.LC18:
 623 01c5 3C564944 		.string	"<VID:PID[:DID]>"
 623      3A504944 
 623      5B3A4449 
 623      445D3E00 
 624              	.LC19:
 625 01d5 767000   		.string	"vp"
 626              	.LC20:
 627 01d8 7600     		.string	"v"
 628 01da 00000000 		.align 8
 628      0000
 629              	.LC21:
 630 01e0 20202020 		.string	"                    sets bank id"
 630      20202020 
 630      20202020 
 630      20202020 
 630      20202020 
 631              	.LC22:
 632 0201 62616E6B 		.string	"bank id in decimal"
 632      20696420 
 632      696E2064 
 632      6563696D 
 632      616C00
 633              	.LC23:
 634 0214 62696400 		.string	"bid"
 635              	.LC24:
 636 0218 6200     		.string	"b"
 637 021a 00000000 		.align 8
 637      0000
 638              	.LC25:
 639 0220 20202020 		.string	"                    starts atm service"
 639      20202020 
 639      20202020 
 639      20202020 
 639      20202020 
 640              	.LC26:
 641 0247 61746D00 		.string	"atm"
 642              	.LC27:
 643 024b 7900     		.string	"y"
 644 024d 000000   		.align 8
 645              	.LC28:
 646 0250 20202020 		.string	"        gives log on more events"
 646      20202020 
 646      67697665 
 646      73206C6F 
 646      67206F6E 
 647              	.LC29:
 648 0271 6C6F6700 		.string	"log"
 649              	.LC30:
 650 0275 6C00     		.string	"l"
 651 0277 00       		.align 8
 652              	.LC31:
 653 0278 20202020 		.string	"                     print this help and exit"
 653      20202020 
 653      20202020 
 653      20202020 
 653      20202020 
 654              	.LC32:
 655 02a6 68656C70 		.string	"help"
 655      00
 656              	.LC33:
 657 02ab 6800     		.string	"h"
 658              	.LC34:
 659 02ad 666C636C 		.string	"flcli"
 659      6900
 660              	.LC35:
 661 02b3 25733A20 		.string	"%s: insufficient memory\n"
 661      696E7375 
 661      66666963 
 661      69656E74 
 661      206D656D 
 662              	.LC36:
 663 02cc 496E7661 		.string	"Invalid bankID"
 663      6C696420 
 663      62616E6B 
 663      494400
 664 02db 00000000 		.align 8
 664      00
 665              	.LC37:
 666 02e0 46504741 		.string	"FPGALink Command-Line Interface Copyright (C) 2017 Jarvis \n\n Usage: %s"
 666      4C696E6B 
 666      20436F6D 
 666      6D616E64 
 666      2D4C696E 
 667              	.LC38:
 668 0327 0A00     		.string	"\n"
 669 0329 00000000 		.align 8
 669      000000
 670              	.LC39:
 671 0330 0A496E74 		.string	"\nInteract with an FPGALink device.\n"
 671      65726163 
 671      74207769 
 671      74682061 
 671      6E204650 
 672              	.LC40:
 673 0354 2020252D 		.string	"  %-10s %s\n"
 673      31307320 
 673      25730A00 
 674              		.align 8
 675              	.LC41:
 676 0360 54727920 		.string	"Try '%s --help' for more information.\n"
 676      27257320 
 676      2D2D6865 
 676      6C702720 
 676      666F7220 
 677 0387 00       		.align 8
 678              	.LC42:
 679 0388 41747465 		.string	"Attempting to open connection to FPGALink device %s...\n"
 679      6D707469 
 679      6E672074 
 679      6F206F70 
 679      656E2063 
 680              	.LC43:
 681 03c0 4C6F6164 		.string	"Loading firmware into %s...\n"
 681      696E6720 
 681      6669726D 
 681      77617265 
 681      20696E74 
 682              	.LC44:
 683 03dd 41776169 		.string	"Awaiting renumeration"
 683      74696E67 
 683      2072656E 
 683      756D6572 
 683      6174696F 
 684 03f3 00000000 		.align 8
 684      00
 685              	.LC45:
 686 03f8 46504741 		.string	"FPGALink device did not renumerate properly as %s\n"
 686      4C696E6B 
 686      20646576 
 686      69636520 
 686      64696420 
 687 042b 00000000 		.align 8
 687      00
 688              	.LC46:
 689 0430 41747465 		.string	"Attempting to open connection to FPGLink device %s again...\n"
 689      6D707469 
 689      6E672074 
 689      6F206F70 
 689      656E2063 
 690 046d 000000   		.align 8
 691              	.LC47:
 692 0470 436F756C 		.string	"Could not open FPGALink device at %s and no initial VID:PID was supplied\n"
 692      64206E6F 
 692      74206F70 
 692      656E2046 
 692      5047414C 
 693 04ba 00000000 		.align 8
 693      0000
 694              	.LC48:
 695 04c0 436F6E6E 		.string	"Connected to FPGALink device %s (firmwareID: 0x%04X, firmwareVersion: 0x%08X)\n"
 695      65637465 
 695      6420746F 
 695      20465047 
 695      414C696E 
 696              	.LC49:
 697 050f 722B00   		.string	"r+"
 698              	.LC50:
 699 0512 53616D70 		.string	"SampleBackEndDatabase.csv"
 699      6C654261 
 699      636B456E 
 699      64446174 
 699      61626173 
 700              	.LC51:
 701 052c 43737620 		.string	"Csv doesn't exist "
 701      646F6573 
 701      6E277420 
 701      65786973 
 701      742000
 702              	.LC52:
 703 053f 52656164 		.string	"Read from channel 0 = %u \n"
 703      2066726F 
 703      6D206368 
 703      616E6E65 
 703      6C203020 
 704              	.LC53:
 705 055a 52656164 		.string	"Read from channel %u = %u \n"
 705      2066726F 
 705      6D206368 
 705      616E6E65 
 705      6C202575 
 706              	.LC54:
 707 0576 56616C69 		.string	"Valid user found "
 707      64207573 
 707      65722066 
 707      6F756E64 
 707      2000
 708              	.LC55:
 709 0588 53756666 		.string	"Sufficient Balance in account"
 709      69636965 
 709      6E742042 
 709      616C616E 
 709      63652069 
 710              	.LC56:
 711 05a6 57726974 		.string	"Write to channel %u = %u \n"
 711      6520746F 
 711      20636861 
 711      6E6E656C 
 711      20257520 
 712              	.LC57:
 713 05c1 772B00   		.string	"w+"
 714 05c4 00000000 		.align 8
 715              	.LC58:
 716 05c8 22557365 		.string	"\"User ID (decimal)\",\"PIN Hash (decimal)\",\"Admin\",\"Balance (decimal)\""
 716      72204944 
 716      20286465 
 716      63696D61 
 716      6C29222C 
 717              	.LC59:
 718 060d 496E7375 		.string	"Insufficient Balance "
 718      66666963 
 718      69656E74 
 718      2042616C 
 718      616E6365 
 719              	.LC60:
 720 0623 55736572 		.string	"User has admin privileges "
 720      20686173 
 720      2061646D 
 720      696E2070 
 720      72697669 
 721              	.LC61:
 722 063e 496E7661 		.string	"Invalid user "
 722      6C696420 
 722      75736572 
 722      2000
 723 064c 00000000 		.align 8
 724              	.LC62:
 725 0650 54686520 		.string	"The FPGALink device at %s is not ready to talk - did you forget --program?\n"
 725      46504741 
 725      4C696E6B 
 725      20646576 
 725      69636520 
 726 069c 00000000 		.align 8
 727              	.LC63:
 728 06a0 41637469 		.string	"Action requested but device at %s does not support CommFPGA\n"
 728      6F6E2072 
 728      65717565 
 728      73746564 
 728      20627574 
 729              	.LC64:
 730 06dd 25730A00 		.string	"%s\n"
 731              		.text
 732              		.globl	main
 734              	main:
 735              	.LFB14:
 140:main.c        **** 
 141:main.c        **** static const char *const errMessages[] = {
 142:main.c        ****         NULL,
 143:main.c        ****         NULL,
 144:main.c        ****         "Unparseable hex number",
 145:main.c        ****         "Channel out of range",
 146:main.c        ****         "Conduit out of range",
 147:main.c        ****         "Illegal character",
 148:main.c        ****         "Unterminated string",
 149:main.c        ****         "No memory",
 150:main.c        ****         "Empty string",
 151:main.c        ****         "Odd number of digits",
 152:main.c        ****         "Cannot load file",
 153:main.c        ****         "Cannot save file",
 154:main.c        ****         "Bad arguments"
 155:main.c        **** };
 156:main.c        **** 
 157:main.c        **** typedef enum {
 158:main.c        ****     FLP_SUCCESS,
 159:main.c        ****     FLP_LIBERR,
 160:main.c        ****     FLP_BAD_HEX,
 161:main.c        ****     FLP_CHAN_RANGE,
 162:main.c        ****     FLP_CONDUIT_RANGE,
 163:main.c        ****     FLP_ILL_CHAR,
 164:main.c        ****     FLP_UNTERM_STRING,
 165:main.c        ****     FLP_NO_MEMORY,
 166:main.c        ****     FLP_EMPTY_STRING,
 167:main.c        ****     FLP_ODD_DIGITS,
 168:main.c        ****     FLP_CANNOT_LOAD,
 169:main.c        ****     FLP_CANNOT_SAVE,
 170:main.c        ****     FLP_ARGS
 171:main.c        **** } ReturnCode;
 172:main.c        **** 
 173:main.c        **** int main(int argc, char *argv[]) {
 736              		.loc 1 173 0
 737              		.cfi_startproc
 738 03fb 55       		pushq	%rbp
 739              		.cfi_def_cfa_offset 16
 740              		.cfi_offset 6, -16
 741 03fc 4889E5   		movq	%rsp, %rbp
 742              		.cfi_def_cfa_register 6
 743 03ff 53       		pushq	%rbx
 744 0400 4881EC78 		subq	$376, %rsp
 744      010000
 745              		.cfi_offset 3, -24
 746 0407 89BD8CFE 		movl	%edi, -372(%rbp)
 746      FFFF
 747 040d 4889B580 		movq	%rsi, -384(%rbp)
 747      FEFFFF
 174:main.c        ****     ReturnCode retVal = FLP_SUCCESS;
 748              		.loc 1 174 0
 749 0414 C785C0FE 		movl	$0, -320(%rbp)
 749      FFFF0000 
 749      0000
 175:main.c        **** 
 176:main.c        ****     struct arg_str *ivpOpt = arg_str0("i", "ivp", "<VID:PID>", "            vendor ID and product I
 750              		.loc 1 176 0
 751 041e B9000000 		movl	$.LC13, %ecx
 751      00
 752 0423 BA000000 		movl	$.LC14, %edx
 752      00
 753 0428 BE000000 		movl	$.LC15, %esi
 753      00
 754 042d BF000000 		movl	$.LC16, %edi
 754      00
 755 0432 E8000000 		call	arg_str0
 755      00
 756 0437 48898538 		movq	%rax, -200(%rbp)
 756      FFFFFF
 177:main.c        ****     struct arg_str *vpOpt = arg_str1("v", "vp", "<VID:PID[:DID]>", "       VID, PID and opt. dev ID
 757              		.loc 1 177 0
 758 043e B9000000 		movl	$.LC17, %ecx
 758      00
 759 0443 BA000000 		movl	$.LC18, %edx
 759      00
 760 0448 BE000000 		movl	$.LC19, %esi
 760      00
 761 044d BF000000 		movl	$.LC20, %edi
 761      00
 762 0452 E8000000 		call	arg_str1
 762      00
 763 0457 48898540 		movq	%rax, -192(%rbp)
 763      FFFFFF
 178:main.c        ****     struct arg_str *bankIdOpt = arg_str0("b", "bid", "bank id in decimal", "                    set
 764              		.loc 1 178 0
 765 045e B9000000 		movl	$.LC21, %ecx
 765      00
 766 0463 BA000000 		movl	$.LC22, %edx
 766      00
 767 0468 BE000000 		movl	$.LC23, %esi
 767      00
 768 046d BF000000 		movl	$.LC24, %edi
 768      00
 769 0472 E8000000 		call	arg_str0
 769      00
 770 0477 48898548 		movq	%rax, -184(%rbp)
 770      FFFFFF
 179:main.c        ****     struct arg_lit *loopOpt = arg_lit0("y", "atm", "                    starts atm service");
 771              		.loc 1 179 0
 772 047e BA000000 		movl	$.LC25, %edx
 772      00
 773 0483 BE000000 		movl	$.LC26, %esi
 773      00
 774 0488 BF000000 		movl	$.LC27, %edi
 774      00
 775 048d E8000000 		call	arg_lit0
 775      00
 776 0492 48898550 		movq	%rax, -176(%rbp)
 776      FFFFFF
 180:main.c        ****     struct arg_lit *verboseOpt = arg_lit0("l", "log", "        gives log on more events");
 777              		.loc 1 180 0
 778 0499 BA000000 		movl	$.LC28, %edx
 778      00
 779 049e BE000000 		movl	$.LC29, %esi
 779      00
 780 04a3 BF000000 		movl	$.LC30, %edi
 780      00
 781 04a8 E8000000 		call	arg_lit0
 781      00
 782 04ad 48898558 		movq	%rax, -168(%rbp)
 782      FFFFFF
 181:main.c        ****     struct arg_lit *helpOpt = arg_lit0("h", "help", "                     print this help and exit"
 783              		.loc 1 181 0
 784 04b4 BA000000 		movl	$.LC31, %edx
 784      00
 785 04b9 BE000000 		movl	$.LC32, %esi
 785      00
 786 04be BF000000 		movl	$.LC33, %edi
 786      00
 787 04c3 E8000000 		call	arg_lit0
 787      00
 788 04c8 48898560 		movq	%rax, -160(%rbp)
 788      FFFFFF
 182:main.c        ****     struct arg_end *endOpt = arg_end(20);
 789              		.loc 1 182 0
 790 04cf BF140000 		movl	$20, %edi
 790      00
 791 04d4 E8000000 		call	arg_end
 791      00
 792 04d9 48898568 		movq	%rax, -152(%rbp)
 792      FFFFFF
 183:main.c        **** 
 184:main.c        ****     void *argTable[] = {
 793              		.loc 1 184 0
 794 04e0 488B8538 		movq	-200(%rbp), %rax
 794      FFFFFF
 795 04e7 488945B0 		movq	%rax, -80(%rbp)
 796 04eb 488B8540 		movq	-192(%rbp), %rax
 796      FFFFFF
 797 04f2 488945B8 		movq	%rax, -72(%rbp)
 798 04f6 488B8548 		movq	-184(%rbp), %rax
 798      FFFFFF
 799 04fd 488945C0 		movq	%rax, -64(%rbp)
 800 0501 488B8550 		movq	-176(%rbp), %rax
 800      FFFFFF
 801 0508 488945C8 		movq	%rax, -56(%rbp)
 802 050c 488B8558 		movq	-168(%rbp), %rax
 802      FFFFFF
 803 0513 488945D0 		movq	%rax, -48(%rbp)
 804 0517 488B8560 		movq	-160(%rbp), %rax
 804      FFFFFF
 805 051e 488945D8 		movq	%rax, -40(%rbp)
 806 0522 488B8568 		movq	-152(%rbp), %rax
 806      FFFFFF
 807 0529 488945E0 		movq	%rax, -32(%rbp)
 185:main.c        ****             ivpOpt,
 186:main.c        ****             vpOpt,
 187:main.c        ****             bankIdOpt,
 188:main.c        ****             loopOpt,
 189:main.c        ****             verboseOpt,
 190:main.c        ****             helpOpt,
 191:main.c        ****             endOpt
 192:main.c        ****     };
 193:main.c        **** 
 194:main.c        ****     const char *progName = "flcli";
 808              		.loc 1 194 0
 809 052d 48C78570 		movq	$.LC34, -144(%rbp)
 809      FFFFFF00 
 809      000000
 195:main.c        ****     int numErrors;
 196:main.c        ****     struct FLContext *handle = NULL;
 810              		.loc 1 196 0
 811 0538 48C78518 		movq	$0, -232(%rbp)
 811      FFFFFF00 
 811      000000
 197:main.c        ****     FLStatus fStatus;
 198:main.c        ****     const char *error = NULL;
 812              		.loc 1 198 0
 813 0543 48C78520 		movq	$0, -224(%rbp)
 813      FFFFFF00 
 813      000000
 199:main.c        ****     const char *ivp = NULL;
 814              		.loc 1 199 0
 815 054e 48C78578 		movq	$0, -136(%rbp)
 815      FFFFFF00 
 815      000000
 200:main.c        ****     const char *vp = NULL;
 816              		.loc 1 200 0
 817 0559 48C74580 		movq	$0, -128(%rbp)
 817      00000000 
 201:main.c        ****     bool isCommCapable;
 202:main.c        ****     const char *line = NULL;
 818              		.loc 1 202 0
 819 0561 48C74588 		movq	$0, -120(%rbp)
 819      00000000 
 203:main.c        ****     uint8 conduit = 0x01;
 820              		.loc 1 203 0
 821 0569 C685A5FE 		movb	$1, -347(%rbp)
 821      FFFF01
 204:main.c        **** 
 205:main.c        ****     if (arg_nullcheck(argTable) != 0) {
 822              		.loc 1 205 0
 823 0570 488D45B0 		leaq	-80(%rbp), %rax
 824 0574 4889C7   		movq	%rax, %rdi
 825 0577 E8000000 		call	arg_nullcheck
 825      00
 826 057c 85C0     		testl	%eax, %eax
 827 057e 742F     		je	.L28
 206:main.c        ****         fprintf(stderr, "%s: insufficient memory\n", progName);
 828              		.loc 1 206 0
 829 0580 488B0500 		movq	stderr(%rip), %rax
 829      000000
 830 0587 488B9570 		movq	-144(%rbp), %rdx
 830      FFFFFF
 831 058e BE000000 		movl	$.LC35, %esi
 831      00
 832 0593 4889C7   		movq	%rax, %rdi
 833 0596 B8000000 		movl	$0, %eax
 833      00
 834 059b E8000000 		call	fprintf
 834      00
 207:main.c        ****         FAIL(1, cleanup);
 835              		.loc 1 207 0
 836 05a0 C785C0FE 		movl	$1, -320(%rbp)
 836      FFFF0100 
 836      0000
 837 05aa E9FF1600 		jmp	.L29
 837      00
 838              	.L28:
 208:main.c        ****     }
 209:main.c        **** 
 210:main.c        ****     numErrors = arg_parse(argc, argv, argTable);
 839              		.loc 1 210 0
 840 05af 488D55B0 		leaq	-80(%rbp), %rdx
 841 05b3 488B8D80 		movq	-384(%rbp), %rcx
 841      FEFFFF
 842 05ba 8B858CFE 		movl	-372(%rbp), %eax
 842      FFFF
 843 05c0 4889CE   		movq	%rcx, %rsi
 844 05c3 89C7     		movl	%eax, %edi
 845 05c5 E8000000 		call	arg_parse
 845      00
 846 05ca 8985ECFE 		movl	%eax, -276(%rbp)
 846      FFFF
 211:main.c        **** 
 212:main.c        ****     if (verboseOpt->count > 0) {
 847              		.loc 1 212 0
 848 05d0 488B8558 		movq	-168(%rbp), %rax
 848      FFFFFF
 849 05d7 8B4060   		movl	96(%rax), %eax
 850 05da 85C0     		testl	%eax, %eax
 851 05dc 7E07     		jle	.L30
 213:main.c        ****         LOG = true;
 852              		.loc 1 213 0
 853 05de C6050000 		movb	$1, LOG(%rip)
 853      000001
 854              	.L30:
 214:main.c        ****     }
 215:main.c        **** 
 216:main.c        ****     if (bankIdOpt->count > 0) {
 855              		.loc 1 216 0
 856 05e5 488B8548 		movq	-184(%rbp), %rax
 856      FFFFFF
 857 05ec 8B4060   		movl	96(%rax), %eax
 858 05ef 85C0     		testl	%eax, %eax
 859 05f1 7E45     		jle	.L31
 217:main.c        ****         bankID = atoi(bankIdOpt->sval[0]);
 860              		.loc 1 217 0
 861 05f3 488B8548 		movq	-184(%rbp), %rax
 861      FFFFFF
 862 05fa 488B4068 		movq	104(%rax), %rax
 863 05fe 488B00   		movq	(%rax), %rax
 864 0601 4889C7   		movq	%rax, %rdi
 865 0604 E8000000 		call	atoi
 865      00
 866 0609 89050000 		movl	%eax, bankID(%rip)
 866      0000
 218:main.c        ****         if(bankID < 0 || bankID > 31) {
 867              		.loc 1 218 0
 868 060f 8B050000 		movl	bankID(%rip), %eax
 868      0000
 869 0615 85C0     		testl	%eax, %eax
 870 0617 780B     		js	.L32
 871              		.loc 1 218 0 is_stmt 0 discriminator 1
 872 0619 8B050000 		movl	bankID(%rip), %eax
 872      0000
 873 061f 83F81F   		cmpl	$31, %eax
 874 0622 7E14     		jle	.L31
 875              	.L32:
 219:main.c        ****             printf("%s\n", "Invalid bankID");
 876              		.loc 1 219 0 is_stmt 1
 877 0624 BF000000 		movl	$.LC36, %edi
 877      00
 878 0629 E8000000 		call	puts
 878      00
 220:main.c        ****             return 0;
 879              		.loc 1 220 0
 880 062e B8000000 		movl	$0, %eax
 880      00
 881 0633 E9D21600 		jmp	.L166
 881      00
 882              	.L31:
 221:main.c        ****         }
 222:main.c        ****     }
 223:main.c        **** 
 224:main.c        ****     if (helpOpt->count > 0) {
 883              		.loc 1 224 0
 884 0638 488B8560 		movq	-160(%rbp), %rax
 884      FFFFFF
 885 063f 8B4060   		movl	96(%rax), %eax
 886 0642 85C0     		testl	%eax, %eax
 887 0644 7E68     		jle	.L34
 225:main.c        ****         printf("FPGALink Command-Line Interface Copyright (C) 2017 Jarvis \n\n Usage: %s", progName
 888              		.loc 1 225 0
 889 0646 488B8570 		movq	-144(%rbp), %rax
 889      FFFFFF
 890 064d 4889C6   		movq	%rax, %rsi
 891 0650 BF000000 		movl	$.LC37, %edi
 891      00
 892 0655 B8000000 		movl	$0, %eax
 892      00
 893 065a E8000000 		call	printf
 893      00
 226:main.c        ****         arg_print_syntax(stdout, argTable, "\n");
 894              		.loc 1 226 0
 895 065f 488B0500 		movq	stdout(%rip), %rax
 895      000000
 896 0666 488D4DB0 		leaq	-80(%rbp), %rcx
 897 066a BA000000 		movl	$.LC38, %edx
 897      00
 898 066f 4889CE   		movq	%rcx, %rsi
 899 0672 4889C7   		movq	%rax, %rdi
 900 0675 E8000000 		call	arg_print_syntax
 900      00
 227:main.c        ****         printf("\nInteract with an FPGALink device.\n\n");
 901              		.loc 1 227 0
 902 067a BF000000 		movl	$.LC39, %edi
 902      00
 903 067f E8000000 		call	puts
 903      00
 228:main.c        ****         arg_print_glossary(stdout, argTable, "  %-10s %s\n");
 904              		.loc 1 228 0
 905 0684 488B0500 		movq	stdout(%rip), %rax
 905      000000
 906 068b 488D4DB0 		leaq	-80(%rbp), %rcx
 907 068f BA000000 		movl	$.LC40, %edx
 907      00
 908 0694 4889CE   		movq	%rcx, %rsi
 909 0697 4889C7   		movq	%rax, %rdi
 910 069a E8000000 		call	arg_print_glossary
 910      00
 229:main.c        ****         FAIL(FLP_SUCCESS, cleanup);
 911              		.loc 1 229 0
 912 069f C785C0FE 		movl	$0, -320(%rbp)
 912      FFFF0000 
 912      0000
 913 06a9 E9001600 		jmp	.L29
 913      00
 914              	.L34:
 230:main.c        ****     }
 231:main.c        **** 
 232:main.c        ****     if (numErrors > 0) {
 915              		.loc 1 232 0
 916 06ae 83BDECFE 		cmpl	$0, -276(%rbp)
 916      FFFF00
 917 06b5 7E4F     		jle	.L35
 233:main.c        ****         arg_print_errors(stdout, endOpt, progName);
 918              		.loc 1 233 0
 919 06b7 488B0500 		movq	stdout(%rip), %rax
 919      000000
 920 06be 488B9570 		movq	-144(%rbp), %rdx
 920      FFFFFF
 921 06c5 488B8D68 		movq	-152(%rbp), %rcx
 921      FFFFFF
 922 06cc 4889CE   		movq	%rcx, %rsi
 923 06cf 4889C7   		movq	%rax, %rdi
 924 06d2 E8000000 		call	arg_print_errors
 924      00
 234:main.c        ****         fprintf(stderr, "Try '%s --help' for more information.\n", progName);
 925              		.loc 1 234 0
 926 06d7 488B0500 		movq	stderr(%rip), %rax
 926      000000
 927 06de 488B9570 		movq	-144(%rbp), %rdx
 927      FFFFFF
 928 06e5 BE000000 		movl	$.LC41, %esi
 928      00
 929 06ea 4889C7   		movq	%rax, %rdi
 930 06ed B8000000 		movl	$0, %eax
 930      00
 931 06f2 E8000000 		call	fprintf
 931      00
 235:main.c        ****         FAIL(FLP_ARGS, cleanup);
 932              		.loc 1 235 0
 933 06f7 C785C0FE 		movl	$12, -320(%rbp)
 933      FFFF0C00 
 933      0000
 934 0701 E9A81500 		jmp	.L29
 934      00
 935              	.L35:
 236:main.c        ****     }
 237:main.c        **** 
 238:main.c        ****     fStatus = flInitialise(0, &error);
 936              		.loc 1 238 0
 937 0706 488D8520 		leaq	-224(%rbp), %rax
 937      FFFFFF
 938 070d 4889C6   		movq	%rax, %rsi
 939 0710 BF000000 		movl	$0, %edi
 939      00
 940 0715 E8000000 		call	flInitialise
 940      00
 941 071a 8985F0FE 		movl	%eax, -272(%rbp)
 941      FFFF
 239:main.c        ****     CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 942              		.loc 1 239 0
 943 0720 83BDF0FE 		cmpl	$0, -272(%rbp)
 943      FFFF00
 944 0727 740F     		je	.L36
 945              		.loc 1 239 0 is_stmt 0 discriminator 1
 946 0729 C785C0FE 		movl	$1, -320(%rbp)
 946      FFFF0100 
 946      0000
 947 0733 E9761500 		jmp	.L29
 947      00
 948              	.L36:
 240:main.c        **** 
 241:main.c        ****     vp = vpOpt->sval[0];
 949              		.loc 1 241 0 is_stmt 1
 950 0738 488B8540 		movq	-192(%rbp), %rax
 950      FFFFFF
 951 073f 488B4068 		movq	104(%rax), %rax
 952 0743 488B00   		movq	(%rax), %rax
 953 0746 48894580 		movq	%rax, -128(%rbp)
 242:main.c        **** 
 243:main.c        ****     printf("Attempting to open connection to FPGALink device %s...\n", vp);
 954              		.loc 1 243 0
 955 074a 488B4580 		movq	-128(%rbp), %rax
 956 074e 4889C6   		movq	%rax, %rsi
 957 0751 BF000000 		movl	$.LC42, %edi
 957      00
 958 0756 B8000000 		movl	$0, %eax
 958      00
 959 075b E8000000 		call	printf
 959      00
 244:main.c        ****     fStatus = flOpen(vp, &handle, NULL);
 960              		.loc 1 244 0
 961 0760 488D8D18 		leaq	-232(%rbp), %rcx
 961      FFFFFF
 962 0767 488B4580 		movq	-128(%rbp), %rax
 963 076b BA000000 		movl	$0, %edx
 963      00
 964 0770 4889CE   		movq	%rcx, %rsi
 965 0773 4889C7   		movq	%rax, %rdi
 966 0776 E8000000 		call	flOpen
 966      00
 967 077b 8985F0FE 		movl	%eax, -272(%rbp)
 967      FFFF
 245:main.c        ****     if (fStatus) {
 968              		.loc 1 245 0
 969 0781 83BDF0FE 		cmpl	$0, -272(%rbp)
 969      FFFF00
 970 0788 0F84D801 		je	.L37
 970      0000
 246:main.c        ****         if (ivpOpt->count) {
 971              		.loc 1 246 0
 972 078e 488B8538 		movq	-200(%rbp), %rax
 972      FFFFFF
 973 0795 8B4060   		movl	96(%rax), %eax
 974 0798 85C0     		testl	%eax, %eax
 975 079a 0F849A01 		je	.L38
 975      0000
 976              	.LBB5:
 247:main.c        ****             int count = 60;
 977              		.loc 1 247 0
 978 07a0 C785C4FE 		movl	$60, -316(%rbp)
 978      FFFF3C00 
 978      0000
 248:main.c        ****             uint8 flag;
 249:main.c        ****             ivp = ivpOpt->sval[0];
 979              		.loc 1 249 0
 980 07aa 488B8538 		movq	-200(%rbp), %rax
 980      FFFFFF
 981 07b1 488B4068 		movq	104(%rax), %rax
 982 07b5 488B00   		movq	(%rax), %rax
 983 07b8 48898578 		movq	%rax, -136(%rbp)
 983      FFFFFF
 250:main.c        ****             printf("Loading firmware into %s...\n", ivp);
 984              		.loc 1 250 0
 985 07bf 488B8578 		movq	-136(%rbp), %rax
 985      FFFFFF
 986 07c6 4889C6   		movq	%rax, %rsi
 987 07c9 BF000000 		movl	$.LC43, %edi
 987      00
 988 07ce B8000000 		movl	$0, %eax
 988      00
 989 07d3 E8000000 		call	printf
 989      00
 251:main.c        ****             fStatus = flLoadStandardFirmware(ivp, vp, &error);
 990              		.loc 1 251 0
 991 07d8 488D9520 		leaq	-224(%rbp), %rdx
 991      FFFFFF
 992 07df 488B4D80 		movq	-128(%rbp), %rcx
 993 07e3 488B8578 		movq	-136(%rbp), %rax
 993      FFFFFF
 994 07ea 4889CE   		movq	%rcx, %rsi
 995 07ed 4889C7   		movq	%rax, %rdi
 996 07f0 E8000000 		call	flLoadStandardFirmware
 996      00
 997 07f5 8985F0FE 		movl	%eax, -272(%rbp)
 997      FFFF
 252:main.c        ****             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 998              		.loc 1 252 0
 999 07fb 83BDF0FE 		cmpl	$0, -272(%rbp)
 999      FFFF00
 1000 0802 740F     		je	.L39
 1001              		.loc 1 252 0 is_stmt 0 discriminator 1
 1002 0804 C785C0FE 		movl	$1, -320(%rbp)
 1002      FFFF0100 
 1002      0000
 1003 080e E99B1400 		jmp	.L29
 1003      00
 1004              	.L39:
 253:main.c        **** 
 254:main.c        ****             printf("Awaiting renumeration");
 1005              		.loc 1 254 0 is_stmt 1
 1006 0813 BF000000 		movl	$.LC44, %edi
 1006      00
 1007 0818 B8000000 		movl	$0, %eax
 1007      00
 1008 081d E8000000 		call	printf
 1008      00
 255:main.c        ****             flSleep(1000);
 1009              		.loc 1 255 0
 1010 0822 BFE80300 		movl	$1000, %edi
 1010      00
 1011 0827 E8000000 		call	flSleep
 1011      00
 1012              	.L43:
 256:main.c        ****             do {
 257:main.c        ****                 printf(".");
 1013              		.loc 1 257 0
 1014 082c BF2E0000 		movl	$46, %edi
 1014      00
 1015 0831 E8000000 		call	putchar
 1015      00
 258:main.c        ****                 fflush(stdout);
 1016              		.loc 1 258 0
 1017 0836 488B0500 		movq	stdout(%rip), %rax
 1017      000000
 1018 083d 4889C7   		movq	%rax, %rdi
 1019 0840 E8000000 		call	fflush
 1019      00
 259:main.c        ****                 fStatus = flIsDeviceAvailable(vp, &flag, &error);
 1020              		.loc 1 259 0
 1021 0845 488D9520 		leaq	-224(%rbp), %rdx
 1021      FFFFFF
 1022 084c 488D8D30 		leaq	-208(%rbp), %rcx
 1022      FFFFFF
 1023 0853 488B4580 		movq	-128(%rbp), %rax
 1024 0857 4889CE   		movq	%rcx, %rsi
 1025 085a 4889C7   		movq	%rax, %rdi
 1026 085d E8000000 		call	flIsDeviceAvailable
 1026      00
 1027 0862 8985F0FE 		movl	%eax, -272(%rbp)
 1027      FFFF
 260:main.c        ****                 CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1028              		.loc 1 260 0
 1029 0868 83BDF0FE 		cmpl	$0, -272(%rbp)
 1029      FFFF00
 1030 086f 740F     		je	.L41
 1031              		.loc 1 260 0 is_stmt 0 discriminator 1
 1032 0871 C785C0FE 		movl	$1, -320(%rbp)
 1032      FFFF0100 
 1032      0000
 1033 087b E92E1400 		jmp	.L29
 1033      00
 1034              	.L41:
 261:main.c        ****                 flSleep(250);
 1035              		.loc 1 261 0 is_stmt 1
 1036 0880 BFFA0000 		movl	$250, %edi
 1036      00
 1037 0885 E8000000 		call	flSleep
 1037      00
 262:main.c        ****                 count--;
 1038              		.loc 1 262 0
 1039 088a 83ADC4FE 		subl	$1, -316(%rbp)
 1039      FFFF01
 263:main.c        ****             } while (!flag && count);
 1040              		.loc 1 263 0
 1041 0891 0FB68530 		movzbl	-208(%rbp), %eax
 1041      FFFFFF
 1042 0898 84C0     		testb	%al, %al
 1043 089a 7509     		jne	.L42
 1044              		.loc 1 263 0 is_stmt 0 discriminator 1
 1045 089c 83BDC4FE 		cmpl	$0, -316(%rbp)
 1045      FFFF00
 1046 08a3 7587     		jne	.L43
 1047              	.L42:
 264:main.c        ****             printf("\n");
 1048              		.loc 1 264 0 is_stmt 1
 1049 08a5 BF0A0000 		movl	$10, %edi
 1049      00
 1050 08aa E8000000 		call	putchar
 1050      00
 265:main.c        ****             if (!flag) {
 1051              		.loc 1 265 0
 1052 08af 0FB68530 		movzbl	-208(%rbp), %eax
 1052      FFFFFF
 1053 08b6 84C0     		testb	%al, %al
 1054 08b8 752C     		jne	.L44
 266:main.c        ****                 fprintf(stderr, "FPGALink device did not renumerate properly as %s\n", vp);
 1055              		.loc 1 266 0
 1056 08ba 488B0500 		movq	stderr(%rip), %rax
 1056      000000
 1057 08c1 488B5580 		movq	-128(%rbp), %rdx
 1058 08c5 BE000000 		movl	$.LC45, %esi
 1058      00
 1059 08ca 4889C7   		movq	%rax, %rdi
 1060 08cd B8000000 		movl	$0, %eax
 1060      00
 1061 08d2 E8000000 		call	fprintf
 1061      00
 267:main.c        ****                 FAIL(FLP_LIBERR, cleanup);
 1062              		.loc 1 267 0
 1063 08d7 C785C0FE 		movl	$1, -320(%rbp)
 1063      FFFF0100 
 1063      0000
 1064 08e1 E9C81300 		jmp	.L29
 1064      00
 1065              	.L44:
 268:main.c        ****             }
 269:main.c        **** 
 270:main.c        ****             printf("Attempting to open connection to FPGLink device %s again...\n", vp);
 1066              		.loc 1 270 0
 1067 08e6 488B4580 		movq	-128(%rbp), %rax
 1068 08ea 4889C6   		movq	%rax, %rsi
 1069 08ed BF000000 		movl	$.LC46, %edi
 1069      00
 1070 08f2 B8000000 		movl	$0, %eax
 1070      00
 1071 08f7 E8000000 		call	printf
 1071      00
 271:main.c        ****             fStatus = flOpen(vp, &handle, &error);
 1072              		.loc 1 271 0
 1073 08fc 488D9520 		leaq	-224(%rbp), %rdx
 1073      FFFFFF
 1074 0903 488D8D18 		leaq	-232(%rbp), %rcx
 1074      FFFFFF
 1075 090a 488B4580 		movq	-128(%rbp), %rax
 1076 090e 4889CE   		movq	%rcx, %rsi
 1077 0911 4889C7   		movq	%rax, %rdi
 1078 0914 E8000000 		call	flOpen
 1078      00
 1079 0919 8985F0FE 		movl	%eax, -272(%rbp)
 1079      FFFF
 272:main.c        ****             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1080              		.loc 1 272 0
 1081 091f 83BDF0FE 		cmpl	$0, -272(%rbp)
 1081      FFFF00
 1082 0926 7410     		je	.L45
 1083              		.loc 1 272 0 is_stmt 0 discriminator 1
 1084 0928 C785C0FE 		movl	$1, -320(%rbp)
 1084      FFFF0100 
 1084      0000
 1085 0932 90       		nop
 1086 0933 E9761300 		jmp	.L29
 1086      00
 1087              	.L45:
 1088              	.LBE5:
 1089 0938 EB2C     		jmp	.L37
 1090              	.L38:
 273:main.c        ****         } else {
 274:main.c        ****             fprintf(stderr, "Could not open FPGALink device at %s and no initial VID:PID was suppli
 1091              		.loc 1 274 0 is_stmt 1
 1092 093a 488B0500 		movq	stderr(%rip), %rax
 1092      000000
 1093 0941 488B5580 		movq	-128(%rbp), %rdx
 1094 0945 BE000000 		movl	$.LC47, %esi
 1094      00
 1095 094a 4889C7   		movq	%rax, %rdi
 1096 094d B8000000 		movl	$0, %eax
 1096      00
 1097 0952 E8000000 		call	fprintf
 1097      00
 275:main.c        ****             FAIL(FLP_ARGS, cleanup);
 1098              		.loc 1 275 0
 1099 0957 C785C0FE 		movl	$12, -320(%rbp)
 1099      FFFF0C00 
 1099      0000
 1100 0961 E9481300 		jmp	.L29
 1100      00
 1101              	.L37:
 276:main.c        ****         }
 277:main.c        ****     }
 278:main.c        **** 
 279:main.c        ****     printf(
 1102              		.loc 1 279 0
 1103 0966 488B8518 		movq	-232(%rbp), %rax
 1103      FFFFFF
 1104 096d 4889C7   		movq	%rax, %rdi
 1105 0970 E8000000 		call	flGetFirmwareVersion
 1105      00
 1106 0975 89C3     		movl	%eax, %ebx
 280:main.c        ****             "Connected to FPGALink device %s (firmwareID: 0x%04X, firmwareVersion: 0x%08X)\n",
 281:main.c        ****             vp, flGetFirmwareID(handle), flGetFirmwareVersion(handle)
 1107              		.loc 1 281 0
 1108 0977 488B8518 		movq	-232(%rbp), %rax
 1108      FFFFFF
 1109 097e 4889C7   		movq	%rax, %rdi
 1110 0981 E8000000 		call	flGetFirmwareID
 1110      00
 279:main.c        ****             "Connected to FPGALink device %s (firmwareID: 0x%04X, firmwareVersion: 0x%08X)\n",
 1111              		.loc 1 279 0
 1112 0986 0FB7D0   		movzwl	%ax, %edx
 1113 0989 488B4580 		movq	-128(%rbp), %rax
 1114 098d 89D9     		movl	%ebx, %ecx
 1115 098f 4889C6   		movq	%rax, %rsi
 1116 0992 BF000000 		movl	$.LC48, %edi
 1116      00
 1117 0997 B8000000 		movl	$0, %eax
 1117      00
 1118 099c E8000000 		call	printf
 1118      00
 282:main.c        ****     );
 283:main.c        **** 
 284:main.c        ****     isCommCapable = flIsCommCapable(handle, conduit);
 1119              		.loc 1 284 0
 1120 09a1 0FB695A5 		movzbl	-347(%rbp), %edx
 1120      FEFFFF
 1121 09a8 488B8518 		movq	-232(%rbp), %rax
 1121      FFFFFF
 1122 09af 89D6     		movl	%edx, %esi
 1123 09b1 4889C7   		movq	%rax, %rdi
 1124 09b4 E8000000 		call	flIsCommCapable
 1124      00
 1125 09b9 84C0     		testb	%al, %al
 1126 09bb 0F95C0   		setne	%al
 1127 09be 8885A6FE 		movb	%al, -346(%rbp)
 1127      FFFF
 285:main.c        **** 
 286:main.c        ****     // -y reads in from csv and initiates the while loop
 287:main.c        ****     if (loopOpt->count > 0) {
 1128              		.loc 1 287 0
 1129 09c4 488B8550 		movq	-176(%rbp), %rax
 1129      FFFFFF
 1130 09cb 8B4060   		movl	96(%rax), %eax
 1131 09ce 85C0     		testl	%eax, %eax
 1132 09d0 0F8ED812 		jle	.L29
 1132      0000
 288:main.c        ****         if (isCommCapable) {
 1133              		.loc 1 288 0
 1134 09d6 80BDA6FE 		cmpb	$0, -346(%rbp)
 1134      FFFF00
 1135 09dd 0F84A312 		je	.L46
 1135      0000
 1136              	.LBB6:
 289:main.c        ****             uint8 isRunning;
 290:main.c        ****             fStatus = flSelectConduit(handle, conduit, &error);
 1137              		.loc 1 290 0
 1138 09e3 0FB68DA5 		movzbl	-347(%rbp), %ecx
 1138      FEFFFF
 1139 09ea 488B8518 		movq	-232(%rbp), %rax
 1139      FFFFFF
 1140 09f1 488D9520 		leaq	-224(%rbp), %rdx
 1140      FFFFFF
 1141 09f8 89CE     		movl	%ecx, %esi
 1142 09fa 4889C7   		movq	%rax, %rdi
 1143 09fd E8000000 		call	flSelectConduit
 1143      00
 1144 0a02 8985F0FE 		movl	%eax, -272(%rbp)
 1144      FFFF
 291:main.c        ****             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1145              		.loc 1 291 0
 1146 0a08 83BDF0FE 		cmpl	$0, -272(%rbp)
 1146      FFFF00
 1147 0a0f 740F     		je	.L47
 1148              		.loc 1 291 0 is_stmt 0 discriminator 1
 1149 0a11 C785C0FE 		movl	$1, -320(%rbp)
 1149      FFFF0100 
 1149      0000
 1150 0a1b E98E1200 		jmp	.L29
 1150      00
 1151              	.L47:
 292:main.c        ****             fStatus = flIsFPGARunning(handle, &isRunning, &error);
 1152              		.loc 1 292 0 is_stmt 1
 1153 0a20 488B8518 		movq	-232(%rbp), %rax
 1153      FFFFFF
 1154 0a27 488D9520 		leaq	-224(%rbp), %rdx
 1154      FFFFFF
 1155 0a2e 488D8D93 		leaq	-365(%rbp), %rcx
 1155      FEFFFF
 1156 0a35 4889CE   		movq	%rcx, %rsi
 1157 0a38 4889C7   		movq	%rax, %rdi
 1158 0a3b E8000000 		call	flIsFPGARunning
 1158      00
 1159 0a40 8985F0FE 		movl	%eax, -272(%rbp)
 1159      FFFF
 293:main.c        ****             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1160              		.loc 1 293 0
 1161 0a46 83BDF0FE 		cmpl	$0, -272(%rbp)
 1161      FFFF00
 1162 0a4d 740F     		je	.L49
 1163              		.loc 1 293 0 is_stmt 0 discriminator 1
 1164 0a4f C785C0FE 		movl	$1, -320(%rbp)
 1164      FFFF0100 
 1164      0000
 1165 0a59 E9501200 		jmp	.L29
 1165      00
 1166              	.L49:
 294:main.c        ****             if (isRunning) {
 1167              		.loc 1 294 0 is_stmt 1
 1168 0a5e 0FB68593 		movzbl	-365(%rbp), %eax
 1168      FEFFFF
 1169 0a65 84C0     		testb	%al, %al
 1170 0a67 0F84EF11 		je	.L50
 1170      0000
 1171              	.LBB7:
 295:main.c        **** 
 296:main.c        ****                 FILE *fPtr;
 297:main.c        ****                 fPtr = fopen("SampleBackEndDatabase.csv", "r+"); // change flag according to need
 1172              		.loc 1 297 0
 1173 0a6d BE000000 		movl	$.LC49, %esi
 1173      00
 1174 0a72 BF000000 		movl	$.LC50, %edi
 1174      00
 1175 0a77 E8000000 		call	fopen
 1175      00
 1176 0a7c 48894590 		movq	%rax, -112(%rbp)
 298:main.c        ****                 if (fPtr == NULL) {
 1177              		.loc 1 298 0
 1178 0a80 48837D90 		cmpq	$0, -112(%rbp)
 1178      00
 1179 0a85 7514     		jne	.L51
 299:main.c        ****                     printf("Csv doesn't exist \n");
 1180              		.loc 1 299 0
 1181 0a87 BF000000 		movl	$.LC51, %edi
 1181      00
 1182 0a8c E8000000 		call	puts
 1182      00
 300:main.c        ****                     return 0;
 1183              		.loc 1 300 0
 1184 0a91 B8000000 		movl	$0, %eax
 1184      00
 1185 0a96 E96F1200 		jmp	.L166
 1185      00
 1186              	.L51:
 301:main.c        ****                 }
 302:main.c        ****                 size_t lineSize = 100;
 1187              		.loc 1 302 0
 1188 0a9b 48C78528 		movq	$100, -216(%rbp)
 1188      FFFFFF64 
 1188      000000
 303:main.c        ****                 char *lineFromFile = malloc(lineSize * sizeof(char));
 1189              		.loc 1 303 0
 1190 0aa6 488B8528 		movq	-216(%rbp), %rax
 1190      FFFFFF
 1191 0aad 4889C7   		movq	%rax, %rdi
 1192 0ab0 E8000000 		call	malloc
 1192      00
 1193 0ab5 48898530 		movq	%rax, -208(%rbp)
 1193      FFFFFF
 304:main.c        **** 
 305:main.c        ****                 while ((getline(&lineFromFile, &lineSize, fPtr)) != -1) {
 1194              		.loc 1 305 0
 1195 0abc EB28     		jmp	.L53
 1196              	.L55:
 306:main.c        ****                     if (numLines != 0) format(lineFromFile);
 1197              		.loc 1 306 0
 1198 0abe 8B050000 		movl	numLines(%rip), %eax
 1198      0000
 1199 0ac4 85C0     		testl	%eax, %eax
 1200 0ac6 740F     		je	.L54
 1201              		.loc 1 306 0 is_stmt 0 discriminator 1
 1202 0ac8 488B8530 		movq	-208(%rbp), %rax
 1202      FFFFFF
 1203 0acf 4889C7   		movq	%rax, %rdi
 1204 0ad2 E8000000 		call	format
 1204      00
 1205              	.L54:
 307:main.c        ****                     numLines++;
 1206              		.loc 1 307 0 is_stmt 1
 1207 0ad7 8B050000 		movl	numLines(%rip), %eax
 1207      0000
 1208 0add 83C001   		addl	$1, %eax
 1209 0ae0 89050000 		movl	%eax, numLines(%rip)
 1209      0000
 1210              	.L53:
 305:main.c        ****                     if (numLines != 0) format(lineFromFile);
 1211              		.loc 1 305 0 discriminator 1
 1212 0ae6 488B5590 		movq	-112(%rbp), %rdx
 1213 0aea 488D8D28 		leaq	-216(%rbp), %rcx
 1213      FFFFFF
 1214 0af1 488D8530 		leaq	-208(%rbp), %rax
 1214      FFFFFF
 1215 0af8 4889CE   		movq	%rcx, %rsi
 1216 0afb 4889C7   		movq	%rax, %rdi
 1217 0afe E8000000 		call	getline
 1217      00
 1218 0b03 4883F8FF 		cmpq	$-1, %rax
 1219 0b07 75B5     		jne	.L55
 308:main.c        ****                 }
 309:main.c        ****                 numLines--;
 1220              		.loc 1 309 0
 1221 0b09 8B050000 		movl	numLines(%rip), %eax
 1221      0000
 1222 0b0f 83E801   		subl	$1, %eax
 1223 0b12 89050000 		movl	%eax, numLines(%rip)
 1223      0000
 310:main.c        ****                 free(lineFromFile);
 1224              		.loc 1 310 0
 1225 0b18 488B8530 		movq	-208(%rbp), %rax
 1225      FFFFFF
 1226 0b1f 4889C7   		movq	%rax, %rdi
 1227 0b22 E8000000 		call	free
 1227      00
 311:main.c        ****                 fclose(fPtr);
 1228              		.loc 1 311 0
 1229 0b27 488B4590 		movq	-112(%rbp), %rax
 1230 0b2b 4889C7   		movq	%rax, %rdi
 1231 0b2e E8000000 		call	fclose
 1231      00
 312:main.c        **** 
 313:main.c        ****                 // Bank id error handling
 314:main.c        ****                 if(bankID < 0 || bankID > 31) {
 1232              		.loc 1 314 0
 1233 0b33 8B050000 		movl	bankID(%rip), %eax
 1233      0000
 1234 0b39 85C0     		testl	%eax, %eax
 1235 0b3b 780B     		js	.L56
 1236              		.loc 1 314 0 is_stmt 0 discriminator 1
 1237 0b3d 8B050000 		movl	bankID(%rip), %eax
 1237      0000
 1238 0b43 83F81F   		cmpl	$31, %eax
 1239 0b46 7E14     		jle	.L57
 1240              	.L56:
 315:main.c        ****                     printf("%s\n", "Invalid bankID");
 1241              		.loc 1 315 0 is_stmt 1
 1242 0b48 BF000000 		movl	$.LC36, %edi
 1242      00
 1243 0b4d E8000000 		call	puts
 1243      00
 316:main.c        ****                     return 0;
 1244              		.loc 1 316 0
 1245 0b52 B8000000 		movl	$0, %eax
 1245      00
 1246 0b57 E9AE1100 		jmp	.L166
 1246      00
 1247              	.L57:
 1248              	.LBB8:
 317:main.c        ****                 }
 318:main.c        ****                 
 319:main.c        ****                 while (true) {
 320:main.c        ****                     uint32_t length = 1;
 1249              		.loc 1 320 0
 1250 0b5c C785F4FE 		movl	$1, -268(%rbp)
 1250      FFFF0100 
 1250      0000
 321:main.c        ****                     uint8_t *readFromChannelZero = malloc(sizeof(uint8_t));
 1251              		.loc 1 321 0
 1252 0b66 BF010000 		movl	$1, %edi
 1252      00
 1253 0b6b E8000000 		call	malloc
 1253      00
 1254 0b70 48894598 		movq	%rax, -104(%rbp)
 322:main.c        **** 
 323:main.c        ****                     fStatus = flReadChannel(handle, (uint8_t) 0, length, readFromChannelZero, &erro
 1255              		.loc 1 323 0
 1256 0b74 8B95F4FE 		movl	-268(%rbp), %edx
 1256      FFFF
 1257 0b7a 488B8518 		movq	-232(%rbp), %rax
 1257      FFFFFF
 1258 0b81 488DB520 		leaq	-224(%rbp), %rsi
 1258      FFFFFF
 1259 0b88 488B4D98 		movq	-104(%rbp), %rcx
 1260 0b8c 4989F0   		movq	%rsi, %r8
 1261 0b8f BE000000 		movl	$0, %esi
 1261      00
 1262 0b94 4889C7   		movq	%rax, %rdi
 1263 0b97 E8000000 		call	flReadChannel
 1263      00
 1264 0b9c 8985F0FE 		movl	%eax, -272(%rbp)
 1264      FFFF
 324:main.c        ****                     CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1265              		.loc 1 324 0
 1266 0ba2 83BDF0FE 		cmpl	$0, -272(%rbp)
 1266      FFFF00
 1267 0ba9 740F     		je	.L58
 1268              		.loc 1 324 0 is_stmt 0 discriminator 1
 1269 0bab C785C0FE 		movl	$1, -320(%rbp)
 1269      FFFF0100 
 1269      0000
 1270 0bb5 E9A01000 		jmp	.L59
 1270      00
 1271              	.L58:
 325:main.c        ****                     if (LOG) printf("Read from channel 0 = %u \n", *readFromChannelZero);
 1272              		.loc 1 325 0 is_stmt 1
 1273 0bba 0FB60500 		movzbl	LOG(%rip), %eax
 1273      000000
 1274 0bc1 84C0     		testb	%al, %al
 1275 0bc3 741B     		je	.L60
 1276              		.loc 1 325 0 is_stmt 0 discriminator 1
 1277 0bc5 488B4598 		movq	-104(%rbp), %rax
 1278 0bc9 0FB600   		movzbl	(%rax), %eax
 1279 0bcc 0FB6C0   		movzbl	%al, %eax
 1280 0bcf 89C6     		movl	%eax, %esi
 1281 0bd1 BF000000 		movl	$.LC52, %edi
 1281      00
 1282 0bd6 B8000000 		movl	$0, %eax
 1282      00
 1283 0bdb E8000000 		call	printf
 1283      00
 1284              	.L60:
 326:main.c        **** 
 327:main.c        ****                     if (((*readFromChannelZero) == 1) || ((*readFromChannelZero) == 2)) {
 1285              		.loc 1 327 0 is_stmt 1
 1286 0be0 488B4598 		movq	-104(%rbp), %rax
 1287 0be4 0FB600   		movzbl	(%rax), %eax
 1288 0be7 3C01     		cmpb	$1, %al
 1289 0be9 740F     		je	.L61
 1290              		.loc 1 327 0 is_stmt 0 discriminator 1
 1291 0beb 488B4598 		movq	-104(%rbp), %rax
 1292 0bef 0FB600   		movzbl	(%rax), %eax
 1293 0bf2 3C02     		cmpb	$2, %al
 1294 0bf4 0F855110 		jne	.L62
 1294      0000
 1295              	.L61:
 1296              	.LBB9:
 328:main.c        ****                         uint8_t cnt = 1, valRead = *readFromChannelZero;
 1297              		.loc 1 328 0 is_stmt 1
 1298 0bfa C68596FE 		movb	$1, -362(%rbp)
 1298      FFFF01
 1299 0c01 488B4598 		movq	-104(%rbp), %rax
 1300 0c05 0FB600   		movzbl	(%rax), %eax
 1301 0c08 8885A7FE 		movb	%al, -345(%rbp)
 1301      FFFF
 329:main.c        ****                         bool cont = true;
 1302              		.loc 1 329 0
 1303 0c0e C68597FE 		movb	$1, -361(%rbp)
 1303      FFFF01
 330:main.c        ****                         while (cnt < 3) {
 1304              		.loc 1 330 0
 1305 0c15 E9A00000 		jmp	.L63
 1305      00
 1306              	.L68:
 331:main.c        ****                             flSleep(1000);
 1307              		.loc 1 331 0
 1308 0c1a BFE80300 		movl	$1000, %edi
 1308      00
 1309 0c1f E8000000 		call	flSleep
 1309      00
 332:main.c        ****                             fStatus = flReadChannel(handle, 0, length, readFromChannelZero, &error)
 1310              		.loc 1 332 0
 1311 0c24 8B95F4FE 		movl	-268(%rbp), %edx
 1311      FFFF
 1312 0c2a 488B8518 		movq	-232(%rbp), %rax
 1312      FFFFFF
 1313 0c31 488DB520 		leaq	-224(%rbp), %rsi
 1313      FFFFFF
 1314 0c38 488B4D98 		movq	-104(%rbp), %rcx
 1315 0c3c 4989F0   		movq	%rsi, %r8
 1316 0c3f BE000000 		movl	$0, %esi
 1316      00
 1317 0c44 4889C7   		movq	%rax, %rdi
 1318 0c47 E8000000 		call	flReadChannel
 1318      00
 1319 0c4c 8985F0FE 		movl	%eax, -272(%rbp)
 1319      FFFF
 333:main.c        ****                             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1320              		.loc 1 333 0
 1321 0c52 83BDF0FE 		cmpl	$0, -272(%rbp)
 1321      FFFF00
 1322 0c59 740F     		je	.L64
 1323              		.loc 1 333 0 is_stmt 0 discriminator 1
 1324 0c5b C785C0FE 		movl	$1, -320(%rbp)
 1324      FFFF0100 
 1324      0000
 1325 0c65 E9F00F00 		jmp	.L59
 1325      00
 1326              	.L64:
 334:main.c        ****                             if (LOG) printf("Read from channel 0 = %u \n", *readFromChannelZero);
 1327              		.loc 1 334 0 is_stmt 1
 1328 0c6a 0FB60500 		movzbl	LOG(%rip), %eax
 1328      000000
 1329 0c71 84C0     		testb	%al, %al
 1330 0c73 741B     		je	.L65
 1331              		.loc 1 334 0 is_stmt 0 discriminator 1
 1332 0c75 488B4598 		movq	-104(%rbp), %rax
 1333 0c79 0FB600   		movzbl	(%rax), %eax
 1334 0c7c 0FB6C0   		movzbl	%al, %eax
 1335 0c7f 89C6     		movl	%eax, %esi
 1336 0c81 BF000000 		movl	$.LC52, %edi
 1336      00
 1337 0c86 B8000000 		movl	$0, %eax
 1337      00
 1338 0c8b E8000000 		call	printf
 1338      00
 1339              	.L65:
 335:main.c        **** 
 336:main.c        ****                             if (*readFromChannelZero == valRead) cnt++;
 1340              		.loc 1 336 0 is_stmt 1
 1341 0c90 488B4598 		movq	-104(%rbp), %rax
 1342 0c94 0FB600   		movzbl	(%rax), %eax
 1343 0c97 3A85A7FE 		cmpb	-345(%rbp), %al
 1343      FFFF
 1344 0c9d 7512     		jne	.L66
 1345              		.loc 1 336 0 is_stmt 0 discriminator 1
 1346 0c9f 0FB68596 		movzbl	-362(%rbp), %eax
 1346      FEFFFF
 1347 0ca6 83C001   		addl	$1, %eax
 1348 0ca9 888596FE 		movb	%al, -362(%rbp)
 1348      FFFF
 1349 0caf EB09     		jmp	.L63
 1350              	.L66:
 337:main.c        ****                             else {
 338:main.c        ****                                 cont = false;
 1351              		.loc 1 338 0 is_stmt 1
 1352 0cb1 C68597FE 		movb	$0, -361(%rbp)
 1352      FFFF00
 339:main.c        ****                                 break;
 1353              		.loc 1 339 0
 1354 0cb8 EB0D     		jmp	.L67
 1355              	.L63:
 330:main.c        ****                             flSleep(1000);
 1356              		.loc 1 330 0 discriminator 1
 1357 0cba 80BD96FE 		cmpb	$2, -362(%rbp)
 1357      FFFF02
 1358 0cc1 0F8653FF 		jbe	.L68
 1358      FFFF
 1359              	.L67:
 340:main.c        ****                             }
 341:main.c        ****                         }
 342:main.c        ****                         if (cont) {
 1360              		.loc 1 342 0
 1361 0cc7 80BD97FE 		cmpb	$0, -361(%rbp)
 1361      FFFF00
 1362 0cce 0F84770F 		je	.L62
 1362      0000
 1363              	.LBB10:
 1364              	.LBB11:
 343:main.c        ****                             uint32_t inpFromFrontEnd[2];
 344:main.c        ****                             for (int i = 0; i < 2; i++) inpFromFrontEnd[i] = 0;
 1365              		.loc 1 344 0
 1366 0cd4 C785C8FE 		movl	$0, -312(%rbp)
 1366      FFFF0000 
 1366      0000
 1367 0cde EB1A     		jmp	.L69
 1368              	.L70:
 1369              		.loc 1 344 0 is_stmt 0 discriminator 2
 1370 0ce0 8B85C8FE 		movl	-312(%rbp), %eax
 1370      FFFF
 1371 0ce6 4898     		cltq
 1372 0ce8 C7848500 		movl	$0, -256(%rbp,%rax,4)
 1372      FFFFFF00 
 1372      000000
 1373 0cf3 8385C8FE 		addl	$1, -312(%rbp)
 1373      FFFF01
 1374              	.L69:
 1375              		.loc 1 344 0 discriminator 1
 1376 0cfa 83BDC8FE 		cmpl	$1, -312(%rbp)
 1376      FFFF01
 1377 0d01 7EDD     		jle	.L70
 1378              	.LBE11:
 1379              	.LBB12:
 345:main.c        ****                             for (uint32_t i = 1; i <= 8; i++) {
 1380              		.loc 1 345 0 is_stmt 1
 1381 0d03 C785CCFE 		movl	$1, -308(%rbp)
 1381      FFFF0100 
 1381      0000
 1382 0d0d E9100100 		jmp	.L71
 1382      00
 1383              	.L77:
 1384              	.LBB13:
 346:main.c        ****                                 uint8_t *readFromChannel_i = malloc(sizeof(uint8_t));
 1385              		.loc 1 346 0
 1386 0d12 BF010000 		movl	$1, %edi
 1386      00
 1387 0d17 E8000000 		call	malloc
 1387      00
 1388 0d1c 488945A0 		movq	%rax, -96(%rbp)
 347:main.c        **** 
 348:main.c        ****                                 flSleep(1000);
 1389              		.loc 1 348 0
 1390 0d20 BFE80300 		movl	$1000, %edi
 1390      00
 1391 0d25 E8000000 		call	flSleep
 1391      00
 349:main.c        ****                                 fStatus = flReadChannel(handle, (uint8_t) i, length, readFromChanne
 1392              		.loc 1 349 0
 1393 0d2a 8B95F4FE 		movl	-268(%rbp), %edx
 1393      FFFF
 1394 0d30 8B85CCFE 		movl	-308(%rbp), %eax
 1394      FFFF
 1395 0d36 0FB6F0   		movzbl	%al, %esi
 1396 0d39 488B8518 		movq	-232(%rbp), %rax
 1396      FFFFFF
 1397 0d40 488DBD20 		leaq	-224(%rbp), %rdi
 1397      FFFFFF
 1398 0d47 488B4DA0 		movq	-96(%rbp), %rcx
 1399 0d4b 4989F8   		movq	%rdi, %r8
 1400 0d4e 4889C7   		movq	%rax, %rdi
 1401 0d51 E8000000 		call	flReadChannel
 1401      00
 1402 0d56 8985F0FE 		movl	%eax, -272(%rbp)
 1402      FFFF
 350:main.c        ****                                 CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1403              		.loc 1 350 0
 1404 0d5c 83BDF0FE 		cmpl	$0, -272(%rbp)
 1404      FFFF00
 1405 0d63 740F     		je	.L72
 1406              		.loc 1 350 0 is_stmt 0 discriminator 1
 1407 0d65 C785C0FE 		movl	$1, -320(%rbp)
 1407      FFFF0100 
 1407      0000
 1408 0d6f E9D50E00 		jmp	.L73
 1408      00
 1409              	.L72:
 351:main.c        ****                                 if (LOG) printf("Read from channel %u = %u \n", i, *readFromChannel
 1410              		.loc 1 351 0 is_stmt 1
 1411 0d74 0FB60500 		movzbl	LOG(%rip), %eax
 1411      000000
 1412 0d7b 84C0     		testb	%al, %al
 1413 0d7d 7421     		je	.L74
 1414              		.loc 1 351 0 is_stmt 0 discriminator 1
 1415 0d7f 488B45A0 		movq	-96(%rbp), %rax
 1416 0d83 0FB600   		movzbl	(%rax), %eax
 1417 0d86 0FB6D0   		movzbl	%al, %edx
 1418 0d89 8B85CCFE 		movl	-308(%rbp), %eax
 1418      FFFF
 1419 0d8f 89C6     		movl	%eax, %esi
 1420 0d91 BF000000 		movl	$.LC53, %edi
 1420      00
 1421 0d96 B8000000 		movl	$0, %eax
 1421      00
 1422 0d9b E8000000 		call	printf
 1422      00
 1423              	.L74:
 352:main.c        ****                                 uint32_t temp1 = 8 * (i - 1), temp2 = 8 * (i - 5);
 1424              		.loc 1 352 0 is_stmt 1
 1425 0da0 8B85CCFE 		movl	-308(%rbp), %eax
 1425      FFFF
 1426 0da6 05FFFFFF 		addl	$536870911, %eax
 1426      1F
 1427 0dab C1E003   		sall	$3, %eax
 1428 0dae 8985F8FE 		movl	%eax, -264(%rbp)
 1428      FFFF
 1429 0db4 8B85CCFE 		movl	-308(%rbp), %eax
 1429      FFFF
 1430 0dba 05FBFFFF 		addl	$536870907, %eax
 1430      1F
 1431 0dbf C1E003   		sall	$3, %eax
 1432 0dc2 8985FCFE 		movl	%eax, -260(%rbp)
 1432      FFFF
 353:main.c        ****                                 if (i <= 4) inpFromFrontEnd[0] += (*readFromChannel_i) * (1 << temp
 1433              		.loc 1 353 0
 1434 0dc8 83BDCCFE 		cmpl	$4, -308(%rbp)
 1434      FFFF04
 1435 0dcf 7726     		ja	.L75
 1436              		.loc 1 353 0 is_stmt 0 discriminator 1
 1437 0dd1 8B9500FF 		movl	-256(%rbp), %edx
 1437      FFFF
 1438 0dd7 488B45A0 		movq	-96(%rbp), %rax
 1439 0ddb 0FB600   		movzbl	(%rax), %eax
 1440 0dde 0FB6F0   		movzbl	%al, %esi
 1441 0de1 8B85F8FE 		movl	-264(%rbp), %eax
 1441      FFFF
 1442 0de7 89C1     		movl	%eax, %ecx
 1443 0de9 D3E6     		sall	%cl, %esi
 1444 0deb 89F0     		movl	%esi, %eax
 1445 0ded 01D0     		addl	%edx, %eax
 1446 0def 898500FF 		movl	%eax, -256(%rbp)
 1446      FFFF
 1447 0df5 EB24     		jmp	.L76
 1448              	.L75:
 354:main.c        ****                                 else inpFromFrontEnd[1] += (*readFromChannel_i) * (1 << temp2);
 1449              		.loc 1 354 0 is_stmt 1
 1450 0df7 8B9504FF 		movl	-252(%rbp), %edx
 1450      FFFF
 1451 0dfd 488B45A0 		movq	-96(%rbp), %rax
 1452 0e01 0FB600   		movzbl	(%rax), %eax
 1453 0e04 0FB6F0   		movzbl	%al, %esi
 1454 0e07 8B85FCFE 		movl	-260(%rbp), %eax
 1454      FFFF
 1455 0e0d 89C1     		movl	%eax, %ecx
 1456 0e0f D3E6     		sall	%cl, %esi
 1457 0e11 89F0     		movl	%esi, %eax
 1458 0e13 01D0     		addl	%edx, %eax
 1459 0e15 898504FF 		movl	%eax, -252(%rbp)
 1459      FFFF
 1460              	.L76:
 1461              	.LBE13:
 345:main.c        ****                                 uint8_t *readFromChannel_i = malloc(sizeof(uint8_t));
 1462              		.loc 1 345 0
 1463 0e1b 8385CCFE 		addl	$1, -308(%rbp)
 1463      FFFF01
 1464              	.L71:
 345:main.c        ****                                 uint8_t *readFromChannel_i = malloc(sizeof(uint8_t));
 1465              		.loc 1 345 0 is_stmt 0 discriminator 1
 1466 0e22 83BDCCFE 		cmpl	$8, -308(%rbp)
 1466      FFFF08
 1467 0e29 0F86E3FE 		jbe	.L77
 1467      FFFF
 1468              	.LBE12:
 355:main.c        ****                             }
 356:main.c        ****                             decrypt64(inpFromFrontEnd);
 1469              		.loc 1 356 0 is_stmt 1
 1470 0e2f 488D8500 		leaq	-256(%rbp), %rax
 1470      FFFFFF
 1471 0e36 4889C7   		movq	%rax, %rdi
 1472 0e39 E8000000 		call	decrypt64
 1472      00
 357:main.c        ****                             uint8_t num_100_admin = 0, num_500_admin = 0, num_1000_admin = 0, num_2
 1473              		.loc 1 357 0
 1474 0e3e C68598FE 		movb	$0, -360(%rbp)
 1474      FFFF00
 1475 0e45 C68599FE 		movb	$0, -359(%rbp)
 1475      FFFF00
 1476 0e4c C6859AFE 		movb	$0, -358(%rbp)
 1476      FFFF00
 1477 0e53 C6859BFE 		movb	$0, -357(%rbp)
 1477      FFFF00
 358:main.c        ****                             uint16_t userID = 0, unhashedPin = 0;
 1478              		.loc 1 358 0
 1479 0e5a 66C785AC 		movw	$0, -340(%rbp)
 1479      FEFFFF00 
 1479      00
 1480 0e63 66C785AE 		movw	$0, -338(%rbp)
 1480      FEFFFF00 
 1480      00
 1481              	.LBB14:
 359:main.c        **** 
 360:main.c        ****                             for (uint16_t i = 1; i <= 32; i++) {
 1482              		.loc 1 360 0
 1483 0e6c 66C785B0 		movw	$1, -336(%rbp)
 1483      FEFFFF01 
 1483      00
 1484 0e75 E9970000 		jmp	.L78
 1484      00
 1485              	.L82:
 361:main.c        ****                                 if (i <= 16) {
 1486              		.loc 1 361 0
 1487 0e7a 6683BDB0 		cmpw	$16, -336(%rbp)
 1487      FEFFFF10 
 1488 0e82 773F     		ja	.L79
 362:main.c        ****                                     if ((inpFromFrontEnd[1] & (1 << (i - 1))) != 0) unhashedPin += 
 1489              		.loc 1 362 0
 1490 0e84 8B9504FF 		movl	-252(%rbp), %edx
 1490      FFFF
 1491 0e8a 0FB785B0 		movzwl	-336(%rbp), %eax
 1491      FEFFFF
 1492 0e91 83E801   		subl	$1, %eax
 1493 0e94 BE010000 		movl	$1, %esi
 1493      00
 1494 0e99 89C1     		movl	%eax, %ecx
 1495 0e9b D3E6     		sall	%cl, %esi
 1496 0e9d 89F0     		movl	%esi, %eax
 1497 0e9f 21D0     		andl	%edx, %eax
 1498 0ea1 85C0     		testl	%eax, %eax
 1499 0ea3 745B     		je	.L81
 1500              		.loc 1 362 0 is_stmt 0 discriminator 1
 1501 0ea5 0FB785B0 		movzwl	-336(%rbp), %eax
 1501      FEFFFF
 1502 0eac 83E801   		subl	$1, %eax
 1503 0eaf BA010000 		movl	$1, %edx
 1503      00
 1504 0eb4 89C1     		movl	%eax, %ecx
 1505 0eb6 D3E2     		sall	%cl, %edx
 1506 0eb8 89D0     		movl	%edx, %eax
 1507 0eba 660185AE 		addw	%ax, -338(%rbp)
 1507      FEFFFF
 1508 0ec1 EB3D     		jmp	.L81
 1509              	.L79:
 363:main.c        ****                                 } else {
 364:main.c        ****                                     if ((inpFromFrontEnd[1] & (1 << (i - 1))) != 0) userID += ((1 <
 1510              		.loc 1 364 0 is_stmt 1
 1511 0ec3 8B9504FF 		movl	-252(%rbp), %edx
 1511      FFFF
 1512 0ec9 0FB785B0 		movzwl	-336(%rbp), %eax
 1512      FEFFFF
 1513 0ed0 83E801   		subl	$1, %eax
 1514 0ed3 BE010000 		movl	$1, %esi
 1514      00
 1515 0ed8 89C1     		movl	%eax, %ecx
 1516 0eda D3E6     		sall	%cl, %esi
 1517 0edc 89F0     		movl	%esi, %eax
 1518 0ede 21D0     		andl	%edx, %eax
 1519 0ee0 85C0     		testl	%eax, %eax
 1520 0ee2 741C     		je	.L81
 1521              		.loc 1 364 0 is_stmt 0 discriminator 1
 1522 0ee4 0FB785B0 		movzwl	-336(%rbp), %eax
 1522      FEFFFF
 1523 0eeb 83E811   		subl	$17, %eax
 1524 0eee BA010000 		movl	$1, %edx
 1524      00
 1525 0ef3 89C1     		movl	%eax, %ecx
 1526 0ef5 D3E2     		sall	%cl, %edx
 1527 0ef7 89D0     		movl	%edx, %eax
 1528 0ef9 660185AC 		addw	%ax, -340(%rbp)
 1528      FEFFFF
 1529              	.L81:
 360:main.c        ****                                 if (i <= 16) {
 1530              		.loc 1 360 0 is_stmt 1
 1531 0f00 0FB785B0 		movzwl	-336(%rbp), %eax
 1531      FEFFFF
 1532 0f07 83C001   		addl	$1, %eax
 1533 0f0a 668985B0 		movw	%ax, -336(%rbp)
 1533      FEFFFF
 1534              	.L78:
 360:main.c        ****                                 if (i <= 16) {
 1535              		.loc 1 360 0 is_stmt 0 discriminator 1
 1536 0f11 6683BDB0 		cmpw	$32, -336(%rbp)
 1536      FEFFFF20 
 1537 0f19 0F865BFF 		jbe	.L82
 1537      FFFF
 1538              	.LBE14:
 365:main.c        ****                                 }
 366:main.c        ****                             }
 367:main.c        **** //                            printf("unhashedPin %u\n", unhashedPin);
 368:main.c        **** //                            printf("userID %u\n", userID);
 369:main.c        ****                             uint16_t hashedPin = myHash(unhashedPin);
 1539              		.loc 1 369 0 is_stmt 1
 1540 0f1f 0FB785AE 		movzwl	-338(%rbp), %eax
 1540      FEFFFF
 1541 0f26 89C7     		movl	%eax, %edi
 1542 0f28 E8000000 		call	myHash
 1542      00
 1543 0f2d 668985B2 		movw	%ax, -334(%rbp)
 1543      FEFFFF
 370:main.c        **** //                            printf("hashedPin %u\n", hashedPin);
 371:main.c        **** 
 372:main.c        ****                             int bal = -1;
 1544              		.loc 1 372 0
 1545 0f34 C785B4FE 		movl	$-1, -332(%rbp)
 1545      FFFFFFFF 
 1545      FFFF
 373:main.c        ****                             bool isAdmin = false;
 1546              		.loc 1 373 0
 1547 0f3e C68594FE 		movb	$0, -364(%rbp)
 1547      FFFF00
 374:main.c        ****                             int inLineNum = -1;
 1548              		.loc 1 374 0
 1549 0f45 C785B8FE 		movl	$-1, -328(%rbp)
 1549      FFFFFFFF 
 1549      FFFF
 375:main.c        ****                             uint8_t *statusOnChan9 = malloc(sizeof(uint8_t));
 1550              		.loc 1 375 0
 1551 0f4f BF010000 		movl	$1, %edi
 1551      00
 1552 0f54 E8000000 		call	malloc
 1552      00
 1553 0f59 488945A8 		movq	%rax, -88(%rbp)
 376:main.c        ****                             if (find(userID, hashedPin, &isAdmin, &bal, &inLineNum)) {
 1554              		.loc 1 376 0
 1555 0f5d 0FB7B5B2 		movzwl	-334(%rbp), %esi
 1555      FEFFFF
 1556 0f64 0FB785AC 		movzwl	-340(%rbp), %eax
 1556      FEFFFF
 1557 0f6b 488DBDB8 		leaq	-328(%rbp), %rdi
 1557      FEFFFF
 1558 0f72 488D8DB4 		leaq	-332(%rbp), %rcx
 1558      FEFFFF
 1559 0f79 488D9594 		leaq	-364(%rbp), %rdx
 1559      FEFFFF
 1560 0f80 4989F8   		movq	%rdi, %r8
 1561 0f83 89C7     		movl	%eax, %edi
 1562 0f85 E8000000 		call	find
 1562      00
 1563 0f8a 84C0     		testb	%al, %al
 1564 0f8c 0F847F0B 		je	.L83
 1564      0000
 377:main.c        ****                                 printf("Valid user found \n");
 1565              		.loc 1 377 0
 1566 0f92 BF000000 		movl	$.LC54, %edi
 1566      00
 1567 0f97 E8000000 		call	puts
 1567      00
 378:main.c        ****                                 if (!isAdmin) {
 1568              		.loc 1 378 0
 1569 0f9c 0FB68594 		movzbl	-364(%rbp), %eax
 1569      FEFFFF
 1570 0fa3 83F001   		xorl	$1, %eax
 1571 0fa6 84C0     		testb	%al, %al
 1572 0fa8 0F841A06 		je	.L84
 1572      0000
 1573              	.LBB15:
 379:main.c        ****                                     int reqAmo = inpFromFrontEnd[0];
 1574              		.loc 1 379 0
 1575 0fae 8B8500FF 		movl	-256(%rbp), %eax
 1575      FFFF
 1576 0fb4 8985BCFE 		movl	%eax, -324(%rbp)
 1576      FFFF
 380:main.c        ****                                     if (suffBalUser(bal, &reqAmo)) {
 1577              		.loc 1 380 0
 1578 0fba 8B85B4FE 		movl	-332(%rbp), %eax
 1578      FFFF
 1579 0fc0 488D95BC 		leaq	-324(%rbp), %rdx
 1579      FEFFFF
 1580 0fc7 4889D6   		movq	%rdx, %rsi
 1581 0fca 89C7     		movl	%eax, %edi
 1582 0fcc E8000000 		call	suffBalUser
 1582      00
 1583 0fd1 84C0     		testb	%al, %al
 1584 0fd3 0F84A104 		je	.L85
 1584      0000
 1585              	.LBB16:
 381:main.c        **** //                                        printf("bal %u\n", bal);
 382:main.c        **** //                                        printf("req %u\n", reqAmo);
 383:main.c        ****                                         if (LOG) printf("Sufficient Balance in account\n");
 1586              		.loc 1 383 0
 1587 0fd9 0FB60500 		movzbl	LOG(%rip), %eax
 1587      000000
 1588 0fe0 84C0     		testb	%al, %al
 1589 0fe2 740A     		je	.L86
 1590              		.loc 1 383 0 is_stmt 0 discriminator 1
 1591 0fe4 BF000000 		movl	$.LC55, %edi
 1591      00
 1592 0fe9 E8000000 		call	puts
 1592      00
 1593              	.L86:
 384:main.c        ****                                         *statusOnChan9 = 1;
 1594              		.loc 1 384 0 is_stmt 1
 1595 0fee 488B45A8 		movq	-88(%rbp), %rax
 1596 0ff2 C60001   		movb	$1, (%rax)
 385:main.c        ****                                         flSleep(1000);
 1597              		.loc 1 385 0
 1598 0ff5 BFE80300 		movl	$1000, %edi
 1598      00
 1599 0ffa E8000000 		call	flSleep
 1599      00
 386:main.c        ****                                         if (LOG) printf("Write to channel %u = %u \n", 9, *statusOn
 1600              		.loc 1 386 0
 1601 0fff 0FB60500 		movzbl	LOG(%rip), %eax
 1601      000000
 1602 1006 84C0     		testb	%al, %al
 1603 1008 7420     		je	.L87
 1604              		.loc 1 386 0 is_stmt 0 discriminator 1
 1605 100a 488B45A8 		movq	-88(%rbp), %rax
 1606 100e 0FB600   		movzbl	(%rax), %eax
 1607 1011 0FB6C0   		movzbl	%al, %eax
 1608 1014 89C2     		movl	%eax, %edx
 1609 1016 BE090000 		movl	$9, %esi
 1609      00
 1610 101b BF000000 		movl	$.LC56, %edi
 1610      00
 1611 1020 B8000000 		movl	$0, %eax
 1611      00
 1612 1025 E8000000 		call	printf
 1612      00
 1613              	.L87:
 387:main.c        ****                                         fStatus = flWriteChannel(handle, (uint8_t) 9, length, statu
 1614              		.loc 1 387 0 is_stmt 1
 1615 102a 8B95F4FE 		movl	-268(%rbp), %edx
 1615      FFFF
 1616 1030 488B8518 		movq	-232(%rbp), %rax
 1616      FFFFFF
 1617 1037 488DB520 		leaq	-224(%rbp), %rsi
 1617      FFFFFF
 1618 103e 488B4DA8 		movq	-88(%rbp), %rcx
 1619 1042 4989F0   		movq	%rsi, %r8
 1620 1045 BE090000 		movl	$9, %esi
 1620      00
 1621 104a 4889C7   		movq	%rax, %rdi
 1622 104d E8000000 		call	flWriteChannel
 1622      00
 1623 1052 8985F0FE 		movl	%eax, -272(%rbp)
 1623      FFFF
 388:main.c        ****                                         CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1624              		.loc 1 388 0
 1625 1058 83BDF0FE 		cmpl	$0, -272(%rbp)
 1625      FFFF00
 1626 105f 740F     		je	.L88
 1627              		.loc 1 388 0 is_stmt 0 discriminator 1
 1628 1061 C785C0FE 		movl	$1, -320(%rbp)
 1628      FFFF0100 
 1628      0000
 1629 106b E9530500 		jmp	.L115
 1629      00
 1630              	.L88:
 389:main.c        ****                                         flSleep(1000);
 1631              		.loc 1 389 0 is_stmt 1
 1632 1070 BFE80300 		movl	$1000, %edi
 1632      00
 1633 1075 E8000000 		call	flSleep
 1633      00
 1634              	.LBB17:
 390:main.c        ****                                         uint32_t befEncSen[2];
 391:main.c        ****                                         for (int i = 0; i < 2; i++) befEncSen[i] = 0;
 1635              		.loc 1 391 0
 1636 107a C785D0FE 		movl	$0, -304(%rbp)
 1636      FFFF0000 
 1636      0000
 1637 1084 EB1A     		jmp	.L90
 1638              	.L91:
 1639              		.loc 1 391 0 is_stmt 0 discriminator 2
 1640 1086 8B85D0FE 		movl	-304(%rbp), %eax
 1640      FFFF
 1641 108c 4898     		cltq
 1642 108e C7848510 		movl	$0, -240(%rbp,%rax,4)
 1642      FFFFFF00 
 1642      000000
 1643 1099 8385D0FE 		addl	$1, -304(%rbp)
 1643      FFFF01
 1644              	.L90:
 1645              		.loc 1 391 0 discriminator 1
 1646 10a0 83BDD0FE 		cmpl	$1, -304(%rbp)
 1646      FFFF01
 1647 10a7 7EDD     		jle	.L91
 1648              	.LBE17:
 392:main.c        ****                                         befEncSen[0] = reqAmo;
 1649              		.loc 1 392 0 is_stmt 1
 1650 10a9 8B85BCFE 		movl	-324(%rbp), %eax
 1650      FFFF
 1651 10af 898510FF 		movl	%eax, -240(%rbp)
 1651      FFFF
 393:main.c        ****                                         encrypt64(befEncSen);
 1652              		.loc 1 393 0
 1653 10b5 488D8510 		leaq	-240(%rbp), %rax
 1653      FFFFFF
 1654 10bc 4889C7   		movq	%rax, %rdi
 1655 10bf E8000000 		call	encrypt64
 1655      00
 1656              	.LBB18:
 394:main.c        ****                                         for (uint8_t i = 10; i <= 13; i++) {
 1657              		.loc 1 394 0
 1658 10c4 C6859CFE 		movb	$10, -356(%rbp)
 1658      FFFF0A
 1659 10cb E91C0100 		jmp	.L92
 1659      00
 1660              	.L98:
 1661              	.LBB19:
 395:main.c        ****                                             uint8_t tempSto = 0;
 1662              		.loc 1 395 0
 1663 10d0 C68595FE 		movb	$0, -363(%rbp)
 1663      FFFF00
 1664              	.LBB20:
 396:main.c        ****                                             for (uint8_t j = 0; j <= 7; j++) {
 1665              		.loc 1 396 0
 1666 10d7 C6859DFE 		movb	$0, -355(%rbp)
 1666      FFFF00
 1667 10de EB71     		jmp	.L93
 1668              	.L95:
 1669              	.LBB21:
 397:main.c        ****                                                 uint8_t temp = j + (i - 10) * 8;
 1670              		.loc 1 397 0
 1671 10e0 0FB6859C 		movzbl	-356(%rbp), %eax
 1671      FEFFFF
 1672 10e7 83E80A   		subl	$10, %eax
 1673 10ea 8D14C500 		leal	0(,%rax,8), %edx
 1673      000000
 1674 10f1 0FB6859D 		movzbl	-355(%rbp), %eax
 1674      FEFFFF
 1675 10f8 01D0     		addl	%edx, %eax
 1676 10fa 8885A8FE 		movb	%al, -344(%rbp)
 1676      FFFF
 398:main.c        ****                                                 if ((befEncSen[0] & (1 << temp)) != 0) {
 1677              		.loc 1 398 0
 1678 1100 8B9510FF 		movl	-240(%rbp), %edx
 1678      FFFF
 1679 1106 0FB685A8 		movzbl	-344(%rbp), %eax
 1679      FEFFFF
 1680 110d BE010000 		movl	$1, %esi
 1680      00
 1681 1112 89C1     		movl	%eax, %ecx
 1682 1114 D3E6     		sall	%cl, %esi
 1683 1116 89F0     		movl	%esi, %eax
 1684 1118 21D0     		andl	%edx, %eax
 1685 111a 85C0     		testl	%eax, %eax
 1686 111c 7423     		je	.L94
 399:main.c        ****                                                     tempSto += (1 << j);
 1687              		.loc 1 399 0
 1688 111e 0FB6859D 		movzbl	-355(%rbp), %eax
 1688      FEFFFF
 1689 1125 BA010000 		movl	$1, %edx
 1689      00
 1690 112a 89C1     		movl	%eax, %ecx
 1691 112c D3E2     		sall	%cl, %edx
 1692 112e 89D0     		movl	%edx, %eax
 1693 1130 89C2     		movl	%eax, %edx
 1694 1132 0FB68595 		movzbl	-363(%rbp), %eax
 1694      FEFFFF
 1695 1139 01D0     		addl	%edx, %eax
 1696 113b 888595FE 		movb	%al, -363(%rbp)
 1696      FFFF
 1697              	.L94:
 1698              	.LBE21:
 396:main.c        ****                                                 uint8_t temp = j + (i - 10) * 8;
 1699              		.loc 1 396 0
 1700 1141 0FB6859D 		movzbl	-355(%rbp), %eax
 1700      FEFFFF
 1701 1148 83C001   		addl	$1, %eax
 1702 114b 88859DFE 		movb	%al, -355(%rbp)
 1702      FFFF
 1703              	.L93:
 396:main.c        ****                                                 uint8_t temp = j + (i - 10) * 8;
 1704              		.loc 1 396 0 is_stmt 0 discriminator 1
 1705 1151 80BD9DFE 		cmpb	$7, -355(%rbp)
 1705      FFFF07
 1706 1158 7686     		jbe	.L95
 1707              	.LBE20:
 400:main.c        ****                                                 }
 401:main.c        ****                                             }
 402:main.c        ****                                             flSleep(1000);
 1708              		.loc 1 402 0 is_stmt 1
 1709 115a BFE80300 		movl	$1000, %edi
 1709      00
 1710 115f E8000000 		call	flSleep
 1710      00
 403:main.c        ****                                             fStatus = flWriteChannel(handle, (uint8_t) i, length, &
 1711              		.loc 1 403 0
 1712 1164 8B95F4FE 		movl	-268(%rbp), %edx
 1712      FFFF
 1713 116a 0FB6B59C 		movzbl	-356(%rbp), %esi
 1713      FEFFFF
 1714 1171 488B8518 		movq	-232(%rbp), %rax
 1714      FFFFFF
 1715 1178 488DBD20 		leaq	-224(%rbp), %rdi
 1715      FFFFFF
 1716 117f 488D8D95 		leaq	-363(%rbp), %rcx
 1716      FEFFFF
 1717 1186 4989F8   		movq	%rdi, %r8
 1718 1189 4889C7   		movq	%rax, %rdi
 1719 118c E8000000 		call	flWriteChannel
 1719      00
 1720 1191 8985F0FE 		movl	%eax, -272(%rbp)
 1720      FFFF
 404:main.c        ****                                             if (LOG) printf("Write to channel %u = %u \n", i, tempS
 1721              		.loc 1 404 0
 1722 1197 0FB60500 		movzbl	LOG(%rip), %eax
 1722      000000
 1723 119e 84C0     		testb	%al, %al
 1724 11a0 7422     		je	.L96
 1725              		.loc 1 404 0 is_stmt 0 discriminator 1
 1726 11a2 0FB68595 		movzbl	-363(%rbp), %eax
 1726      FEFFFF
 1727 11a9 0FB6D0   		movzbl	%al, %edx
 1728 11ac 0FB6859C 		movzbl	-356(%rbp), %eax
 1728      FEFFFF
 1729 11b3 89C6     		movl	%eax, %esi
 1730 11b5 BF000000 		movl	$.LC56, %edi
 1730      00
 1731 11ba B8000000 		movl	$0, %eax
 1731      00
 1732 11bf E8000000 		call	printf
 1732      00
 1733              	.L96:
 405:main.c        ****                                             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1734              		.loc 1 405 0 is_stmt 1
 1735 11c4 83BDF0FE 		cmpl	$0, -272(%rbp)
 1735      FFFF00
 1736 11cb 740F     		je	.L97
 1737              		.loc 1 405 0 is_stmt 0 discriminator 1
 1738 11cd C785C0FE 		movl	$1, -320(%rbp)
 1738      FFFF0100 
 1738      0000
 1739              	.LBE19:
 1740              	.LBE18:
 388:main.c        ****                                         flSleep(1000);
 1741              		.loc 1 388 0 is_stmt 1 discriminator 1
 1742 11d7 E9E70300 		jmp	.L115
 1742      00
 1743              	.L97:
 1744              	.LBB22:
 394:main.c        ****                                             uint8_t tempSto = 0;
 1745              		.loc 1 394 0
 1746 11dc 0FB6859C 		movzbl	-356(%rbp), %eax
 1746      FEFFFF
 1747 11e3 83C001   		addl	$1, %eax
 1748 11e6 88859CFE 		movb	%al, -356(%rbp)
 1748      FFFF
 1749              	.L92:
 394:main.c        ****                                             uint8_t tempSto = 0;
 1750              		.loc 1 394 0 is_stmt 0 discriminator 1
 1751 11ec 80BD9CFE 		cmpb	$13, -356(%rbp)
 1751      FFFF0D
 1752 11f3 0F86D7FE 		jbe	.L98
 1752      FFFF
 1753              	.LBE22:
 1754              	.LBB23:
 406:main.c        ****                                         }
 407:main.c        **** 
 408:main.c        ****                                         for (uint8_t i = 14; i <= 17; i++) {
 1755              		.loc 1 408 0 is_stmt 1
 1756 11f9 C6859EFE 		movb	$14, -354(%rbp)
 1756      FFFF0E
 1757 1200 E91C0100 		jmp	.L99
 1757      00
 1758              	.L105:
 1759              	.LBB24:
 409:main.c        ****                                             uint8_t tempSto = 0;
 1760              		.loc 1 409 0
 1761 1205 C68595FE 		movb	$0, -363(%rbp)
 1761      FFFF00
 1762              	.LBB25:
 410:main.c        ****                                             for (uint8_t j = 0; j <= 7; j++) {
 1763              		.loc 1 410 0
 1764 120c C6859FFE 		movb	$0, -353(%rbp)
 1764      FFFF00
 1765 1213 EB71     		jmp	.L100
 1766              	.L102:
 1767              	.LBB26:
 411:main.c        ****                                                 uint8_t temp = j + (i - 14) * 8;
 1768              		.loc 1 411 0
 1769 1215 0FB6859E 		movzbl	-354(%rbp), %eax
 1769      FEFFFF
 1770 121c 83E80E   		subl	$14, %eax
 1771 121f 8D14C500 		leal	0(,%rax,8), %edx
 1771      000000
 1772 1226 0FB6859F 		movzbl	-353(%rbp), %eax
 1772      FEFFFF
 1773 122d 01D0     		addl	%edx, %eax
 1774 122f 8885A9FE 		movb	%al, -343(%rbp)
 1774      FFFF
 412:main.c        ****                                                 if ((befEncSen[1] & (1 << temp)) != 0) {
 1775              		.loc 1 412 0
 1776 1235 8B9514FF 		movl	-236(%rbp), %edx
 1776      FFFF
 1777 123b 0FB685A9 		movzbl	-343(%rbp), %eax
 1777      FEFFFF
 1778 1242 BE010000 		movl	$1, %esi
 1778      00
 1779 1247 89C1     		movl	%eax, %ecx
 1780 1249 D3E6     		sall	%cl, %esi
 1781 124b 89F0     		movl	%esi, %eax
 1782 124d 21D0     		andl	%edx, %eax
 1783 124f 85C0     		testl	%eax, %eax
 1784 1251 7423     		je	.L101
 413:main.c        ****                                                     tempSto += (1 << j);
 1785              		.loc 1 413 0
 1786 1253 0FB6859F 		movzbl	-353(%rbp), %eax
 1786      FEFFFF
 1787 125a BA010000 		movl	$1, %edx
 1787      00
 1788 125f 89C1     		movl	%eax, %ecx
 1789 1261 D3E2     		sall	%cl, %edx
 1790 1263 89D0     		movl	%edx, %eax
 1791 1265 89C2     		movl	%eax, %edx
 1792 1267 0FB68595 		movzbl	-363(%rbp), %eax
 1792      FEFFFF
 1793 126e 01D0     		addl	%edx, %eax
 1794 1270 888595FE 		movb	%al, -363(%rbp)
 1794      FFFF
 1795              	.L101:
 1796              	.LBE26:
 410:main.c        ****                                                 uint8_t temp = j + (i - 14) * 8;
 1797              		.loc 1 410 0
 1798 1276 0FB6859F 		movzbl	-353(%rbp), %eax
 1798      FEFFFF
 1799 127d 83C001   		addl	$1, %eax
 1800 1280 88859FFE 		movb	%al, -353(%rbp)
 1800      FFFF
 1801              	.L100:
 410:main.c        ****                                                 uint8_t temp = j + (i - 14) * 8;
 1802              		.loc 1 410 0 is_stmt 0 discriminator 1
 1803 1286 80BD9FFE 		cmpb	$7, -353(%rbp)
 1803      FFFF07
 1804 128d 7686     		jbe	.L102
 1805              	.LBE25:
 414:main.c        ****                                                 }
 415:main.c        ****                                             }
 416:main.c        ****                                             flSleep(1000);
 1806              		.loc 1 416 0 is_stmt 1
 1807 128f BFE80300 		movl	$1000, %edi
 1807      00
 1808 1294 E8000000 		call	flSleep
 1808      00
 417:main.c        ****                                             fStatus = flWriteChannel(handle, (uint8_t) i, length, &
 1809              		.loc 1 417 0
 1810 1299 8B95F4FE 		movl	-268(%rbp), %edx
 1810      FFFF
 1811 129f 0FB6B59E 		movzbl	-354(%rbp), %esi
 1811      FEFFFF
 1812 12a6 488B8518 		movq	-232(%rbp), %rax
 1812      FFFFFF
 1813 12ad 488DBD20 		leaq	-224(%rbp), %rdi
 1813      FFFFFF
 1814 12b4 488D8D95 		leaq	-363(%rbp), %rcx
 1814      FEFFFF
 1815 12bb 4989F8   		movq	%rdi, %r8
 1816 12be 4889C7   		movq	%rax, %rdi
 1817 12c1 E8000000 		call	flWriteChannel
 1817      00
 1818 12c6 8985F0FE 		movl	%eax, -272(%rbp)
 1818      FFFF
 418:main.c        ****                                             if (LOG) printf("Write to channel %u = %u \n", i, tempS
 1819              		.loc 1 418 0
 1820 12cc 0FB60500 		movzbl	LOG(%rip), %eax
 1820      000000
 1821 12d3 84C0     		testb	%al, %al
 1822 12d5 7422     		je	.L103
 1823              		.loc 1 418 0 is_stmt 0 discriminator 1
 1824 12d7 0FB68595 		movzbl	-363(%rbp), %eax
 1824      FEFFFF
 1825 12de 0FB6D0   		movzbl	%al, %edx
 1826 12e1 0FB6859E 		movzbl	-354(%rbp), %eax
 1826      FEFFFF
 1827 12e8 89C6     		movl	%eax, %esi
 1828 12ea BF000000 		movl	$.LC56, %edi
 1828      00
 1829 12ef B8000000 		movl	$0, %eax
 1829      00
 1830 12f4 E8000000 		call	printf
 1830      00
 1831              	.L103:
 419:main.c        ****                                             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1832              		.loc 1 419 0 is_stmt 1
 1833 12f9 83BDF0FE 		cmpl	$0, -272(%rbp)
 1833      FFFF00
 1834 1300 740F     		je	.L104
 1835              		.loc 1 419 0 is_stmt 0 discriminator 1
 1836 1302 C785C0FE 		movl	$1, -320(%rbp)
 1836      FFFF0100 
 1836      0000
 1837              	.LBE24:
 1838              	.LBE23:
 388:main.c        ****                                         flSleep(1000);
 1839              		.loc 1 388 0 is_stmt 1 discriminator 1
 1840 130c E9B20200 		jmp	.L115
 1840      00
 1841              	.L104:
 1842              	.LBB27:
 408:main.c        ****                                             uint8_t tempSto = 0;
 1843              		.loc 1 408 0
 1844 1311 0FB6859E 		movzbl	-354(%rbp), %eax
 1844      FEFFFF
 1845 1318 83C001   		addl	$1, %eax
 1846 131b 88859EFE 		movb	%al, -354(%rbp)
 1846      FFFF
 1847              	.L99:
 408:main.c        ****                                             uint8_t tempSto = 0;
 1848              		.loc 1 408 0 is_stmt 0 discriminator 1
 1849 1321 80BD9EFE 		cmpb	$17, -354(%rbp)
 1849      FFFF11
 1850 1328 0F86D7FE 		jbe	.L105
 1850      FFFF
 1851              	.LBE27:
 420:main.c        ****                                         }
 421:main.c        ****                                         /* update the balance in the global variable now and update
 422:main.c        ****                                         if ((*readFromChannelZero) == 1) {
 1852              		.loc 1 422 0 is_stmt 1
 1853 132e 488B4598 		movq	-104(%rbp), %rax
 1854 1332 0FB600   		movzbl	(%rax), %eax
 1855 1335 3C01     		cmpb	$1, %al
 1856 1337 0F853801 		jne	.L106
 1856      0000
 423:main.c        ****                                             dataFromCSV[inLineNum][3] -= reqAmo;
 1857              		.loc 1 423 0
 1858 133d 8B85B8FE 		movl	-328(%rbp), %eax
 1858      FFFF
 1859 1343 8B95B8FE 		movl	-328(%rbp), %edx
 1859      FFFF
 1860 1349 4863D2   		movslq	%edx, %rdx
 1861 134c 48C1E204 		salq	$4, %rdx
 1862 1350 4881C200 		addq	$dataFromCSV+12, %rdx
 1862      000000
 1863 1357 8B0A     		movl	(%rdx), %ecx
 1864 1359 8B95BCFE 		movl	-324(%rbp), %edx
 1864      FFFF
 1865 135f 29D1     		subl	%edx, %ecx
 1866 1361 89CA     		movl	%ecx, %edx
 1867 1363 4898     		cltq
 1868 1365 48C1E004 		salq	$4, %rax
 1869 1369 48050000 		addq	$dataFromCSV+12, %rax
 1869      0000
 1870 136f 8910     		movl	%edx, (%rax)
 424:main.c        **** 
 425:main.c        ****                                             /* Updating csv file in place */
 426:main.c        ****                                             fPtr = fopen("SampleBackEndDatabase.csv", "w+"); // cha
 1871              		.loc 1 426 0
 1872 1371 BE000000 		movl	$.LC57, %esi
 1872      00
 1873 1376 BF000000 		movl	$.LC50, %edi
 1873      00
 1874 137b E8000000 		call	fopen
 1874      00
 1875 1380 48894590 		movq	%rax, -112(%rbp)
 427:main.c        ****                                             fprintf(fPtr, "%s", "\"User ID (decimal)\",\"PIN Hash (
 1876              		.loc 1 427 0
 1877 1384 488B4590 		movq	-112(%rbp), %rax
 1878 1388 4889C1   		movq	%rax, %rcx
 1879 138b BA440000 		movl	$68, %edx
 1879      00
 1880 1390 BE010000 		movl	$1, %esi
 1880      00
 1881 1395 BF000000 		movl	$.LC58, %edi
 1881      00
 1882 139a E8000000 		call	fwrite
 1882      00
 428:main.c        ****                                             fprintf(fPtr, "\n");
 1883              		.loc 1 428 0
 1884 139f 488B4590 		movq	-112(%rbp), %rax
 1885 13a3 4889C6   		movq	%rax, %rsi
 1886 13a6 BF0A0000 		movl	$10, %edi
 1886      00
 1887 13ab E8000000 		call	fputc
 1887      00
 1888              	.LBB28:
 429:main.c        ****                                             for (int i = 1; i <= numLines; i++) {
 1889              		.loc 1 429 0
 1890 13b0 C785D4FE 		movl	$1, -300(%rbp)
 1890      FFFF0100 
 1890      0000
 1891 13ba E9930000 		jmp	.L107
 1891      00
 1892              	.L113:
 1893              	.LBB29:
 430:main.c        ****                                                 for (int k = 0; k < 4; k++) {
 1894              		.loc 1 430 0
 1895 13bf C785D8FE 		movl	$0, -296(%rbp)
 1895      FFFF0000 
 1895      0000
 1896 13c9 EB77     		jmp	.L108
 1897              	.L112:
 431:main.c        ****                                                     fprintf(fPtr, "%d", dataFromCSV[i][k]);
 1898              		.loc 1 431 0
 1899 13cb 8B85D8FE 		movl	-296(%rbp), %eax
 1899      FFFF
 1900 13d1 4898     		cltq
 1901 13d3 8B95D4FE 		movl	-300(%rbp), %edx
 1901      FFFF
 1902 13d9 4863D2   		movslq	%edx, %rdx
 1903 13dc 48C1E202 		salq	$2, %rdx
 1904 13e0 4801D0   		addq	%rdx, %rax
 1905 13e3 8B148500 		movl	dataFromCSV(,%rax,4), %edx
 1905      000000
 1906 13ea 488B4590 		movq	-112(%rbp), %rax
 1907 13ee BE000000 		movl	$.LC1, %esi
 1907      00
 1908 13f3 4889C7   		movq	%rax, %rdi
 1909 13f6 B8000000 		movl	$0, %eax
 1909      00
 1910 13fb E8000000 		call	fprintf
 1910      00
 432:main.c        ****                                                     if (k == 3) {
 1911              		.loc 1 432 0
 1912 1400 83BDD8FE 		cmpl	$3, -296(%rbp)
 1912      FFFF03
 1913 1407 7521     		jne	.L109
 433:main.c        ****                                                         if (i != numLines) fprintf(fPtr, "\n");
 1914              		.loc 1 433 0
 1915 1409 8B050000 		movl	numLines(%rip), %eax
 1915      0000
 1916 140f 3985D4FE 		cmpl	%eax, -300(%rbp)
 1916      FFFF
 1917 1415 7424     		je	.L111
 1918              		.loc 1 433 0 is_stmt 0 discriminator 1
 1919 1417 488B4590 		movq	-112(%rbp), %rax
 1920 141b 4889C6   		movq	%rax, %rsi
 1921 141e BF0A0000 		movl	$10, %edi
 1921      00
 1922 1423 E8000000 		call	fputc
 1922      00
 1923 1428 EB11     		jmp	.L111
 1924              	.L109:
 434:main.c        ****                                                     } else fprintf(fPtr, ",");
 1925              		.loc 1 434 0 is_stmt 1
 1926 142a 488B4590 		movq	-112(%rbp), %rax
 1927 142e 4889C6   		movq	%rax, %rsi
 1928 1431 BF2C0000 		movl	$44, %edi
 1928      00
 1929 1436 E8000000 		call	fputc
 1929      00
 1930              	.L111:
 430:main.c        ****                                                     fprintf(fPtr, "%d", dataFromCSV[i][k]);
 1931              		.loc 1 430 0
 1932 143b 8385D8FE 		addl	$1, -296(%rbp)
 1932      FFFF01
 1933              	.L108:
 430:main.c        ****                                                     fprintf(fPtr, "%d", dataFromCSV[i][k]);
 1934              		.loc 1 430 0 is_stmt 0 discriminator 1
 1935 1442 83BDD8FE 		cmpl	$3, -296(%rbp)
 1935      FFFF03
 1936 1449 7E80     		jle	.L112
 1937              	.LBE29:
 429:main.c        ****                                                 for (int k = 0; k < 4; k++) {
 1938              		.loc 1 429 0 is_stmt 1
 1939 144b 8385D4FE 		addl	$1, -300(%rbp)
 1939      FFFF01
 1940              	.L107:
 429:main.c        ****                                                 for (int k = 0; k < 4; k++) {
 1941              		.loc 1 429 0 is_stmt 0 discriminator 1
 1942 1452 8B050000 		movl	numLines(%rip), %eax
 1942      0000
 1943 1458 3985D4FE 		cmpl	%eax, -300(%rbp)
 1943      FFFF
 1944 145e 0F8E5BFF 		jle	.L113
 1944      FFFF
 1945              	.LBE28:
 435:main.c        ****                                                 }
 436:main.c        ****                                             }
 437:main.c        ****                                             fclose(fPtr);
 1946              		.loc 1 437 0 is_stmt 1
 1947 1464 488B4590 		movq	-112(%rbp), %rax
 1948 1468 4889C7   		movq	%rax, %rdi
 1949 146b E8000000 		call	fclose
 1949      00
 1950              	.LBE16:
 1951 1470 E9490100 		jmp	.L114
 1951      00
 1952              	.L106:
 1953 1475 E9440100 		jmp	.L114
 1953      00
 1954              	.L85:
 438:main.c        ****                                         }
 439:main.c        ****                                     } else {
 440:main.c        **** //                                        printf("bal %u\n", bal);
 441:main.c        **** //                                        printf("req %u\n", reqAmo);
 442:main.c        ****                                         if (LOG) printf("Insufficient Balance \n");
 1955              		.loc 1 442 0
 1956 147a 0FB60500 		movzbl	LOG(%rip), %eax
 1956      000000
 1957 1481 84C0     		testb	%al, %al
 1958 1483 740A     		je	.L116
 1959              		.loc 1 442 0 is_stmt 0 discriminator 1
 1960 1485 BF000000 		movl	$.LC59, %edi
 1960      00
 1961 148a E8000000 		call	puts
 1961      00
 1962              	.L116:
 443:main.c        ****                                         *statusOnChan9 = 2;
 1963              		.loc 1 443 0 is_stmt 1
 1964 148f 488B45A8 		movq	-88(%rbp), %rax
 1965 1493 C60002   		movb	$2, (%rax)
 444:main.c        ****                                         flSleep(1000);
 1966              		.loc 1 444 0
 1967 1496 BFE80300 		movl	$1000, %edi
 1967      00
 1968 149b E8000000 		call	flSleep
 1968      00
 445:main.c        ****                                         if (LOG) printf("Write to channel %u = %u \n", 9, *statusOn
 1969              		.loc 1 445 0
 1970 14a0 0FB60500 		movzbl	LOG(%rip), %eax
 1970      000000
 1971 14a7 84C0     		testb	%al, %al
 1972 14a9 7420     		je	.L117
 1973              		.loc 1 445 0 is_stmt 0 discriminator 1
 1974 14ab 488B45A8 		movq	-88(%rbp), %rax
 1975 14af 0FB600   		movzbl	(%rax), %eax
 1976 14b2 0FB6C0   		movzbl	%al, %eax
 1977 14b5 89C2     		movl	%eax, %edx
 1978 14b7 BE090000 		movl	$9, %esi
 1978      00
 1979 14bc BF000000 		movl	$.LC56, %edi
 1979      00
 1980 14c1 B8000000 		movl	$0, %eax
 1980      00
 1981 14c6 E8000000 		call	printf
 1981      00
 1982              	.L117:
 446:main.c        ****                                         fStatus = flWriteChannel(handle, (uint8_t) 9, length, statu
 1983              		.loc 1 446 0 is_stmt 1
 1984 14cb 8B95F4FE 		movl	-268(%rbp), %edx
 1984      FFFF
 1985 14d1 488B8518 		movq	-232(%rbp), %rax
 1985      FFFFFF
 1986 14d8 488DB520 		leaq	-224(%rbp), %rsi
 1986      FFFFFF
 1987 14df 488B4DA8 		movq	-88(%rbp), %rcx
 1988 14e3 4989F0   		movq	%rsi, %r8
 1989 14e6 BE090000 		movl	$9, %esi
 1989      00
 1990 14eb 4889C7   		movq	%rax, %rdi
 1991 14ee E8000000 		call	flWriteChannel
 1991      00
 1992 14f3 8985F0FE 		movl	%eax, -272(%rbp)
 1992      FFFF
 447:main.c        ****                                         CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1993              		.loc 1 447 0
 1994 14f9 83BDF0FE 		cmpl	$0, -272(%rbp)
 1994      FFFF00
 1995 1500 740F     		je	.L118
 1996              		.loc 1 447 0 is_stmt 0 discriminator 1
 1997 1502 C785C0FE 		movl	$1, -320(%rbp)
 1997      FFFF0100 
 1997      0000
 1998 150c E9B20000 		jmp	.L115
 1998      00
 1999              	.L118:
 2000              	.LBB30:
 448:main.c        ****                                         for (int i = 10; i <= 17; i++) {
 2001              		.loc 1 448 0 is_stmt 1
 2002 1511 C785DCFE 		movl	$10, -292(%rbp)
 2002      FFFF0A00 
 2002      0000
 2003 151b E9910000 		jmp	.L119
 2003      00
 2004              	.L122:
 2005              	.LBB31:
 449:main.c        ****                                             uint8_t tempSto = 0;
 2006              		.loc 1 449 0
 2007 1520 C68510FF 		movb	$0, -240(%rbp)
 2007      FFFF00
 450:main.c        ****                                             flSleep(1000);
 2008              		.loc 1 450 0
 2009 1527 BFE80300 		movl	$1000, %edi
 2009      00
 2010 152c E8000000 		call	flSleep
 2010      00
 451:main.c        ****                                             if (LOG) printf("Write to channel %u = %u \n", i, tempS
 2011              		.loc 1 451 0
 2012 1531 0FB60500 		movzbl	LOG(%rip), %eax
 2012      000000
 2013 1538 84C0     		testb	%al, %al
 2014 153a 7421     		je	.L120
 2015              		.loc 1 451 0 is_stmt 0 discriminator 1
 2016 153c 0FB68510 		movzbl	-240(%rbp), %eax
 2016      FFFFFF
 2017 1543 0FB6D0   		movzbl	%al, %edx
 2018 1546 8B85DCFE 		movl	-292(%rbp), %eax
 2018      FFFF
 2019 154c 89C6     		movl	%eax, %esi
 2020 154e BF000000 		movl	$.LC56, %edi
 2020      00
 2021 1553 B8000000 		movl	$0, %eax
 2021      00
 2022 1558 E8000000 		call	printf
 2022      00
 2023              	.L120:
 452:main.c        ****                                             fStatus = flWriteChannel(handle, (uint8_t) i, length, &
 2024              		.loc 1 452 0 is_stmt 1
 2025 155d 8B95F4FE 		movl	-268(%rbp), %edx
 2025      FFFF
 2026 1563 8B85DCFE 		movl	-292(%rbp), %eax
 2026      FFFF
 2027 1569 0FB6F0   		movzbl	%al, %esi
 2028 156c 488B8518 		movq	-232(%rbp), %rax
 2028      FFFFFF
 2029 1573 488DBD20 		leaq	-224(%rbp), %rdi
 2029      FFFFFF
 2030 157a 488D8D10 		leaq	-240(%rbp), %rcx
 2030      FFFFFF
 2031 1581 4989F8   		movq	%rdi, %r8
 2032 1584 4889C7   		movq	%rax, %rdi
 2033 1587 E8000000 		call	flWriteChannel
 2033      00
 2034 158c 8985F0FE 		movl	%eax, -272(%rbp)
 2034      FFFF
 453:main.c        ****                                             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2035              		.loc 1 453 0
 2036 1592 83BDF0FE 		cmpl	$0, -272(%rbp)
 2036      FFFF00
 2037 1599 740F     		je	.L121
 2038              		.loc 1 453 0 is_stmt 0 discriminator 1
 2039 159b C785C0FE 		movl	$1, -320(%rbp)
 2039      FFFF0100 
 2039      0000
 2040              	.LBE31:
 2041              	.LBE30:
 2042 15a5 E99F0600 		jmp	.L73
 2042      00
 2043              	.L121:
 2044              	.LBB32:
 448:main.c        ****                                             uint8_t tempSto = 0;
 2045              		.loc 1 448 0 is_stmt 1
 2046 15aa 8385DCFE 		addl	$1, -292(%rbp)
 2046      FFFF01
 2047              	.L119:
 448:main.c        ****                                             uint8_t tempSto = 0;
 2048              		.loc 1 448 0 is_stmt 0 discriminator 1
 2049 15b1 83BDDCFE 		cmpl	$17, -292(%rbp)
 2049      FFFF11
 2050 15b8 0F8E62FF 		jle	.L122
 2050      FFFF
 2051              	.L114:
 2052              	.LBE32:
 2053              	.LBE15:
 2054 15be E9880600 		jmp	.L62
 2054      00
 2055              	.L115:
 350:main.c        ****                                 if (LOG) printf("Read from channel %u = %u \n", i, *readFromChannel
 2056              		.loc 1 350 0 is_stmt 1
 2057 15c3 E9920600 		jmp	.L59
 2057      00
 2058              	.L84:
 2059              	.LBB33:
 454:main.c        ****                                         }
 455:main.c        ****                                     }
 456:main.c        ****                                 } else {
 457:main.c        ****                                     printf("User has admin privileges \n");
 2060              		.loc 1 457 0
 2061 15c8 BF000000 		movl	$.LC60, %edi
 2061      00
 2062 15cd E8000000 		call	puts
 2062      00
 458:main.c        ****                                     *statusOnChan9 = 3;
 2063              		.loc 1 458 0
 2064 15d2 488B45A8 		movq	-88(%rbp), %rax
 2065 15d6 C60003   		movb	$3, (%rax)
 459:main.c        ****                                     flSleep(1000);
 2066              		.loc 1 459 0
 2067 15d9 BFE80300 		movl	$1000, %edi
 2067      00
 2068 15de E8000000 		call	flSleep
 2068      00
 460:main.c        ****                                     if (LOG) printf("Write to channel %u = %u \n", 9, *statusOnChan
 2069              		.loc 1 460 0
 2070 15e3 0FB60500 		movzbl	LOG(%rip), %eax
 2070      000000
 2071 15ea 84C0     		testb	%al, %al
 2072 15ec 7420     		je	.L124
 2073              		.loc 1 460 0 is_stmt 0 discriminator 1
 2074 15ee 488B45A8 		movq	-88(%rbp), %rax
 2075 15f2 0FB600   		movzbl	(%rax), %eax
 2076 15f5 0FB6C0   		movzbl	%al, %eax
 2077 15f8 89C2     		movl	%eax, %edx
 2078 15fa BE090000 		movl	$9, %esi
 2078      00
 2079 15ff BF000000 		movl	$.LC56, %edi
 2079      00
 2080 1604 B8000000 		movl	$0, %eax
 2080      00
 2081 1609 E8000000 		call	printf
 2081      00
 2082              	.L124:
 461:main.c        ****                                     fStatus = flWriteChannel(handle, (uint8_t) 9, length, statusOnC
 2083              		.loc 1 461 0 is_stmt 1
 2084 160e 8B95F4FE 		movl	-268(%rbp), %edx
 2084      FFFF
 2085 1614 488B8518 		movq	-232(%rbp), %rax
 2085      FFFFFF
 2086 161b 488DB520 		leaq	-224(%rbp), %rsi
 2086      FFFFFF
 2087 1622 488B4DA8 		movq	-88(%rbp), %rcx
 2088 1626 4989F0   		movq	%rsi, %r8
 2089 1629 BE090000 		movl	$9, %esi
 2089      00
 2090 162e 4889C7   		movq	%rax, %rdi
 2091 1631 E8000000 		call	flWriteChannel
 2091      00
 2092 1636 8985F0FE 		movl	%eax, -272(%rbp)
 2092      FFFF
 462:main.c        ****                                     CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2093              		.loc 1 462 0
 2094 163c 83BDF0FE 		cmpl	$0, -272(%rbp)
 2094      FFFF00
 2095 1643 740F     		je	.L125
 2096              		.loc 1 462 0 is_stmt 0 discriminator 1
 2097 1645 C785C0FE 		movl	$1, -320(%rbp)
 2097      FFFF0100 
 2097      0000
 2098 164f E9F50500 		jmp	.L73
 2098      00
 2099              	.L125:
 2100              	.LBB34:
 463:main.c        **** 
 464:main.c        ****                                     for (uint8_t i = 1; i <= 32; i++) {
 2101              		.loc 1 464 0 is_stmt 1
 2102 1654 C685A0FE 		movb	$1, -352(%rbp)
 2102      FFFF01
 2103 165b E92F0100 		jmp	.L127
 2103      00
 2104              	.L135:
 465:main.c        ****                                         if (i <= 8) {
 2105              		.loc 1 465 0
 2106 1660 80BDA0FE 		cmpb	$8, -352(%rbp)
 2106      FFFF08
 2107 1667 7745     		ja	.L128
 466:main.c        ****                                             if ((inpFromFrontEnd[0] & (1 << (i - 1))) != 0) num_100
 2108              		.loc 1 466 0
 2109 1669 8B9500FF 		movl	-256(%rbp), %edx
 2109      FFFF
 2110 166f 0FB685A0 		movzbl	-352(%rbp), %eax
 2110      FEFFFF
 2111 1676 83E801   		subl	$1, %eax
 2112 1679 BE010000 		movl	$1, %esi
 2112      00
 2113 167e 89C1     		movl	%eax, %ecx
 2114 1680 D3E6     		sall	%cl, %esi
 2115 1682 89F0     		movl	%esi, %eax
 2116 1684 21D0     		andl	%edx, %eax
 2117 1686 85C0     		testl	%eax, %eax
 2118 1688 0F84F100 		je	.L130
 2118      0000
 2119              		.loc 1 466 0 is_stmt 0 discriminator 1
 2120 168e 0FB685A0 		movzbl	-352(%rbp), %eax
 2120      FEFFFF
 2121 1695 83E801   		subl	$1, %eax
 2122 1698 BA010000 		movl	$1, %edx
 2122      00
 2123 169d 89C1     		movl	%eax, %ecx
 2124 169f D3E2     		sall	%cl, %edx
 2125 16a1 89D0     		movl	%edx, %eax
 2126 16a3 008598FE 		addb	%al, -360(%rbp)
 2126      FFFF
 2127 16a9 E9D10000 		jmp	.L130
 2127      00
 2128              	.L128:
 467:main.c        ****                                         } else if (i <= 16) {
 2129              		.loc 1 467 0 is_stmt 1
 2130 16ae 80BDA0FE 		cmpb	$16, -352(%rbp)
 2130      FFFF10
 2131 16b5 7745     		ja	.L131
 468:main.c        ****                                             if ((inpFromFrontEnd[0] & (1 << (i - 1))) != 0) num_500
 2132              		.loc 1 468 0
 2133 16b7 8B9500FF 		movl	-256(%rbp), %edx
 2133      FFFF
 2134 16bd 0FB685A0 		movzbl	-352(%rbp), %eax
 2134      FEFFFF
 2135 16c4 83E801   		subl	$1, %eax
 2136 16c7 BE010000 		movl	$1, %esi
 2136      00
 2137 16cc 89C1     		movl	%eax, %ecx
 2138 16ce D3E6     		sall	%cl, %esi
 2139 16d0 89F0     		movl	%esi, %eax
 2140 16d2 21D0     		andl	%edx, %eax
 2141 16d4 85C0     		testl	%eax, %eax
 2142 16d6 0F84A300 		je	.L130
 2142      0000
 2143              		.loc 1 468 0 is_stmt 0 discriminator 1
 2144 16dc 0FB685A0 		movzbl	-352(%rbp), %eax
 2144      FEFFFF
 2145 16e3 83E809   		subl	$9, %eax
 2146 16e6 BA010000 		movl	$1, %edx
 2146      00
 2147 16eb 89C1     		movl	%eax, %ecx
 2148 16ed D3E2     		sall	%cl, %edx
 2149 16ef 89D0     		movl	%edx, %eax
 2150 16f1 008599FE 		addb	%al, -359(%rbp)
 2150      FFFF
 2151 16f7 E9830000 		jmp	.L130
 2151      00
 2152              	.L131:
 469:main.c        ****                                         } else if (i <= 24) {
 2153              		.loc 1 469 0 is_stmt 1
 2154 16fc 80BDA0FE 		cmpb	$24, -352(%rbp)
 2154      FFFF18
 2155 1703 773E     		ja	.L133
 470:main.c        ****                                             if ((inpFromFrontEnd[0] & (1 << (i - 1))) != 0) num_100
 2156              		.loc 1 470 0
 2157 1705 8B9500FF 		movl	-256(%rbp), %edx
 2157      FFFF
 2158 170b 0FB685A0 		movzbl	-352(%rbp), %eax
 2158      FEFFFF
 2159 1712 83E801   		subl	$1, %eax
 2160 1715 BE010000 		movl	$1, %esi
 2160      00
 2161 171a 89C1     		movl	%eax, %ecx
 2162 171c D3E6     		sall	%cl, %esi
 2163 171e 89F0     		movl	%esi, %eax
 2164 1720 21D0     		andl	%edx, %eax
 2165 1722 85C0     		testl	%eax, %eax
 2166 1724 7459     		je	.L130
 2167              		.loc 1 470 0 is_stmt 0 discriminator 1
 2168 1726 0FB685A0 		movzbl	-352(%rbp), %eax
 2168      FEFFFF
 2169 172d 83E811   		subl	$17, %eax
 2170 1730 BA010000 		movl	$1, %edx
 2170      00
 2171 1735 89C1     		movl	%eax, %ecx
 2172 1737 D3E2     		sall	%cl, %edx
 2173 1739 89D0     		movl	%edx, %eax
 2174 173b 00859AFE 		addb	%al, -358(%rbp)
 2174      FFFF
 2175 1741 EB3C     		jmp	.L130
 2176              	.L133:
 471:main.c        ****                                         } else {
 472:main.c        ****                                             if ((inpFromFrontEnd[0] & (1 << (i - 1))) != 0) num_200
 2177              		.loc 1 472 0 is_stmt 1
 2178 1743 8B9500FF 		movl	-256(%rbp), %edx
 2178      FFFF
 2179 1749 0FB685A0 		movzbl	-352(%rbp), %eax
 2179      FEFFFF
 2180 1750 83E801   		subl	$1, %eax
 2181 1753 BE010000 		movl	$1, %esi
 2181      00
 2182 1758 89C1     		movl	%eax, %ecx
 2183 175a D3E6     		sall	%cl, %esi
 2184 175c 89F0     		movl	%esi, %eax
 2185 175e 21D0     		andl	%edx, %eax
 2186 1760 85C0     		testl	%eax, %eax
 2187 1762 741B     		je	.L130
 2188              		.loc 1 472 0 is_stmt 0 discriminator 1
 2189 1764 0FB685A0 		movzbl	-352(%rbp), %eax
 2189      FEFFFF
 2190 176b 83E819   		subl	$25, %eax
 2191 176e BA010000 		movl	$1, %edx
 2191      00
 2192 1773 89C1     		movl	%eax, %ecx
 2193 1775 D3E2     		sall	%cl, %edx
 2194 1777 89D0     		movl	%edx, %eax
 2195 1779 00859BFE 		addb	%al, -357(%rbp)
 2195      FFFF
 2196              	.L130:
 464:main.c        ****                                         if (i <= 8) {
 2197              		.loc 1 464 0 is_stmt 1
 2198 177f 0FB685A0 		movzbl	-352(%rbp), %eax
 2198      FEFFFF
 2199 1786 83C001   		addl	$1, %eax
 2200 1789 8885A0FE 		movb	%al, -352(%rbp)
 2200      FFFF
 2201              	.L127:
 464:main.c        ****                                         if (i <= 8) {
 2202              		.loc 1 464 0 is_stmt 0 discriminator 1
 2203 178f 80BDA0FE 		cmpb	$32, -352(%rbp)
 2203      FFFF20
 2204 1796 0F86C4FE 		jbe	.L135
 2204      FFFF
 2205              	.LBE34:
 2206              	.LBB35:
 473:main.c        ****                                         }
 474:main.c        ****                                     }
 475:main.c        **** 
 476:main.c        **** //                            printf("num_2000_admin %u\n", num_2000_admin);
 477:main.c        **** //                            printf("num_1000_admin %u\n", num_1000_admin);
 478:main.c        **** //                            printf("num_500_admin %u\n", num_500_admin);
 479:main.c        **** //                            printf("num_100_admin %u\n", num_100_admin);
 480:main.c        **** 
 481:main.c        ****                                     uint32_t befEncSen[2];
 482:main.c        ****                                     for (int i = 0; i < 2; i++) befEncSen[i] = 0;
 2207              		.loc 1 482 0 is_stmt 1
 2208 179c C785E0FE 		movl	$0, -288(%rbp)
 2208      FFFF0000 
 2208      0000
 2209 17a6 EB1A     		jmp	.L136
 2210              	.L137:
 2211              		.loc 1 482 0 is_stmt 0 discriminator 2
 2212 17a8 8B85E0FE 		movl	-288(%rbp), %eax
 2212      FFFF
 2213 17ae 4898     		cltq
 2214 17b0 C7848510 		movl	$0, -240(%rbp,%rax,4)
 2214      FFFFFF00 
 2214      000000
 2215 17bb 8385E0FE 		addl	$1, -288(%rbp)
 2215      FFFF01
 2216              	.L136:
 2217              		.loc 1 482 0 discriminator 1
 2218 17c2 83BDE0FE 		cmpl	$1, -288(%rbp)
 2218      FFFF01
 2219 17c9 7EDD     		jle	.L137
 2220              	.LBE35:
 2221              	.LBB36:
 483:main.c        ****                                     for (uint32_t i = 0; i <= 31; i += 8) {
 2222              		.loc 1 483 0 is_stmt 1
 2223 17cb C785E4FE 		movl	$0, -284(%rbp)
 2223      FFFF0000 
 2223      0000
 2224 17d5 E9AC0000 		jmp	.L138
 2224      00
 2225              	.L143:
 484:main.c        ****                                         if (i == 0) befEncSen[0] += ((1 << i) * ((uint32_t) num_100
 2226              		.loc 1 484 0
 2227 17da 83BDE4FE 		cmpl	$0, -284(%rbp)
 2227      FFFF00
 2228 17e1 7523     		jne	.L139
 2229              		.loc 1 484 0 is_stmt 0 discriminator 1
 2230 17e3 8B9510FF 		movl	-240(%rbp), %edx
 2230      FFFF
 2231 17e9 0FB6B598 		movzbl	-360(%rbp), %esi
 2231      FEFFFF
 2232 17f0 8B85E4FE 		movl	-284(%rbp), %eax
 2232      FFFF
 2233 17f6 89C1     		movl	%eax, %ecx
 2234 17f8 D3E6     		sall	%cl, %esi
 2235 17fa 89F0     		movl	%esi, %eax
 2236 17fc 01D0     		addl	%edx, %eax
 2237 17fe 898510FF 		movl	%eax, -240(%rbp)
 2237      FFFF
 2238 1804 EB79     		jmp	.L140
 2239              	.L139:
 485:main.c        ****                                         else if (i == 8) befEncSen[0] += ((1 << i) * ((uint32_t) nu
 2240              		.loc 1 485 0 is_stmt 1
 2241 1806 83BDE4FE 		cmpl	$8, -284(%rbp)
 2241      FFFF08
 2242 180d 7523     		jne	.L141
 2243              		.loc 1 485 0 is_stmt 0 discriminator 1
 2244 180f 8B9510FF 		movl	-240(%rbp), %edx
 2244      FFFF
 2245 1815 0FB6B599 		movzbl	-359(%rbp), %esi
 2245      FEFFFF
 2246 181c 8B85E4FE 		movl	-284(%rbp), %eax
 2246      FFFF
 2247 1822 89C1     		movl	%eax, %ecx
 2248 1824 D3E6     		sall	%cl, %esi
 2249 1826 89F0     		movl	%esi, %eax
 2250 1828 01D0     		addl	%edx, %eax
 2251 182a 898510FF 		movl	%eax, -240(%rbp)
 2251      FFFF
 2252 1830 EB4D     		jmp	.L140
 2253              	.L141:
 486:main.c        ****                                         else if (i == 16) befEncSen[0] += ((1 << i) * ((uint32_t) n
 2254              		.loc 1 486 0 is_stmt 1
 2255 1832 83BDE4FE 		cmpl	$16, -284(%rbp)
 2255      FFFF10
 2256 1839 7523     		jne	.L142
 2257              		.loc 1 486 0 is_stmt 0 discriminator 1
 2258 183b 8B9510FF 		movl	-240(%rbp), %edx
 2258      FFFF
 2259 1841 0FB6B59A 		movzbl	-358(%rbp), %esi
 2259      FEFFFF
 2260 1848 8B85E4FE 		movl	-284(%rbp), %eax
 2260      FFFF
 2261 184e 89C1     		movl	%eax, %ecx
 2262 1850 D3E6     		sall	%cl, %esi
 2263 1852 89F0     		movl	%esi, %eax
 2264 1854 01D0     		addl	%edx, %eax
 2265 1856 898510FF 		movl	%eax, -240(%rbp)
 2265      FFFF
 2266 185c EB21     		jmp	.L140
 2267              	.L142:
 487:main.c        ****                                         else befEncSen[0] += ((1 << i) * ((uint32_t) num_2000_admin
 2268              		.loc 1 487 0 is_stmt 1
 2269 185e 8B9510FF 		movl	-240(%rbp), %edx
 2269      FFFF
 2270 1864 0FB6B59B 		movzbl	-357(%rbp), %esi
 2270      FEFFFF
 2271 186b 8B85E4FE 		movl	-284(%rbp), %eax
 2271      FFFF
 2272 1871 89C1     		movl	%eax, %ecx
 2273 1873 D3E6     		sall	%cl, %esi
 2274 1875 89F0     		movl	%esi, %eax
 2275 1877 01D0     		addl	%edx, %eax
 2276 1879 898510FF 		movl	%eax, -240(%rbp)
 2276      FFFF
 2277              	.L140:
 483:main.c        ****                                         if (i == 0) befEncSen[0] += ((1 << i) * ((uint32_t) num_100
 2278              		.loc 1 483 0
 2279 187f 8385E4FE 		addl	$8, -284(%rbp)
 2279      FFFF08
 2280              	.L138:
 483:main.c        ****                                         if (i == 0) befEncSen[0] += ((1 << i) * ((uint32_t) num_100
 2281              		.loc 1 483 0 is_stmt 0 discriminator 1
 2282 1886 83BDE4FE 		cmpl	$31, -284(%rbp)
 2282      FFFF1F
 2283 188d 0F8647FF 		jbe	.L143
 2283      FFFF
 2284              	.LBE36:
 488:main.c        ****                                     }
 489:main.c        ****                                     encrypt64(befEncSen);
 2285              		.loc 1 489 0 is_stmt 1
 2286 1893 488D8510 		leaq	-240(%rbp), %rax
 2286      FFFFFF
 2287 189a 4889C7   		movq	%rax, %rdi
 2288 189d E8000000 		call	encrypt64
 2288      00
 2289              	.LBB37:
 490:main.c        ****                                     for (uint8_t i = 10; i <= 13; i++) {
 2290              		.loc 1 490 0
 2291 18a2 C685A1FE 		movb	$10, -351(%rbp)
 2291      FFFF0A
 2292 18a9 E91C0100 		jmp	.L144
 2292      00
 2293              	.L150:
 2294              	.LBB38:
 491:main.c        ****                                         uint8_t tempSto = 0;
 2295              		.loc 1 491 0
 2296 18ae C685BCFE 		movb	$0, -324(%rbp)
 2296      FFFF00
 2297              	.LBB39:
 492:main.c        ****                                         for (uint8_t j = 0; j <= 7; j++) {
 2298              		.loc 1 492 0
 2299 18b5 C685A2FE 		movb	$0, -350(%rbp)
 2299      FFFF00
 2300 18bc EB71     		jmp	.L145
 2301              	.L147:
 2302              	.LBB40:
 493:main.c        ****                                             uint8_t temp = j + (i - 10) * 8;
 2303              		.loc 1 493 0
 2304 18be 0FB685A1 		movzbl	-351(%rbp), %eax
 2304      FEFFFF
 2305 18c5 83E80A   		subl	$10, %eax
 2306 18c8 8D14C500 		leal	0(,%rax,8), %edx
 2306      000000
 2307 18cf 0FB685A2 		movzbl	-350(%rbp), %eax
 2307      FEFFFF
 2308 18d6 01D0     		addl	%edx, %eax
 2309 18d8 8885AAFE 		movb	%al, -342(%rbp)
 2309      FFFF
 494:main.c        ****                                             if ((befEncSen[0] & (1 << temp)) != 0) {
 2310              		.loc 1 494 0
 2311 18de 8B9510FF 		movl	-240(%rbp), %edx
 2311      FFFF
 2312 18e4 0FB685AA 		movzbl	-342(%rbp), %eax
 2312      FEFFFF
 2313 18eb BE010000 		movl	$1, %esi
 2313      00
 2314 18f0 89C1     		movl	%eax, %ecx
 2315 18f2 D3E6     		sall	%cl, %esi
 2316 18f4 89F0     		movl	%esi, %eax
 2317 18f6 21D0     		andl	%edx, %eax
 2318 18f8 85C0     		testl	%eax, %eax
 2319 18fa 7423     		je	.L146
 495:main.c        ****                                                 tempSto += (1 << j);
 2320              		.loc 1 495 0
 2321 18fc 0FB685A2 		movzbl	-350(%rbp), %eax
 2321      FEFFFF
 2322 1903 BA010000 		movl	$1, %edx
 2322      00
 2323 1908 89C1     		movl	%eax, %ecx
 2324 190a D3E2     		sall	%cl, %edx
 2325 190c 89D0     		movl	%edx, %eax
 2326 190e 89C2     		movl	%eax, %edx
 2327 1910 0FB685BC 		movzbl	-324(%rbp), %eax
 2327      FEFFFF
 2328 1917 01D0     		addl	%edx, %eax
 2329 1919 8885BCFE 		movb	%al, -324(%rbp)
 2329      FFFF
 2330              	.L146:
 2331              	.LBE40:
 492:main.c        ****                                             uint8_t temp = j + (i - 10) * 8;
 2332              		.loc 1 492 0
 2333 191f 0FB685A2 		movzbl	-350(%rbp), %eax
 2333      FEFFFF
 2334 1926 83C001   		addl	$1, %eax
 2335 1929 8885A2FE 		movb	%al, -350(%rbp)
 2335      FFFF
 2336              	.L145:
 492:main.c        ****                                             uint8_t temp = j + (i - 10) * 8;
 2337              		.loc 1 492 0 is_stmt 0 discriminator 1
 2338 192f 80BDA2FE 		cmpb	$7, -350(%rbp)
 2338      FFFF07
 2339 1936 7686     		jbe	.L147
 2340              	.LBE39:
 496:main.c        ****                                             }
 497:main.c        ****                                         }
 498:main.c        ****                                         flSleep(1000);
 2341              		.loc 1 498 0 is_stmt 1
 2342 1938 BFE80300 		movl	$1000, %edi
 2342      00
 2343 193d E8000000 		call	flSleep
 2343      00
 499:main.c        ****                                         if (LOG) printf("Write to channel %u = %u \n", i, tempSto);
 2344              		.loc 1 499 0
 2345 1942 0FB60500 		movzbl	LOG(%rip), %eax
 2345      000000
 2346 1949 84C0     		testb	%al, %al
 2347 194b 7422     		je	.L148
 2348              		.loc 1 499 0 is_stmt 0 discriminator 1
 2349 194d 0FB685BC 		movzbl	-324(%rbp), %eax
 2349      FEFFFF
 2350 1954 0FB6D0   		movzbl	%al, %edx
 2351 1957 0FB685A1 		movzbl	-351(%rbp), %eax
 2351      FEFFFF
 2352 195e 89C6     		movl	%eax, %esi
 2353 1960 BF000000 		movl	$.LC56, %edi
 2353      00
 2354 1965 B8000000 		movl	$0, %eax
 2354      00
 2355 196a E8000000 		call	printf
 2355      00
 2356              	.L148:
 500:main.c        ****                                         fStatus = flWriteChannel(handle, (uint8_t) i, length, &temp
 2357              		.loc 1 500 0 is_stmt 1
 2358 196f 8B95F4FE 		movl	-268(%rbp), %edx
 2358      FFFF
 2359 1975 0FB6B5A1 		movzbl	-351(%rbp), %esi
 2359      FEFFFF
 2360 197c 488B8518 		movq	-232(%rbp), %rax
 2360      FFFFFF
 2361 1983 488DBD20 		leaq	-224(%rbp), %rdi
 2361      FFFFFF
 2362 198a 488D8DBC 		leaq	-324(%rbp), %rcx
 2362      FEFFFF
 2363 1991 4989F8   		movq	%rdi, %r8
 2364 1994 4889C7   		movq	%rax, %rdi
 2365 1997 E8000000 		call	flWriteChannel
 2365      00
 2366 199c 8985F0FE 		movl	%eax, -272(%rbp)
 2366      FFFF
 501:main.c        ****                                         CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2367              		.loc 1 501 0
 2368 19a2 83BDF0FE 		cmpl	$0, -272(%rbp)
 2368      FFFF00
 2369 19a9 740F     		je	.L149
 2370              		.loc 1 501 0 is_stmt 0 discriminator 1
 2371 19ab C785C0FE 		movl	$1, -320(%rbp)
 2371      FFFF0100 
 2371      0000
 2372              	.LBE38:
 2373              	.LBE37:
 462:main.c        **** 
 2374              		.loc 1 462 0 is_stmt 1 discriminator 1
 2375 19b5 E98F0200 		jmp	.L73
 2375      00
 2376              	.L149:
 2377              	.LBB41:
 490:main.c        ****                                         uint8_t tempSto = 0;
 2378              		.loc 1 490 0
 2379 19ba 0FB685A1 		movzbl	-351(%rbp), %eax
 2379      FEFFFF
 2380 19c1 83C001   		addl	$1, %eax
 2381 19c4 8885A1FE 		movb	%al, -351(%rbp)
 2381      FFFF
 2382              	.L144:
 490:main.c        ****                                         uint8_t tempSto = 0;
 2383              		.loc 1 490 0 is_stmt 0 discriminator 1
 2384 19ca 80BDA1FE 		cmpb	$13, -351(%rbp)
 2384      FFFF0D
 2385 19d1 0F86D7FE 		jbe	.L150
 2385      FFFF
 2386              	.LBE41:
 2387              	.LBB42:
 502:main.c        ****                                     }
 503:main.c        **** 
 504:main.c        ****                                     for (uint8_t i = 14; i <= 17; i++) {
 2388              		.loc 1 504 0 is_stmt 1
 2389 19d7 C685A3FE 		movb	$14, -349(%rbp)
 2389      FFFF0E
 2390 19de E91C0100 		jmp	.L151
 2390      00
 2391              	.L157:
 2392              	.LBB43:
 505:main.c        ****                                         uint8_t tempSto = 0;
 2393              		.loc 1 505 0
 2394 19e3 C685BCFE 		movb	$0, -324(%rbp)
 2394      FFFF00
 2395              	.LBB44:
 506:main.c        ****                                         for (uint8_t j = 0; j <= 7; j++) {
 2396              		.loc 1 506 0
 2397 19ea C685A4FE 		movb	$0, -348(%rbp)
 2397      FFFF00
 2398 19f1 EB71     		jmp	.L152
 2399              	.L154:
 2400              	.LBB45:
 507:main.c        ****                                             uint8_t temp = j + (i - 14) * 8;
 2401              		.loc 1 507 0
 2402 19f3 0FB685A3 		movzbl	-349(%rbp), %eax
 2402      FEFFFF
 2403 19fa 83E80E   		subl	$14, %eax
 2404 19fd 8D14C500 		leal	0(,%rax,8), %edx
 2404      000000
 2405 1a04 0FB685A4 		movzbl	-348(%rbp), %eax
 2405      FEFFFF
 2406 1a0b 01D0     		addl	%edx, %eax
 2407 1a0d 8885ABFE 		movb	%al, -341(%rbp)
 2407      FFFF
 508:main.c        ****                                             if ((befEncSen[1] & (1 << temp)) != 0) {
 2408              		.loc 1 508 0
 2409 1a13 8B9514FF 		movl	-236(%rbp), %edx
 2409      FFFF
 2410 1a19 0FB685AB 		movzbl	-341(%rbp), %eax
 2410      FEFFFF
 2411 1a20 BE010000 		movl	$1, %esi
 2411      00
 2412 1a25 89C1     		movl	%eax, %ecx
 2413 1a27 D3E6     		sall	%cl, %esi
 2414 1a29 89F0     		movl	%esi, %eax
 2415 1a2b 21D0     		andl	%edx, %eax
 2416 1a2d 85C0     		testl	%eax, %eax
 2417 1a2f 7423     		je	.L153
 509:main.c        ****                                                 tempSto += (1 << j);
 2418              		.loc 1 509 0
 2419 1a31 0FB685A4 		movzbl	-348(%rbp), %eax
 2419      FEFFFF
 2420 1a38 BA010000 		movl	$1, %edx
 2420      00
 2421 1a3d 89C1     		movl	%eax, %ecx
 2422 1a3f D3E2     		sall	%cl, %edx
 2423 1a41 89D0     		movl	%edx, %eax
 2424 1a43 89C2     		movl	%eax, %edx
 2425 1a45 0FB685BC 		movzbl	-324(%rbp), %eax
 2425      FEFFFF
 2426 1a4c 01D0     		addl	%edx, %eax
 2427 1a4e 8885BCFE 		movb	%al, -324(%rbp)
 2427      FFFF
 2428              	.L153:
 2429              	.LBE45:
 506:main.c        ****                                             uint8_t temp = j + (i - 14) * 8;
 2430              		.loc 1 506 0
 2431 1a54 0FB685A4 		movzbl	-348(%rbp), %eax
 2431      FEFFFF
 2432 1a5b 83C001   		addl	$1, %eax
 2433 1a5e 8885A4FE 		movb	%al, -348(%rbp)
 2433      FFFF
 2434              	.L152:
 506:main.c        ****                                             uint8_t temp = j + (i - 14) * 8;
 2435              		.loc 1 506 0 is_stmt 0 discriminator 1
 2436 1a64 80BDA4FE 		cmpb	$7, -348(%rbp)
 2436      FFFF07
 2437 1a6b 7686     		jbe	.L154
 2438              	.LBE44:
 510:main.c        ****                                             }
 511:main.c        ****                                         }
 512:main.c        ****                                         flSleep(1000);
 2439              		.loc 1 512 0 is_stmt 1
 2440 1a6d BFE80300 		movl	$1000, %edi
 2440      00
 2441 1a72 E8000000 		call	flSleep
 2441      00
 513:main.c        ****                                         if (LOG) printf("Write to channel %u = %u \n", i, tempSto);
 2442              		.loc 1 513 0
 2443 1a77 0FB60500 		movzbl	LOG(%rip), %eax
 2443      000000
 2444 1a7e 84C0     		testb	%al, %al
 2445 1a80 7422     		je	.L155
 2446              		.loc 1 513 0 is_stmt 0 discriminator 1
 2447 1a82 0FB685BC 		movzbl	-324(%rbp), %eax
 2447      FEFFFF
 2448 1a89 0FB6D0   		movzbl	%al, %edx
 2449 1a8c 0FB685A3 		movzbl	-349(%rbp), %eax
 2449      FEFFFF
 2450 1a93 89C6     		movl	%eax, %esi
 2451 1a95 BF000000 		movl	$.LC56, %edi
 2451      00
 2452 1a9a B8000000 		movl	$0, %eax
 2452      00
 2453 1a9f E8000000 		call	printf
 2453      00
 2454              	.L155:
 514:main.c        ****                                         fStatus = flWriteChannel(handle, (uint8_t) i, length, &temp
 2455              		.loc 1 514 0 is_stmt 1
 2456 1aa4 8B95F4FE 		movl	-268(%rbp), %edx
 2456      FFFF
 2457 1aaa 0FB6B5A3 		movzbl	-349(%rbp), %esi
 2457      FEFFFF
 2458 1ab1 488B8518 		movq	-232(%rbp), %rax
 2458      FFFFFF
 2459 1ab8 488DBD20 		leaq	-224(%rbp), %rdi
 2459      FFFFFF
 2460 1abf 488D8DBC 		leaq	-324(%rbp), %rcx
 2460      FEFFFF
 2461 1ac6 4989F8   		movq	%rdi, %r8
 2462 1ac9 4889C7   		movq	%rax, %rdi
 2463 1acc E8000000 		call	flWriteChannel
 2463      00
 2464 1ad1 8985F0FE 		movl	%eax, -272(%rbp)
 2464      FFFF
 515:main.c        ****                                         CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2465              		.loc 1 515 0
 2466 1ad7 83BDF0FE 		cmpl	$0, -272(%rbp)
 2466      FFFF00
 2467 1ade 740F     		je	.L156
 2468              		.loc 1 515 0 is_stmt 0 discriminator 1
 2469 1ae0 C785C0FE 		movl	$1, -320(%rbp)
 2469      FFFF0100 
 2469      0000
 2470              	.LBE43:
 2471              	.LBE42:
 462:main.c        **** 
 2472              		.loc 1 462 0 is_stmt 1 discriminator 1
 2473 1aea E95A0100 		jmp	.L73
 2473      00
 2474              	.L156:
 2475              	.LBB46:
 504:main.c        ****                                         uint8_t tempSto = 0;
 2476              		.loc 1 504 0
 2477 1aef 0FB685A3 		movzbl	-349(%rbp), %eax
 2477      FEFFFF
 2478 1af6 83C001   		addl	$1, %eax
 2479 1af9 8885A3FE 		movb	%al, -349(%rbp)
 2479      FFFF
 2480              	.L151:
 504:main.c        ****                                         uint8_t tempSto = 0;
 2481              		.loc 1 504 0 is_stmt 0 discriminator 1
 2482 1aff 80BDA3FE 		cmpb	$17, -349(%rbp)
 2482      FFFF11
 2483 1b06 0F86D7FE 		jbe	.L157
 2483      FFFF
 2484              	.LBE46:
 2485 1b0c E9360100 		jmp	.L158
 2485      00
 2486              	.L83:
 2487              	.LBE33:
 516:main.c        ****                                     }
 517:main.c        ****                                 }
 518:main.c        ****                             } else {
 519:main.c        ****                                 printf("Invalid user \n");
 2488              		.loc 1 519 0 is_stmt 1
 2489 1b11 BF000000 		movl	$.LC61, %edi
 2489      00
 2490 1b16 E8000000 		call	puts
 2490      00
 520:main.c        ****                                 *statusOnChan9 = 4;
 2491              		.loc 1 520 0
 2492 1b1b 488B45A8 		movq	-88(%rbp), %rax
 2493 1b1f C60004   		movb	$4, (%rax)
 521:main.c        ****                                 flSleep(1000);
 2494              		.loc 1 521 0
 2495 1b22 BFE80300 		movl	$1000, %edi
 2495      00
 2496 1b27 E8000000 		call	flSleep
 2496      00
 522:main.c        ****                                 if (LOG) printf("Write to channel %u = %u \n", 9, *statusOnChan9);
 2497              		.loc 1 522 0
 2498 1b2c 0FB60500 		movzbl	LOG(%rip), %eax
 2498      000000
 2499 1b33 84C0     		testb	%al, %al
 2500 1b35 7420     		je	.L159
 2501              		.loc 1 522 0 is_stmt 0 discriminator 1
 2502 1b37 488B45A8 		movq	-88(%rbp), %rax
 2503 1b3b 0FB600   		movzbl	(%rax), %eax
 2504 1b3e 0FB6C0   		movzbl	%al, %eax
 2505 1b41 89C2     		movl	%eax, %edx
 2506 1b43 BE090000 		movl	$9, %esi
 2506      00
 2507 1b48 BF000000 		movl	$.LC56, %edi
 2507      00
 2508 1b4d B8000000 		movl	$0, %eax
 2508      00
 2509 1b52 E8000000 		call	printf
 2509      00
 2510              	.L159:
 523:main.c        ****                                 fStatus = flWriteChannel(handle, (uint8_t) 9, length, statusOnChan9
 2511              		.loc 1 523 0 is_stmt 1
 2512 1b57 8B95F4FE 		movl	-268(%rbp), %edx
 2512      FFFF
 2513 1b5d 488B8518 		movq	-232(%rbp), %rax
 2513      FFFFFF
 2514 1b64 488DB520 		leaq	-224(%rbp), %rsi
 2514      FFFFFF
 2515 1b6b 488B4DA8 		movq	-88(%rbp), %rcx
 2516 1b6f 4989F0   		movq	%rsi, %r8
 2517 1b72 BE090000 		movl	$9, %esi
 2517      00
 2518 1b77 4889C7   		movq	%rax, %rdi
 2519 1b7a E8000000 		call	flWriteChannel
 2519      00
 2520 1b7f 8985F0FE 		movl	%eax, -272(%rbp)
 2520      FFFF
 524:main.c        ****                                 CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2521              		.loc 1 524 0
 2522 1b85 83BDF0FE 		cmpl	$0, -272(%rbp)
 2522      FFFF00
 2523 1b8c 740F     		je	.L160
 2524              		.loc 1 524 0 is_stmt 0 discriminator 1
 2525 1b8e C785C0FE 		movl	$1, -320(%rbp)
 2525      FFFF0100 
 2525      0000
 2526 1b98 E9AC0000 		jmp	.L73
 2526      00
 2527              	.L160:
 2528              	.LBB47:
 525:main.c        ****                                 for (int i = 10; i <= 17; i++) {
 2529              		.loc 1 525 0 is_stmt 1
 2530 1b9d C785E8FE 		movl	$10, -280(%rbp)
 2530      FFFF0A00 
 2530      0000
 2531 1ba7 E98E0000 		jmp	.L161
 2531      00
 2532              	.L164:
 2533              	.LBB48:
 526:main.c        ****                                     uint8_t tempSto = 0;
 2534              		.loc 1 526 0
 2535 1bac C68510FF 		movb	$0, -240(%rbp)
 2535      FFFF00
 527:main.c        ****                                     flSleep(1000);
 2536              		.loc 1 527 0
 2537 1bb3 BFE80300 		movl	$1000, %edi
 2537      00
 2538 1bb8 E8000000 		call	flSleep
 2538      00
 528:main.c        ****                                     if (LOG) printf("Write to channel %u = %u \n", i, tempSto);
 2539              		.loc 1 528 0
 2540 1bbd 0FB60500 		movzbl	LOG(%rip), %eax
 2540      000000
 2541 1bc4 84C0     		testb	%al, %al
 2542 1bc6 7421     		je	.L162
 2543              		.loc 1 528 0 is_stmt 0 discriminator 1
 2544 1bc8 0FB68510 		movzbl	-240(%rbp), %eax
 2544      FFFFFF
 2545 1bcf 0FB6D0   		movzbl	%al, %edx
 2546 1bd2 8B85E8FE 		movl	-280(%rbp), %eax
 2546      FFFF
 2547 1bd8 89C6     		movl	%eax, %esi
 2548 1bda BF000000 		movl	$.LC56, %edi
 2548      00
 2549 1bdf B8000000 		movl	$0, %eax
 2549      00
 2550 1be4 E8000000 		call	printf
 2550      00
 2551              	.L162:
 529:main.c        ****                                     fStatus = flWriteChannel(handle, (uint8_t) i, length, &tempSto,
 2552              		.loc 1 529 0 is_stmt 1
 2553 1be9 8B95F4FE 		movl	-268(%rbp), %edx
 2553      FFFF
 2554 1bef 8B85E8FE 		movl	-280(%rbp), %eax
 2554      FFFF
 2555 1bf5 0FB6F0   		movzbl	%al, %esi
 2556 1bf8 488B8518 		movq	-232(%rbp), %rax
 2556      FFFFFF
 2557 1bff 488DBD20 		leaq	-224(%rbp), %rdi
 2557      FFFFFF
 2558 1c06 488D8D10 		leaq	-240(%rbp), %rcx
 2558      FFFFFF
 2559 1c0d 4989F8   		movq	%rdi, %r8
 2560 1c10 4889C7   		movq	%rax, %rdi
 2561 1c13 E8000000 		call	flWriteChannel
 2561      00
 2562 1c18 8985F0FE 		movl	%eax, -272(%rbp)
 2562      FFFF
 530:main.c        ****                                     CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2563              		.loc 1 530 0
 2564 1c1e 83BDF0FE 		cmpl	$0, -272(%rbp)
 2564      FFFF00
 2565 1c25 740C     		je	.L163
 2566              		.loc 1 530 0 is_stmt 0 discriminator 1
 2567 1c27 C785C0FE 		movl	$1, -320(%rbp)
 2567      FFFF0100 
 2567      0000
 2568              	.LBE48:
 2569              	.LBE47:
 350:main.c        ****                                 if (LOG) printf("Read from channel %u = %u \n", i, *readFromChannel
 2570              		.loc 1 350 0 is_stmt 1 discriminator 1
 2571 1c31 EB27     		jmp	.L59
 2572              	.L163:
 2573              	.LBB49:
 525:main.c        ****                                     uint8_t tempSto = 0;
 2574              		.loc 1 525 0
 2575 1c33 8385E8FE 		addl	$1, -280(%rbp)
 2575      FFFF01
 2576              	.L161:
 525:main.c        ****                                     uint8_t tempSto = 0;
 2577              		.loc 1 525 0 is_stmt 0 discriminator 1
 2578 1c3a 83BDE8FE 		cmpl	$17, -280(%rbp)
 2578      FFFF11
 2579 1c41 0F8E65FF 		jle	.L164
 2579      FFFF
 2580              	.L158:
 2581              	.LBE49:
 2582 1c47 EB02     		jmp	.L62
 2583              	.L73:
 2584              	.LBE10:
 2585              	.LBE9:
 2586              	.LBE8:
 324:main.c        ****                     if (LOG) printf("Read from channel 0 = %u \n", *readFromChannelZero);
 2587              		.loc 1 324 0 is_stmt 1 discriminator 1
 2588 1c49 EB63     		jmp	.L29
 2589              	.L62:
 2590              	.LBB50:
 531:main.c        ****                                 }
 532:main.c        ****                             }
 533:main.c        ****                         }
 534:main.c        ****                     }
 535:main.c        ****                     flSleep(1000);
 2591              		.loc 1 535 0
 2592 1c4b BFE80300 		movl	$1000, %edi
 2592      00
 2593 1c50 E8000000 		call	flSleep
 2593      00
 2594              	.LBE50:
 536:main.c        ****                 }
 2595              		.loc 1 536 0
 2596 1c55 E902EFFF 		jmp	.L57
 2596      FF
 2597              	.L59:
 2598              	.LBE7:
 291:main.c        ****             fStatus = flIsFPGARunning(handle, &isRunning, &error);
 2599              		.loc 1 291 0 discriminator 1
 2600 1c5a EB52     		jmp	.L29
 2601              	.L50:
 537:main.c        **** 
 538:main.c        ****             } else {
 539:main.c        ****                 fprintf(stderr, "The FPGALink device at %s is not ready to talk - did you forget --
 2602              		.loc 1 539 0
 2603 1c5c 488B0500 		movq	stderr(%rip), %rax
 2603      000000
 2604 1c63 488B5580 		movq	-128(%rbp), %rdx
 2605 1c67 BE000000 		movl	$.LC62, %esi
 2605      00
 2606 1c6c 4889C7   		movq	%rax, %rdi
 2607 1c6f B8000000 		movl	$0, %eax
 2607      00
 2608 1c74 E8000000 		call	fprintf
 2608      00
 540:main.c        ****                 FAIL(FLP_ARGS, cleanup);
 2609              		.loc 1 540 0
 2610 1c79 C785C0FE 		movl	$12, -320(%rbp)
 2610      FFFF0C00 
 2610      0000
 2611 1c83 90       		nop
 2612 1c84 EB28     		jmp	.L29
 2613              	.L46:
 2614              	.LBE6:
 541:main.c        ****             }
 542:main.c        ****         } else {
 543:main.c        ****             fprintf(stderr, "Action requested but device at %s does not support CommFPGA\n", vp);
 2615              		.loc 1 543 0
 2616 1c86 488B0500 		movq	stderr(%rip), %rax
 2616      000000
 2617 1c8d 488B5580 		movq	-128(%rbp), %rdx
 2618 1c91 BE000000 		movl	$.LC63, %esi
 2618      00
 2619 1c96 4889C7   		movq	%rax, %rdi
 2620 1c99 B8000000 		movl	$0, %eax
 2620      00
 2621 1c9e E8000000 		call	fprintf
 2621      00
 544:main.c        ****             FAIL(FLP_ARGS, cleanup);
 2622              		.loc 1 544 0
 2623 1ca3 C785C0FE 		movl	$12, -320(%rbp)
 2623      FFFF0C00 
 2623      0000
 2624 1cad 90       		nop
 2625              	.L29:
 545:main.c        ****         }
 546:main.c        ****     }
 547:main.c        **** 
 548:main.c        ****     cleanup:
 549:main.c        ****     free((void *) line);
 2626              		.loc 1 549 0
 2627 1cae 488B4588 		movq	-120(%rbp), %rax
 2628 1cb2 4889C7   		movq	%rax, %rdi
 2629 1cb5 E8000000 		call	free
 2629      00
 550:main.c        ****     flClose(handle);
 2630              		.loc 1 550 0
 2631 1cba 488B8518 		movq	-232(%rbp), %rax
 2631      FFFFFF
 2632 1cc1 4889C7   		movq	%rax, %rdi
 2633 1cc4 E8000000 		call	flClose
 2633      00
 551:main.c        ****     if (error) {
 2634              		.loc 1 551 0
 2635 1cc9 488B8520 		movq	-224(%rbp), %rax
 2635      FFFFFF
 2636 1cd0 4885C0   		testq	%rax, %rax
 2637 1cd3 742F     		je	.L165
 552:main.c        ****         fprintf(stderr, "%s\n", error);
 2638              		.loc 1 552 0
 2639 1cd5 488B9520 		movq	-224(%rbp), %rdx
 2639      FFFFFF
 2640 1cdc 488B0500 		movq	stderr(%rip), %rax
 2640      000000
 2641 1ce3 BE000000 		movl	$.LC64, %esi
 2641      00
 2642 1ce8 4889C7   		movq	%rax, %rdi
 2643 1ceb B8000000 		movl	$0, %eax
 2643      00
 2644 1cf0 E8000000 		call	fprintf
 2644      00
 553:main.c        ****         flFreeError(error);
 2645              		.loc 1 553 0
 2646 1cf5 488B8520 		movq	-224(%rbp), %rax
 2646      FFFFFF
 2647 1cfc 4889C7   		movq	%rax, %rdi
 2648 1cff E8000000 		call	flFreeError
 2648      00
 2649              	.L165:
 554:main.c        ****     }
 555:main.c        ****     return retVal;
 2650              		.loc 1 555 0
 2651 1d04 8B85C0FE 		movl	-320(%rbp), %eax
 2651      FFFF
 2652              	.L166:
 556:main.c        **** }...
 2653              		.loc 1 556 0
 2654 1d0a 4881C478 		addq	$376, %rsp
 2654      010000
 2655 1d11 5B       		popq	%rbx
 2656 1d12 5D       		popq	%rbp
 2657              		.cfi_def_cfa 7, 8
 2658 1d13 C3       		ret
 2659              		.cfi_endproc
 2660              	.LFE14:
 2662              	.Letext0:
 2663              		.file 2 "/usr/include/stdint.h"
 2664              		.file 3 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
 2665              		.file 4 "/usr/include/x86_64-linux-gnu/bits/types.h"
 2666              		.file 5 "/usr/include/stdio.h"
 2667              		.file 6 "/usr/include/libio.h"
 2668              		.file 7 "/home/anirudh/Downloads/DLD-LAB/04-connectingatms/backend/libs/libargtable2/argtable2.h"
 2669              		.file 8 "/home/anirudh/Downloads/DLD-LAB/04-connectingatms/backend/common/makestuff.h"
 2670              		.file 9 "/home/anirudh/Downloads/DLD-LAB/04-connectingatms/backend/libs/libfpgalink/libfpgalink.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
                            *COM*:0000000000186a50 dataFromCSV
     /tmp/ccE6gMzs.s:10     .bss:0000000000000000 numLines
     /tmp/ccE6gMzs.s:15     .bss:0000000000000004 LOG
     /tmp/ccE6gMzs.s:22     .data:0000000000000000 bankID
     /tmp/ccE6gMzs.s:28     .data:0000000000000004 maxAmountCanBeDispensed
     /tmp/ccE6gMzs.s:33     .data:0000000000000008 max2000Limit
     /tmp/ccE6gMzs.s:38     .data:0000000000000009 max1000Limit
     /tmp/ccE6gMzs.s:43     .data:000000000000000a max500Limit
     /tmp/ccE6gMzs.s:48     .data:000000000000000b max100Limit
     /tmp/ccE6gMzs.s:53     .text:0000000000000000 decrypt
     /tmp/ccE6gMzs.s:155    .text:00000000000000dd encrypt
     /tmp/ccE6gMzs.s:256    .text:00000000000001ba decrypt64
     /tmp/ccE6gMzs.s:290    .text:00000000000001f7 encrypt64
     /tmp/ccE6gMzs.s:324    .text:0000000000000234 myHash
     /tmp/ccE6gMzs.s:397    .text:00000000000002aa format
     /tmp/ccE6gMzs.s:453    .text:000000000000032a find
     /tmp/ccE6gMzs.s:540    .text:00000000000003d7 suffBalUser
     /tmp/ccE6gMzs.s:596    .rodata:00000000000000e0 errMessages
     /tmp/ccE6gMzs.s:734    .text:00000000000003fb main

UNDEFINED SYMBOLS
strtok
sscanf
arg_str0
arg_str1
arg_lit0
arg_end
arg_nullcheck
stderr
fprintf
arg_parse
atoi
puts
printf
stdout
arg_print_syntax
arg_print_glossary
arg_print_errors
flInitialise
flOpen
flLoadStandardFirmware
flSleep
putchar
fflush
flIsDeviceAvailable
flGetFirmwareVersion
flGetFirmwareID
flIsCommCapable
flSelectConduit
flIsFPGARunning
fopen
malloc
getline
free
fclose
flReadChannel
flWriteChannel
fwrite
fputc
flClose
flFreeError
