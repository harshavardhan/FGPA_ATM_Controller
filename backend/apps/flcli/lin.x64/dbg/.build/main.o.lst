   1              		.file	"main.c"
   2              		.text
   3              	.Ltext0:
   4              		.comm	dataFromCSV,1600080,32
   5              		.globl	numLines
   6              		.bss
   7              		.align 4
  10              	numLines:
  11 0000 00000000 		.zero	4
  12              		.globl	LOG
  15              	LOG:
  16 0004 00       		.zero	1
  17              		.globl	bankID
  18              		.data
  19              		.align 4
  22              	bankID:
  23 0000 FFFFFFFF 		.long	-1
  24              		.globl	maxAmountCanBeDispensed
  25              		.align 4
  28              	maxAmountCanBeDispensed:
  29 0004 FFFFFFFF 		.long	-1
  30              		.globl	max2000Limit
  33              	max2000Limit:
  34 0008 01       		.byte	1
  35              		.globl	max1000Limit
  38              	max1000Limit:
  39 0009 01       		.byte	1
  40              		.globl	max500Limit
  43              	max500Limit:
  44 000a FF       		.byte	-1
  45              		.globl	max100Limit
  48              	max100Limit:
  49 000b FF       		.byte	-1
  50              		.text
  51              		.globl	decrypt
  53              	decrypt:
  54              	.LFB6:
  55              		.file 1 "main.c"
   1:main.c        **** /*
   2:main.c        ****    If the user is an admin : 
   3:main.c        ****    Original 64 bit -> | User ID 16-bit | Password 16-bit | 2k 8-bit | 1k 8-bit | 500 8-bit | 100 8-
   4:main.c        ****    (in VHDL before encryption)  8 7 6 5 4 3 2 1
   5:main.c        **** 
   6:main.c        ****    If the user is an accountee : 
   7:main.c        ****    Original 64 bit -> | User ID 16-bit | Password 16-bit | Amount in 32 bit |
   8:main.c        ****    (in VHDL before encryption)  8 7 6 5 4 3 2 1
   9:main.c        **** 
  10:main.c        ****    User ID 16-bit -> Least 5 significant bits indicate bankID
  11:main.c        **** */
  12:main.c        **** 
  13:main.c        **** #define _GNU_SOURCE
  14:main.c        **** 
  15:main.c        **** #include <stdint.h>
  16:main.c        **** #include <stdbool.h>
  17:main.c        **** #include <stdio.h>
  18:main.c        **** #include <stdlib.h>
  19:main.c        **** #include <argtable2.h>
  20:main.c        **** #include <string.h>
  21:main.c        **** #include <libfpgalink.h>
  22:main.c        **** #include <errno.h>
  23:main.c        **** #include <makestuff.h>
  24:main.c        **** #include <libbuffer.h>
  25:main.c        **** #include <liberror.h>
  26:main.c        **** #include <libdump.h>
  27:main.c        **** #include <readline/readline.h>
  28:main.c        **** #include <readline/history.h>
  29:main.c        **** 
  30:main.c        **** #ifdef WIN32
  31:main.c        **** #include <Windows.h>
  32:main.c        **** #else
  33:main.c        **** #include <sys/time.h>
  34:main.c        **** #endif
  35:main.c        **** 
  36:main.c        **** #define N 100005
  37:main.c        **** #define M (((ll)1 << 32)-1)
  38:main.c        **** #define maxNotes 255
  39:main.c        **** #define ll long long
  40:main.c        **** 
  41:main.c        **** int dataFromCSV[N][4];
  42:main.c        **** int numLines = 0;
  43:main.c        **** bool LOG = false;
  44:main.c        **** int bankID = -1;
  45:main.c        **** uint32_t maxAmountCanBeDispensed = M;
  46:main.c        **** uint8_t max2000Limit = 1, max1000Limit = 1, max500Limit = maxNotes, max100Limit = maxNotes; 
  47:main.c        **** 
  48:main.c        **** /* Adapted from tiny encryption algorithm wikipedia */
  49:main.c        **** void decrypt(uint32_t *v, uint32_t *k) {
  56              		.loc 1 49 0
  57              		.cfi_startproc
  58 0000 55       		pushq	%rbp
  59              		.cfi_def_cfa_offset 16
  60              		.cfi_offset 6, -16
  61 0001 4889E5   		movq	%rsp, %rbp
  62              		.cfi_def_cfa_register 6
  63 0004 48897DC8 		movq	%rdi, -56(%rbp)
  64 0008 488975C0 		movq	%rsi, -64(%rbp)
  50:main.c        ****     uint32_t v0 = v[0], v1 = v[1], sum = 0xC6EF3720, i;  /* set up */
  65              		.loc 1 50 0
  66 000c 488B45C8 		movq	-56(%rbp), %rax
  67 0010 8B00     		movl	(%rax), %eax
  68 0012 8945DC   		movl	%eax, -36(%rbp)
  69 0015 488B45C8 		movq	-56(%rbp), %rax
  70 0019 8B4004   		movl	4(%rax), %eax
  71 001c 8945E0   		movl	%eax, -32(%rbp)
  72 001f C745E420 		movl	$-957401312, -28(%rbp)
  72      37EFC6
  51:main.c        ****     uint32_t delta = 0x9e3779b9;                     /* a key schedule constant */
  73              		.loc 1 51 0
  74 0026 C745ECB9 		movl	$-1640531527, -20(%rbp)
  74      79379E
  52:main.c        ****     uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3];   /* cache key */
  75              		.loc 1 52 0
  76 002d 488B45C0 		movq	-64(%rbp), %rax
  77 0031 8B00     		movl	(%rax), %eax
  78 0033 8945F0   		movl	%eax, -16(%rbp)
  79 0036 488B45C0 		movq	-64(%rbp), %rax
  80 003a 8B4004   		movl	4(%rax), %eax
  81 003d 8945F4   		movl	%eax, -12(%rbp)
  82 0040 488B45C0 		movq	-64(%rbp), %rax
  83 0044 8B4008   		movl	8(%rax), %eax
  84 0047 8945F8   		movl	%eax, -8(%rbp)
  85 004a 488B45C0 		movq	-64(%rbp), %rax
  86 004e 8B400C   		movl	12(%rax), %eax
  87 0051 8945FC   		movl	%eax, -4(%rbp)
  53:main.c        ****     /* basic cycle start */
  54:main.c        ****     for (i = 0; i < 32; i++) {
  88              		.loc 1 54 0
  89 0054 C745E800 		movl	$0, -24(%rbp)
  89      000000
  90 005b EB62     		jmp	.L2
  91              	.L3:
  55:main.c        ****         v1 -= ((v0 << 4) + k2) ^ (v0 + sum) ^ ((v0 >> 5) + k3);
  92              		.loc 1 55 0 discriminator 2
  93 005d 8B45DC   		movl	-36(%rbp), %eax
  94 0060 C1E004   		sall	$4, %eax
  95 0063 89C2     		movl	%eax, %edx
  96 0065 8B45F8   		movl	-8(%rbp), %eax
  97 0068 8D0C02   		leal	(%rdx,%rax), %ecx
  98 006b 8B45E4   		movl	-28(%rbp), %eax
  99 006e 8B55DC   		movl	-36(%rbp), %edx
 100 0071 01D0     		addl	%edx, %eax
 101 0073 31C1     		xorl	%eax, %ecx
 102 0075 89CA     		movl	%ecx, %edx
 103 0077 8B45DC   		movl	-36(%rbp), %eax
 104 007a C1E805   		shrl	$5, %eax
 105 007d 89C1     		movl	%eax, %ecx
 106 007f 8B45FC   		movl	-4(%rbp), %eax
 107 0082 01C8     		addl	%ecx, %eax
 108 0084 31D0     		xorl	%edx, %eax
 109 0086 2945E0   		subl	%eax, -32(%rbp)
  56:main.c        ****         v0 -= ((v1 << 4) + k0) ^ (v1 + sum) ^ ((v1 >> 5) + k1);
 110              		.loc 1 56 0 discriminator 2
 111 0089 8B45E0   		movl	-32(%rbp), %eax
 112 008c C1E004   		sall	$4, %eax
 113 008f 89C2     		movl	%eax, %edx
 114 0091 8B45F0   		movl	-16(%rbp), %eax
 115 0094 8D0C02   		leal	(%rdx,%rax), %ecx
 116 0097 8B45E4   		movl	-28(%rbp), %eax
 117 009a 8B55E0   		movl	-32(%rbp), %edx
 118 009d 01D0     		addl	%edx, %eax
 119 009f 31C1     		xorl	%eax, %ecx
 120 00a1 89CA     		movl	%ecx, %edx
 121 00a3 8B45E0   		movl	-32(%rbp), %eax
 122 00a6 C1E805   		shrl	$5, %eax
 123 00a9 89C1     		movl	%eax, %ecx
 124 00ab 8B45F4   		movl	-12(%rbp), %eax
 125 00ae 01C8     		addl	%ecx, %eax
 126 00b0 31D0     		xorl	%edx, %eax
 127 00b2 2945DC   		subl	%eax, -36(%rbp)
  57:main.c        ****         sum -= delta;
 128              		.loc 1 57 0 discriminator 2
 129 00b5 8B45EC   		movl	-20(%rbp), %eax
 130 00b8 2945E4   		subl	%eax, -28(%rbp)
  54:main.c        ****         v1 -= ((v0 << 4) + k2) ^ (v0 + sum) ^ ((v0 >> 5) + k3);
 131              		.loc 1 54 0 discriminator 2
 132 00bb 8345E801 		addl	$1, -24(%rbp)
 133              	.L2:
  54:main.c        ****         v1 -= ((v0 << 4) + k2) ^ (v0 + sum) ^ ((v0 >> 5) + k3);
 134              		.loc 1 54 0 is_stmt 0 discriminator 1
 135 00bf 837DE81F 		cmpl	$31, -24(%rbp)
 136 00c3 7698     		jbe	.L3
  58:main.c        ****     }
  59:main.c        ****     /* end cycle */
  60:main.c        ****     v[0] = v0;
 137              		.loc 1 60 0 is_stmt 1
 138 00c5 488B45C8 		movq	-56(%rbp), %rax
 139 00c9 8B55DC   		movl	-36(%rbp), %edx
 140 00cc 8910     		movl	%edx, (%rax)
  61:main.c        ****     v[1] = v1;
 141              		.loc 1 61 0
 142 00ce 488B45C8 		movq	-56(%rbp), %rax
 143 00d2 488D5004 		leaq	4(%rax), %rdx
 144 00d6 8B45E0   		movl	-32(%rbp), %eax
 145 00d9 8902     		movl	%eax, (%rdx)
  62:main.c        **** }
 146              		.loc 1 62 0
 147 00db 5D       		popq	%rbp
 148              		.cfi_def_cfa 7, 8
 149 00dc C3       		ret
 150              		.cfi_endproc
 151              	.LFE6:
 153              		.globl	encrypt
 155              	encrypt:
 156              	.LFB7:
  63:main.c        **** 
  64:main.c        **** /* Adapted from tiny encryption algorithm wikipedia */
  65:main.c        **** void encrypt(uint32_t *v, uint32_t *k) {
 157              		.loc 1 65 0
 158              		.cfi_startproc
 159 00dd 55       		pushq	%rbp
 160              		.cfi_def_cfa_offset 16
 161              		.cfi_offset 6, -16
 162 00de 4889E5   		movq	%rsp, %rbp
 163              		.cfi_def_cfa_register 6
 164 00e1 48897DC8 		movq	%rdi, -56(%rbp)
 165 00e5 488975C0 		movq	%rsi, -64(%rbp)
  66:main.c        ****     uint32_t v0 = v[0], v1 = v[1], sum = 0, i;           /* set up */
 166              		.loc 1 66 0
 167 00e9 488B45C8 		movq	-56(%rbp), %rax
 168 00ed 8B00     		movl	(%rax), %eax
 169 00ef 8945DC   		movl	%eax, -36(%rbp)
 170 00f2 488B45C8 		movq	-56(%rbp), %rax
 171 00f6 8B4004   		movl	4(%rax), %eax
 172 00f9 8945E0   		movl	%eax, -32(%rbp)
 173 00fc C745E400 		movl	$0, -28(%rbp)
 173      000000
  67:main.c        ****     uint32_t delta = 0x9e3779b9;                     /* a key schedule constant */
 174              		.loc 1 67 0
 175 0103 C745ECB9 		movl	$-1640531527, -20(%rbp)
 175      79379E
  68:main.c        ****     uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3];   /* cache key */
 176              		.loc 1 68 0
 177 010a 488B45C0 		movq	-64(%rbp), %rax
 178 010e 8B00     		movl	(%rax), %eax
 179 0110 8945F0   		movl	%eax, -16(%rbp)
 180 0113 488B45C0 		movq	-64(%rbp), %rax
 181 0117 8B4004   		movl	4(%rax), %eax
 182 011a 8945F4   		movl	%eax, -12(%rbp)
 183 011d 488B45C0 		movq	-64(%rbp), %rax
 184 0121 8B4008   		movl	8(%rax), %eax
 185 0124 8945F8   		movl	%eax, -8(%rbp)
 186 0127 488B45C0 		movq	-64(%rbp), %rax
 187 012b 8B400C   		movl	12(%rax), %eax
 188 012e 8945FC   		movl	%eax, -4(%rbp)
  69:main.c        ****     /* basic cycle start */
  70:main.c        ****     for (i = 0; i < 32; i++) {
 189              		.loc 1 70 0
 190 0131 C745E800 		movl	$0, -24(%rbp)
 190      000000
 191 0138 EB62     		jmp	.L5
 192              	.L6:
  71:main.c        ****         sum += delta;
 193              		.loc 1 71 0 discriminator 2
 194 013a 8B45EC   		movl	-20(%rbp), %eax
 195 013d 0145E4   		addl	%eax, -28(%rbp)
  72:main.c        ****         v0 += ((v1 << 4) + k0) ^ (v1 + sum) ^ ((v1 >> 5) + k1);
 196              		.loc 1 72 0 discriminator 2
 197 0140 8B45E0   		movl	-32(%rbp), %eax
 198 0143 C1E004   		sall	$4, %eax
 199 0146 89C2     		movl	%eax, %edx
 200 0148 8B45F0   		movl	-16(%rbp), %eax
 201 014b 8D0C02   		leal	(%rdx,%rax), %ecx
 202 014e 8B45E4   		movl	-28(%rbp), %eax
 203 0151 8B55E0   		movl	-32(%rbp), %edx
 204 0154 01D0     		addl	%edx, %eax
 205 0156 31C1     		xorl	%eax, %ecx
 206 0158 89CA     		movl	%ecx, %edx
 207 015a 8B45E0   		movl	-32(%rbp), %eax
 208 015d C1E805   		shrl	$5, %eax
 209 0160 89C1     		movl	%eax, %ecx
 210 0162 8B45F4   		movl	-12(%rbp), %eax
 211 0165 01C8     		addl	%ecx, %eax
 212 0167 31D0     		xorl	%edx, %eax
 213 0169 0145DC   		addl	%eax, -36(%rbp)
  73:main.c        ****         v1 += ((v0 << 4) + k2) ^ (v0 + sum) ^ ((v0 >> 5) + k3);
 214              		.loc 1 73 0 discriminator 2
 215 016c 8B45DC   		movl	-36(%rbp), %eax
 216 016f C1E004   		sall	$4, %eax
 217 0172 89C2     		movl	%eax, %edx
 218 0174 8B45F8   		movl	-8(%rbp), %eax
 219 0177 8D0C02   		leal	(%rdx,%rax), %ecx
 220 017a 8B45E4   		movl	-28(%rbp), %eax
 221 017d 8B55DC   		movl	-36(%rbp), %edx
 222 0180 01D0     		addl	%edx, %eax
 223 0182 31C1     		xorl	%eax, %ecx
 224 0184 89CA     		movl	%ecx, %edx
 225 0186 8B45DC   		movl	-36(%rbp), %eax
 226 0189 C1E805   		shrl	$5, %eax
 227 018c 89C1     		movl	%eax, %ecx
 228 018e 8B45FC   		movl	-4(%rbp), %eax
 229 0191 01C8     		addl	%ecx, %eax
 230 0193 31D0     		xorl	%edx, %eax
 231 0195 0145E0   		addl	%eax, -32(%rbp)
  70:main.c        ****         sum += delta;
 232              		.loc 1 70 0 discriminator 2
 233 0198 8345E801 		addl	$1, -24(%rbp)
 234              	.L5:
  70:main.c        ****         sum += delta;
 235              		.loc 1 70 0 is_stmt 0 discriminator 1
 236 019c 837DE81F 		cmpl	$31, -24(%rbp)
 237 01a0 7698     		jbe	.L6
  74:main.c        ****     }
  75:main.c        ****     /* end cycle */
  76:main.c        ****     v[0] = v0;
 238              		.loc 1 76 0 is_stmt 1
 239 01a2 488B45C8 		movq	-56(%rbp), %rax
 240 01a6 8B55DC   		movl	-36(%rbp), %edx
 241 01a9 8910     		movl	%edx, (%rax)
  77:main.c        ****     v[1] = v1;
 242              		.loc 1 77 0
 243 01ab 488B45C8 		movq	-56(%rbp), %rax
 244 01af 488D5004 		leaq	4(%rax), %rdx
 245 01b3 8B45E0   		movl	-32(%rbp), %eax
 246 01b6 8902     		movl	%eax, (%rdx)
  78:main.c        **** }
 247              		.loc 1 78 0
 248 01b8 5D       		popq	%rbp
 249              		.cfi_def_cfa 7, 8
 250 01b9 C3       		ret
 251              		.cfi_endproc
 252              	.LFE7:
 254              		.globl	decrypt64
 256              	decrypt64:
 257              	.LFB8:
  79:main.c        **** 
  80:main.c        **** void decrypt64(uint32_t *inpData) {
 258              		.loc 1 80 0
 259              		.cfi_startproc
 260 01ba 55       		pushq	%rbp
 261              		.cfi_def_cfa_offset 16
 262              		.cfi_offset 6, -16
 263 01bb 4889E5   		movq	%rsp, %rbp
 264              		.cfi_def_cfa_register 6
 265 01be 4883EC18 		subq	$24, %rsp
 266 01c2 48897DE8 		movq	%rdi, -24(%rbp)
  81:main.c        ****     uint32_t key[4];
  82:main.c        ****     key[0] = 0x2927c18c;
 267              		.loc 1 82 0
 268 01c6 C745F08C 		movl	$690471308, -16(%rbp)
 268      C12729
  83:main.c        ****     key[1] = 0x75f8c48f;
 269              		.loc 1 83 0
 270 01cd C745F48F 		movl	$1979237519, -12(%rbp)
 270      C4F875
  84:main.c        ****     key[2] = 0x43fd99f7;
 271              		.loc 1 84 0
 272 01d4 C745F8F7 		movl	$1140693495, -8(%rbp)
 272      99FD43
  85:main.c        ****     key[3] = 0xff0f7457;
 273              		.loc 1 85 0
 274 01db C745FC57 		movl	$-15764393, -4(%rbp)
 274      740FFF
  86:main.c        ****     decrypt(inpData, key);
 275              		.loc 1 86 0
 276 01e2 488D55F0 		leaq	-16(%rbp), %rdx
 277 01e6 488B45E8 		movq	-24(%rbp), %rax
 278 01ea 4889D6   		movq	%rdx, %rsi
 279 01ed 4889C7   		movq	%rax, %rdi
 280 01f0 E8000000 		call	decrypt
 280      00
  87:main.c        **** }
 281              		.loc 1 87 0
 282 01f5 C9       		leave
 283              		.cfi_def_cfa 7, 8
 284 01f6 C3       		ret
 285              		.cfi_endproc
 286              	.LFE8:
 288              		.globl	encrypt64
 290              	encrypt64:
 291              	.LFB9:
  88:main.c        **** 
  89:main.c        **** void encrypt64(uint32_t *inpData) {
 292              		.loc 1 89 0
 293              		.cfi_startproc
 294 01f7 55       		pushq	%rbp
 295              		.cfi_def_cfa_offset 16
 296              		.cfi_offset 6, -16
 297 01f8 4889E5   		movq	%rsp, %rbp
 298              		.cfi_def_cfa_register 6
 299 01fb 4883EC18 		subq	$24, %rsp
 300 01ff 48897DE8 		movq	%rdi, -24(%rbp)
  90:main.c        ****     uint32_t key[4];
  91:main.c        ****     key[0] = 0x2927c18c;
 301              		.loc 1 91 0
 302 0203 C745F08C 		movl	$690471308, -16(%rbp)
 302      C12729
  92:main.c        ****     key[1] = 0x75f8c48f;
 303              		.loc 1 92 0
 304 020a C745F48F 		movl	$1979237519, -12(%rbp)
 304      C4F875
  93:main.c        ****     key[2] = 0x43fd99f7;
 305              		.loc 1 93 0
 306 0211 C745F8F7 		movl	$1140693495, -8(%rbp)
 306      99FD43
  94:main.c        ****     key[3] = 0xff0f7457;
 307              		.loc 1 94 0
 308 0218 C745FC57 		movl	$-15764393, -4(%rbp)
 308      740FFF
  95:main.c        ****     encrypt(inpData, key);
 309              		.loc 1 95 0
 310 021f 488D55F0 		leaq	-16(%rbp), %rdx
 311 0223 488B45E8 		movq	-24(%rbp), %rax
 312 0227 4889D6   		movq	%rdx, %rsi
 313 022a 4889C7   		movq	%rax, %rdi
 314 022d E8000000 		call	encrypt
 314      00
  96:main.c        **** }
 315              		.loc 1 96 0
 316 0232 C9       		leave
 317              		.cfi_def_cfa 7, 8
 318 0233 C3       		ret
 319              		.cfi_endproc
 320              	.LFE9:
 322              		.globl	myHash
 324              	myHash:
 325              	.LFB10:
  97:main.c        **** 
  98:main.c        **** uint16_t myHash(uint16_t befHash) {
 326              		.loc 1 98 0
 327              		.cfi_startproc
 328 0234 55       		pushq	%rbp
 329              		.cfi_def_cfa_offset 16
 330              		.cfi_offset 6, -16
 331 0235 4889E5   		movq	%rsp, %rbp
 332              		.cfi_def_cfa_register 6
 333 0238 89F8     		movl	%edi, %eax
 334 023a 668945EC 		movw	%ax, -20(%rbp)
  99:main.c        ****     uint16_t ret = 0;
 335              		.loc 1 99 0
 336 023e 66C745F8 		movw	$0, -8(%rbp)
 336      0000
 337              	.LBB2:
 100:main.c        ****     for (uint16_t i = 0; i <= 15; i++) {
 338              		.loc 1 100 0
 339 0244 66C745FA 		movw	$0, -6(%rbp)
 339      0000
 340 024a EB51     		jmp	.L10
 341              	.L12:
 101:main.c        ****         if ((befHash & (1 << i)) != 0) {
 342              		.loc 1 101 0
 343 024c 0FB755EC 		movzwl	-20(%rbp), %edx
 344 0250 0FB745FA 		movzwl	-6(%rbp), %eax
 345 0254 89C1     		movl	%eax, %ecx
 346 0256 D3FA     		sarl	%cl, %edx
 347 0258 89D0     		movl	%edx, %eax
 348 025a 83E001   		andl	$1, %eax
 349 025d 85C0     		testl	%eax, %eax
 350 025f 7431     		je	.L11
 351              	.LBB3:
 102:main.c        ****             uint16_t leftShift = (uint16_t)bankID % 16;
 352              		.loc 1 102 0
 353 0261 8B050000 		movl	bankID(%rip), %eax
 353      0000
 354 0267 83E00F   		andl	$15, %eax
 355 026a 668945FC 		movw	%ax, -4(%rbp)
 103:main.c        ****             uint16_t j = ((i + leftShift) % 16);
 356              		.loc 1 103 0
 357 026e 0FB745FC 		movzwl	-4(%rbp), %eax
 358 0272 0FB755FA 		movzwl	-6(%rbp), %edx
 359 0276 01D0     		addl	%edx, %eax
 360 0278 83E00F   		andl	$15, %eax
 361 027b 668945FE 		movw	%ax, -2(%rbp)
 104:main.c        ****             ret += (1 << j);
 362              		.loc 1 104 0
 363 027f 0FB745FE 		movzwl	-2(%rbp), %eax
 364 0283 BA010000 		movl	$1, %edx
 364      00
 365 0288 89C1     		movl	%eax, %ecx
 366 028a D3E2     		sall	%cl, %edx
 367 028c 89D0     		movl	%edx, %eax
 368 028e 660145F8 		addw	%ax, -8(%rbp)
 369              	.L11:
 370              	.LBE3:
 100:main.c        ****         if ((befHash & (1 << i)) != 0) {
 371              		.loc 1 100 0
 372 0292 0FB745FA 		movzwl	-6(%rbp), %eax
 373 0296 83C001   		addl	$1, %eax
 374 0299 668945FA 		movw	%ax, -6(%rbp)
 375              	.L10:
 100:main.c        ****         if ((befHash & (1 << i)) != 0) {
 376              		.loc 1 100 0 is_stmt 0 discriminator 1
 377 029d 66837DFA 		cmpw	$15, -6(%rbp)
 377      0F
 378 02a2 76A8     		jbe	.L12
 379              	.LBE2:
 105:main.c        ****         }
 106:main.c        ****     }
 107:main.c        ****     return ret;
 380              		.loc 1 107 0 is_stmt 1
 381 02a4 0FB745F8 		movzwl	-8(%rbp), %eax
 108:main.c        **** }
 382              		.loc 1 108 0
 383 02a8 5D       		popq	%rbp
 384              		.cfi_def_cfa 7, 8
 385 02a9 C3       		ret
 386              		.cfi_endproc
 387              	.LFE10:
 389              		.section	.rodata
 390              	.LC0:
 391 0000 2C00     		.string	","
 392              	.LC1:
 393 0002 256400   		.string	"%d"
 394              		.text
 395              		.globl	format
 397              	format:
 398              	.LFB11:
 109:main.c        **** 
 110:main.c        **** void format(char *line) {
 399              		.loc 1 110 0
 400              		.cfi_startproc
 401 02aa 55       		pushq	%rbp
 402              		.cfi_def_cfa_offset 16
 403              		.cfi_offset 6, -16
 404 02ab 4889E5   		movq	%rsp, %rbp
 405              		.cfi_def_cfa_register 6
 406 02ae 4883EC20 		subq	$32, %rsp
 407 02b2 48897DE8 		movq	%rdi, -24(%rbp)
 111:main.c        ****     char *wordPtr;
 112:main.c        ****     wordPtr = strtok(line, ",");
 408              		.loc 1 112 0
 409 02b6 488B45E8 		movq	-24(%rbp), %rax
 410 02ba BE000000 		movl	$.LC0, %esi
 410      00
 411 02bf 4889C7   		movq	%rax, %rdi
 412 02c2 E8000000 		call	strtok
 412      00
 413 02c7 488945F8 		movq	%rax, -8(%rbp)
 113:main.c        ****     int cnt = 0;
 414              		.loc 1 113 0
 415 02cb C745F400 		movl	$0, -12(%rbp)
 415      000000
 114:main.c        ****     while (wordPtr != NULL) {
 416              		.loc 1 114 0
 417 02d2 EB4D     		jmp	.L15
 418              	.L16:
 115:main.c        ****         sscanf(wordPtr, "%d", &dataFromCSV[numLines][cnt]);
 419              		.loc 1 115 0
 420 02d4 8B150000 		movl	numLines(%rip), %edx
 420      0000
 421 02da 8B45F4   		movl	-12(%rbp), %eax
 422 02dd 4898     		cltq
 423 02df 4863D2   		movslq	%edx, %rdx
 424 02e2 48C1E202 		salq	$2, %rdx
 425 02e6 4801D0   		addq	%rdx, %rax
 426 02e9 48C1E002 		salq	$2, %rax
 427 02ed 488D9000 		leaq	dataFromCSV(%rax), %rdx
 427      000000
 428 02f4 488B45F8 		movq	-8(%rbp), %rax
 429 02f8 BE000000 		movl	$.LC1, %esi
 429      00
 430 02fd 4889C7   		movq	%rax, %rdi
 431 0300 B8000000 		movl	$0, %eax
 431      00
 432 0305 E8000000 		call	sscanf
 432      00
 116:main.c        ****         wordPtr = strtok(NULL, ",");
 433              		.loc 1 116 0
 434 030a BE000000 		movl	$.LC0, %esi
 434      00
 435 030f BF000000 		movl	$0, %edi
 435      00
 436 0314 E8000000 		call	strtok
 436      00
 437 0319 488945F8 		movq	%rax, -8(%rbp)
 117:main.c        ****         cnt++;
 438              		.loc 1 117 0
 439 031d 8345F401 		addl	$1, -12(%rbp)
 440              	.L15:
 114:main.c        ****         sscanf(wordPtr, "%d", &dataFromCSV[numLines][cnt]);
 441              		.loc 1 114 0 discriminator 1
 442 0321 48837DF8 		cmpq	$0, -8(%rbp)
 442      00
 443 0326 75AC     		jne	.L16
 118:main.c        ****     }
 119:main.c        **** }
 444              		.loc 1 119 0
 445 0328 C9       		leave
 446              		.cfi_def_cfa 7, 8
 447 0329 C3       		ret
 448              		.cfi_endproc
 449              	.LFE11:
 451              		.globl	find
 453              	find:
 454              	.LFB12:
 120:main.c        **** 
 121:main.c        **** bool find(uint16_t userID, uint16_t hashedPin, bool *isAdmin, int *bal, int *inLineNum) {
 455              		.loc 1 121 0
 456              		.cfi_startproc
 457 032a 55       		pushq	%rbp
 458              		.cfi_def_cfa_offset 16
 459              		.cfi_offset 6, -16
 460 032b 4889E5   		movq	%rsp, %rbp
 461              		.cfi_def_cfa_register 6
 462 032e 89F0     		movl	%esi, %eax
 463 0330 488955E0 		movq	%rdx, -32(%rbp)
 464 0334 48894DD8 		movq	%rcx, -40(%rbp)
 465 0338 4C8945D0 		movq	%r8, -48(%rbp)
 466 033c 66897DEC 		movw	%di, -20(%rbp)
 467 0340 668945E8 		movw	%ax, -24(%rbp)
 122:main.c        ****     bool pos = false;
 468              		.loc 1 122 0
 469 0344 C645FB00 		movb	$0, -5(%rbp)
 470              	.LBB4:
 123:main.c        ****     for (int i = 1; i <= numLines; i++) {
 471              		.loc 1 123 0
 472 0348 C745FC01 		movl	$1, -4(%rbp)
 472      000000
 473 034f EB75     		jmp	.L18
 474              	.L22:
 124:main.c        ****         if (userID == (uint16_t) dataFromCSV[i][0] && hashedPin == (uint16_t) dataFromCSV[i][1]) {
 475              		.loc 1 124 0
 476 0351 8B45FC   		movl	-4(%rbp), %eax
 477 0354 4898     		cltq
 478 0356 48C1E004 		salq	$4, %rax
 479 035a 48050000 		addq	$dataFromCSV, %rax
 479      0000
 480 0360 8B00     		movl	(%rax), %eax
 481 0362 663B45EC 		cmpw	-20(%rbp), %ax
 482 0366 755A     		jne	.L19
 483              		.loc 1 124 0 is_stmt 0 discriminator 1
 484 0368 8B45FC   		movl	-4(%rbp), %eax
 485 036b 4898     		cltq
 486 036d 48C1E004 		salq	$4, %rax
 487 0371 48050000 		addq	$dataFromCSV+4, %rax
 487      0000
 488 0377 8B00     		movl	(%rax), %eax
 489 0379 663B45E8 		cmpw	-24(%rbp), %ax
 490 037d 7543     		jne	.L19
 125:main.c        ****             pos = true;
 491              		.loc 1 125 0 is_stmt 1
 492 037f C645FB01 		movb	$1, -5(%rbp)
 126:main.c        ****             if (dataFromCSV[i][2] == 1) *isAdmin = true;
 493              		.loc 1 126 0
 494 0383 8B45FC   		movl	-4(%rbp), %eax
 495 0386 4898     		cltq
 496 0388 48C1E004 		salq	$4, %rax
 497 038c 48050000 		addq	$dataFromCSV+8, %rax
 497      0000
 498 0392 8B00     		movl	(%rax), %eax
 499 0394 83F801   		cmpl	$1, %eax
 500 0397 7507     		jne	.L20
 501              		.loc 1 126 0 is_stmt 0 discriminator 1
 502 0399 488B45E0 		movq	-32(%rbp), %rax
 503 039d C60001   		movb	$1, (%rax)
 504              	.L20:
 127:main.c        ****             *bal = dataFromCSV[i][3];
 505              		.loc 1 127 0 is_stmt 1
 506 03a0 8B45FC   		movl	-4(%rbp), %eax
 507 03a3 4898     		cltq
 508 03a5 48C1E004 		salq	$4, %rax
 509 03a9 48050000 		addq	$dataFromCSV+12, %rax
 509      0000
 510 03af 8B10     		movl	(%rax), %edx
 511 03b1 488B45D8 		movq	-40(%rbp), %rax
 512 03b5 8910     		movl	%edx, (%rax)
 128:main.c        ****             *inLineNum = i;
 513              		.loc 1 128 0
 514 03b7 488B45D0 		movq	-48(%rbp), %rax
 515 03bb 8B55FC   		movl	-4(%rbp), %edx
 516 03be 8910     		movl	%edx, (%rax)
 129:main.c        ****             break;
 517              		.loc 1 129 0
 518 03c0 EB0F     		jmp	.L21
 519              	.L19:
 123:main.c        ****         if (userID == (uint16_t) dataFromCSV[i][0] && hashedPin == (uint16_t) dataFromCSV[i][1]) {
 520              		.loc 1 123 0
 521 03c2 8345FC01 		addl	$1, -4(%rbp)
 522              	.L18:
 123:main.c        ****         if (userID == (uint16_t) dataFromCSV[i][0] && hashedPin == (uint16_t) dataFromCSV[i][1]) {
 523              		.loc 1 123 0 is_stmt 0 discriminator 1
 524 03c6 8B050000 		movl	numLines(%rip), %eax
 524      0000
 525 03cc 3945FC   		cmpl	%eax, -4(%rbp)
 526 03cf 7E80     		jle	.L22
 527              	.L21:
 528              	.LBE4:
 130:main.c        ****         }
 131:main.c        ****     }
 132:main.c        ****     return pos;
 529              		.loc 1 132 0 is_stmt 1
 530 03d1 0FB645FB 		movzbl	-5(%rbp), %eax
 133:main.c        **** }
 531              		.loc 1 133 0
 532 03d5 5D       		popq	%rbp
 533              		.cfi_def_cfa 7, 8
 534 03d6 C3       		ret
 535              		.cfi_endproc
 536              	.LFE12:
 538              		.globl	suffBalUser
 540              	suffBalUser:
 541              	.LFB13:
 134:main.c        **** 
 135:main.c        **** bool suffBalUser(int bal, int *reqAmo) {
 542              		.loc 1 135 0
 543              		.cfi_startproc
 544 03d7 55       		pushq	%rbp
 545              		.cfi_def_cfa_offset 16
 546              		.cfi_offset 6, -16
 547 03d8 4889E5   		movq	%rsp, %rbp
 548              		.cfi_def_cfa_register 6
 549 03db 897DEC   		movl	%edi, -20(%rbp)
 550 03de 488975E0 		movq	%rsi, -32(%rbp)
 136:main.c        ****     bool hasSuffBal = true;
 551              		.loc 1 136 0
 552 03e2 C645FF01 		movb	$1, -1(%rbp)
 137:main.c        ****     if (*reqAmo > bal) hasSuffBal = false;
 553              		.loc 1 137 0
 554 03e6 488B45E0 		movq	-32(%rbp), %rax
 555 03ea 8B00     		movl	(%rax), %eax
 556 03ec 3B45EC   		cmpl	-20(%rbp), %eax
 557 03ef 7E04     		jle	.L25
 558              		.loc 1 137 0 is_stmt 0 discriminator 1
 559 03f1 C645FF00 		movb	$0, -1(%rbp)
 560              	.L25:
 138:main.c        ****     return hasSuffBal;
 561              		.loc 1 138 0 is_stmt 1
 562 03f5 0FB645FF 		movzbl	-1(%rbp), %eax
 139:main.c        **** }
 563              		.loc 1 139 0
 564 03f9 5D       		popq	%rbp
 565              		.cfi_def_cfa 7, 8
 566 03fa C3       		ret
 567              		.cfi_endproc
 568              	.LFE13:
 570              		.section	.rodata
 571              	.LC2:
 572 0005 556E7061 		.string	"Unparseable hex number"
 572      72736561 
 572      626C6520 
 572      68657820 
 572      6E756D62 
 573              	.LC3:
 574 001c 4368616E 		.string	"Channel out of range"
 574      6E656C20 
 574      6F757420 
 574      6F662072 
 574      616E6765 
 575              	.LC4:
 576 0031 436F6E64 		.string	"Conduit out of range"
 576      75697420 
 576      6F757420 
 576      6F662072 
 576      616E6765 
 577              	.LC5:
 578 0046 496C6C65 		.string	"Illegal character"
 578      67616C20 
 578      63686172 
 578      61637465 
 578      7200
 579              	.LC6:
 580 0058 556E7465 		.string	"Unterminated string"
 580      726D696E 
 580      61746564 
 580      20737472 
 580      696E6700 
 581              	.LC7:
 582 006c 4E6F206D 		.string	"No memory"
 582      656D6F72 
 582      7900
 583              	.LC8:
 584 0076 456D7074 		.string	"Empty string"
 584      79207374 
 584      72696E67 
 584      00
 585              	.LC9:
 586 0083 4F646420 		.string	"Odd number of digits"
 586      6E756D62 
 586      6572206F 
 586      66206469 
 586      67697473 
 587              	.LC10:
 588 0098 43616E6E 		.string	"Cannot load file"
 588      6F74206C 
 588      6F616420 
 588      66696C65 
 588      00
 589              	.LC11:
 590 00a9 43616E6E 		.string	"Cannot save file"
 590      6F742073 
 590      61766520 
 590      66696C65 
 590      00
 591              	.LC12:
 592 00ba 42616420 		.string	"Bad arguments"
 592      61726775 
 592      6D656E74 
 592      7300
 593 00c8 00000000 		.align 32
 593      00000000 
 593      00000000 
 593      00000000 
 593      00000000 
 596              	errMessages:
 597 00e0 00000000 		.quad	0
 597      00000000 
 598 00e8 00000000 		.quad	0
 598      00000000 
 599 00f0 00000000 		.quad	.LC2
 599      00000000 
 600 00f8 00000000 		.quad	.LC3
 600      00000000 
 601 0100 00000000 		.quad	.LC4
 601      00000000 
 602 0108 00000000 		.quad	.LC5
 602      00000000 
 603 0110 00000000 		.quad	.LC6
 603      00000000 
 604 0118 00000000 		.quad	.LC7
 604      00000000 
 605 0120 00000000 		.quad	.LC8
 605      00000000 
 606 0128 00000000 		.quad	.LC9
 606      00000000 
 607 0130 00000000 		.quad	.LC10
 607      00000000 
 608 0138 00000000 		.quad	.LC11
 608      00000000 
 609 0140 00000000 		.quad	.LC12
 609      00000000 
 610              		.align 8
 611              	.LC13:
 612 0148 20202020 		.string	"            vendor ID and product ID (e.g 04B4:8613)"
 612      20202020 
 612      20202020 
 612      76656E64 
 612      6F722049 
 613              	.LC14:
 614 017d 3C564944 		.string	"<VID:PID>"
 614      3A504944 
 614      3E00
 615              	.LC15:
 616 0187 69767000 		.string	"ivp"
 617              	.LC16:
 618 018b 6900     		.string	"i"
 619 018d 000000   		.align 8
 620              	.LC17:
 621 0190 20202020 		.string	"       VID, PID and opt. dev ID (e.g 1D50:602B:0001)"
 621      20202056 
 621      49442C20 
 621      50494420 
 621      616E6420 
 622              	.LC18:
 623 01c5 3C564944 		.string	"<VID:PID[:DID]>"
 623      3A504944 
 623      5B3A4449 
 623      445D3E00 
 624              	.LC19:
 625 01d5 767000   		.string	"vp"
 626              	.LC20:
 627 01d8 7600     		.string	"v"
 628 01da 00000000 		.align 8
 628      0000
 629              	.LC21:
 630 01e0 20202020 		.string	"                    sets bank id"
 630      20202020 
 630      20202020 
 630      20202020 
 630      20202020 
 631              	.LC22:
 632 0201 62616E6B 		.string	"bank id in decimal"
 632      20696420 
 632      696E2064 
 632      6563696D 
 632      616C00
 633              	.LC23:
 634 0214 62696400 		.string	"bid"
 635              	.LC24:
 636 0218 6200     		.string	"b"
 637 021a 00000000 		.align 8
 637      0000
 638              	.LC25:
 639 0220 20202020 		.string	"                    starts atm service"
 639      20202020 
 639      20202020 
 639      20202020 
 639      20202020 
 640              	.LC26:
 641 0247 61746D00 		.string	"atm"
 642              	.LC27:
 643 024b 7900     		.string	"y"
 644 024d 000000   		.align 8
 645              	.LC28:
 646 0250 20202020 		.string	"        gives log on more events"
 646      20202020 
 646      67697665 
 646      73206C6F 
 646      67206F6E 
 647              	.LC29:
 648 0271 6C6F6700 		.string	"log"
 649              	.LC30:
 650 0275 6C00     		.string	"l"
 651 0277 00       		.align 8
 652              	.LC31:
 653 0278 20202020 		.string	"                     print this help and exit"
 653      20202020 
 653      20202020 
 653      20202020 
 653      20202020 
 654              	.LC32:
 655 02a6 68656C70 		.string	"help"
 655      00
 656              	.LC33:
 657 02ab 6800     		.string	"h"
 658              	.LC34:
 659 02ad 666C636C 		.string	"flcli"
 659      6900
 660              	.LC35:
 661 02b3 25733A20 		.string	"%s: insufficient memory\n"
 661      696E7375 
 661      66666963 
 661      69656E74 
 661      206D656D 
 662              	.LC36:
 663 02cc 496E7661 		.string	"Invalid bankID"
 663      6C696420 
 663      62616E6B 
 663      494400
 664 02db 00000000 		.align 8
 664      00
 665              	.LC37:
 666 02e0 46504741 		.string	"FPGALink Command-Line Interface Copyright (C) 2017 Jarvis \n\n Usage: %s"
 666      4C696E6B 
 666      20436F6D 
 666      6D616E64 
 666      2D4C696E 
 667              	.LC38:
 668 0327 0A00     		.string	"\n"
 669 0329 00000000 		.align 8
 669      000000
 670              	.LC39:
 671 0330 0A496E74 		.string	"\nInteract with an FPGALink device.\n"
 671      65726163 
 671      74207769 
 671      74682061 
 671      6E204650 
 672              	.LC40:
 673 0354 2020252D 		.string	"  %-10s %s\n"
 673      31307320 
 673      25730A00 
 674              		.align 8
 675              	.LC41:
 676 0360 54727920 		.string	"Try '%s --help' for more information.\n"
 676      27257320 
 676      2D2D6865 
 676      6C702720 
 676      666F7220 
 677 0387 00       		.align 8
 678              	.LC42:
 679 0388 41747465 		.string	"Attempting to open connection to FPGALink device %s...\n"
 679      6D707469 
 679      6E672074 
 679      6F206F70 
 679      656E2063 
 680              	.LC43:
 681 03c0 4C6F6164 		.string	"Loading firmware into %s...\n"
 681      696E6720 
 681      6669726D 
 681      77617265 
 681      20696E74 
 682              	.LC44:
 683 03dd 41776169 		.string	"Awaiting renumeration"
 683      74696E67 
 683      2072656E 
 683      756D6572 
 683      6174696F 
 684 03f3 00000000 		.align 8
 684      00
 685              	.LC45:
 686 03f8 46504741 		.string	"FPGALink device did not renumerate properly as %s\n"
 686      4C696E6B 
 686      20646576 
 686      69636520 
 686      64696420 
 687 042b 00000000 		.align 8
 687      00
 688              	.LC46:
 689 0430 41747465 		.string	"Attempting to open connection to FPGLink device %s again...\n"
 689      6D707469 
 689      6E672074 
 689      6F206F70 
 689      656E2063 
 690 046d 000000   		.align 8
 691              	.LC47:
 692 0470 436F756C 		.string	"Could not open FPGALink device at %s and no initial VID:PID was supplied\n"
 692      64206E6F 
 692      74206F70 
 692      656E2046 
 692      5047414C 
 693 04ba 00000000 		.align 8
 693      0000
 694              	.LC48:
 695 04c0 436F6E6E 		.string	"Connected to FPGALink device %s (firmwareID: 0x%04X, firmwareVersion: 0x%08X)\n"
 695      65637465 
 695      6420746F 
 695      20465047 
 695      414C696E 
 696              	.LC49:
 697 050f 722B00   		.string	"r+"
 698              	.LC50:
 699 0512 53616D70 		.string	"SampleBackEndDatabase.csv"
 699      6C654261 
 699      636B456E 
 699      64446174 
 699      61626173 
 700              	.LC51:
 701 052c 43737620 		.string	"Csv doesn't exist "
 701      646F6573 
 701      6E277420 
 701      65786973 
 701      742000
 702              	.LC52:
 703 053f 57726974 		.string	"Write to channel %u = %u \n"
 703      6520746F 
 703      20636861 
 703      6E6E656C 
 703      20257520 
 704              	.LC53:
 705 055a 52656164 		.string	"Read from channel 0 = %u \n"
 705      2066726F 
 705      6D206368 
 705      616E6E65 
 705      6C203020 
 706              	.LC54:
 707 0575 52656164 		.string	"Read from channel %u = %u \n"
 707      2066726F 
 707      6D206368 
 707      616E6E65 
 707      6C202575 
 708              	.LC55:
 709 0591 756E6861 		.string	"unhashedPin %u\n"
 709      73686564 
 709      50696E20 
 709      25750A00 
 710              	.LC56:
 711 05a1 75736572 		.string	"userID %u\n"
 711      49442025 
 711      750A00
 712              	.LC57:
 713 05ac 68617368 		.string	"hashedPin %u\n"
 713      65645069 
 713      6E202575 
 713      0A00
 714              	.LC58:
 715 05ba 56616C69 		.string	"Valid user found "
 715      64207573 
 715      65722066 
 715      6F756E64 
 715      2000
 716              	.LC59:
 717 05cc 53756666 		.string	"Sufficient Balance in account"
 717      69636965 
 717      6E742042 
 717      616C616E 
 717      63652069 
 718              	.LC60:
 719 05ea 772B00   		.string	"w+"
 720 05ed 000000   		.align 8
 721              	.LC61:
 722 05f0 22557365 		.string	"\"User ID (decimal)\",\"PIN Hash (decimal)\",\"Admin\",\"Balance (decimal)\""
 722      72204944 
 722      20286465 
 722      63696D61 
 722      6C29222C 
 723              	.LC62:
 724 0635 496E7375 		.string	"Insufficient Balance "
 724      66666963 
 724      69656E74 
 724      2042616C 
 724      616E6365 
 725              	.LC63:
 726 064b 55736572 		.string	"User has admin privileges "
 726      20686173 
 726      2061646D 
 726      696E2070 
 726      72697669 
 727              	.LC64:
 728 0666 496E7661 		.string	"Invalid user "
 728      6C696420 
 728      75736572 
 728      2000
 729 0674 00000000 		.align 8
 730              	.LC65:
 731 0678 54686520 		.string	"The FPGALink device at %s is not ready to talk - did you forget --program?\n"
 731      46504741 
 731      4C696E6B 
 731      20646576 
 731      69636520 
 732 06c4 00000000 		.align 8
 733              	.LC66:
 734 06c8 41637469 		.string	"Action requested but device at %s does not support CommFPGA\n"
 734      6F6E2072 
 734      65717565 
 734      73746564 
 734      20627574 
 735              	.LC67:
 736 0705 25730A00 		.string	"%s\n"
 737              		.text
 738              		.globl	main
 740              	main:
 741              	.LFB14:
 140:main.c        **** 
 141:main.c        **** static const char *const errMessages[] = {
 142:main.c        ****         NULL,
 143:main.c        ****         NULL,
 144:main.c        ****         "Unparseable hex number",
 145:main.c        ****         "Channel out of range",
 146:main.c        ****         "Conduit out of range",
 147:main.c        ****         "Illegal character",
 148:main.c        ****         "Unterminated string",
 149:main.c        ****         "No memory",
 150:main.c        ****         "Empty string",
 151:main.c        ****         "Odd number of digits",
 152:main.c        ****         "Cannot load file",
 153:main.c        ****         "Cannot save file",
 154:main.c        ****         "Bad arguments"
 155:main.c        **** };
 156:main.c        **** 
 157:main.c        **** typedef enum {
 158:main.c        ****     FLP_SUCCESS,
 159:main.c        ****     FLP_LIBERR,
 160:main.c        ****     FLP_BAD_HEX,
 161:main.c        ****     FLP_CHAN_RANGE,
 162:main.c        ****     FLP_CONDUIT_RANGE,
 163:main.c        ****     FLP_ILL_CHAR,
 164:main.c        ****     FLP_UNTERM_STRING,
 165:main.c        ****     FLP_NO_MEMORY,
 166:main.c        ****     FLP_EMPTY_STRING,
 167:main.c        ****     FLP_ODD_DIGITS,
 168:main.c        ****     FLP_CANNOT_LOAD,
 169:main.c        ****     FLP_CANNOT_SAVE,
 170:main.c        ****     FLP_ARGS
 171:main.c        **** } ReturnCode;
 172:main.c        **** 
 173:main.c        **** int main(int argc, char *argv[]) {
 742              		.loc 1 173 0
 743              		.cfi_startproc
 744 03fb 55       		pushq	%rbp
 745              		.cfi_def_cfa_offset 16
 746              		.cfi_offset 6, -16
 747 03fc 4889E5   		movq	%rsp, %rbp
 748              		.cfi_def_cfa_register 6
 749 03ff 53       		pushq	%rbx
 750 0400 4881EC98 		subq	$408, %rsp
 750      010000
 751              		.cfi_offset 3, -24
 752 0407 89BD6CFE 		movl	%edi, -404(%rbp)
 752      FFFF
 753 040d 4889B560 		movq	%rsi, -416(%rbp)
 753      FEFFFF
 174:main.c        ****     ReturnCode retVal = FLP_SUCCESS;
 754              		.loc 1 174 0
 755 0414 C785A8FE 		movl	$0, -344(%rbp)
 755      FFFF0000 
 755      0000
 175:main.c        **** 
 176:main.c        ****     struct arg_str *ivpOpt = arg_str0("i", "ivp", "<VID:PID>", "            vendor ID and product I
 756              		.loc 1 176 0
 757 041e B9000000 		movl	$.LC13, %ecx
 757      00
 758 0423 BA000000 		movl	$.LC14, %edx
 758      00
 759 0428 BE000000 		movl	$.LC15, %esi
 759      00
 760 042d BF000000 		movl	$.LC16, %edi
 760      00
 761 0432 E8000000 		call	arg_str0
 761      00
 762 0437 48898538 		movq	%rax, -200(%rbp)
 762      FFFFFF
 177:main.c        ****     struct arg_str *vpOpt = arg_str1("v", "vp", "<VID:PID[:DID]>", "       VID, PID and opt. dev ID
 763              		.loc 1 177 0
 764 043e B9000000 		movl	$.LC17, %ecx
 764      00
 765 0443 BA000000 		movl	$.LC18, %edx
 765      00
 766 0448 BE000000 		movl	$.LC19, %esi
 766      00
 767 044d BF000000 		movl	$.LC20, %edi
 767      00
 768 0452 E8000000 		call	arg_str1
 768      00
 769 0457 48898540 		movq	%rax, -192(%rbp)
 769      FFFFFF
 178:main.c        ****     struct arg_str *bankIdOpt = arg_str0("b", "bid", "bank id in decimal", "                    set
 770              		.loc 1 178 0
 771 045e B9000000 		movl	$.LC21, %ecx
 771      00
 772 0463 BA000000 		movl	$.LC22, %edx
 772      00
 773 0468 BE000000 		movl	$.LC23, %esi
 773      00
 774 046d BF000000 		movl	$.LC24, %edi
 774      00
 775 0472 E8000000 		call	arg_str0
 775      00
 776 0477 48898548 		movq	%rax, -184(%rbp)
 776      FFFFFF
 179:main.c        ****     struct arg_lit *loopOpt = arg_lit0("y", "atm", "                    starts atm service");
 777              		.loc 1 179 0
 778 047e BA000000 		movl	$.LC25, %edx
 778      00
 779 0483 BE000000 		movl	$.LC26, %esi
 779      00
 780 0488 BF000000 		movl	$.LC27, %edi
 780      00
 781 048d E8000000 		call	arg_lit0
 781      00
 782 0492 48898550 		movq	%rax, -176(%rbp)
 782      FFFFFF
 180:main.c        ****     struct arg_lit *verboseOpt = arg_lit0("l", "log", "        gives log on more events");
 783              		.loc 1 180 0
 784 0499 BA000000 		movl	$.LC28, %edx
 784      00
 785 049e BE000000 		movl	$.LC29, %esi
 785      00
 786 04a3 BF000000 		movl	$.LC30, %edi
 786      00
 787 04a8 E8000000 		call	arg_lit0
 787      00
 788 04ad 48898558 		movq	%rax, -168(%rbp)
 788      FFFFFF
 181:main.c        ****     struct arg_lit *helpOpt = arg_lit0("h", "help", "                     print this help and exit"
 789              		.loc 1 181 0
 790 04b4 BA000000 		movl	$.LC31, %edx
 790      00
 791 04b9 BE000000 		movl	$.LC32, %esi
 791      00
 792 04be BF000000 		movl	$.LC33, %edi
 792      00
 793 04c3 E8000000 		call	arg_lit0
 793      00
 794 04c8 48898560 		movq	%rax, -160(%rbp)
 794      FFFFFF
 182:main.c        ****     struct arg_end *endOpt = arg_end(20);
 795              		.loc 1 182 0
 796 04cf BF140000 		movl	$20, %edi
 796      00
 797 04d4 E8000000 		call	arg_end
 797      00
 798 04d9 48898568 		movq	%rax, -152(%rbp)
 798      FFFFFF
 183:main.c        **** 
 184:main.c        ****     void *argTable[] = {
 799              		.loc 1 184 0
 800 04e0 488B8538 		movq	-200(%rbp), %rax
 800      FFFFFF
 801 04e7 488945B0 		movq	%rax, -80(%rbp)
 802 04eb 488B8540 		movq	-192(%rbp), %rax
 802      FFFFFF
 803 04f2 488945B8 		movq	%rax, -72(%rbp)
 804 04f6 488B8548 		movq	-184(%rbp), %rax
 804      FFFFFF
 805 04fd 488945C0 		movq	%rax, -64(%rbp)
 806 0501 488B8550 		movq	-176(%rbp), %rax
 806      FFFFFF
 807 0508 488945C8 		movq	%rax, -56(%rbp)
 808 050c 488B8558 		movq	-168(%rbp), %rax
 808      FFFFFF
 809 0513 488945D0 		movq	%rax, -48(%rbp)
 810 0517 488B8560 		movq	-160(%rbp), %rax
 810      FFFFFF
 811 051e 488945D8 		movq	%rax, -40(%rbp)
 812 0522 488B8568 		movq	-152(%rbp), %rax
 812      FFFFFF
 813 0529 488945E0 		movq	%rax, -32(%rbp)
 185:main.c        ****             ivpOpt,
 186:main.c        ****             vpOpt,
 187:main.c        ****             bankIdOpt,
 188:main.c        ****             loopOpt,
 189:main.c        ****             verboseOpt,
 190:main.c        ****             helpOpt,
 191:main.c        ****             endOpt
 192:main.c        ****     };
 193:main.c        **** 
 194:main.c        ****     const char *progName = "flcli";
 814              		.loc 1 194 0
 815 052d 48C78570 		movq	$.LC34, -144(%rbp)
 815      FFFFFF00 
 815      000000
 195:main.c        ****     int numErrors;
 196:main.c        ****     struct FLContext *handle = NULL;
 816              		.loc 1 196 0
 817 0538 48C78518 		movq	$0, -232(%rbp)
 817      FFFFFF00 
 817      000000
 197:main.c        ****     FLStatus fStatus;
 198:main.c        ****     const char *error = NULL;
 818              		.loc 1 198 0
 819 0543 48C78520 		movq	$0, -224(%rbp)
 819      FFFFFF00 
 819      000000
 199:main.c        ****     const char *ivp = NULL;
 820              		.loc 1 199 0
 821 054e 48C78578 		movq	$0, -136(%rbp)
 821      FFFFFF00 
 821      000000
 200:main.c        ****     const char *vp = NULL;
 822              		.loc 1 200 0
 823 0559 48C74580 		movq	$0, -128(%rbp)
 823      00000000 
 201:main.c        ****     bool isCommCapable;
 202:main.c        ****     const char *line = NULL;
 824              		.loc 1 202 0
 825 0561 48C74588 		movq	$0, -120(%rbp)
 825      00000000 
 203:main.c        ****     uint8 conduit = 0x01;
 826              		.loc 1 203 0
 827 0569 C6858BFE 		movb	$1, -373(%rbp)
 827      FFFF01
 204:main.c        **** 
 205:main.c        ****     if (arg_nullcheck(argTable) != 0) {
 828              		.loc 1 205 0
 829 0570 488D45B0 		leaq	-80(%rbp), %rax
 830 0574 4889C7   		movq	%rax, %rdi
 831 0577 E8000000 		call	arg_nullcheck
 831      00
 832 057c 85C0     		testl	%eax, %eax
 833 057e 742F     		je	.L28
 206:main.c        ****         fprintf(stderr, "%s: insufficient memory\n", progName);
 834              		.loc 1 206 0
 835 0580 488B0500 		movq	stderr(%rip), %rax
 835      000000
 836 0587 488B9570 		movq	-144(%rbp), %rdx
 836      FFFFFF
 837 058e BE000000 		movl	$.LC35, %esi
 837      00
 838 0593 4889C7   		movq	%rax, %rdi
 839 0596 B8000000 		movl	$0, %eax
 839      00
 840 059b E8000000 		call	fprintf
 840      00
 207:main.c        ****         FAIL(1, cleanup);
 841              		.loc 1 207 0
 842 05a0 C785A8FE 		movl	$1, -344(%rbp)
 842      FFFF0100 
 842      0000
 843 05aa E9D21A00 		jmp	.L29
 843      00
 844              	.L28:
 208:main.c        ****     }
 209:main.c        **** 
 210:main.c        ****     numErrors = arg_parse(argc, argv, argTable);
 845              		.loc 1 210 0
 846 05af 488D55B0 		leaq	-80(%rbp), %rdx
 847 05b3 488B8D60 		movq	-416(%rbp), %rcx
 847      FEFFFF
 848 05ba 8B856CFE 		movl	-404(%rbp), %eax
 848      FFFF
 849 05c0 4889CE   		movq	%rcx, %rsi
 850 05c3 89C7     		movl	%eax, %edi
 851 05c5 E8000000 		call	arg_parse
 851      00
 852 05ca 8985DCFE 		movl	%eax, -292(%rbp)
 852      FFFF
 211:main.c        **** 
 212:main.c        ****     if (verboseOpt->count > 0) {
 853              		.loc 1 212 0
 854 05d0 488B8558 		movq	-168(%rbp), %rax
 854      FFFFFF
 855 05d7 8B4060   		movl	96(%rax), %eax
 856 05da 85C0     		testl	%eax, %eax
 857 05dc 7E07     		jle	.L30
 213:main.c        ****         LOG = true;
 858              		.loc 1 213 0
 859 05de C6050000 		movb	$1, LOG(%rip)
 859      000001
 860              	.L30:
 214:main.c        ****     }
 215:main.c        **** 
 216:main.c        ****     if (bankIdOpt->count > 0) {
 861              		.loc 1 216 0
 862 05e5 488B8548 		movq	-184(%rbp), %rax
 862      FFFFFF
 863 05ec 8B4060   		movl	96(%rax), %eax
 864 05ef 85C0     		testl	%eax, %eax
 865 05f1 7E45     		jle	.L31
 217:main.c        ****         bankID = atoi(bankIdOpt->sval[0]);
 866              		.loc 1 217 0
 867 05f3 488B8548 		movq	-184(%rbp), %rax
 867      FFFFFF
 868 05fa 488B4068 		movq	104(%rax), %rax
 869 05fe 488B00   		movq	(%rax), %rax
 870 0601 4889C7   		movq	%rax, %rdi
 871 0604 E8000000 		call	atoi
 871      00
 872 0609 89050000 		movl	%eax, bankID(%rip)
 872      0000
 218:main.c        ****         if(bankID < 0 || bankID > 31) {
 873              		.loc 1 218 0
 874 060f 8B050000 		movl	bankID(%rip), %eax
 874      0000
 875 0615 85C0     		testl	%eax, %eax
 876 0617 780B     		js	.L32
 877              		.loc 1 218 0 is_stmt 0 discriminator 1
 878 0619 8B050000 		movl	bankID(%rip), %eax
 878      0000
 879 061f 83F81F   		cmpl	$31, %eax
 880 0622 7E14     		jle	.L31
 881              	.L32:
 219:main.c        ****             printf("%s\n", "Invalid bankID");
 882              		.loc 1 219 0 is_stmt 1
 883 0624 BF000000 		movl	$.LC36, %edi
 883      00
 884 0629 E8000000 		call	puts
 884      00
 220:main.c        ****             return 0;
 885              		.loc 1 220 0
 886 062e B8000000 		movl	$0, %eax
 886      00
 887 0633 E9A51A00 		jmp	.L189
 887      00
 888              	.L31:
 221:main.c        ****         }
 222:main.c        ****     }
 223:main.c        **** 
 224:main.c        ****     if (helpOpt->count > 0) {
 889              		.loc 1 224 0
 890 0638 488B8560 		movq	-160(%rbp), %rax
 890      FFFFFF
 891 063f 8B4060   		movl	96(%rax), %eax
 892 0642 85C0     		testl	%eax, %eax
 893 0644 7E68     		jle	.L34
 225:main.c        ****         printf("FPGALink Command-Line Interface Copyright (C) 2017 Jarvis \n\n Usage: %s", progName
 894              		.loc 1 225 0
 895 0646 488B8570 		movq	-144(%rbp), %rax
 895      FFFFFF
 896 064d 4889C6   		movq	%rax, %rsi
 897 0650 BF000000 		movl	$.LC37, %edi
 897      00
 898 0655 B8000000 		movl	$0, %eax
 898      00
 899 065a E8000000 		call	printf
 899      00
 226:main.c        ****         arg_print_syntax(stdout, argTable, "\n");
 900              		.loc 1 226 0
 901 065f 488B0500 		movq	stdout(%rip), %rax
 901      000000
 902 0666 488D4DB0 		leaq	-80(%rbp), %rcx
 903 066a BA000000 		movl	$.LC38, %edx
 903      00
 904 066f 4889CE   		movq	%rcx, %rsi
 905 0672 4889C7   		movq	%rax, %rdi
 906 0675 E8000000 		call	arg_print_syntax
 906      00
 227:main.c        ****         printf("\nInteract with an FPGALink device.\n\n");
 907              		.loc 1 227 0
 908 067a BF000000 		movl	$.LC39, %edi
 908      00
 909 067f E8000000 		call	puts
 909      00
 228:main.c        ****         arg_print_glossary(stdout, argTable, "  %-10s %s\n");
 910              		.loc 1 228 0
 911 0684 488B0500 		movq	stdout(%rip), %rax
 911      000000
 912 068b 488D4DB0 		leaq	-80(%rbp), %rcx
 913 068f BA000000 		movl	$.LC40, %edx
 913      00
 914 0694 4889CE   		movq	%rcx, %rsi
 915 0697 4889C7   		movq	%rax, %rdi
 916 069a E8000000 		call	arg_print_glossary
 916      00
 229:main.c        ****         FAIL(FLP_SUCCESS, cleanup);
 917              		.loc 1 229 0
 918 069f C785A8FE 		movl	$0, -344(%rbp)
 918      FFFF0000 
 918      0000
 919 06a9 E9D31900 		jmp	.L29
 919      00
 920              	.L34:
 230:main.c        ****     }
 231:main.c        **** 
 232:main.c        ****     if (numErrors > 0) {
 921              		.loc 1 232 0
 922 06ae 83BDDCFE 		cmpl	$0, -292(%rbp)
 922      FFFF00
 923 06b5 7E4F     		jle	.L35
 233:main.c        ****         arg_print_errors(stdout, endOpt, progName);
 924              		.loc 1 233 0
 925 06b7 488B0500 		movq	stdout(%rip), %rax
 925      000000
 926 06be 488B9570 		movq	-144(%rbp), %rdx
 926      FFFFFF
 927 06c5 488B8D68 		movq	-152(%rbp), %rcx
 927      FFFFFF
 928 06cc 4889CE   		movq	%rcx, %rsi
 929 06cf 4889C7   		movq	%rax, %rdi
 930 06d2 E8000000 		call	arg_print_errors
 930      00
 234:main.c        ****         fprintf(stderr, "Try '%s --help' for more information.\n", progName);
 931              		.loc 1 234 0
 932 06d7 488B0500 		movq	stderr(%rip), %rax
 932      000000
 933 06de 488B9570 		movq	-144(%rbp), %rdx
 933      FFFFFF
 934 06e5 BE000000 		movl	$.LC41, %esi
 934      00
 935 06ea 4889C7   		movq	%rax, %rdi
 936 06ed B8000000 		movl	$0, %eax
 936      00
 937 06f2 E8000000 		call	fprintf
 937      00
 235:main.c        ****         FAIL(FLP_ARGS, cleanup);
 938              		.loc 1 235 0
 939 06f7 C785A8FE 		movl	$12, -344(%rbp)
 939      FFFF0C00 
 939      0000
 940 0701 E97B1900 		jmp	.L29
 940      00
 941              	.L35:
 236:main.c        ****     }
 237:main.c        **** 
 238:main.c        ****     fStatus = flInitialise(0, &error);
 942              		.loc 1 238 0
 943 0706 488D8520 		leaq	-224(%rbp), %rax
 943      FFFFFF
 944 070d 4889C6   		movq	%rax, %rsi
 945 0710 BF000000 		movl	$0, %edi
 945      00
 946 0715 E8000000 		call	flInitialise
 946      00
 947 071a 8985E0FE 		movl	%eax, -288(%rbp)
 947      FFFF
 239:main.c        ****     CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 948              		.loc 1 239 0
 949 0720 83BDE0FE 		cmpl	$0, -288(%rbp)
 949      FFFF00
 950 0727 740F     		je	.L36
 951              		.loc 1 239 0 is_stmt 0 discriminator 1
 952 0729 C785A8FE 		movl	$1, -344(%rbp)
 952      FFFF0100 
 952      0000
 953 0733 E9491900 		jmp	.L29
 953      00
 954              	.L36:
 240:main.c        **** 
 241:main.c        ****     vp = vpOpt->sval[0];
 955              		.loc 1 241 0 is_stmt 1
 956 0738 488B8540 		movq	-192(%rbp), %rax
 956      FFFFFF
 957 073f 488B4068 		movq	104(%rax), %rax
 958 0743 488B00   		movq	(%rax), %rax
 959 0746 48894580 		movq	%rax, -128(%rbp)
 242:main.c        **** 
 243:main.c        ****     printf("Attempting to open connection to FPGALink device %s...\n", vp);
 960              		.loc 1 243 0
 961 074a 488B4580 		movq	-128(%rbp), %rax
 962 074e 4889C6   		movq	%rax, %rsi
 963 0751 BF000000 		movl	$.LC42, %edi
 963      00
 964 0756 B8000000 		movl	$0, %eax
 964      00
 965 075b E8000000 		call	printf
 965      00
 244:main.c        ****     fStatus = flOpen(vp, &handle, NULL);
 966              		.loc 1 244 0
 967 0760 488D8D18 		leaq	-232(%rbp), %rcx
 967      FFFFFF
 968 0767 488B4580 		movq	-128(%rbp), %rax
 969 076b BA000000 		movl	$0, %edx
 969      00
 970 0770 4889CE   		movq	%rcx, %rsi
 971 0773 4889C7   		movq	%rax, %rdi
 972 0776 E8000000 		call	flOpen
 972      00
 973 077b 8985E0FE 		movl	%eax, -288(%rbp)
 973      FFFF
 245:main.c        ****     if (fStatus) {
 974              		.loc 1 245 0
 975 0781 83BDE0FE 		cmpl	$0, -288(%rbp)
 975      FFFF00
 976 0788 0F84D801 		je	.L37
 976      0000
 246:main.c        ****         if (ivpOpt->count) {
 977              		.loc 1 246 0
 978 078e 488B8538 		movq	-200(%rbp), %rax
 978      FFFFFF
 979 0795 8B4060   		movl	96(%rax), %eax
 980 0798 85C0     		testl	%eax, %eax
 981 079a 0F849A01 		je	.L38
 981      0000
 982              	.LBB5:
 247:main.c        ****             int count = 60;
 983              		.loc 1 247 0
 984 07a0 C785ACFE 		movl	$60, -340(%rbp)
 984      FFFF3C00 
 984      0000
 248:main.c        ****             uint8 flag;
 249:main.c        ****             ivp = ivpOpt->sval[0];
 985              		.loc 1 249 0
 986 07aa 488B8538 		movq	-200(%rbp), %rax
 986      FFFFFF
 987 07b1 488B4068 		movq	104(%rax), %rax
 988 07b5 488B00   		movq	(%rax), %rax
 989 07b8 48898578 		movq	%rax, -136(%rbp)
 989      FFFFFF
 250:main.c        ****             printf("Loading firmware into %s...\n", ivp);
 990              		.loc 1 250 0
 991 07bf 488B8578 		movq	-136(%rbp), %rax
 991      FFFFFF
 992 07c6 4889C6   		movq	%rax, %rsi
 993 07c9 BF000000 		movl	$.LC43, %edi
 993      00
 994 07ce B8000000 		movl	$0, %eax
 994      00
 995 07d3 E8000000 		call	printf
 995      00
 251:main.c        ****             fStatus = flLoadStandardFirmware(ivp, vp, &error);
 996              		.loc 1 251 0
 997 07d8 488D9520 		leaq	-224(%rbp), %rdx
 997      FFFFFF
 998 07df 488B4D80 		movq	-128(%rbp), %rcx
 999 07e3 488B8578 		movq	-136(%rbp), %rax
 999      FFFFFF
 1000 07ea 4889CE   		movq	%rcx, %rsi
 1001 07ed 4889C7   		movq	%rax, %rdi
 1002 07f0 E8000000 		call	flLoadStandardFirmware
 1002      00
 1003 07f5 8985E0FE 		movl	%eax, -288(%rbp)
 1003      FFFF
 252:main.c        ****             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1004              		.loc 1 252 0
 1005 07fb 83BDE0FE 		cmpl	$0, -288(%rbp)
 1005      FFFF00
 1006 0802 740F     		je	.L39
 1007              		.loc 1 252 0 is_stmt 0 discriminator 1
 1008 0804 C785A8FE 		movl	$1, -344(%rbp)
 1008      FFFF0100 
 1008      0000
 1009 080e E96E1800 		jmp	.L29
 1009      00
 1010              	.L39:
 253:main.c        **** 
 254:main.c        ****             printf("Awaiting renumeration");
 1011              		.loc 1 254 0 is_stmt 1
 1012 0813 BF000000 		movl	$.LC44, %edi
 1012      00
 1013 0818 B8000000 		movl	$0, %eax
 1013      00
 1014 081d E8000000 		call	printf
 1014      00
 255:main.c        ****             flSleep(1000);
 1015              		.loc 1 255 0
 1016 0822 BFE80300 		movl	$1000, %edi
 1016      00
 1017 0827 E8000000 		call	flSleep
 1017      00
 1018              	.L43:
 256:main.c        ****             do {
 257:main.c        ****                 printf(".");
 1019              		.loc 1 257 0
 1020 082c BF2E0000 		movl	$46, %edi
 1020      00
 1021 0831 E8000000 		call	putchar
 1021      00
 258:main.c        ****                 fflush(stdout);
 1022              		.loc 1 258 0
 1023 0836 488B0500 		movq	stdout(%rip), %rax
 1023      000000
 1024 083d 4889C7   		movq	%rax, %rdi
 1025 0840 E8000000 		call	fflush
 1025      00
 259:main.c        ****                 fStatus = flIsDeviceAvailable(vp, &flag, &error);
 1026              		.loc 1 259 0
 1027 0845 488D9520 		leaq	-224(%rbp), %rdx
 1027      FFFFFF
 1028 084c 488D8D30 		leaq	-208(%rbp), %rcx
 1028      FFFFFF
 1029 0853 488B4580 		movq	-128(%rbp), %rax
 1030 0857 4889CE   		movq	%rcx, %rsi
 1031 085a 4889C7   		movq	%rax, %rdi
 1032 085d E8000000 		call	flIsDeviceAvailable
 1032      00
 1033 0862 8985E0FE 		movl	%eax, -288(%rbp)
 1033      FFFF
 260:main.c        ****                 CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1034              		.loc 1 260 0
 1035 0868 83BDE0FE 		cmpl	$0, -288(%rbp)
 1035      FFFF00
 1036 086f 740F     		je	.L41
 1037              		.loc 1 260 0 is_stmt 0 discriminator 1
 1038 0871 C785A8FE 		movl	$1, -344(%rbp)
 1038      FFFF0100 
 1038      0000
 1039 087b E9011800 		jmp	.L29
 1039      00
 1040              	.L41:
 261:main.c        ****                 flSleep(250);
 1041              		.loc 1 261 0 is_stmt 1
 1042 0880 BFFA0000 		movl	$250, %edi
 1042      00
 1043 0885 E8000000 		call	flSleep
 1043      00
 262:main.c        ****                 count--;
 1044              		.loc 1 262 0
 1045 088a 83ADACFE 		subl	$1, -340(%rbp)
 1045      FFFF01
 263:main.c        ****             } while (!flag && count);
 1046              		.loc 1 263 0
 1047 0891 0FB68530 		movzbl	-208(%rbp), %eax
 1047      FFFFFF
 1048 0898 84C0     		testb	%al, %al
 1049 089a 7509     		jne	.L42
 1050              		.loc 1 263 0 is_stmt 0 discriminator 1
 1051 089c 83BDACFE 		cmpl	$0, -340(%rbp)
 1051      FFFF00
 1052 08a3 7587     		jne	.L43
 1053              	.L42:
 264:main.c        ****             printf("\n");
 1054              		.loc 1 264 0 is_stmt 1
 1055 08a5 BF0A0000 		movl	$10, %edi
 1055      00
 1056 08aa E8000000 		call	putchar
 1056      00
 265:main.c        ****             if (!flag) {
 1057              		.loc 1 265 0
 1058 08af 0FB68530 		movzbl	-208(%rbp), %eax
 1058      FFFFFF
 1059 08b6 84C0     		testb	%al, %al
 1060 08b8 752C     		jne	.L44
 266:main.c        ****                 fprintf(stderr, "FPGALink device did not renumerate properly as %s\n", vp);
 1061              		.loc 1 266 0
 1062 08ba 488B0500 		movq	stderr(%rip), %rax
 1062      000000
 1063 08c1 488B5580 		movq	-128(%rbp), %rdx
 1064 08c5 BE000000 		movl	$.LC45, %esi
 1064      00
 1065 08ca 4889C7   		movq	%rax, %rdi
 1066 08cd B8000000 		movl	$0, %eax
 1066      00
 1067 08d2 E8000000 		call	fprintf
 1067      00
 267:main.c        ****                 FAIL(FLP_LIBERR, cleanup);
 1068              		.loc 1 267 0
 1069 08d7 C785A8FE 		movl	$1, -344(%rbp)
 1069      FFFF0100 
 1069      0000
 1070 08e1 E99B1700 		jmp	.L29
 1070      00
 1071              	.L44:
 268:main.c        ****             }
 269:main.c        **** 
 270:main.c        ****             printf("Attempting to open connection to FPGLink device %s again...\n", vp);
 1072              		.loc 1 270 0
 1073 08e6 488B4580 		movq	-128(%rbp), %rax
 1074 08ea 4889C6   		movq	%rax, %rsi
 1075 08ed BF000000 		movl	$.LC46, %edi
 1075      00
 1076 08f2 B8000000 		movl	$0, %eax
 1076      00
 1077 08f7 E8000000 		call	printf
 1077      00
 271:main.c        ****             fStatus = flOpen(vp, &handle, &error);
 1078              		.loc 1 271 0
 1079 08fc 488D9520 		leaq	-224(%rbp), %rdx
 1079      FFFFFF
 1080 0903 488D8D18 		leaq	-232(%rbp), %rcx
 1080      FFFFFF
 1081 090a 488B4580 		movq	-128(%rbp), %rax
 1082 090e 4889CE   		movq	%rcx, %rsi
 1083 0911 4889C7   		movq	%rax, %rdi
 1084 0914 E8000000 		call	flOpen
 1084      00
 1085 0919 8985E0FE 		movl	%eax, -288(%rbp)
 1085      FFFF
 272:main.c        ****             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1086              		.loc 1 272 0
 1087 091f 83BDE0FE 		cmpl	$0, -288(%rbp)
 1087      FFFF00
 1088 0926 7410     		je	.L45
 1089              		.loc 1 272 0 is_stmt 0 discriminator 1
 1090 0928 C785A8FE 		movl	$1, -344(%rbp)
 1090      FFFF0100 
 1090      0000
 1091 0932 90       		nop
 1092 0933 E9491700 		jmp	.L29
 1092      00
 1093              	.L45:
 1094              	.LBE5:
 1095 0938 EB2C     		jmp	.L37
 1096              	.L38:
 273:main.c        ****         } else {
 274:main.c        ****             fprintf(stderr, "Could not open FPGALink device at %s and no initial VID:PID was suppli
 1097              		.loc 1 274 0 is_stmt 1
 1098 093a 488B0500 		movq	stderr(%rip), %rax
 1098      000000
 1099 0941 488B5580 		movq	-128(%rbp), %rdx
 1100 0945 BE000000 		movl	$.LC47, %esi
 1100      00
 1101 094a 4889C7   		movq	%rax, %rdi
 1102 094d B8000000 		movl	$0, %eax
 1102      00
 1103 0952 E8000000 		call	fprintf
 1103      00
 275:main.c        ****             FAIL(FLP_ARGS, cleanup);
 1104              		.loc 1 275 0
 1105 0957 C785A8FE 		movl	$12, -344(%rbp)
 1105      FFFF0C00 
 1105      0000
 1106 0961 E91B1700 		jmp	.L29
 1106      00
 1107              	.L37:
 276:main.c        ****         }
 277:main.c        ****     }
 278:main.c        **** 
 279:main.c        ****     printf(
 1108              		.loc 1 279 0
 1109 0966 488B8518 		movq	-232(%rbp), %rax
 1109      FFFFFF
 1110 096d 4889C7   		movq	%rax, %rdi
 1111 0970 E8000000 		call	flGetFirmwareVersion
 1111      00
 1112 0975 89C3     		movl	%eax, %ebx
 280:main.c        ****             "Connected to FPGALink device %s (firmwareID: 0x%04X, firmwareVersion: 0x%08X)\n",
 281:main.c        ****             vp, flGetFirmwareID(handle), flGetFirmwareVersion(handle)
 1113              		.loc 1 281 0
 1114 0977 488B8518 		movq	-232(%rbp), %rax
 1114      FFFFFF
 1115 097e 4889C7   		movq	%rax, %rdi
 1116 0981 E8000000 		call	flGetFirmwareID
 1116      00
 279:main.c        ****             "Connected to FPGALink device %s (firmwareID: 0x%04X, firmwareVersion: 0x%08X)\n",
 1117              		.loc 1 279 0
 1118 0986 0FB7D0   		movzwl	%ax, %edx
 1119 0989 488B4580 		movq	-128(%rbp), %rax
 1120 098d 89D9     		movl	%ebx, %ecx
 1121 098f 4889C6   		movq	%rax, %rsi
 1122 0992 BF000000 		movl	$.LC48, %edi
 1122      00
 1123 0997 B8000000 		movl	$0, %eax
 1123      00
 1124 099c E8000000 		call	printf
 1124      00
 282:main.c        ****     );
 283:main.c        **** 
 284:main.c        ****     isCommCapable = flIsCommCapable(handle, conduit);
 1125              		.loc 1 284 0
 1126 09a1 0FB6958B 		movzbl	-373(%rbp), %edx
 1126      FEFFFF
 1127 09a8 488B8518 		movq	-232(%rbp), %rax
 1127      FFFFFF
 1128 09af 89D6     		movl	%edx, %esi
 1129 09b1 4889C7   		movq	%rax, %rdi
 1130 09b4 E8000000 		call	flIsCommCapable
 1130      00
 1131 09b9 84C0     		testb	%al, %al
 1132 09bb 0F95C0   		setne	%al
 1133 09be 88858CFE 		movb	%al, -372(%rbp)
 1133      FFFF
 285:main.c        **** 
 286:main.c        ****     // -y reads in from csv and initiates the while loop
 287:main.c        ****     if (loopOpt->count > 0) {
 1134              		.loc 1 287 0
 1135 09c4 488B8550 		movq	-176(%rbp), %rax
 1135      FFFFFF
 1136 09cb 8B4060   		movl	96(%rax), %eax
 1137 09ce 85C0     		testl	%eax, %eax
 1138 09d0 0F8EAB16 		jle	.L29
 1138      0000
 288:main.c        ****         if (isCommCapable) {
 1139              		.loc 1 288 0
 1140 09d6 80BD8CFE 		cmpb	$0, -372(%rbp)
 1140      FFFF00
 1141 09dd 0F847616 		je	.L46
 1141      0000
 1142              	.LBB6:
 289:main.c        ****             uint8 isRunning;
 290:main.c        ****             fStatus = flSelectConduit(handle, conduit, &error);
 1143              		.loc 1 290 0
 1144 09e3 0FB68D8B 		movzbl	-373(%rbp), %ecx
 1144      FEFFFF
 1145 09ea 488B8518 		movq	-232(%rbp), %rax
 1145      FFFFFF
 1146 09f1 488D9520 		leaq	-224(%rbp), %rdx
 1146      FFFFFF
 1147 09f8 89CE     		movl	%ecx, %esi
 1148 09fa 4889C7   		movq	%rax, %rdi
 1149 09fd E8000000 		call	flSelectConduit
 1149      00
 1150 0a02 8985E0FE 		movl	%eax, -288(%rbp)
 1150      FFFF
 291:main.c        ****             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1151              		.loc 1 291 0
 1152 0a08 83BDE0FE 		cmpl	$0, -288(%rbp)
 1152      FFFF00
 1153 0a0f 740F     		je	.L47
 1154              		.loc 1 291 0 is_stmt 0 discriminator 1
 1155 0a11 C785A8FE 		movl	$1, -344(%rbp)
 1155      FFFF0100 
 1155      0000
 1156 0a1b E9611600 		jmp	.L29
 1156      00
 1157              	.L47:
 292:main.c        ****             fStatus = flIsFPGARunning(handle, &isRunning, &error);
 1158              		.loc 1 292 0 is_stmt 1
 1159 0a20 488B8518 		movq	-232(%rbp), %rax
 1159      FFFFFF
 1160 0a27 488D9520 		leaq	-224(%rbp), %rdx
 1160      FFFFFF
 1161 0a2e 488D8D75 		leaq	-395(%rbp), %rcx
 1161      FEFFFF
 1162 0a35 4889CE   		movq	%rcx, %rsi
 1163 0a38 4889C7   		movq	%rax, %rdi
 1164 0a3b E8000000 		call	flIsFPGARunning
 1164      00
 1165 0a40 8985E0FE 		movl	%eax, -288(%rbp)
 1165      FFFF
 293:main.c        ****             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1166              		.loc 1 293 0
 1167 0a46 83BDE0FE 		cmpl	$0, -288(%rbp)
 1167      FFFF00
 1168 0a4d 740F     		je	.L49
 1169              		.loc 1 293 0 is_stmt 0 discriminator 1
 1170 0a4f C785A8FE 		movl	$1, -344(%rbp)
 1170      FFFF0100 
 1170      0000
 1171 0a59 E9231600 		jmp	.L29
 1171      00
 1172              	.L49:
 294:main.c        ****             if (isRunning) {
 1173              		.loc 1 294 0 is_stmt 1
 1174 0a5e 0FB68575 		movzbl	-395(%rbp), %eax
 1174      FEFFFF
 1175 0a65 84C0     		testb	%al, %al
 1176 0a67 0F84C215 		je	.L50
 1176      0000
 1177              	.LBB7:
 295:main.c        **** 
 296:main.c        ****                 FILE *fPtr;
 297:main.c        ****                 fPtr = fopen("SampleBackEndDatabase.csv", "r+"); // change flag according to need
 1178              		.loc 1 297 0
 1179 0a6d BE000000 		movl	$.LC49, %esi
 1179      00
 1180 0a72 BF000000 		movl	$.LC50, %edi
 1180      00
 1181 0a77 E8000000 		call	fopen
 1181      00
 1182 0a7c 48894590 		movq	%rax, -112(%rbp)
 298:main.c        ****                 if (fPtr == NULL) {
 1183              		.loc 1 298 0
 1184 0a80 48837D90 		cmpq	$0, -112(%rbp)
 1184      00
 1185 0a85 7514     		jne	.L51
 299:main.c        ****                     printf("Csv doesn't exist \n");
 1186              		.loc 1 299 0
 1187 0a87 BF000000 		movl	$.LC51, %edi
 1187      00
 1188 0a8c E8000000 		call	puts
 1188      00
 300:main.c        ****                     return 0;
 1189              		.loc 1 300 0
 1190 0a91 B8000000 		movl	$0, %eax
 1190      00
 1191 0a96 E9421600 		jmp	.L189
 1191      00
 1192              	.L51:
 301:main.c        ****                 }
 302:main.c        ****                 size_t lineSize = 100;
 1193              		.loc 1 302 0
 1194 0a9b 48C78528 		movq	$100, -216(%rbp)
 1194      FFFFFF64 
 1194      000000
 303:main.c        ****                 char *lineFromFile = malloc(lineSize * sizeof(char));
 1195              		.loc 1 303 0
 1196 0aa6 488B8528 		movq	-216(%rbp), %rax
 1196      FFFFFF
 1197 0aad 4889C7   		movq	%rax, %rdi
 1198 0ab0 E8000000 		call	malloc
 1198      00
 1199 0ab5 48898530 		movq	%rax, -208(%rbp)
 1199      FFFFFF
 304:main.c        **** 
 305:main.c        ****                 while ((getline(&lineFromFile, &lineSize, fPtr)) != -1) {
 1200              		.loc 1 305 0
 1201 0abc EB28     		jmp	.L53
 1202              	.L55:
 306:main.c        ****                     if (numLines != 0) format(lineFromFile);
 1203              		.loc 1 306 0
 1204 0abe 8B050000 		movl	numLines(%rip), %eax
 1204      0000
 1205 0ac4 85C0     		testl	%eax, %eax
 1206 0ac6 740F     		je	.L54
 1207              		.loc 1 306 0 is_stmt 0 discriminator 1
 1208 0ac8 488B8530 		movq	-208(%rbp), %rax
 1208      FFFFFF
 1209 0acf 4889C7   		movq	%rax, %rdi
 1210 0ad2 E8000000 		call	format
 1210      00
 1211              	.L54:
 307:main.c        ****                     numLines++;
 1212              		.loc 1 307 0 is_stmt 1
 1213 0ad7 8B050000 		movl	numLines(%rip), %eax
 1213      0000
 1214 0add 83C001   		addl	$1, %eax
 1215 0ae0 89050000 		movl	%eax, numLines(%rip)
 1215      0000
 1216              	.L53:
 305:main.c        ****                     if (numLines != 0) format(lineFromFile);
 1217              		.loc 1 305 0 discriminator 1
 1218 0ae6 488B5590 		movq	-112(%rbp), %rdx
 1219 0aea 488D8D28 		leaq	-216(%rbp), %rcx
 1219      FFFFFF
 1220 0af1 488D8530 		leaq	-208(%rbp), %rax
 1220      FFFFFF
 1221 0af8 4889CE   		movq	%rcx, %rsi
 1222 0afb 4889C7   		movq	%rax, %rdi
 1223 0afe E8000000 		call	getline
 1223      00
 1224 0b03 4883F8FF 		cmpq	$-1, %rax
 1225 0b07 75B5     		jne	.L55
 308:main.c        ****                 }
 309:main.c        ****                 numLines--;
 1226              		.loc 1 309 0
 1227 0b09 8B050000 		movl	numLines(%rip), %eax
 1227      0000
 1228 0b0f 83E801   		subl	$1, %eax
 1229 0b12 89050000 		movl	%eax, numLines(%rip)
 1229      0000
 310:main.c        ****                 free(lineFromFile);
 1230              		.loc 1 310 0
 1231 0b18 488B8530 		movq	-208(%rbp), %rax
 1231      FFFFFF
 1232 0b1f 4889C7   		movq	%rax, %rdi
 1233 0b22 E8000000 		call	free
 1233      00
 311:main.c        ****                 fclose(fPtr);
 1234              		.loc 1 311 0
 1235 0b27 488B4590 		movq	-112(%rbp), %rax
 1236 0b2b 4889C7   		movq	%rax, %rdi
 1237 0b2e E8000000 		call	fclose
 1237      00
 312:main.c        **** 
 313:main.c        ****                 // Bank id error handling
 314:main.c        ****                 if(bankID < 0 || bankID > 31) {
 1238              		.loc 1 314 0
 1239 0b33 8B050000 		movl	bankID(%rip), %eax
 1239      0000
 1240 0b39 85C0     		testl	%eax, %eax
 1241 0b3b 780B     		js	.L56
 1242              		.loc 1 314 0 is_stmt 0 discriminator 1
 1243 0b3d 8B050000 		movl	bankID(%rip), %eax
 1243      0000
 1244 0b43 83F81F   		cmpl	$31, %eax
 1245 0b46 7E14     		jle	.L57
 1246              	.L56:
 315:main.c        ****                     printf("%s\n", "Invalid bankID");
 1247              		.loc 1 315 0 is_stmt 1
 1248 0b48 BF000000 		movl	$.LC36, %edi
 1248      00
 1249 0b4d E8000000 		call	puts
 1249      00
 316:main.c        ****                     return 0;
 1250              		.loc 1 316 0
 1251 0b52 B8000000 		movl	$0, %eax
 1251      00
 1252 0b57 E9811500 		jmp	.L189
 1252      00
 1253              	.L57:
 317:main.c        ****                 }
 318:main.c        ****                 
 319:main.c        ****                 /*
 320:main.c        ****                     Format for initialisation of Max Amount which can be withdrawn in a transaction
 321:main.c        ****                     cap on number of notes to be dispensed
 322:main.c        **** 
 323:main.c        ****                     MAX Amount in a transaction (32 bit) | 2k cap (8 bit) | 1k cap (8 bit) | 500 ca
 324:main.c        ****                     (Before encryption)
 325:main.c        ****                 */
 326:main.c        ****                 uint32_t length = 1;
 1254              		.loc 1 326 0
 1255 0b5c C785E4FE 		movl	$1, -284(%rbp)
 1255      FFFF0100 
 1255      0000
 1256              	.LBB8:
 327:main.c        ****                 uint32_t befEncSenInit[2];
 328:main.c        ****                 for (int i = 0; i < 2; i++) befEncSenInit[i] = 0;
 1257              		.loc 1 328 0
 1258 0b66 C785B0FE 		movl	$0, -336(%rbp)
 1258      FFFF0000 
 1258      0000
 1259 0b70 EB1A     		jmp	.L58
 1260              	.L59:
 1261              		.loc 1 328 0 is_stmt 0 discriminator 2
 1262 0b72 8B85B0FE 		movl	-336(%rbp), %eax
 1262      FFFF
 1263 0b78 4898     		cltq
 1264 0b7a C78485F0 		movl	$0, -272(%rbp,%rax,4)
 1264      FEFFFF00 
 1264      000000
 1265 0b85 8385B0FE 		addl	$1, -336(%rbp)
 1265      FFFF01
 1266              	.L58:
 1267              		.loc 1 328 0 discriminator 1
 1268 0b8c 83BDB0FE 		cmpl	$1, -336(%rbp)
 1268      FFFF01
 1269 0b93 7EDD     		jle	.L59
 1270              	.LBE8:
 329:main.c        ****                 befEncSenInit[1] = maxAmountCanBeDispensed;
 1271              		.loc 1 329 0 is_stmt 1
 1272 0b95 8B050000 		movl	maxAmountCanBeDispensed(%rip), %eax
 1272      0000
 1273 0b9b 8985F4FE 		movl	%eax, -268(%rbp)
 1273      FFFF
 1274              	.LBB9:
 330:main.c        ****                 for (uint32_t i = 0; i <= 31; i += 8) {
 1275              		.loc 1 330 0
 1276 0ba1 C785B4FE 		movl	$0, -332(%rbp)
 1276      FFFF0000 
 1276      0000
 1277 0bab E9BB0000 		jmp	.L60
 1277      00
 1278              	.L65:
 331:main.c        ****                     if (i == 0) befEncSenInit[0] += ((1 << i) * ((uint32_t) max100Limit));
 1279              		.loc 1 331 0
 1280 0bb0 83BDB4FE 		cmpl	$0, -332(%rbp)
 1280      FFFF00
 1281 0bb7 7529     		jne	.L61
 1282              		.loc 1 331 0 is_stmt 0 discriminator 1
 1283 0bb9 8B95F0FE 		movl	-272(%rbp), %edx
 1283      FFFF
 1284 0bbf 0FB60500 		movzbl	max100Limit(%rip), %eax
 1284      000000
 1285 0bc6 0FB6F0   		movzbl	%al, %esi
 1286 0bc9 8B85B4FE 		movl	-332(%rbp), %eax
 1286      FFFF
 1287 0bcf 89C1     		movl	%eax, %ecx
 1288 0bd1 D3E6     		sall	%cl, %esi
 1289 0bd3 89F0     		movl	%esi, %eax
 1290 0bd5 01D0     		addl	%edx, %eax
 1291 0bd7 8985F0FE 		movl	%eax, -272(%rbp)
 1291      FFFF
 1292 0bdd E9820000 		jmp	.L62
 1292      00
 1293              	.L61:
 332:main.c        ****                     else if (i == 8) befEncSenInit[0] += ((1 << i) * ((uint32_t) max500Limit));
 1294              		.loc 1 332 0 is_stmt 1
 1295 0be2 83BDB4FE 		cmpl	$8, -332(%rbp)
 1295      FFFF08
 1296 0be9 7526     		jne	.L63
 1297              		.loc 1 332 0 is_stmt 0 discriminator 1
 1298 0beb 8B95F0FE 		movl	-272(%rbp), %edx
 1298      FFFF
 1299 0bf1 0FB60500 		movzbl	max500Limit(%rip), %eax
 1299      000000
 1300 0bf8 0FB6F0   		movzbl	%al, %esi
 1301 0bfb 8B85B4FE 		movl	-332(%rbp), %eax
 1301      FFFF
 1302 0c01 89C1     		movl	%eax, %ecx
 1303 0c03 D3E6     		sall	%cl, %esi
 1304 0c05 89F0     		movl	%esi, %eax
 1305 0c07 01D0     		addl	%edx, %eax
 1306 0c09 8985F0FE 		movl	%eax, -272(%rbp)
 1306      FFFF
 1307 0c0f EB53     		jmp	.L62
 1308              	.L63:
 333:main.c        ****                     else if (i == 16) befEncSenInit[0] += ((1 << i) * ((uint32_t) max1000Limit));
 1309              		.loc 1 333 0 is_stmt 1
 1310 0c11 83BDB4FE 		cmpl	$16, -332(%rbp)
 1310      FFFF10
 1311 0c18 7526     		jne	.L64
 1312              		.loc 1 333 0 is_stmt 0 discriminator 1
 1313 0c1a 8B95F0FE 		movl	-272(%rbp), %edx
 1313      FFFF
 1314 0c20 0FB60500 		movzbl	max1000Limit(%rip), %eax
 1314      000000
 1315 0c27 0FB6F0   		movzbl	%al, %esi
 1316 0c2a 8B85B4FE 		movl	-332(%rbp), %eax
 1316      FFFF
 1317 0c30 89C1     		movl	%eax, %ecx
 1318 0c32 D3E6     		sall	%cl, %esi
 1319 0c34 89F0     		movl	%esi, %eax
 1320 0c36 01D0     		addl	%edx, %eax
 1321 0c38 8985F0FE 		movl	%eax, -272(%rbp)
 1321      FFFF
 1322 0c3e EB24     		jmp	.L62
 1323              	.L64:
 334:main.c        ****                     else befEncSenInit[0] += ((1 << i) * ((uint32_t) max2000Limit));
 1324              		.loc 1 334 0 is_stmt 1
 1325 0c40 8B95F0FE 		movl	-272(%rbp), %edx
 1325      FFFF
 1326 0c46 0FB60500 		movzbl	max2000Limit(%rip), %eax
 1326      000000
 1327 0c4d 0FB6F0   		movzbl	%al, %esi
 1328 0c50 8B85B4FE 		movl	-332(%rbp), %eax
 1328      FFFF
 1329 0c56 89C1     		movl	%eax, %ecx
 1330 0c58 D3E6     		sall	%cl, %esi
 1331 0c5a 89F0     		movl	%esi, %eax
 1332 0c5c 01D0     		addl	%edx, %eax
 1333 0c5e 8985F0FE 		movl	%eax, -272(%rbp)
 1333      FFFF
 1334              	.L62:
 330:main.c        ****                     if (i == 0) befEncSenInit[0] += ((1 << i) * ((uint32_t) max100Limit));
 1335              		.loc 1 330 0
 1336 0c64 8385B4FE 		addl	$8, -332(%rbp)
 1336      FFFF08
 1337              	.L60:
 330:main.c        ****                     if (i == 0) befEncSenInit[0] += ((1 << i) * ((uint32_t) max100Limit));
 1338              		.loc 1 330 0 is_stmt 0 discriminator 1
 1339 0c6b 83BDB4FE 		cmpl	$31, -332(%rbp)
 1339      FFFF1F
 1340 0c72 0F8638FF 		jbe	.L65
 1340      FFFF
 1341              	.LBE9:
 335:main.c        ****                 }
 336:main.c        ****                 encrypt64(befEncSenInit);
 1342              		.loc 1 336 0 is_stmt 1
 1343 0c78 488D85F0 		leaq	-272(%rbp), %rax
 1343      FEFFFF
 1344 0c7f 4889C7   		movq	%rax, %rdi
 1345 0c82 E8000000 		call	encrypt64
 1345      00
 1346              	.LBB10:
 337:main.c        **** 
 338:main.c        ****                 for (uint8_t i = 18; i <= 21; i++) {
 1347              		.loc 1 338 0
 1348 0c87 C68578FE 		movb	$18, -392(%rbp)
 1348      FFFF12
 1349 0c8e E91C0100 		jmp	.L66
 1349      00
 1350              	.L73:
 1351              	.LBB11:
 339:main.c        ****                     uint8_t tempSto = 0;
 1352              		.loc 1 339 0
 1353 0c93 C68510FF 		movb	$0, -240(%rbp)
 1353      FFFF00
 1354              	.LBB12:
 340:main.c        ****                     for (uint8_t j = 0; j <= 7; j++) {
 1355              		.loc 1 340 0
 1356 0c9a C68579FE 		movb	$0, -391(%rbp)
 1356      FFFF00
 1357 0ca1 EB71     		jmp	.L67
 1358              	.L69:
 1359              	.LBB13:
 341:main.c        ****                         uint8_t temp = j + (i - 18) * 8;
 1360              		.loc 1 341 0
 1361 0ca3 0FB68578 		movzbl	-392(%rbp), %eax
 1361      FEFFFF
 1362 0caa 83E812   		subl	$18, %eax
 1363 0cad 8D14C500 		leal	0(,%rax,8), %edx
 1363      000000
 1364 0cb4 0FB68579 		movzbl	-391(%rbp), %eax
 1364      FEFFFF
 1365 0cbb 01D0     		addl	%edx, %eax
 1366 0cbd 88858DFE 		movb	%al, -371(%rbp)
 1366      FFFF
 342:main.c        ****                         if ((befEncSenInit[0] & (1 << temp)) != 0) {
 1367              		.loc 1 342 0
 1368 0cc3 8B95F0FE 		movl	-272(%rbp), %edx
 1368      FFFF
 1369 0cc9 0FB6858D 		movzbl	-371(%rbp), %eax
 1369      FEFFFF
 1370 0cd0 BE010000 		movl	$1, %esi
 1370      00
 1371 0cd5 89C1     		movl	%eax, %ecx
 1372 0cd7 D3E6     		sall	%cl, %esi
 1373 0cd9 89F0     		movl	%esi, %eax
 1374 0cdb 21D0     		andl	%edx, %eax
 1375 0cdd 85C0     		testl	%eax, %eax
 1376 0cdf 7423     		je	.L68
 343:main.c        ****                             tempSto += (1 << j);
 1377              		.loc 1 343 0
 1378 0ce1 0FB68579 		movzbl	-391(%rbp), %eax
 1378      FEFFFF
 1379 0ce8 BA010000 		movl	$1, %edx
 1379      00
 1380 0ced 89C1     		movl	%eax, %ecx
 1381 0cef D3E2     		sall	%cl, %edx
 1382 0cf1 89D0     		movl	%edx, %eax
 1383 0cf3 89C2     		movl	%eax, %edx
 1384 0cf5 0FB68510 		movzbl	-240(%rbp), %eax
 1384      FFFFFF
 1385 0cfc 01D0     		addl	%edx, %eax
 1386 0cfe 888510FF 		movb	%al, -240(%rbp)
 1386      FFFF
 1387              	.L68:
 1388              	.LBE13:
 340:main.c        ****                         uint8_t temp = j + (i - 18) * 8;
 1389              		.loc 1 340 0
 1390 0d04 0FB68579 		movzbl	-391(%rbp), %eax
 1390      FEFFFF
 1391 0d0b 83C001   		addl	$1, %eax
 1392 0d0e 888579FE 		movb	%al, -391(%rbp)
 1392      FFFF
 1393              	.L67:
 340:main.c        ****                         uint8_t temp = j + (i - 18) * 8;
 1394              		.loc 1 340 0 is_stmt 0 discriminator 1
 1395 0d14 80BD79FE 		cmpb	$7, -391(%rbp)
 1395      FFFF07
 1396 0d1b 7686     		jbe	.L69
 1397              	.LBE12:
 344:main.c        ****                         }
 345:main.c        ****                     }
 346:main.c        ****                     flSleep(1000);
 1398              		.loc 1 346 0 is_stmt 1
 1399 0d1d BFE80300 		movl	$1000, %edi
 1399      00
 1400 0d22 E8000000 		call	flSleep
 1400      00
 347:main.c        ****                     fStatus = flWriteChannel(handle, (uint8_t) i, length, &tempSto, &error);
 1401              		.loc 1 347 0
 1402 0d27 8B95E4FE 		movl	-284(%rbp), %edx
 1402      FFFF
 1403 0d2d 0FB6B578 		movzbl	-392(%rbp), %esi
 1403      FEFFFF
 1404 0d34 488B8518 		movq	-232(%rbp), %rax
 1404      FFFFFF
 1405 0d3b 488DBD20 		leaq	-224(%rbp), %rdi
 1405      FFFFFF
 1406 0d42 488D8D10 		leaq	-240(%rbp), %rcx
 1406      FFFFFF
 1407 0d49 4989F8   		movq	%rdi, %r8
 1408 0d4c 4889C7   		movq	%rax, %rdi
 1409 0d4f E8000000 		call	flWriteChannel
 1409      00
 1410 0d54 8985E0FE 		movl	%eax, -288(%rbp)
 1410      FFFF
 348:main.c        ****                     if (LOG) printf("Write to channel %u = %u \n", i, tempSto);
 1411              		.loc 1 348 0
 1412 0d5a 0FB60500 		movzbl	LOG(%rip), %eax
 1412      000000
 1413 0d61 84C0     		testb	%al, %al
 1414 0d63 7422     		je	.L70
 1415              		.loc 1 348 0 is_stmt 0 discriminator 1
 1416 0d65 0FB68510 		movzbl	-240(%rbp), %eax
 1416      FFFFFF
 1417 0d6c 0FB6D0   		movzbl	%al, %edx
 1418 0d6f 0FB68578 		movzbl	-392(%rbp), %eax
 1418      FEFFFF
 1419 0d76 89C6     		movl	%eax, %esi
 1420 0d78 BF000000 		movl	$.LC52, %edi
 1420      00
 1421 0d7d B8000000 		movl	$0, %eax
 1421      00
 1422 0d82 E8000000 		call	printf
 1422      00
 1423              	.L70:
 349:main.c        ****                     CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1424              		.loc 1 349 0 is_stmt 1
 1425 0d87 83BDE0FE 		cmpl	$0, -288(%rbp)
 1425      FFFF00
 1426 0d8e 740F     		je	.L71
 1427              		.loc 1 349 0 is_stmt 0 discriminator 1
 1428 0d90 C785A8FE 		movl	$1, -344(%rbp)
 1428      FFFF0100 
 1428      0000
 1429              	.LBE11:
 1430              	.LBE10:
 1431 0d9a E9E21200 		jmp	.L29
 1431      00
 1432              	.L71:
 1433              	.LBB14:
 338:main.c        ****                     uint8_t tempSto = 0;
 1434              		.loc 1 338 0 is_stmt 1
 1435 0d9f 0FB68578 		movzbl	-392(%rbp), %eax
 1435      FEFFFF
 1436 0da6 83C001   		addl	$1, %eax
 1437 0da9 888578FE 		movb	%al, -392(%rbp)
 1437      FFFF
 1438              	.L66:
 338:main.c        ****                     uint8_t tempSto = 0;
 1439              		.loc 1 338 0 is_stmt 0 discriminator 1
 1440 0daf 80BD78FE 		cmpb	$21, -392(%rbp)
 1440      FFFF15
 1441 0db6 0F86D7FE 		jbe	.L73
 1441      FFFF
 1442              	.LBE14:
 1443              	.LBB15:
 350:main.c        ****                 }
 351:main.c        **** 
 352:main.c        ****                 for (uint8_t i = 22; i <= 25; i++) {
 1444              		.loc 1 352 0 is_stmt 1
 1445 0dbc C6857AFE 		movb	$22, -390(%rbp)
 1445      FFFF16
 1446 0dc3 E91C0100 		jmp	.L74
 1446      00
 1447              	.L80:
 1448              	.LBB16:
 353:main.c        ****                     uint8_t tempSto = 0;
 1449              		.loc 1 353 0
 1450 0dc8 C68510FF 		movb	$0, -240(%rbp)
 1450      FFFF00
 1451              	.LBB17:
 354:main.c        ****                     for (uint8_t j = 0; j <= 7; j++) {
 1452              		.loc 1 354 0
 1453 0dcf C6857BFE 		movb	$0, -389(%rbp)
 1453      FFFF00
 1454 0dd6 EB71     		jmp	.L75
 1455              	.L77:
 1456              	.LBB18:
 355:main.c        ****                         uint8_t temp = j + (i - 22) * 8;
 1457              		.loc 1 355 0
 1458 0dd8 0FB6857A 		movzbl	-390(%rbp), %eax
 1458      FEFFFF
 1459 0ddf 83E816   		subl	$22, %eax
 1460 0de2 8D14C500 		leal	0(,%rax,8), %edx
 1460      000000
 1461 0de9 0FB6857B 		movzbl	-389(%rbp), %eax
 1461      FEFFFF
 1462 0df0 01D0     		addl	%edx, %eax
 1463 0df2 88858EFE 		movb	%al, -370(%rbp)
 1463      FFFF
 356:main.c        ****                         if ((befEncSenInit[1] & (1 << temp)) != 0) {
 1464              		.loc 1 356 0
 1465 0df8 8B95F4FE 		movl	-268(%rbp), %edx
 1465      FFFF
 1466 0dfe 0FB6858E 		movzbl	-370(%rbp), %eax
 1466      FEFFFF
 1467 0e05 BE010000 		movl	$1, %esi
 1467      00
 1468 0e0a 89C1     		movl	%eax, %ecx
 1469 0e0c D3E6     		sall	%cl, %esi
 1470 0e0e 89F0     		movl	%esi, %eax
 1471 0e10 21D0     		andl	%edx, %eax
 1472 0e12 85C0     		testl	%eax, %eax
 1473 0e14 7423     		je	.L76
 357:main.c        ****                             tempSto += (1 << j);
 1474              		.loc 1 357 0
 1475 0e16 0FB6857B 		movzbl	-389(%rbp), %eax
 1475      FEFFFF
 1476 0e1d BA010000 		movl	$1, %edx
 1476      00
 1477 0e22 89C1     		movl	%eax, %ecx
 1478 0e24 D3E2     		sall	%cl, %edx
 1479 0e26 89D0     		movl	%edx, %eax
 1480 0e28 89C2     		movl	%eax, %edx
 1481 0e2a 0FB68510 		movzbl	-240(%rbp), %eax
 1481      FFFFFF
 1482 0e31 01D0     		addl	%edx, %eax
 1483 0e33 888510FF 		movb	%al, -240(%rbp)
 1483      FFFF
 1484              	.L76:
 1485              	.LBE18:
 354:main.c        ****                         uint8_t temp = j + (i - 22) * 8;
 1486              		.loc 1 354 0
 1487 0e39 0FB6857B 		movzbl	-389(%rbp), %eax
 1487      FEFFFF
 1488 0e40 83C001   		addl	$1, %eax
 1489 0e43 88857BFE 		movb	%al, -389(%rbp)
 1489      FFFF
 1490              	.L75:
 354:main.c        ****                         uint8_t temp = j + (i - 22) * 8;
 1491              		.loc 1 354 0 is_stmt 0 discriminator 1
 1492 0e49 80BD7BFE 		cmpb	$7, -389(%rbp)
 1492      FFFF07
 1493 0e50 7686     		jbe	.L77
 1494              	.LBE17:
 358:main.c        ****                         }
 359:main.c        ****                     }
 360:main.c        ****                     flSleep(1000);
 1495              		.loc 1 360 0 is_stmt 1
 1496 0e52 BFE80300 		movl	$1000, %edi
 1496      00
 1497 0e57 E8000000 		call	flSleep
 1497      00
 361:main.c        ****                     fStatus = flWriteChannel(handle, (uint8_t) i, length, &tempSto, &error);
 1498              		.loc 1 361 0
 1499 0e5c 8B95E4FE 		movl	-284(%rbp), %edx
 1499      FFFF
 1500 0e62 0FB6B57A 		movzbl	-390(%rbp), %esi
 1500      FEFFFF
 1501 0e69 488B8518 		movq	-232(%rbp), %rax
 1501      FFFFFF
 1502 0e70 488DBD20 		leaq	-224(%rbp), %rdi
 1502      FFFFFF
 1503 0e77 488D8D10 		leaq	-240(%rbp), %rcx
 1503      FFFFFF
 1504 0e7e 4989F8   		movq	%rdi, %r8
 1505 0e81 4889C7   		movq	%rax, %rdi
 1506 0e84 E8000000 		call	flWriteChannel
 1506      00
 1507 0e89 8985E0FE 		movl	%eax, -288(%rbp)
 1507      FFFF
 362:main.c        ****                     if (LOG) printf("Write to channel %u = %u \n", i, tempSto);
 1508              		.loc 1 362 0
 1509 0e8f 0FB60500 		movzbl	LOG(%rip), %eax
 1509      000000
 1510 0e96 84C0     		testb	%al, %al
 1511 0e98 7422     		je	.L78
 1512              		.loc 1 362 0 is_stmt 0 discriminator 1
 1513 0e9a 0FB68510 		movzbl	-240(%rbp), %eax
 1513      FFFFFF
 1514 0ea1 0FB6D0   		movzbl	%al, %edx
 1515 0ea4 0FB6857A 		movzbl	-390(%rbp), %eax
 1515      FEFFFF
 1516 0eab 89C6     		movl	%eax, %esi
 1517 0ead BF000000 		movl	$.LC52, %edi
 1517      00
 1518 0eb2 B8000000 		movl	$0, %eax
 1518      00
 1519 0eb7 E8000000 		call	printf
 1519      00
 1520              	.L78:
 363:main.c        ****                     CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1521              		.loc 1 363 0 is_stmt 1
 1522 0ebc 83BDE0FE 		cmpl	$0, -288(%rbp)
 1522      FFFF00
 1523 0ec3 740F     		je	.L79
 1524              		.loc 1 363 0 is_stmt 0 discriminator 1
 1525 0ec5 C785A8FE 		movl	$1, -344(%rbp)
 1525      FFFF0100 
 1525      0000
 1526              	.LBE16:
 1527              	.LBE15:
 1528 0ecf E9AD1100 		jmp	.L29
 1528      00
 1529              	.L79:
 1530              	.LBB19:
 352:main.c        ****                     uint8_t tempSto = 0;
 1531              		.loc 1 352 0 is_stmt 1
 1532 0ed4 0FB6857A 		movzbl	-390(%rbp), %eax
 1532      FEFFFF
 1533 0edb 83C001   		addl	$1, %eax
 1534 0ede 88857AFE 		movb	%al, -390(%rbp)
 1534      FFFF
 1535              	.L74:
 352:main.c        ****                     uint8_t tempSto = 0;
 1536              		.loc 1 352 0 is_stmt 0 discriminator 1
 1537 0ee4 80BD7AFE 		cmpb	$25, -390(%rbp)
 1537      FFFF19
 1538 0eeb 0F86D7FE 		jbe	.L80
 1538      FFFF
 1539              	.L187:
 1540              	.LBE19:
 1541              	.LBB20:
 364:main.c        ****                 }
 365:main.c        **** 
 366:main.c        ****                 while (true) {
 367:main.c        ****                     uint8_t *readFromChannelZero = malloc(sizeof(uint8_t));
 1542              		.loc 1 367 0 is_stmt 1
 1543 0ef1 BF010000 		movl	$1, %edi
 1543      00
 1544 0ef6 E8000000 		call	malloc
 1544      00
 1545 0efb 48894598 		movq	%rax, -104(%rbp)
 368:main.c        **** 
 369:main.c        ****                     fStatus = flReadChannel(handle, (uint8_t) 0, length, readFromChannelZero, &erro
 1546              		.loc 1 369 0
 1547 0eff 8B95E4FE 		movl	-284(%rbp), %edx
 1547      FFFF
 1548 0f05 488B8518 		movq	-232(%rbp), %rax
 1548      FFFFFF
 1549 0f0c 488DB520 		leaq	-224(%rbp), %rsi
 1549      FFFFFF
 1550 0f13 488B4D98 		movq	-104(%rbp), %rcx
 1551 0f17 4989F0   		movq	%rsi, %r8
 1552 0f1a BE000000 		movl	$0, %esi
 1552      00
 1553 0f1f 4889C7   		movq	%rax, %rdi
 1554 0f22 E8000000 		call	flReadChannel
 1554      00
 1555 0f27 8985E0FE 		movl	%eax, -288(%rbp)
 1555      FFFF
 370:main.c        ****                     CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1556              		.loc 1 370 0
 1557 0f2d 83BDE0FE 		cmpl	$0, -288(%rbp)
 1557      FFFF00
 1558 0f34 740F     		je	.L81
 1559              		.loc 1 370 0 is_stmt 0 discriminator 1
 1560 0f36 C785A8FE 		movl	$1, -344(%rbp)
 1560      FFFF0100 
 1560      0000
 1561 0f40 E9E81000 		jmp	.L72
 1561      00
 1562              	.L81:
 371:main.c        ****                     if (LOG) printf("Read from channel 0 = %u \n", *readFromChannelZero);
 1563              		.loc 1 371 0 is_stmt 1
 1564 0f45 0FB60500 		movzbl	LOG(%rip), %eax
 1564      000000
 1565 0f4c 84C0     		testb	%al, %al
 1566 0f4e 741B     		je	.L82
 1567              		.loc 1 371 0 is_stmt 0 discriminator 1
 1568 0f50 488B4598 		movq	-104(%rbp), %rax
 1569 0f54 0FB600   		movzbl	(%rax), %eax
 1570 0f57 0FB6C0   		movzbl	%al, %eax
 1571 0f5a 89C6     		movl	%eax, %esi
 1572 0f5c BF000000 		movl	$.LC53, %edi
 1572      00
 1573 0f61 B8000000 		movl	$0, %eax
 1573      00
 1574 0f66 E8000000 		call	printf
 1574      00
 1575              	.L82:
 372:main.c        **** 
 373:main.c        ****                     if (((*readFromChannelZero) == 1) || ((*readFromChannelZero) == 2)) {
 1576              		.loc 1 373 0 is_stmt 1
 1577 0f6b 488B4598 		movq	-104(%rbp), %rax
 1578 0f6f 0FB600   		movzbl	(%rax), %eax
 1579 0f72 3C01     		cmpb	$1, %al
 1580 0f74 740F     		je	.L83
 1581              		.loc 1 373 0 is_stmt 0 discriminator 1
 1582 0f76 488B4598 		movq	-104(%rbp), %rax
 1583 0f7a 0FB600   		movzbl	(%rax), %eax
 1584 0f7d 3C02     		cmpb	$2, %al
 1585 0f7f 0F859910 		jne	.L84
 1585      0000
 1586              	.L83:
 1587              	.LBB21:
 374:main.c        ****                         uint8_t cnt = 1, valRead = *readFromChannelZero;
 1588              		.loc 1 374 0 is_stmt 1
 1589 0f85 C6857CFE 		movb	$1, -388(%rbp)
 1589      FFFF01
 1590 0f8c 488B4598 		movq	-104(%rbp), %rax
 1591 0f90 0FB600   		movzbl	(%rax), %eax
 1592 0f93 88858FFE 		movb	%al, -369(%rbp)
 1592      FFFF
 375:main.c        ****                         bool cont = true;
 1593              		.loc 1 375 0
 1594 0f99 C6857DFE 		movb	$1, -387(%rbp)
 1594      FFFF01
 376:main.c        ****                         while (cnt < 3) {
 1595              		.loc 1 376 0
 1596 0fa0 E9A00000 		jmp	.L85
 1596      00
 1597              	.L90:
 377:main.c        ****                             flSleep(1000);
 1598              		.loc 1 377 0
 1599 0fa5 BFE80300 		movl	$1000, %edi
 1599      00
 1600 0faa E8000000 		call	flSleep
 1600      00
 378:main.c        ****                             fStatus = flReadChannel(handle, 0, length, readFromChannelZero, &error)
 1601              		.loc 1 378 0
 1602 0faf 8B95E4FE 		movl	-284(%rbp), %edx
 1602      FFFF
 1603 0fb5 488B8518 		movq	-232(%rbp), %rax
 1603      FFFFFF
 1604 0fbc 488DB520 		leaq	-224(%rbp), %rsi
 1604      FFFFFF
 1605 0fc3 488B4D98 		movq	-104(%rbp), %rcx
 1606 0fc7 4989F0   		movq	%rsi, %r8
 1607 0fca BE000000 		movl	$0, %esi
 1607      00
 1608 0fcf 4889C7   		movq	%rax, %rdi
 1609 0fd2 E8000000 		call	flReadChannel
 1609      00
 1610 0fd7 8985E0FE 		movl	%eax, -288(%rbp)
 1610      FFFF
 379:main.c        ****                             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1611              		.loc 1 379 0
 1612 0fdd 83BDE0FE 		cmpl	$0, -288(%rbp)
 1612      FFFF00
 1613 0fe4 740F     		je	.L86
 1614              		.loc 1 379 0 is_stmt 0 discriminator 1
 1615 0fe6 C785A8FE 		movl	$1, -344(%rbp)
 1615      FFFF0100 
 1615      0000
 1616 0ff0 E9381000 		jmp	.L72
 1616      00
 1617              	.L86:
 380:main.c        ****                             if (LOG) printf("Read from channel 0 = %u \n", *readFromChannelZero);
 1618              		.loc 1 380 0 is_stmt 1
 1619 0ff5 0FB60500 		movzbl	LOG(%rip), %eax
 1619      000000
 1620 0ffc 84C0     		testb	%al, %al
 1621 0ffe 741B     		je	.L87
 1622              		.loc 1 380 0 is_stmt 0 discriminator 1
 1623 1000 488B4598 		movq	-104(%rbp), %rax
 1624 1004 0FB600   		movzbl	(%rax), %eax
 1625 1007 0FB6C0   		movzbl	%al, %eax
 1626 100a 89C6     		movl	%eax, %esi
 1627 100c BF000000 		movl	$.LC53, %edi
 1627      00
 1628 1011 B8000000 		movl	$0, %eax
 1628      00
 1629 1016 E8000000 		call	printf
 1629      00
 1630              	.L87:
 381:main.c        **** 
 382:main.c        ****                             if (*readFromChannelZero == valRead) cnt++;
 1631              		.loc 1 382 0 is_stmt 1
 1632 101b 488B4598 		movq	-104(%rbp), %rax
 1633 101f 0FB600   		movzbl	(%rax), %eax
 1634 1022 3A858FFE 		cmpb	-369(%rbp), %al
 1634      FFFF
 1635 1028 7512     		jne	.L88
 1636              		.loc 1 382 0 is_stmt 0 discriminator 1
 1637 102a 0FB6857C 		movzbl	-388(%rbp), %eax
 1637      FEFFFF
 1638 1031 83C001   		addl	$1, %eax
 1639 1034 88857CFE 		movb	%al, -388(%rbp)
 1639      FFFF
 1640 103a EB09     		jmp	.L85
 1641              	.L88:
 383:main.c        ****                             else {
 384:main.c        ****                                 cont = false;
 1642              		.loc 1 384 0 is_stmt 1
 1643 103c C6857DFE 		movb	$0, -387(%rbp)
 1643      FFFF00
 385:main.c        ****                                 break;
 1644              		.loc 1 385 0
 1645 1043 EB0D     		jmp	.L89
 1646              	.L85:
 376:main.c        ****                             flSleep(1000);
 1647              		.loc 1 376 0 discriminator 1
 1648 1045 80BD7CFE 		cmpb	$2, -388(%rbp)
 1648      FFFF02
 1649 104c 0F8653FF 		jbe	.L90
 1649      FFFF
 1650              	.L89:
 386:main.c        ****                             }
 387:main.c        ****                         }
 388:main.c        ****                         if (cont) {
 1651              		.loc 1 388 0
 1652 1052 80BD7DFE 		cmpb	$0, -387(%rbp)
 1652      FFFF00
 1653 1059 0F84BF0F 		je	.L84
 1653      0000
 1654              	.LBB22:
 1655              	.LBB23:
 389:main.c        ****                             uint32_t inpFromFrontEnd[2];
 390:main.c        ****                             for (int i = 0; i < 2; i++) inpFromFrontEnd[i] = 0;
 1656              		.loc 1 390 0
 1657 105f C785B8FE 		movl	$0, -328(%rbp)
 1657      FFFF0000 
 1657      0000
 1658 1069 EB1A     		jmp	.L91
 1659              	.L92:
 1660              		.loc 1 390 0 is_stmt 0 discriminator 2
 1661 106b 8B85B8FE 		movl	-328(%rbp), %eax
 1661      FFFF
 1662 1071 4898     		cltq
 1663 1073 C7848500 		movl	$0, -256(%rbp,%rax,4)
 1663      FFFFFF00 
 1663      000000
 1664 107e 8385B8FE 		addl	$1, -328(%rbp)
 1664      FFFF01
 1665              	.L91:
 1666              		.loc 1 390 0 discriminator 1
 1667 1085 83BDB8FE 		cmpl	$1, -328(%rbp)
 1667      FFFF01
 1668 108c 7EDD     		jle	.L92
 1669              	.LBE23:
 1670              	.LBB24:
 391:main.c        ****                             for (uint32_t i = 1; i <= 8; i++) {
 1671              		.loc 1 391 0 is_stmt 1
 1672 108e C785BCFE 		movl	$1, -324(%rbp)
 1672      FFFF0100 
 1672      0000
 1673 1098 E9100100 		jmp	.L93
 1673      00
 1674              	.L99:
 1675              	.LBB25:
 392:main.c        ****                                 uint8_t *readFromChannel_i = malloc(sizeof(uint8_t));
 1676              		.loc 1 392 0
 1677 109d BF010000 		movl	$1, %edi
 1677      00
 1678 10a2 E8000000 		call	malloc
 1678      00
 1679 10a7 488945A0 		movq	%rax, -96(%rbp)
 393:main.c        **** 
 394:main.c        ****                                 flSleep(1000);
 1680              		.loc 1 394 0
 1681 10ab BFE80300 		movl	$1000, %edi
 1681      00
 1682 10b0 E8000000 		call	flSleep
 1682      00
 395:main.c        ****                                 fStatus = flReadChannel(handle, (uint8_t) i, length, readFromChanne
 1683              		.loc 1 395 0
 1684 10b5 8B95E4FE 		movl	-284(%rbp), %edx
 1684      FFFF
 1685 10bb 8B85BCFE 		movl	-324(%rbp), %eax
 1685      FFFF
 1686 10c1 0FB6F0   		movzbl	%al, %esi
 1687 10c4 488B8518 		movq	-232(%rbp), %rax
 1687      FFFFFF
 1688 10cb 488DBD20 		leaq	-224(%rbp), %rdi
 1688      FFFFFF
 1689 10d2 488B4DA0 		movq	-96(%rbp), %rcx
 1690 10d6 4989F8   		movq	%rdi, %r8
 1691 10d9 4889C7   		movq	%rax, %rdi
 1692 10dc E8000000 		call	flReadChannel
 1692      00
 1693 10e1 8985E0FE 		movl	%eax, -288(%rbp)
 1693      FFFF
 396:main.c        ****                                 CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1694              		.loc 1 396 0
 1695 10e7 83BDE0FE 		cmpl	$0, -288(%rbp)
 1695      FFFF00
 1696 10ee 740F     		je	.L94
 1697              		.loc 1 396 0 is_stmt 0 discriminator 1
 1698 10f0 C785A8FE 		movl	$1, -344(%rbp)
 1698      FFFF0100 
 1698      0000
 1699 10fa E91D0F00 		jmp	.L95
 1699      00
 1700              	.L94:
 397:main.c        ****                                 if (LOG) printf("Read from channel %u = %u \n", i, *readFromChannel
 1701              		.loc 1 397 0 is_stmt 1
 1702 10ff 0FB60500 		movzbl	LOG(%rip), %eax
 1702      000000
 1703 1106 84C0     		testb	%al, %al
 1704 1108 7421     		je	.L96
 1705              		.loc 1 397 0 is_stmt 0 discriminator 1
 1706 110a 488B45A0 		movq	-96(%rbp), %rax
 1707 110e 0FB600   		movzbl	(%rax), %eax
 1708 1111 0FB6D0   		movzbl	%al, %edx
 1709 1114 8B85BCFE 		movl	-324(%rbp), %eax
 1709      FFFF
 1710 111a 89C6     		movl	%eax, %esi
 1711 111c BF000000 		movl	$.LC54, %edi
 1711      00
 1712 1121 B8000000 		movl	$0, %eax
 1712      00
 1713 1126 E8000000 		call	printf
 1713      00
 1714              	.L96:
 398:main.c        ****                                 uint32_t temp1 = 8 * (i - 1), temp2 = 8 * (i - 5);
 1715              		.loc 1 398 0 is_stmt 1
 1716 112b 8B85BCFE 		movl	-324(%rbp), %eax
 1716      FFFF
 1717 1131 05FFFFFF 		addl	$536870911, %eax
 1717      1F
 1718 1136 C1E003   		sall	$3, %eax
 1719 1139 8985E8FE 		movl	%eax, -280(%rbp)
 1719      FFFF
 1720 113f 8B85BCFE 		movl	-324(%rbp), %eax
 1720      FFFF
 1721 1145 05FBFFFF 		addl	$536870907, %eax
 1721      1F
 1722 114a C1E003   		sall	$3, %eax
 1723 114d 8985ECFE 		movl	%eax, -276(%rbp)
 1723      FFFF
 399:main.c        ****                                 if (i <= 4) inpFromFrontEnd[0] += (*readFromChannel_i) * (1 << temp
 1724              		.loc 1 399 0
 1725 1153 83BDBCFE 		cmpl	$4, -324(%rbp)
 1725      FFFF04
 1726 115a 7726     		ja	.L97
 1727              		.loc 1 399 0 is_stmt 0 discriminator 1
 1728 115c 8B9500FF 		movl	-256(%rbp), %edx
 1728      FFFF
 1729 1162 488B45A0 		movq	-96(%rbp), %rax
 1730 1166 0FB600   		movzbl	(%rax), %eax
 1731 1169 0FB6F0   		movzbl	%al, %esi
 1732 116c 8B85E8FE 		movl	-280(%rbp), %eax
 1732      FFFF
 1733 1172 89C1     		movl	%eax, %ecx
 1734 1174 D3E6     		sall	%cl, %esi
 1735 1176 89F0     		movl	%esi, %eax
 1736 1178 01D0     		addl	%edx, %eax
 1737 117a 898500FF 		movl	%eax, -256(%rbp)
 1737      FFFF
 1738 1180 EB24     		jmp	.L98
 1739              	.L97:
 400:main.c        ****                                 else inpFromFrontEnd[1] += (*readFromChannel_i) * (1 << temp2);
 1740              		.loc 1 400 0 is_stmt 1
 1741 1182 8B9504FF 		movl	-252(%rbp), %edx
 1741      FFFF
 1742 1188 488B45A0 		movq	-96(%rbp), %rax
 1743 118c 0FB600   		movzbl	(%rax), %eax
 1744 118f 0FB6F0   		movzbl	%al, %esi
 1745 1192 8B85ECFE 		movl	-276(%rbp), %eax
 1745      FFFF
 1746 1198 89C1     		movl	%eax, %ecx
 1747 119a D3E6     		sall	%cl, %esi
 1748 119c 89F0     		movl	%esi, %eax
 1749 119e 01D0     		addl	%edx, %eax
 1750 11a0 898504FF 		movl	%eax, -252(%rbp)
 1750      FFFF
 1751              	.L98:
 1752              	.LBE25:
 391:main.c        ****                                 uint8_t *readFromChannel_i = malloc(sizeof(uint8_t));
 1753              		.loc 1 391 0
 1754 11a6 8385BCFE 		addl	$1, -324(%rbp)
 1754      FFFF01
 1755              	.L93:
 391:main.c        ****                                 uint8_t *readFromChannel_i = malloc(sizeof(uint8_t));
 1756              		.loc 1 391 0 is_stmt 0 discriminator 1
 1757 11ad 83BDBCFE 		cmpl	$8, -324(%rbp)
 1757      FFFF08
 1758 11b4 0F86E3FE 		jbe	.L99
 1758      FFFF
 1759              	.LBE24:
 401:main.c        ****                             }
 402:main.c        ****                             decrypt64(inpFromFrontEnd);
 1760              		.loc 1 402 0 is_stmt 1
 1761 11ba 488D8500 		leaq	-256(%rbp), %rax
 1761      FFFFFF
 1762 11c1 4889C7   		movq	%rax, %rdi
 1763 11c4 E8000000 		call	decrypt64
 1763      00
 403:main.c        ****                             uint8_t num_100_admin = 0, num_500_admin = 0, num_1000_admin = 0, num_2
 1764              		.loc 1 403 0
 1765 11c9 C6857EFE 		movb	$0, -386(%rbp)
 1765      FFFF00
 1766 11d0 C6857FFE 		movb	$0, -385(%rbp)
 1766      FFFF00
 1767 11d7 C68580FE 		movb	$0, -384(%rbp)
 1767      FFFF00
 1768 11de C68581FE 		movb	$0, -383(%rbp)
 1768      FFFF00
 404:main.c        ****                             uint16_t userID = 0, unhashedPin = 0;
 1769              		.loc 1 404 0
 1770 11e5 66C78594 		movw	$0, -364(%rbp)
 1770      FEFFFF00 
 1770      00
 1771 11ee 66C78596 		movw	$0, -362(%rbp)
 1771      FEFFFF00 
 1771      00
 1772              	.LBB26:
 405:main.c        **** 
 406:main.c        ****                             for (uint16_t i = 1; i <= 32; i++) {
 1773              		.loc 1 406 0
 1774 11f7 66C78598 		movw	$1, -360(%rbp)
 1774      FEFFFF01 
 1774      00
 1775 1200 E9970000 		jmp	.L100
 1775      00
 1776              	.L104:
 407:main.c        ****                                 if (i <= 16) {
 1777              		.loc 1 407 0
 1778 1205 6683BD98 		cmpw	$16, -360(%rbp)
 1778      FEFFFF10 
 1779 120d 773F     		ja	.L101
 408:main.c        ****                                     if ((inpFromFrontEnd[1] & (1 << (i - 1))) != 0) unhashedPin += 
 1780              		.loc 1 408 0
 1781 120f 8B9504FF 		movl	-252(%rbp), %edx
 1781      FFFF
 1782 1215 0FB78598 		movzwl	-360(%rbp), %eax
 1782      FEFFFF
 1783 121c 83E801   		subl	$1, %eax
 1784 121f BE010000 		movl	$1, %esi
 1784      00
 1785 1224 89C1     		movl	%eax, %ecx
 1786 1226 D3E6     		sall	%cl, %esi
 1787 1228 89F0     		movl	%esi, %eax
 1788 122a 21D0     		andl	%edx, %eax
 1789 122c 85C0     		testl	%eax, %eax
 1790 122e 745B     		je	.L103
 1791              		.loc 1 408 0 is_stmt 0 discriminator 1
 1792 1230 0FB78598 		movzwl	-360(%rbp), %eax
 1792      FEFFFF
 1793 1237 83E801   		subl	$1, %eax
 1794 123a BA010000 		movl	$1, %edx
 1794      00
 1795 123f 89C1     		movl	%eax, %ecx
 1796 1241 D3E2     		sall	%cl, %edx
 1797 1243 89D0     		movl	%edx, %eax
 1798 1245 66018596 		addw	%ax, -362(%rbp)
 1798      FEFFFF
 1799 124c EB3D     		jmp	.L103
 1800              	.L101:
 409:main.c        ****                                 } else {
 410:main.c        ****                                     if ((inpFromFrontEnd[1] & (1 << (i - 1))) != 0) userID += ((1 <
 1801              		.loc 1 410 0 is_stmt 1
 1802 124e 8B9504FF 		movl	-252(%rbp), %edx
 1802      FFFF
 1803 1254 0FB78598 		movzwl	-360(%rbp), %eax
 1803      FEFFFF
 1804 125b 83E801   		subl	$1, %eax
 1805 125e BE010000 		movl	$1, %esi
 1805      00
 1806 1263 89C1     		movl	%eax, %ecx
 1807 1265 D3E6     		sall	%cl, %esi
 1808 1267 89F0     		movl	%esi, %eax
 1809 1269 21D0     		andl	%edx, %eax
 1810 126b 85C0     		testl	%eax, %eax
 1811 126d 741C     		je	.L103
 1812              		.loc 1 410 0 is_stmt 0 discriminator 1
 1813 126f 0FB78598 		movzwl	-360(%rbp), %eax
 1813      FEFFFF
 1814 1276 83E811   		subl	$17, %eax
 1815 1279 BA010000 		movl	$1, %edx
 1815      00
 1816 127e 89C1     		movl	%eax, %ecx
 1817 1280 D3E2     		sall	%cl, %edx
 1818 1282 89D0     		movl	%edx, %eax
 1819 1284 66018594 		addw	%ax, -364(%rbp)
 1819      FEFFFF
 1820              	.L103:
 406:main.c        ****                                 if (i <= 16) {
 1821              		.loc 1 406 0 is_stmt 1
 1822 128b 0FB78598 		movzwl	-360(%rbp), %eax
 1822      FEFFFF
 1823 1292 83C001   		addl	$1, %eax
 1824 1295 66898598 		movw	%ax, -360(%rbp)
 1824      FEFFFF
 1825              	.L100:
 406:main.c        ****                                 if (i <= 16) {
 1826              		.loc 1 406 0 is_stmt 0 discriminator 1
 1827 129c 6683BD98 		cmpw	$32, -360(%rbp)
 1827      FEFFFF20 
 1828 12a4 0F865BFF 		jbe	.L104
 1828      FFFF
 1829              	.LBE26:
 411:main.c        ****                                 }
 412:main.c        ****                             }
 413:main.c        ****                            printf("unhashedPin %u\n", unhashedPin);
 1830              		.loc 1 413 0 is_stmt 1
 1831 12aa 0FB78596 		movzwl	-362(%rbp), %eax
 1831      FEFFFF
 1832 12b1 89C6     		movl	%eax, %esi
 1833 12b3 BF000000 		movl	$.LC55, %edi
 1833      00
 1834 12b8 B8000000 		movl	$0, %eax
 1834      00
 1835 12bd E8000000 		call	printf
 1835      00
 414:main.c        ****                            printf("userID %u\n", userID);
 1836              		.loc 1 414 0
 1837 12c2 0FB78594 		movzwl	-364(%rbp), %eax
 1837      FEFFFF
 1838 12c9 89C6     		movl	%eax, %esi
 1839 12cb BF000000 		movl	$.LC56, %edi
 1839      00
 1840 12d0 B8000000 		movl	$0, %eax
 1840      00
 1841 12d5 E8000000 		call	printf
 1841      00
 415:main.c        ****                             uint16_t hashedPin = myHash(unhashedPin);
 1842              		.loc 1 415 0
 1843 12da 0FB78596 		movzwl	-362(%rbp), %eax
 1843      FEFFFF
 1844 12e1 89C7     		movl	%eax, %edi
 1845 12e3 E8000000 		call	myHash
 1845      00
 1846 12e8 6689859A 		movw	%ax, -358(%rbp)
 1846      FEFFFF
 416:main.c        ****                            printf("hashedPin %u\n", hashedPin);
 1847              		.loc 1 416 0
 1848 12ef 0FB7859A 		movzwl	-358(%rbp), %eax
 1848      FEFFFF
 1849 12f6 89C6     		movl	%eax, %esi
 1850 12f8 BF000000 		movl	$.LC57, %edi
 1850      00
 1851 12fd B8000000 		movl	$0, %eax
 1851      00
 1852 1302 E8000000 		call	printf
 1852      00
 417:main.c        **** 
 418:main.c        ****                             int bal = -1;
 1853              		.loc 1 418 0
 1854 1307 C7859CFE 		movl	$-1, -356(%rbp)
 1854      FFFFFFFF 
 1854      FFFF
 419:main.c        ****                             bool isAdmin = false;
 1855              		.loc 1 419 0
 1856 1311 C68576FE 		movb	$0, -394(%rbp)
 1856      FFFF00
 420:main.c        ****                             int inLineNum = -1;
 1857              		.loc 1 420 0
 1858 1318 C785A0FE 		movl	$-1, -352(%rbp)
 1858      FFFFFFFF 
 1858      FFFF
 421:main.c        ****                             uint8_t *statusOnChan9 = malloc(sizeof(uint8_t));
 1859              		.loc 1 421 0
 1860 1322 BF010000 		movl	$1, %edi
 1860      00
 1861 1327 E8000000 		call	malloc
 1861      00
 1862 132c 488945A8 		movq	%rax, -88(%rbp)
 422:main.c        ****                             if (find(userID, hashedPin, &isAdmin, &bal, &inLineNum)) {
 1863              		.loc 1 422 0
 1864 1330 0FB7B59A 		movzwl	-358(%rbp), %esi
 1864      FEFFFF
 1865 1337 0FB78594 		movzwl	-364(%rbp), %eax
 1865      FEFFFF
 1866 133e 488DBDA0 		leaq	-352(%rbp), %rdi
 1866      FEFFFF
 1867 1345 488D8D9C 		leaq	-356(%rbp), %rcx
 1867      FEFFFF
 1868 134c 488D9576 		leaq	-394(%rbp), %rdx
 1868      FEFFFF
 1869 1353 4989F8   		movq	%rdi, %r8
 1870 1356 89C7     		movl	%eax, %edi
 1871 1358 E8000000 		call	find
 1871      00
 1872 135d 84C0     		testb	%al, %al
 1873 135f 0F847F0B 		je	.L105
 1873      0000
 423:main.c        ****                                 printf("Valid user found \n");
 1874              		.loc 1 423 0
 1875 1365 BF000000 		movl	$.LC58, %edi
 1875      00
 1876 136a E8000000 		call	puts
 1876      00
 424:main.c        ****                                 if (!isAdmin) {
 1877              		.loc 1 424 0
 1878 136f 0FB68576 		movzbl	-394(%rbp), %eax
 1878      FEFFFF
 1879 1376 83F001   		xorl	$1, %eax
 1880 1379 84C0     		testb	%al, %al
 1881 137b 0F841A06 		je	.L106
 1881      0000
 1882              	.LBB27:
 425:main.c        ****                                     int reqAmo = inpFromFrontEnd[0];
 1883              		.loc 1 425 0
 1884 1381 8B8500FF 		movl	-256(%rbp), %eax
 1884      FFFF
 1885 1387 8985A4FE 		movl	%eax, -348(%rbp)
 1885      FFFF
 426:main.c        ****                                     if (suffBalUser(bal, &reqAmo)) {
 1886              		.loc 1 426 0
 1887 138d 8B859CFE 		movl	-356(%rbp), %eax
 1887      FFFF
 1888 1393 488D95A4 		leaq	-348(%rbp), %rdx
 1888      FEFFFF
 1889 139a 4889D6   		movq	%rdx, %rsi
 1890 139d 89C7     		movl	%eax, %edi
 1891 139f E8000000 		call	suffBalUser
 1891      00
 1892 13a4 84C0     		testb	%al, %al
 1893 13a6 0F84A104 		je	.L107
 1893      0000
 1894              	.LBB28:
 427:main.c        **** //                                        printf("bal %u\n", bal);
 428:main.c        **** //                                        printf("req %u\n", reqAmo);
 429:main.c        ****                                         if (LOG) printf("Sufficient Balance in account\n");
 1895              		.loc 1 429 0
 1896 13ac 0FB60500 		movzbl	LOG(%rip), %eax
 1896      000000
 1897 13b3 84C0     		testb	%al, %al
 1898 13b5 740A     		je	.L108
 1899              		.loc 1 429 0 is_stmt 0 discriminator 1
 1900 13b7 BF000000 		movl	$.LC59, %edi
 1900      00
 1901 13bc E8000000 		call	puts
 1901      00
 1902              	.L108:
 430:main.c        ****                                         *statusOnChan9 = 1;
 1903              		.loc 1 430 0 is_stmt 1
 1904 13c1 488B45A8 		movq	-88(%rbp), %rax
 1905 13c5 C60001   		movb	$1, (%rax)
 431:main.c        ****                                         flSleep(1000);
 1906              		.loc 1 431 0
 1907 13c8 BFE80300 		movl	$1000, %edi
 1907      00
 1908 13cd E8000000 		call	flSleep
 1908      00
 432:main.c        ****                                         if (LOG) printf("Write to channel %u = %u \n", 9, *statusOn
 1909              		.loc 1 432 0
 1910 13d2 0FB60500 		movzbl	LOG(%rip), %eax
 1910      000000
 1911 13d9 84C0     		testb	%al, %al
 1912 13db 7420     		je	.L109
 1913              		.loc 1 432 0 is_stmt 0 discriminator 1
 1914 13dd 488B45A8 		movq	-88(%rbp), %rax
 1915 13e1 0FB600   		movzbl	(%rax), %eax
 1916 13e4 0FB6C0   		movzbl	%al, %eax
 1917 13e7 89C2     		movl	%eax, %edx
 1918 13e9 BE090000 		movl	$9, %esi
 1918      00
 1919 13ee BF000000 		movl	$.LC52, %edi
 1919      00
 1920 13f3 B8000000 		movl	$0, %eax
 1920      00
 1921 13f8 E8000000 		call	printf
 1921      00
 1922              	.L109:
 433:main.c        ****                                         fStatus = flWriteChannel(handle, (uint8_t) 9, length, statu
 1923              		.loc 1 433 0 is_stmt 1
 1924 13fd 8B95E4FE 		movl	-284(%rbp), %edx
 1924      FFFF
 1925 1403 488B8518 		movq	-232(%rbp), %rax
 1925      FFFFFF
 1926 140a 488DB520 		leaq	-224(%rbp), %rsi
 1926      FFFFFF
 1927 1411 488B4DA8 		movq	-88(%rbp), %rcx
 1928 1415 4989F0   		movq	%rsi, %r8
 1929 1418 BE090000 		movl	$9, %esi
 1929      00
 1930 141d 4889C7   		movq	%rax, %rdi
 1931 1420 E8000000 		call	flWriteChannel
 1931      00
 1932 1425 8985E0FE 		movl	%eax, -288(%rbp)
 1932      FFFF
 434:main.c        ****                                         CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1933              		.loc 1 434 0
 1934 142b 83BDE0FE 		cmpl	$0, -288(%rbp)
 1934      FFFF00
 1935 1432 740F     		je	.L110
 1936              		.loc 1 434 0 is_stmt 0 discriminator 1
 1937 1434 C785A8FE 		movl	$1, -344(%rbp)
 1937      FFFF0100 
 1937      0000
 1938 143e E9530500 		jmp	.L137
 1938      00
 1939              	.L110:
 435:main.c        ****                                         flSleep(1000);
 1940              		.loc 1 435 0 is_stmt 1
 1941 1443 BFE80300 		movl	$1000, %edi
 1941      00
 1942 1448 E8000000 		call	flSleep
 1942      00
 1943              	.LBB29:
 436:main.c        ****                                         uint32_t befEncSen[2];
 437:main.c        ****                                         for (int i = 0; i < 2; i++) befEncSen[i] = 0;
 1944              		.loc 1 437 0
 1945 144d C785C0FE 		movl	$0, -320(%rbp)
 1945      FFFF0000 
 1945      0000
 1946 1457 EB1A     		jmp	.L112
 1947              	.L113:
 1948              		.loc 1 437 0 is_stmt 0 discriminator 2
 1949 1459 8B85C0FE 		movl	-320(%rbp), %eax
 1949      FFFF
 1950 145f 4898     		cltq
 1951 1461 C7848510 		movl	$0, -240(%rbp,%rax,4)
 1951      FFFFFF00 
 1951      000000
 1952 146c 8385C0FE 		addl	$1, -320(%rbp)
 1952      FFFF01
 1953              	.L112:
 1954              		.loc 1 437 0 discriminator 1
 1955 1473 83BDC0FE 		cmpl	$1, -320(%rbp)
 1955      FFFF01
 1956 147a 7EDD     		jle	.L113
 1957              	.LBE29:
 438:main.c        ****                                         befEncSen[0] = reqAmo;
 1958              		.loc 1 438 0 is_stmt 1
 1959 147c 8B85A4FE 		movl	-348(%rbp), %eax
 1959      FFFF
 1960 1482 898510FF 		movl	%eax, -240(%rbp)
 1960      FFFF
 439:main.c        ****                                         encrypt64(befEncSen);
 1961              		.loc 1 439 0
 1962 1488 488D8510 		leaq	-240(%rbp), %rax
 1962      FFFFFF
 1963 148f 4889C7   		movq	%rax, %rdi
 1964 1492 E8000000 		call	encrypt64
 1964      00
 1965              	.LBB30:
 440:main.c        ****                                         for (uint8_t i = 10; i <= 13; i++) {
 1966              		.loc 1 440 0
 1967 1497 C68582FE 		movb	$10, -382(%rbp)
 1967      FFFF0A
 1968 149e E91C0100 		jmp	.L114
 1968      00
 1969              	.L120:
 1970              	.LBB31:
 441:main.c        ****                                             uint8_t tempSto = 0;
 1971              		.loc 1 441 0
 1972 14a3 C68577FE 		movb	$0, -393(%rbp)
 1972      FFFF00
 1973              	.LBB32:
 442:main.c        ****                                             for (uint8_t j = 0; j <= 7; j++) {
 1974              		.loc 1 442 0
 1975 14aa C68583FE 		movb	$0, -381(%rbp)
 1975      FFFF00
 1976 14b1 EB71     		jmp	.L115
 1977              	.L117:
 1978              	.LBB33:
 443:main.c        ****                                                 uint8_t temp = j + (i - 10) * 8;
 1979              		.loc 1 443 0
 1980 14b3 0FB68582 		movzbl	-382(%rbp), %eax
 1980      FEFFFF
 1981 14ba 83E80A   		subl	$10, %eax
 1982 14bd 8D14C500 		leal	0(,%rax,8), %edx
 1982      000000
 1983 14c4 0FB68583 		movzbl	-381(%rbp), %eax
 1983      FEFFFF
 1984 14cb 01D0     		addl	%edx, %eax
 1985 14cd 888590FE 		movb	%al, -368(%rbp)
 1985      FFFF
 444:main.c        ****                                                 if ((befEncSen[0] & (1 << temp)) != 0) {
 1986              		.loc 1 444 0
 1987 14d3 8B9510FF 		movl	-240(%rbp), %edx
 1987      FFFF
 1988 14d9 0FB68590 		movzbl	-368(%rbp), %eax
 1988      FEFFFF
 1989 14e0 BE010000 		movl	$1, %esi
 1989      00
 1990 14e5 89C1     		movl	%eax, %ecx
 1991 14e7 D3E6     		sall	%cl, %esi
 1992 14e9 89F0     		movl	%esi, %eax
 1993 14eb 21D0     		andl	%edx, %eax
 1994 14ed 85C0     		testl	%eax, %eax
 1995 14ef 7423     		je	.L116
 445:main.c        ****                                                     tempSto += (1 << j);
 1996              		.loc 1 445 0
 1997 14f1 0FB68583 		movzbl	-381(%rbp), %eax
 1997      FEFFFF
 1998 14f8 BA010000 		movl	$1, %edx
 1998      00
 1999 14fd 89C1     		movl	%eax, %ecx
 2000 14ff D3E2     		sall	%cl, %edx
 2001 1501 89D0     		movl	%edx, %eax
 2002 1503 89C2     		movl	%eax, %edx
 2003 1505 0FB68577 		movzbl	-393(%rbp), %eax
 2003      FEFFFF
 2004 150c 01D0     		addl	%edx, %eax
 2005 150e 888577FE 		movb	%al, -393(%rbp)
 2005      FFFF
 2006              	.L116:
 2007              	.LBE33:
 442:main.c        ****                                                 uint8_t temp = j + (i - 10) * 8;
 2008              		.loc 1 442 0
 2009 1514 0FB68583 		movzbl	-381(%rbp), %eax
 2009      FEFFFF
 2010 151b 83C001   		addl	$1, %eax
 2011 151e 888583FE 		movb	%al, -381(%rbp)
 2011      FFFF
 2012              	.L115:
 442:main.c        ****                                                 uint8_t temp = j + (i - 10) * 8;
 2013              		.loc 1 442 0 is_stmt 0 discriminator 1
 2014 1524 80BD83FE 		cmpb	$7, -381(%rbp)
 2014      FFFF07
 2015 152b 7686     		jbe	.L117
 2016              	.LBE32:
 446:main.c        ****                                                 }
 447:main.c        ****                                             }
 448:main.c        ****                                             flSleep(1000);
 2017              		.loc 1 448 0 is_stmt 1
 2018 152d BFE80300 		movl	$1000, %edi
 2018      00
 2019 1532 E8000000 		call	flSleep
 2019      00
 449:main.c        ****                                             fStatus = flWriteChannel(handle, (uint8_t) i, length, &
 2020              		.loc 1 449 0
 2021 1537 8B95E4FE 		movl	-284(%rbp), %edx
 2021      FFFF
 2022 153d 0FB6B582 		movzbl	-382(%rbp), %esi
 2022      FEFFFF
 2023 1544 488B8518 		movq	-232(%rbp), %rax
 2023      FFFFFF
 2024 154b 488DBD20 		leaq	-224(%rbp), %rdi
 2024      FFFFFF
 2025 1552 488D8D77 		leaq	-393(%rbp), %rcx
 2025      FEFFFF
 2026 1559 4989F8   		movq	%rdi, %r8
 2027 155c 4889C7   		movq	%rax, %rdi
 2028 155f E8000000 		call	flWriteChannel
 2028      00
 2029 1564 8985E0FE 		movl	%eax, -288(%rbp)
 2029      FFFF
 450:main.c        ****                                             if (LOG) printf("Write to channel %u = %u \n", i, tempS
 2030              		.loc 1 450 0
 2031 156a 0FB60500 		movzbl	LOG(%rip), %eax
 2031      000000
 2032 1571 84C0     		testb	%al, %al
 2033 1573 7422     		je	.L118
 2034              		.loc 1 450 0 is_stmt 0 discriminator 1
 2035 1575 0FB68577 		movzbl	-393(%rbp), %eax
 2035      FEFFFF
 2036 157c 0FB6D0   		movzbl	%al, %edx
 2037 157f 0FB68582 		movzbl	-382(%rbp), %eax
 2037      FEFFFF
 2038 1586 89C6     		movl	%eax, %esi
 2039 1588 BF000000 		movl	$.LC52, %edi
 2039      00
 2040 158d B8000000 		movl	$0, %eax
 2040      00
 2041 1592 E8000000 		call	printf
 2041      00
 2042              	.L118:
 451:main.c        ****                                             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2043              		.loc 1 451 0 is_stmt 1
 2044 1597 83BDE0FE 		cmpl	$0, -288(%rbp)
 2044      FFFF00
 2045 159e 740F     		je	.L119
 2046              		.loc 1 451 0 is_stmt 0 discriminator 1
 2047 15a0 C785A8FE 		movl	$1, -344(%rbp)
 2047      FFFF0100 
 2047      0000
 2048              	.LBE31:
 2049              	.LBE30:
 434:main.c        ****                                         flSleep(1000);
 2050              		.loc 1 434 0 is_stmt 1 discriminator 1
 2051 15aa E9E70300 		jmp	.L137
 2051      00
 2052              	.L119:
 2053              	.LBB34:
 440:main.c        ****                                             uint8_t tempSto = 0;
 2054              		.loc 1 440 0
 2055 15af 0FB68582 		movzbl	-382(%rbp), %eax
 2055      FEFFFF
 2056 15b6 83C001   		addl	$1, %eax
 2057 15b9 888582FE 		movb	%al, -382(%rbp)
 2057      FFFF
 2058              	.L114:
 440:main.c        ****                                             uint8_t tempSto = 0;
 2059              		.loc 1 440 0 is_stmt 0 discriminator 1
 2060 15bf 80BD82FE 		cmpb	$13, -382(%rbp)
 2060      FFFF0D
 2061 15c6 0F86D7FE 		jbe	.L120
 2061      FFFF
 2062              	.LBE34:
 2063              	.LBB35:
 452:main.c        ****                                         }
 453:main.c        **** 
 454:main.c        ****                                         for (uint8_t i = 14; i <= 17; i++) {
 2064              		.loc 1 454 0 is_stmt 1
 2065 15cc C68584FE 		movb	$14, -380(%rbp)
 2065      FFFF0E
 2066 15d3 E91C0100 		jmp	.L121
 2066      00
 2067              	.L127:
 2068              	.LBB36:
 455:main.c        ****                                             uint8_t tempSto = 0;
 2069              		.loc 1 455 0
 2070 15d8 C68577FE 		movb	$0, -393(%rbp)
 2070      FFFF00
 2071              	.LBB37:
 456:main.c        ****                                             for (uint8_t j = 0; j <= 7; j++) {
 2072              		.loc 1 456 0
 2073 15df C68585FE 		movb	$0, -379(%rbp)
 2073      FFFF00
 2074 15e6 EB71     		jmp	.L122
 2075              	.L124:
 2076              	.LBB38:
 457:main.c        ****                                                 uint8_t temp = j + (i - 14) * 8;
 2077              		.loc 1 457 0
 2078 15e8 0FB68584 		movzbl	-380(%rbp), %eax
 2078      FEFFFF
 2079 15ef 83E80E   		subl	$14, %eax
 2080 15f2 8D14C500 		leal	0(,%rax,8), %edx
 2080      000000
 2081 15f9 0FB68585 		movzbl	-379(%rbp), %eax
 2081      FEFFFF
 2082 1600 01D0     		addl	%edx, %eax
 2083 1602 888591FE 		movb	%al, -367(%rbp)
 2083      FFFF
 458:main.c        ****                                                 if ((befEncSen[1] & (1 << temp)) != 0) {
 2084              		.loc 1 458 0
 2085 1608 8B9514FF 		movl	-236(%rbp), %edx
 2085      FFFF
 2086 160e 0FB68591 		movzbl	-367(%rbp), %eax
 2086      FEFFFF
 2087 1615 BE010000 		movl	$1, %esi
 2087      00
 2088 161a 89C1     		movl	%eax, %ecx
 2089 161c D3E6     		sall	%cl, %esi
 2090 161e 89F0     		movl	%esi, %eax
 2091 1620 21D0     		andl	%edx, %eax
 2092 1622 85C0     		testl	%eax, %eax
 2093 1624 7423     		je	.L123
 459:main.c        ****                                                     tempSto += (1 << j);
 2094              		.loc 1 459 0
 2095 1626 0FB68585 		movzbl	-379(%rbp), %eax
 2095      FEFFFF
 2096 162d BA010000 		movl	$1, %edx
 2096      00
 2097 1632 89C1     		movl	%eax, %ecx
 2098 1634 D3E2     		sall	%cl, %edx
 2099 1636 89D0     		movl	%edx, %eax
 2100 1638 89C2     		movl	%eax, %edx
 2101 163a 0FB68577 		movzbl	-393(%rbp), %eax
 2101      FEFFFF
 2102 1641 01D0     		addl	%edx, %eax
 2103 1643 888577FE 		movb	%al, -393(%rbp)
 2103      FFFF
 2104              	.L123:
 2105              	.LBE38:
 456:main.c        ****                                                 uint8_t temp = j + (i - 14) * 8;
 2106              		.loc 1 456 0
 2107 1649 0FB68585 		movzbl	-379(%rbp), %eax
 2107      FEFFFF
 2108 1650 83C001   		addl	$1, %eax
 2109 1653 888585FE 		movb	%al, -379(%rbp)
 2109      FFFF
 2110              	.L122:
 456:main.c        ****                                                 uint8_t temp = j + (i - 14) * 8;
 2111              		.loc 1 456 0 is_stmt 0 discriminator 1
 2112 1659 80BD85FE 		cmpb	$7, -379(%rbp)
 2112      FFFF07
 2113 1660 7686     		jbe	.L124
 2114              	.LBE37:
 460:main.c        ****                                                 }
 461:main.c        ****                                             }
 462:main.c        ****                                             flSleep(1000);
 2115              		.loc 1 462 0 is_stmt 1
 2116 1662 BFE80300 		movl	$1000, %edi
 2116      00
 2117 1667 E8000000 		call	flSleep
 2117      00
 463:main.c        ****                                             fStatus = flWriteChannel(handle, (uint8_t) i, length, &
 2118              		.loc 1 463 0
 2119 166c 8B95E4FE 		movl	-284(%rbp), %edx
 2119      FFFF
 2120 1672 0FB6B584 		movzbl	-380(%rbp), %esi
 2120      FEFFFF
 2121 1679 488B8518 		movq	-232(%rbp), %rax
 2121      FFFFFF
 2122 1680 488DBD20 		leaq	-224(%rbp), %rdi
 2122      FFFFFF
 2123 1687 488D8D77 		leaq	-393(%rbp), %rcx
 2123      FEFFFF
 2124 168e 4989F8   		movq	%rdi, %r8
 2125 1691 4889C7   		movq	%rax, %rdi
 2126 1694 E8000000 		call	flWriteChannel
 2126      00
 2127 1699 8985E0FE 		movl	%eax, -288(%rbp)
 2127      FFFF
 464:main.c        ****                                             if (LOG) printf("Write to channel %u = %u \n", i, tempS
 2128              		.loc 1 464 0
 2129 169f 0FB60500 		movzbl	LOG(%rip), %eax
 2129      000000
 2130 16a6 84C0     		testb	%al, %al
 2131 16a8 7422     		je	.L125
 2132              		.loc 1 464 0 is_stmt 0 discriminator 1
 2133 16aa 0FB68577 		movzbl	-393(%rbp), %eax
 2133      FEFFFF
 2134 16b1 0FB6D0   		movzbl	%al, %edx
 2135 16b4 0FB68584 		movzbl	-380(%rbp), %eax
 2135      FEFFFF
 2136 16bb 89C6     		movl	%eax, %esi
 2137 16bd BF000000 		movl	$.LC52, %edi
 2137      00
 2138 16c2 B8000000 		movl	$0, %eax
 2138      00
 2139 16c7 E8000000 		call	printf
 2139      00
 2140              	.L125:
 465:main.c        ****                                             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2141              		.loc 1 465 0 is_stmt 1
 2142 16cc 83BDE0FE 		cmpl	$0, -288(%rbp)
 2142      FFFF00
 2143 16d3 740F     		je	.L126
 2144              		.loc 1 465 0 is_stmt 0 discriminator 1
 2145 16d5 C785A8FE 		movl	$1, -344(%rbp)
 2145      FFFF0100 
 2145      0000
 2146              	.LBE36:
 2147              	.LBE35:
 434:main.c        ****                                         flSleep(1000);
 2148              		.loc 1 434 0 is_stmt 1 discriminator 1
 2149 16df E9B20200 		jmp	.L137
 2149      00
 2150              	.L126:
 2151              	.LBB39:
 454:main.c        ****                                             uint8_t tempSto = 0;
 2152              		.loc 1 454 0
 2153 16e4 0FB68584 		movzbl	-380(%rbp), %eax
 2153      FEFFFF
 2154 16eb 83C001   		addl	$1, %eax
 2155 16ee 888584FE 		movb	%al, -380(%rbp)
 2155      FFFF
 2156              	.L121:
 454:main.c        ****                                             uint8_t tempSto = 0;
 2157              		.loc 1 454 0 is_stmt 0 discriminator 1
 2158 16f4 80BD84FE 		cmpb	$17, -380(%rbp)
 2158      FFFF11
 2159 16fb 0F86D7FE 		jbe	.L127
 2159      FFFF
 2160              	.LBE39:
 466:main.c        ****                                         }
 467:main.c        ****                                         /* update the balance in the global variable now and update
 468:main.c        ****                                         if ((*readFromChannelZero) == 1) {
 2161              		.loc 1 468 0 is_stmt 1
 2162 1701 488B4598 		movq	-104(%rbp), %rax
 2163 1705 0FB600   		movzbl	(%rax), %eax
 2164 1708 3C01     		cmpb	$1, %al
 2165 170a 0F853801 		jne	.L128
 2165      0000
 469:main.c        ****                                             dataFromCSV[inLineNum][3] -= reqAmo;
 2166              		.loc 1 469 0
 2167 1710 8B85A0FE 		movl	-352(%rbp), %eax
 2167      FFFF
 2168 1716 8B95A0FE 		movl	-352(%rbp), %edx
 2168      FFFF
 2169 171c 4863D2   		movslq	%edx, %rdx
 2170 171f 48C1E204 		salq	$4, %rdx
 2171 1723 4881C200 		addq	$dataFromCSV+12, %rdx
 2171      000000
 2172 172a 8B0A     		movl	(%rdx), %ecx
 2173 172c 8B95A4FE 		movl	-348(%rbp), %edx
 2173      FFFF
 2174 1732 29D1     		subl	%edx, %ecx
 2175 1734 89CA     		movl	%ecx, %edx
 2176 1736 4898     		cltq
 2177 1738 48C1E004 		salq	$4, %rax
 2178 173c 48050000 		addq	$dataFromCSV+12, %rax
 2178      0000
 2179 1742 8910     		movl	%edx, (%rax)
 470:main.c        **** 
 471:main.c        ****                                             /* Updating csv file in place */
 472:main.c        ****                                             fPtr = fopen("SampleBackEndDatabase.csv", "w+"); // cha
 2180              		.loc 1 472 0
 2181 1744 BE000000 		movl	$.LC60, %esi
 2181      00
 2182 1749 BF000000 		movl	$.LC50, %edi
 2182      00
 2183 174e E8000000 		call	fopen
 2183      00
 2184 1753 48894590 		movq	%rax, -112(%rbp)
 473:main.c        ****                                             fprintf(fPtr, "%s", "\"User ID (decimal)\",\"PIN Hash (
 2185              		.loc 1 473 0
 2186 1757 488B4590 		movq	-112(%rbp), %rax
 2187 175b 4889C1   		movq	%rax, %rcx
 2188 175e BA440000 		movl	$68, %edx
 2188      00
 2189 1763 BE010000 		movl	$1, %esi
 2189      00
 2190 1768 BF000000 		movl	$.LC61, %edi
 2190      00
 2191 176d E8000000 		call	fwrite
 2191      00
 474:main.c        ****                                             fprintf(fPtr, "\n");
 2192              		.loc 1 474 0
 2193 1772 488B4590 		movq	-112(%rbp), %rax
 2194 1776 4889C6   		movq	%rax, %rsi
 2195 1779 BF0A0000 		movl	$10, %edi
 2195      00
 2196 177e E8000000 		call	fputc
 2196      00
 2197              	.LBB40:
 475:main.c        ****                                             for (int i = 1; i <= numLines; i++) {
 2198              		.loc 1 475 0
 2199 1783 C785C4FE 		movl	$1, -316(%rbp)
 2199      FFFF0100 
 2199      0000
 2200 178d E9930000 		jmp	.L129
 2200      00
 2201              	.L135:
 2202              	.LBB41:
 476:main.c        ****                                                 for (int k = 0; k < 4; k++) {
 2203              		.loc 1 476 0
 2204 1792 C785C8FE 		movl	$0, -312(%rbp)
 2204      FFFF0000 
 2204      0000
 2205 179c EB77     		jmp	.L130
 2206              	.L134:
 477:main.c        ****                                                     fprintf(fPtr, "%d", dataFromCSV[i][k]);
 2207              		.loc 1 477 0
 2208 179e 8B85C8FE 		movl	-312(%rbp), %eax
 2208      FFFF
 2209 17a4 4898     		cltq
 2210 17a6 8B95C4FE 		movl	-316(%rbp), %edx
 2210      FFFF
 2211 17ac 4863D2   		movslq	%edx, %rdx
 2212 17af 48C1E202 		salq	$2, %rdx
 2213 17b3 4801D0   		addq	%rdx, %rax
 2214 17b6 8B148500 		movl	dataFromCSV(,%rax,4), %edx
 2214      000000
 2215 17bd 488B4590 		movq	-112(%rbp), %rax
 2216 17c1 BE000000 		movl	$.LC1, %esi
 2216      00
 2217 17c6 4889C7   		movq	%rax, %rdi
 2218 17c9 B8000000 		movl	$0, %eax
 2218      00
 2219 17ce E8000000 		call	fprintf
 2219      00
 478:main.c        ****                                                     if (k == 3) {
 2220              		.loc 1 478 0
 2221 17d3 83BDC8FE 		cmpl	$3, -312(%rbp)
 2221      FFFF03
 2222 17da 7521     		jne	.L131
 479:main.c        ****                                                         if (i != numLines) fprintf(fPtr, "\n");
 2223              		.loc 1 479 0
 2224 17dc 8B050000 		movl	numLines(%rip), %eax
 2224      0000
 2225 17e2 3985C4FE 		cmpl	%eax, -316(%rbp)
 2225      FFFF
 2226 17e8 7424     		je	.L133
 2227              		.loc 1 479 0 is_stmt 0 discriminator 1
 2228 17ea 488B4590 		movq	-112(%rbp), %rax
 2229 17ee 4889C6   		movq	%rax, %rsi
 2230 17f1 BF0A0000 		movl	$10, %edi
 2230      00
 2231 17f6 E8000000 		call	fputc
 2231      00
 2232 17fb EB11     		jmp	.L133
 2233              	.L131:
 480:main.c        ****                                                     } else fprintf(fPtr, ",");
 2234              		.loc 1 480 0 is_stmt 1
 2235 17fd 488B4590 		movq	-112(%rbp), %rax
 2236 1801 4889C6   		movq	%rax, %rsi
 2237 1804 BF2C0000 		movl	$44, %edi
 2237      00
 2238 1809 E8000000 		call	fputc
 2238      00
 2239              	.L133:
 476:main.c        ****                                                     fprintf(fPtr, "%d", dataFromCSV[i][k]);
 2240              		.loc 1 476 0
 2241 180e 8385C8FE 		addl	$1, -312(%rbp)
 2241      FFFF01
 2242              	.L130:
 476:main.c        ****                                                     fprintf(fPtr, "%d", dataFromCSV[i][k]);
 2243              		.loc 1 476 0 is_stmt 0 discriminator 1
 2244 1815 83BDC8FE 		cmpl	$3, -312(%rbp)
 2244      FFFF03
 2245 181c 7E80     		jle	.L134
 2246              	.LBE41:
 475:main.c        ****                                                 for (int k = 0; k < 4; k++) {
 2247              		.loc 1 475 0 is_stmt 1
 2248 181e 8385C4FE 		addl	$1, -316(%rbp)
 2248      FFFF01
 2249              	.L129:
 475:main.c        ****                                                 for (int k = 0; k < 4; k++) {
 2250              		.loc 1 475 0 is_stmt 0 discriminator 1
 2251 1825 8B050000 		movl	numLines(%rip), %eax
 2251      0000
 2252 182b 3985C4FE 		cmpl	%eax, -316(%rbp)
 2252      FFFF
 2253 1831 0F8E5BFF 		jle	.L135
 2253      FFFF
 2254              	.LBE40:
 481:main.c        ****                                                 }
 482:main.c        ****                                             }
 483:main.c        ****                                             fclose(fPtr);
 2255              		.loc 1 483 0 is_stmt 1
 2256 1837 488B4590 		movq	-112(%rbp), %rax
 2257 183b 4889C7   		movq	%rax, %rdi
 2258 183e E8000000 		call	fclose
 2258      00
 2259              	.LBE28:
 2260 1843 E9490100 		jmp	.L136
 2260      00
 2261              	.L128:
 2262 1848 E9440100 		jmp	.L136
 2262      00
 2263              	.L107:
 484:main.c        ****                                         }
 485:main.c        ****                                     } else {
 486:main.c        **** //                                        printf("bal %u\n", bal);
 487:main.c        **** //                                        printf("req %u\n", reqAmo);
 488:main.c        ****                                         if (LOG) printf("Insufficient Balance \n");
 2264              		.loc 1 488 0
 2265 184d 0FB60500 		movzbl	LOG(%rip), %eax
 2265      000000
 2266 1854 84C0     		testb	%al, %al
 2267 1856 740A     		je	.L138
 2268              		.loc 1 488 0 is_stmt 0 discriminator 1
 2269 1858 BF000000 		movl	$.LC62, %edi
 2269      00
 2270 185d E8000000 		call	puts
 2270      00
 2271              	.L138:
 489:main.c        ****                                         *statusOnChan9 = 2;
 2272              		.loc 1 489 0 is_stmt 1
 2273 1862 488B45A8 		movq	-88(%rbp), %rax
 2274 1866 C60002   		movb	$2, (%rax)
 490:main.c        ****                                         flSleep(1000);
 2275              		.loc 1 490 0
 2276 1869 BFE80300 		movl	$1000, %edi
 2276      00
 2277 186e E8000000 		call	flSleep
 2277      00
 491:main.c        ****                                         if (LOG) printf("Write to channel %u = %u \n", 9, *statusOn
 2278              		.loc 1 491 0
 2279 1873 0FB60500 		movzbl	LOG(%rip), %eax
 2279      000000
 2280 187a 84C0     		testb	%al, %al
 2281 187c 7420     		je	.L139
 2282              		.loc 1 491 0 is_stmt 0 discriminator 1
 2283 187e 488B45A8 		movq	-88(%rbp), %rax
 2284 1882 0FB600   		movzbl	(%rax), %eax
 2285 1885 0FB6C0   		movzbl	%al, %eax
 2286 1888 89C2     		movl	%eax, %edx
 2287 188a BE090000 		movl	$9, %esi
 2287      00
 2288 188f BF000000 		movl	$.LC52, %edi
 2288      00
 2289 1894 B8000000 		movl	$0, %eax
 2289      00
 2290 1899 E8000000 		call	printf
 2290      00
 2291              	.L139:
 492:main.c        ****                                         fStatus = flWriteChannel(handle, (uint8_t) 9, length, statu
 2292              		.loc 1 492 0 is_stmt 1
 2293 189e 8B95E4FE 		movl	-284(%rbp), %edx
 2293      FFFF
 2294 18a4 488B8518 		movq	-232(%rbp), %rax
 2294      FFFFFF
 2295 18ab 488DB520 		leaq	-224(%rbp), %rsi
 2295      FFFFFF
 2296 18b2 488B4DA8 		movq	-88(%rbp), %rcx
 2297 18b6 4989F0   		movq	%rsi, %r8
 2298 18b9 BE090000 		movl	$9, %esi
 2298      00
 2299 18be 4889C7   		movq	%rax, %rdi
 2300 18c1 E8000000 		call	flWriteChannel
 2300      00
 2301 18c6 8985E0FE 		movl	%eax, -288(%rbp)
 2301      FFFF
 493:main.c        ****                                         CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2302              		.loc 1 493 0
 2303 18cc 83BDE0FE 		cmpl	$0, -288(%rbp)
 2303      FFFF00
 2304 18d3 740F     		je	.L140
 2305              		.loc 1 493 0 is_stmt 0 discriminator 1
 2306 18d5 C785A8FE 		movl	$1, -344(%rbp)
 2306      FFFF0100 
 2306      0000
 2307 18df E9B20000 		jmp	.L137
 2307      00
 2308              	.L140:
 2309              	.LBB42:
 494:main.c        ****                                         for (int i = 10; i <= 17; i++) {
 2310              		.loc 1 494 0 is_stmt 1
 2311 18e4 C785CCFE 		movl	$10, -308(%rbp)
 2311      FFFF0A00 
 2311      0000
 2312 18ee E9910000 		jmp	.L141
 2312      00
 2313              	.L144:
 2314              	.LBB43:
 495:main.c        ****                                             uint8_t tempSto = 0;
 2315              		.loc 1 495 0
 2316 18f3 C68510FF 		movb	$0, -240(%rbp)
 2316      FFFF00
 496:main.c        ****                                             flSleep(1000);
 2317              		.loc 1 496 0
 2318 18fa BFE80300 		movl	$1000, %edi
 2318      00
 2319 18ff E8000000 		call	flSleep
 2319      00
 497:main.c        ****                                             if (LOG) printf("Write to channel %u = %u \n", i, tempS
 2320              		.loc 1 497 0
 2321 1904 0FB60500 		movzbl	LOG(%rip), %eax
 2321      000000
 2322 190b 84C0     		testb	%al, %al
 2323 190d 7421     		je	.L142
 2324              		.loc 1 497 0 is_stmt 0 discriminator 1
 2325 190f 0FB68510 		movzbl	-240(%rbp), %eax
 2325      FFFFFF
 2326 1916 0FB6D0   		movzbl	%al, %edx
 2327 1919 8B85CCFE 		movl	-308(%rbp), %eax
 2327      FFFF
 2328 191f 89C6     		movl	%eax, %esi
 2329 1921 BF000000 		movl	$.LC52, %edi
 2329      00
 2330 1926 B8000000 		movl	$0, %eax
 2330      00
 2331 192b E8000000 		call	printf
 2331      00
 2332              	.L142:
 498:main.c        ****                                             fStatus = flWriteChannel(handle, (uint8_t) i, length, &
 2333              		.loc 1 498 0 is_stmt 1
 2334 1930 8B95E4FE 		movl	-284(%rbp), %edx
 2334      FFFF
 2335 1936 8B85CCFE 		movl	-308(%rbp), %eax
 2335      FFFF
 2336 193c 0FB6F0   		movzbl	%al, %esi
 2337 193f 488B8518 		movq	-232(%rbp), %rax
 2337      FFFFFF
 2338 1946 488DBD20 		leaq	-224(%rbp), %rdi
 2338      FFFFFF
 2339 194d 488D8D10 		leaq	-240(%rbp), %rcx
 2339      FFFFFF
 2340 1954 4989F8   		movq	%rdi, %r8
 2341 1957 4889C7   		movq	%rax, %rdi
 2342 195a E8000000 		call	flWriteChannel
 2342      00
 2343 195f 8985E0FE 		movl	%eax, -288(%rbp)
 2343      FFFF
 499:main.c        ****                                             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2344              		.loc 1 499 0
 2345 1965 83BDE0FE 		cmpl	$0, -288(%rbp)
 2345      FFFF00
 2346 196c 740F     		je	.L143
 2347              		.loc 1 499 0 is_stmt 0 discriminator 1
 2348 196e C785A8FE 		movl	$1, -344(%rbp)
 2348      FFFF0100 
 2348      0000
 2349              	.LBE43:
 2350              	.LBE42:
 2351 1978 E99F0600 		jmp	.L95
 2351      00
 2352              	.L143:
 2353              	.LBB44:
 494:main.c        ****                                             uint8_t tempSto = 0;
 2354              		.loc 1 494 0 is_stmt 1
 2355 197d 8385CCFE 		addl	$1, -308(%rbp)
 2355      FFFF01
 2356              	.L141:
 494:main.c        ****                                             uint8_t tempSto = 0;
 2357              		.loc 1 494 0 is_stmt 0 discriminator 1
 2358 1984 83BDCCFE 		cmpl	$17, -308(%rbp)
 2358      FFFF11
 2359 198b 0F8E62FF 		jle	.L144
 2359      FFFF
 2360              	.L136:
 2361              	.LBE44:
 2362              	.LBE27:
 2363 1991 E9880600 		jmp	.L84
 2363      00
 2364              	.L137:
 396:main.c        ****                                 if (LOG) printf("Read from channel %u = %u \n", i, *readFromChannel
 2365              		.loc 1 396 0 is_stmt 1
 2366 1996 E9920600 		jmp	.L72
 2366      00
 2367              	.L106:
 2368              	.LBB45:
 500:main.c        ****                                         }
 501:main.c        ****                                     }
 502:main.c        ****                                 } else {
 503:main.c        ****                                     printf("User has admin privileges \n");
 2369              		.loc 1 503 0
 2370 199b BF000000 		movl	$.LC63, %edi
 2370      00
 2371 19a0 E8000000 		call	puts
 2371      00
 504:main.c        ****                                     *statusOnChan9 = 3;
 2372              		.loc 1 504 0
 2373 19a5 488B45A8 		movq	-88(%rbp), %rax
 2374 19a9 C60003   		movb	$3, (%rax)
 505:main.c        ****                                     flSleep(1000);
 2375              		.loc 1 505 0
 2376 19ac BFE80300 		movl	$1000, %edi
 2376      00
 2377 19b1 E8000000 		call	flSleep
 2377      00
 506:main.c        ****                                     if (LOG) printf("Write to channel %u = %u \n", 9, *statusOnChan
 2378              		.loc 1 506 0
 2379 19b6 0FB60500 		movzbl	LOG(%rip), %eax
 2379      000000
 2380 19bd 84C0     		testb	%al, %al
 2381 19bf 7420     		je	.L146
 2382              		.loc 1 506 0 is_stmt 0 discriminator 1
 2383 19c1 488B45A8 		movq	-88(%rbp), %rax
 2384 19c5 0FB600   		movzbl	(%rax), %eax
 2385 19c8 0FB6C0   		movzbl	%al, %eax
 2386 19cb 89C2     		movl	%eax, %edx
 2387 19cd BE090000 		movl	$9, %esi
 2387      00
 2388 19d2 BF000000 		movl	$.LC52, %edi
 2388      00
 2389 19d7 B8000000 		movl	$0, %eax
 2389      00
 2390 19dc E8000000 		call	printf
 2390      00
 2391              	.L146:
 507:main.c        ****                                     fStatus = flWriteChannel(handle, (uint8_t) 9, length, statusOnC
 2392              		.loc 1 507 0 is_stmt 1
 2393 19e1 8B95E4FE 		movl	-284(%rbp), %edx
 2393      FFFF
 2394 19e7 488B8518 		movq	-232(%rbp), %rax
 2394      FFFFFF
 2395 19ee 488DB520 		leaq	-224(%rbp), %rsi
 2395      FFFFFF
 2396 19f5 488B4DA8 		movq	-88(%rbp), %rcx
 2397 19f9 4989F0   		movq	%rsi, %r8
 2398 19fc BE090000 		movl	$9, %esi
 2398      00
 2399 1a01 4889C7   		movq	%rax, %rdi
 2400 1a04 E8000000 		call	flWriteChannel
 2400      00
 2401 1a09 8985E0FE 		movl	%eax, -288(%rbp)
 2401      FFFF
 508:main.c        ****                                     CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2402              		.loc 1 508 0
 2403 1a0f 83BDE0FE 		cmpl	$0, -288(%rbp)
 2403      FFFF00
 2404 1a16 740F     		je	.L147
 2405              		.loc 1 508 0 is_stmt 0 discriminator 1
 2406 1a18 C785A8FE 		movl	$1, -344(%rbp)
 2406      FFFF0100 
 2406      0000
 2407 1a22 E9F50500 		jmp	.L95
 2407      00
 2408              	.L147:
 2409              	.LBB46:
 509:main.c        **** 
 510:main.c        ****                                     for (uint8_t i = 1; i <= 32; i++) {
 2410              		.loc 1 510 0 is_stmt 1
 2411 1a27 C68586FE 		movb	$1, -378(%rbp)
 2411      FFFF01
 2412 1a2e E92F0100 		jmp	.L149
 2412      00
 2413              	.L157:
 511:main.c        ****                                         if (i <= 8) {
 2414              		.loc 1 511 0
 2415 1a33 80BD86FE 		cmpb	$8, -378(%rbp)
 2415      FFFF08
 2416 1a3a 7745     		ja	.L150
 512:main.c        ****                                             if ((inpFromFrontEnd[0] & (1 << (i - 1))) != 0) num_100
 2417              		.loc 1 512 0
 2418 1a3c 8B9500FF 		movl	-256(%rbp), %edx
 2418      FFFF
 2419 1a42 0FB68586 		movzbl	-378(%rbp), %eax
 2419      FEFFFF
 2420 1a49 83E801   		subl	$1, %eax
 2421 1a4c BE010000 		movl	$1, %esi
 2421      00
 2422 1a51 89C1     		movl	%eax, %ecx
 2423 1a53 D3E6     		sall	%cl, %esi
 2424 1a55 89F0     		movl	%esi, %eax
 2425 1a57 21D0     		andl	%edx, %eax
 2426 1a59 85C0     		testl	%eax, %eax
 2427 1a5b 0F84F100 		je	.L152
 2427      0000
 2428              		.loc 1 512 0 is_stmt 0 discriminator 1
 2429 1a61 0FB68586 		movzbl	-378(%rbp), %eax
 2429      FEFFFF
 2430 1a68 83E801   		subl	$1, %eax
 2431 1a6b BA010000 		movl	$1, %edx
 2431      00
 2432 1a70 89C1     		movl	%eax, %ecx
 2433 1a72 D3E2     		sall	%cl, %edx
 2434 1a74 89D0     		movl	%edx, %eax
 2435 1a76 00857EFE 		addb	%al, -386(%rbp)
 2435      FFFF
 2436 1a7c E9D10000 		jmp	.L152
 2436      00
 2437              	.L150:
 513:main.c        ****                                         } else if (i <= 16) {
 2438              		.loc 1 513 0 is_stmt 1
 2439 1a81 80BD86FE 		cmpb	$16, -378(%rbp)
 2439      FFFF10
 2440 1a88 7745     		ja	.L153
 514:main.c        ****                                             if ((inpFromFrontEnd[0] & (1 << (i - 1))) != 0) num_500
 2441              		.loc 1 514 0
 2442 1a8a 8B9500FF 		movl	-256(%rbp), %edx
 2442      FFFF
 2443 1a90 0FB68586 		movzbl	-378(%rbp), %eax
 2443      FEFFFF
 2444 1a97 83E801   		subl	$1, %eax
 2445 1a9a BE010000 		movl	$1, %esi
 2445      00
 2446 1a9f 89C1     		movl	%eax, %ecx
 2447 1aa1 D3E6     		sall	%cl, %esi
 2448 1aa3 89F0     		movl	%esi, %eax
 2449 1aa5 21D0     		andl	%edx, %eax
 2450 1aa7 85C0     		testl	%eax, %eax
 2451 1aa9 0F84A300 		je	.L152
 2451      0000
 2452              		.loc 1 514 0 is_stmt 0 discriminator 1
 2453 1aaf 0FB68586 		movzbl	-378(%rbp), %eax
 2453      FEFFFF
 2454 1ab6 83E809   		subl	$9, %eax
 2455 1ab9 BA010000 		movl	$1, %edx
 2455      00
 2456 1abe 89C1     		movl	%eax, %ecx
 2457 1ac0 D3E2     		sall	%cl, %edx
 2458 1ac2 89D0     		movl	%edx, %eax
 2459 1ac4 00857FFE 		addb	%al, -385(%rbp)
 2459      FFFF
 2460 1aca E9830000 		jmp	.L152
 2460      00
 2461              	.L153:
 515:main.c        ****                                         } else if (i <= 24) {
 2462              		.loc 1 515 0 is_stmt 1
 2463 1acf 80BD86FE 		cmpb	$24, -378(%rbp)
 2463      FFFF18
 2464 1ad6 773E     		ja	.L155
 516:main.c        ****                                             if ((inpFromFrontEnd[0] & (1 << (i - 1))) != 0) num_100
 2465              		.loc 1 516 0
 2466 1ad8 8B9500FF 		movl	-256(%rbp), %edx
 2466      FFFF
 2467 1ade 0FB68586 		movzbl	-378(%rbp), %eax
 2467      FEFFFF
 2468 1ae5 83E801   		subl	$1, %eax
 2469 1ae8 BE010000 		movl	$1, %esi
 2469      00
 2470 1aed 89C1     		movl	%eax, %ecx
 2471 1aef D3E6     		sall	%cl, %esi
 2472 1af1 89F0     		movl	%esi, %eax
 2473 1af3 21D0     		andl	%edx, %eax
 2474 1af5 85C0     		testl	%eax, %eax
 2475 1af7 7459     		je	.L152
 2476              		.loc 1 516 0 is_stmt 0 discriminator 1
 2477 1af9 0FB68586 		movzbl	-378(%rbp), %eax
 2477      FEFFFF
 2478 1b00 83E811   		subl	$17, %eax
 2479 1b03 BA010000 		movl	$1, %edx
 2479      00
 2480 1b08 89C1     		movl	%eax, %ecx
 2481 1b0a D3E2     		sall	%cl, %edx
 2482 1b0c 89D0     		movl	%edx, %eax
 2483 1b0e 008580FE 		addb	%al, -384(%rbp)
 2483      FFFF
 2484 1b14 EB3C     		jmp	.L152
 2485              	.L155:
 517:main.c        ****                                         } else {
 518:main.c        ****                                             if ((inpFromFrontEnd[0] & (1 << (i - 1))) != 0) num_200
 2486              		.loc 1 518 0 is_stmt 1
 2487 1b16 8B9500FF 		movl	-256(%rbp), %edx
 2487      FFFF
 2488 1b1c 0FB68586 		movzbl	-378(%rbp), %eax
 2488      FEFFFF
 2489 1b23 83E801   		subl	$1, %eax
 2490 1b26 BE010000 		movl	$1, %esi
 2490      00
 2491 1b2b 89C1     		movl	%eax, %ecx
 2492 1b2d D3E6     		sall	%cl, %esi
 2493 1b2f 89F0     		movl	%esi, %eax
 2494 1b31 21D0     		andl	%edx, %eax
 2495 1b33 85C0     		testl	%eax, %eax
 2496 1b35 741B     		je	.L152
 2497              		.loc 1 518 0 is_stmt 0 discriminator 1
 2498 1b37 0FB68586 		movzbl	-378(%rbp), %eax
 2498      FEFFFF
 2499 1b3e 83E819   		subl	$25, %eax
 2500 1b41 BA010000 		movl	$1, %edx
 2500      00
 2501 1b46 89C1     		movl	%eax, %ecx
 2502 1b48 D3E2     		sall	%cl, %edx
 2503 1b4a 89D0     		movl	%edx, %eax
 2504 1b4c 008581FE 		addb	%al, -383(%rbp)
 2504      FFFF
 2505              	.L152:
 510:main.c        ****                                         if (i <= 8) {
 2506              		.loc 1 510 0 is_stmt 1
 2507 1b52 0FB68586 		movzbl	-378(%rbp), %eax
 2507      FEFFFF
 2508 1b59 83C001   		addl	$1, %eax
 2509 1b5c 888586FE 		movb	%al, -378(%rbp)
 2509      FFFF
 2510              	.L149:
 510:main.c        ****                                         if (i <= 8) {
 2511              		.loc 1 510 0 is_stmt 0 discriminator 1
 2512 1b62 80BD86FE 		cmpb	$32, -378(%rbp)
 2512      FFFF20
 2513 1b69 0F86C4FE 		jbe	.L157
 2513      FFFF
 2514              	.LBE46:
 2515              	.LBB47:
 519:main.c        ****                                         }
 520:main.c        ****                                     }
 521:main.c        **** 
 522:main.c        **** //                            printf("num_2000_admin %u\n", num_2000_admin);
 523:main.c        **** //                            printf("num_1000_admin %u\n", num_1000_admin);
 524:main.c        **** //                            printf("num_500_admin %u\n", num_500_admin);
 525:main.c        **** //                            printf("num_100_admin %u\n", num_100_admin);
 526:main.c        **** 
 527:main.c        ****                                     uint32_t befEncSen[2];
 528:main.c        ****                                     for (int i = 0; i < 2; i++) befEncSen[i] = 0;
 2516              		.loc 1 528 0 is_stmt 1
 2517 1b6f C785D0FE 		movl	$0, -304(%rbp)
 2517      FFFF0000 
 2517      0000
 2518 1b79 EB1A     		jmp	.L158
 2519              	.L159:
 2520              		.loc 1 528 0 is_stmt 0 discriminator 2
 2521 1b7b 8B85D0FE 		movl	-304(%rbp), %eax
 2521      FFFF
 2522 1b81 4898     		cltq
 2523 1b83 C7848510 		movl	$0, -240(%rbp,%rax,4)
 2523      FFFFFF00 
 2523      000000
 2524 1b8e 8385D0FE 		addl	$1, -304(%rbp)
 2524      FFFF01
 2525              	.L158:
 2526              		.loc 1 528 0 discriminator 1
 2527 1b95 83BDD0FE 		cmpl	$1, -304(%rbp)
 2527      FFFF01
 2528 1b9c 7EDD     		jle	.L159
 2529              	.LBE47:
 2530              	.LBB48:
 529:main.c        ****                                     for (uint32_t i = 0; i <= 31; i += 8) {
 2531              		.loc 1 529 0 is_stmt 1
 2532 1b9e C785D4FE 		movl	$0, -300(%rbp)
 2532      FFFF0000 
 2532      0000
 2533 1ba8 E9AC0000 		jmp	.L160
 2533      00
 2534              	.L165:
 530:main.c        ****                                         if (i == 0) befEncSen[0] += ((1 << i) * ((uint32_t) num_100
 2535              		.loc 1 530 0
 2536 1bad 83BDD4FE 		cmpl	$0, -300(%rbp)
 2536      FFFF00
 2537 1bb4 7523     		jne	.L161
 2538              		.loc 1 530 0 is_stmt 0 discriminator 1
 2539 1bb6 8B9510FF 		movl	-240(%rbp), %edx
 2539      FFFF
 2540 1bbc 0FB6B57E 		movzbl	-386(%rbp), %esi
 2540      FEFFFF
 2541 1bc3 8B85D4FE 		movl	-300(%rbp), %eax
 2541      FFFF
 2542 1bc9 89C1     		movl	%eax, %ecx
 2543 1bcb D3E6     		sall	%cl, %esi
 2544 1bcd 89F0     		movl	%esi, %eax
 2545 1bcf 01D0     		addl	%edx, %eax
 2546 1bd1 898510FF 		movl	%eax, -240(%rbp)
 2546      FFFF
 2547 1bd7 EB79     		jmp	.L162
 2548              	.L161:
 531:main.c        ****                                         else if (i == 8) befEncSen[0] += ((1 << i) * ((uint32_t) nu
 2549              		.loc 1 531 0 is_stmt 1
 2550 1bd9 83BDD4FE 		cmpl	$8, -300(%rbp)
 2550      FFFF08
 2551 1be0 7523     		jne	.L163
 2552              		.loc 1 531 0 is_stmt 0 discriminator 1
 2553 1be2 8B9510FF 		movl	-240(%rbp), %edx
 2553      FFFF
 2554 1be8 0FB6B57F 		movzbl	-385(%rbp), %esi
 2554      FEFFFF
 2555 1bef 8B85D4FE 		movl	-300(%rbp), %eax
 2555      FFFF
 2556 1bf5 89C1     		movl	%eax, %ecx
 2557 1bf7 D3E6     		sall	%cl, %esi
 2558 1bf9 89F0     		movl	%esi, %eax
 2559 1bfb 01D0     		addl	%edx, %eax
 2560 1bfd 898510FF 		movl	%eax, -240(%rbp)
 2560      FFFF
 2561 1c03 EB4D     		jmp	.L162
 2562              	.L163:
 532:main.c        ****                                         else if (i == 16) befEncSen[0] += ((1 << i) * ((uint32_t) n
 2563              		.loc 1 532 0 is_stmt 1
 2564 1c05 83BDD4FE 		cmpl	$16, -300(%rbp)
 2564      FFFF10
 2565 1c0c 7523     		jne	.L164
 2566              		.loc 1 532 0 is_stmt 0 discriminator 1
 2567 1c0e 8B9510FF 		movl	-240(%rbp), %edx
 2567      FFFF
 2568 1c14 0FB6B580 		movzbl	-384(%rbp), %esi
 2568      FEFFFF
 2569 1c1b 8B85D4FE 		movl	-300(%rbp), %eax
 2569      FFFF
 2570 1c21 89C1     		movl	%eax, %ecx
 2571 1c23 D3E6     		sall	%cl, %esi
 2572 1c25 89F0     		movl	%esi, %eax
 2573 1c27 01D0     		addl	%edx, %eax
 2574 1c29 898510FF 		movl	%eax, -240(%rbp)
 2574      FFFF
 2575 1c2f EB21     		jmp	.L162
 2576              	.L164:
 533:main.c        ****                                         else befEncSen[0] += ((1 << i) * ((uint32_t) num_2000_admin
 2577              		.loc 1 533 0 is_stmt 1
 2578 1c31 8B9510FF 		movl	-240(%rbp), %edx
 2578      FFFF
 2579 1c37 0FB6B581 		movzbl	-383(%rbp), %esi
 2579      FEFFFF
 2580 1c3e 8B85D4FE 		movl	-300(%rbp), %eax
 2580      FFFF
 2581 1c44 89C1     		movl	%eax, %ecx
 2582 1c46 D3E6     		sall	%cl, %esi
 2583 1c48 89F0     		movl	%esi, %eax
 2584 1c4a 01D0     		addl	%edx, %eax
 2585 1c4c 898510FF 		movl	%eax, -240(%rbp)
 2585      FFFF
 2586              	.L162:
 529:main.c        ****                                         if (i == 0) befEncSen[0] += ((1 << i) * ((uint32_t) num_100
 2587              		.loc 1 529 0
 2588 1c52 8385D4FE 		addl	$8, -300(%rbp)
 2588      FFFF08
 2589              	.L160:
 529:main.c        ****                                         if (i == 0) befEncSen[0] += ((1 << i) * ((uint32_t) num_100
 2590              		.loc 1 529 0 is_stmt 0 discriminator 1
 2591 1c59 83BDD4FE 		cmpl	$31, -300(%rbp)
 2591      FFFF1F
 2592 1c60 0F8647FF 		jbe	.L165
 2592      FFFF
 2593              	.LBE48:
 534:main.c        ****                                     }
 535:main.c        ****                                     encrypt64(befEncSen);
 2594              		.loc 1 535 0 is_stmt 1
 2595 1c66 488D8510 		leaq	-240(%rbp), %rax
 2595      FFFFFF
 2596 1c6d 4889C7   		movq	%rax, %rdi
 2597 1c70 E8000000 		call	encrypt64
 2597      00
 2598              	.LBB49:
 536:main.c        ****                                     for (uint8_t i = 10; i <= 13; i++) {
 2599              		.loc 1 536 0
 2600 1c75 C68587FE 		movb	$10, -377(%rbp)
 2600      FFFF0A
 2601 1c7c E91C0100 		jmp	.L166
 2601      00
 2602              	.L172:
 2603              	.LBB50:
 537:main.c        ****                                         uint8_t tempSto = 0;
 2604              		.loc 1 537 0
 2605 1c81 C685A4FE 		movb	$0, -348(%rbp)
 2605      FFFF00
 2606              	.LBB51:
 538:main.c        ****                                         for (uint8_t j = 0; j <= 7; j++) {
 2607              		.loc 1 538 0
 2608 1c88 C68588FE 		movb	$0, -376(%rbp)
 2608      FFFF00
 2609 1c8f EB71     		jmp	.L167
 2610              	.L169:
 2611              	.LBB52:
 539:main.c        ****                                             uint8_t temp = j + (i - 10) * 8;
 2612              		.loc 1 539 0
 2613 1c91 0FB68587 		movzbl	-377(%rbp), %eax
 2613      FEFFFF
 2614 1c98 83E80A   		subl	$10, %eax
 2615 1c9b 8D14C500 		leal	0(,%rax,8), %edx
 2615      000000
 2616 1ca2 0FB68588 		movzbl	-376(%rbp), %eax
 2616      FEFFFF
 2617 1ca9 01D0     		addl	%edx, %eax
 2618 1cab 888592FE 		movb	%al, -366(%rbp)
 2618      FFFF
 540:main.c        ****                                             if ((befEncSen[0] & (1 << temp)) != 0) {
 2619              		.loc 1 540 0
 2620 1cb1 8B9510FF 		movl	-240(%rbp), %edx
 2620      FFFF
 2621 1cb7 0FB68592 		movzbl	-366(%rbp), %eax
 2621      FEFFFF
 2622 1cbe BE010000 		movl	$1, %esi
 2622      00
 2623 1cc3 89C1     		movl	%eax, %ecx
 2624 1cc5 D3E6     		sall	%cl, %esi
 2625 1cc7 89F0     		movl	%esi, %eax
 2626 1cc9 21D0     		andl	%edx, %eax
 2627 1ccb 85C0     		testl	%eax, %eax
 2628 1ccd 7423     		je	.L168
 541:main.c        ****                                                 tempSto += (1 << j);
 2629              		.loc 1 541 0
 2630 1ccf 0FB68588 		movzbl	-376(%rbp), %eax
 2630      FEFFFF
 2631 1cd6 BA010000 		movl	$1, %edx
 2631      00
 2632 1cdb 89C1     		movl	%eax, %ecx
 2633 1cdd D3E2     		sall	%cl, %edx
 2634 1cdf 89D0     		movl	%edx, %eax
 2635 1ce1 89C2     		movl	%eax, %edx
 2636 1ce3 0FB685A4 		movzbl	-348(%rbp), %eax
 2636      FEFFFF
 2637 1cea 01D0     		addl	%edx, %eax
 2638 1cec 8885A4FE 		movb	%al, -348(%rbp)
 2638      FFFF
 2639              	.L168:
 2640              	.LBE52:
 538:main.c        ****                                             uint8_t temp = j + (i - 10) * 8;
 2641              		.loc 1 538 0
 2642 1cf2 0FB68588 		movzbl	-376(%rbp), %eax
 2642      FEFFFF
 2643 1cf9 83C001   		addl	$1, %eax
 2644 1cfc 888588FE 		movb	%al, -376(%rbp)
 2644      FFFF
 2645              	.L167:
 538:main.c        ****                                             uint8_t temp = j + (i - 10) * 8;
 2646              		.loc 1 538 0 is_stmt 0 discriminator 1
 2647 1d02 80BD88FE 		cmpb	$7, -376(%rbp)
 2647      FFFF07
 2648 1d09 7686     		jbe	.L169
 2649              	.LBE51:
 542:main.c        ****                                             }
 543:main.c        ****                                         }
 544:main.c        ****                                         flSleep(1000);
 2650              		.loc 1 544 0 is_stmt 1
 2651 1d0b BFE80300 		movl	$1000, %edi
 2651      00
 2652 1d10 E8000000 		call	flSleep
 2652      00
 545:main.c        ****                                         if (LOG) printf("Write to channel %u = %u \n", i, tempSto);
 2653              		.loc 1 545 0
 2654 1d15 0FB60500 		movzbl	LOG(%rip), %eax
 2654      000000
 2655 1d1c 84C0     		testb	%al, %al
 2656 1d1e 7422     		je	.L170
 2657              		.loc 1 545 0 is_stmt 0 discriminator 1
 2658 1d20 0FB685A4 		movzbl	-348(%rbp), %eax
 2658      FEFFFF
 2659 1d27 0FB6D0   		movzbl	%al, %edx
 2660 1d2a 0FB68587 		movzbl	-377(%rbp), %eax
 2660      FEFFFF
 2661 1d31 89C6     		movl	%eax, %esi
 2662 1d33 BF000000 		movl	$.LC52, %edi
 2662      00
 2663 1d38 B8000000 		movl	$0, %eax
 2663      00
 2664 1d3d E8000000 		call	printf
 2664      00
 2665              	.L170:
 546:main.c        ****                                         fStatus = flWriteChannel(handle, (uint8_t) i, length, &temp
 2666              		.loc 1 546 0 is_stmt 1
 2667 1d42 8B95E4FE 		movl	-284(%rbp), %edx
 2667      FFFF
 2668 1d48 0FB6B587 		movzbl	-377(%rbp), %esi
 2668      FEFFFF
 2669 1d4f 488B8518 		movq	-232(%rbp), %rax
 2669      FFFFFF
 2670 1d56 488DBD20 		leaq	-224(%rbp), %rdi
 2670      FFFFFF
 2671 1d5d 488D8DA4 		leaq	-348(%rbp), %rcx
 2671      FEFFFF
 2672 1d64 4989F8   		movq	%rdi, %r8
 2673 1d67 4889C7   		movq	%rax, %rdi
 2674 1d6a E8000000 		call	flWriteChannel
 2674      00
 2675 1d6f 8985E0FE 		movl	%eax, -288(%rbp)
 2675      FFFF
 547:main.c        ****                                         CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2676              		.loc 1 547 0
 2677 1d75 83BDE0FE 		cmpl	$0, -288(%rbp)
 2677      FFFF00
 2678 1d7c 740F     		je	.L171
 2679              		.loc 1 547 0 is_stmt 0 discriminator 1
 2680 1d7e C785A8FE 		movl	$1, -344(%rbp)
 2680      FFFF0100 
 2680      0000
 2681              	.LBE50:
 2682              	.LBE49:
 508:main.c        **** 
 2683              		.loc 1 508 0 is_stmt 1 discriminator 1
 2684 1d88 E98F0200 		jmp	.L95
 2684      00
 2685              	.L171:
 2686              	.LBB53:
 536:main.c        ****                                         uint8_t tempSto = 0;
 2687              		.loc 1 536 0
 2688 1d8d 0FB68587 		movzbl	-377(%rbp), %eax
 2688      FEFFFF
 2689 1d94 83C001   		addl	$1, %eax
 2690 1d97 888587FE 		movb	%al, -377(%rbp)
 2690      FFFF
 2691              	.L166:
 536:main.c        ****                                         uint8_t tempSto = 0;
 2692              		.loc 1 536 0 is_stmt 0 discriminator 1
 2693 1d9d 80BD87FE 		cmpb	$13, -377(%rbp)
 2693      FFFF0D
 2694 1da4 0F86D7FE 		jbe	.L172
 2694      FFFF
 2695              	.LBE53:
 2696              	.LBB54:
 548:main.c        ****                                     }
 549:main.c        **** 
 550:main.c        ****                                     for (uint8_t i = 14; i <= 17; i++) {
 2697              		.loc 1 550 0 is_stmt 1
 2698 1daa C68589FE 		movb	$14, -375(%rbp)
 2698      FFFF0E
 2699 1db1 E91C0100 		jmp	.L173
 2699      00
 2700              	.L179:
 2701              	.LBB55:
 551:main.c        ****                                         uint8_t tempSto = 0;
 2702              		.loc 1 551 0
 2703 1db6 C685A4FE 		movb	$0, -348(%rbp)
 2703      FFFF00
 2704              	.LBB56:
 552:main.c        ****                                         for (uint8_t j = 0; j <= 7; j++) {
 2705              		.loc 1 552 0
 2706 1dbd C6858AFE 		movb	$0, -374(%rbp)
 2706      FFFF00
 2707 1dc4 EB71     		jmp	.L174
 2708              	.L176:
 2709              	.LBB57:
 553:main.c        ****                                             uint8_t temp = j + (i - 14) * 8;
 2710              		.loc 1 553 0
 2711 1dc6 0FB68589 		movzbl	-375(%rbp), %eax
 2711      FEFFFF
 2712 1dcd 83E80E   		subl	$14, %eax
 2713 1dd0 8D14C500 		leal	0(,%rax,8), %edx
 2713      000000
 2714 1dd7 0FB6858A 		movzbl	-374(%rbp), %eax
 2714      FEFFFF
 2715 1dde 01D0     		addl	%edx, %eax
 2716 1de0 888593FE 		movb	%al, -365(%rbp)
 2716      FFFF
 554:main.c        ****                                             if ((befEncSen[1] & (1 << temp)) != 0) {
 2717              		.loc 1 554 0
 2718 1de6 8B9514FF 		movl	-236(%rbp), %edx
 2718      FFFF
 2719 1dec 0FB68593 		movzbl	-365(%rbp), %eax
 2719      FEFFFF
 2720 1df3 BE010000 		movl	$1, %esi
 2720      00
 2721 1df8 89C1     		movl	%eax, %ecx
 2722 1dfa D3E6     		sall	%cl, %esi
 2723 1dfc 89F0     		movl	%esi, %eax
 2724 1dfe 21D0     		andl	%edx, %eax
 2725 1e00 85C0     		testl	%eax, %eax
 2726 1e02 7423     		je	.L175
 555:main.c        ****                                                 tempSto += (1 << j);
 2727              		.loc 1 555 0
 2728 1e04 0FB6858A 		movzbl	-374(%rbp), %eax
 2728      FEFFFF
 2729 1e0b BA010000 		movl	$1, %edx
 2729      00
 2730 1e10 89C1     		movl	%eax, %ecx
 2731 1e12 D3E2     		sall	%cl, %edx
 2732 1e14 89D0     		movl	%edx, %eax
 2733 1e16 89C2     		movl	%eax, %edx
 2734 1e18 0FB685A4 		movzbl	-348(%rbp), %eax
 2734      FEFFFF
 2735 1e1f 01D0     		addl	%edx, %eax
 2736 1e21 8885A4FE 		movb	%al, -348(%rbp)
 2736      FFFF
 2737              	.L175:
 2738              	.LBE57:
 552:main.c        ****                                             uint8_t temp = j + (i - 14) * 8;
 2739              		.loc 1 552 0
 2740 1e27 0FB6858A 		movzbl	-374(%rbp), %eax
 2740      FEFFFF
 2741 1e2e 83C001   		addl	$1, %eax
 2742 1e31 88858AFE 		movb	%al, -374(%rbp)
 2742      FFFF
 2743              	.L174:
 552:main.c        ****                                             uint8_t temp = j + (i - 14) * 8;
 2744              		.loc 1 552 0 is_stmt 0 discriminator 1
 2745 1e37 80BD8AFE 		cmpb	$7, -374(%rbp)
 2745      FFFF07
 2746 1e3e 7686     		jbe	.L176
 2747              	.LBE56:
 556:main.c        ****                                             }
 557:main.c        ****                                         }
 558:main.c        ****                                         flSleep(1000);
 2748              		.loc 1 558 0 is_stmt 1
 2749 1e40 BFE80300 		movl	$1000, %edi
 2749      00
 2750 1e45 E8000000 		call	flSleep
 2750      00
 559:main.c        ****                                         if (LOG) printf("Write to channel %u = %u \n", i, tempSto);
 2751              		.loc 1 559 0
 2752 1e4a 0FB60500 		movzbl	LOG(%rip), %eax
 2752      000000
 2753 1e51 84C0     		testb	%al, %al
 2754 1e53 7422     		je	.L177
 2755              		.loc 1 559 0 is_stmt 0 discriminator 1
 2756 1e55 0FB685A4 		movzbl	-348(%rbp), %eax
 2756      FEFFFF
 2757 1e5c 0FB6D0   		movzbl	%al, %edx
 2758 1e5f 0FB68589 		movzbl	-375(%rbp), %eax
 2758      FEFFFF
 2759 1e66 89C6     		movl	%eax, %esi
 2760 1e68 BF000000 		movl	$.LC52, %edi
 2760      00
 2761 1e6d B8000000 		movl	$0, %eax
 2761      00
 2762 1e72 E8000000 		call	printf
 2762      00
 2763              	.L177:
 560:main.c        ****                                         fStatus = flWriteChannel(handle, (uint8_t) i, length, &temp
 2764              		.loc 1 560 0 is_stmt 1
 2765 1e77 8B95E4FE 		movl	-284(%rbp), %edx
 2765      FFFF
 2766 1e7d 0FB6B589 		movzbl	-375(%rbp), %esi
 2766      FEFFFF
 2767 1e84 488B8518 		movq	-232(%rbp), %rax
 2767      FFFFFF
 2768 1e8b 488DBD20 		leaq	-224(%rbp), %rdi
 2768      FFFFFF
 2769 1e92 488D8DA4 		leaq	-348(%rbp), %rcx
 2769      FEFFFF
 2770 1e99 4989F8   		movq	%rdi, %r8
 2771 1e9c 4889C7   		movq	%rax, %rdi
 2772 1e9f E8000000 		call	flWriteChannel
 2772      00
 2773 1ea4 8985E0FE 		movl	%eax, -288(%rbp)
 2773      FFFF
 561:main.c        ****                                         CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2774              		.loc 1 561 0
 2775 1eaa 83BDE0FE 		cmpl	$0, -288(%rbp)
 2775      FFFF00
 2776 1eb1 740F     		je	.L178
 2777              		.loc 1 561 0 is_stmt 0 discriminator 1
 2778 1eb3 C785A8FE 		movl	$1, -344(%rbp)
 2778      FFFF0100 
 2778      0000
 2779              	.LBE55:
 2780              	.LBE54:
 508:main.c        **** 
 2781              		.loc 1 508 0 is_stmt 1 discriminator 1
 2782 1ebd E95A0100 		jmp	.L95
 2782      00
 2783              	.L178:
 2784              	.LBB58:
 550:main.c        ****                                         uint8_t tempSto = 0;
 2785              		.loc 1 550 0
 2786 1ec2 0FB68589 		movzbl	-375(%rbp), %eax
 2786      FEFFFF
 2787 1ec9 83C001   		addl	$1, %eax
 2788 1ecc 888589FE 		movb	%al, -375(%rbp)
 2788      FFFF
 2789              	.L173:
 550:main.c        ****                                         uint8_t tempSto = 0;
 2790              		.loc 1 550 0 is_stmt 0 discriminator 1
 2791 1ed2 80BD89FE 		cmpb	$17, -375(%rbp)
 2791      FFFF11
 2792 1ed9 0F86D7FE 		jbe	.L179
 2792      FFFF
 2793              	.LBE58:
 2794 1edf E9360100 		jmp	.L180
 2794      00
 2795              	.L105:
 2796              	.LBE45:
 562:main.c        ****                                     }
 563:main.c        ****                                 }
 564:main.c        ****                             } else {
 565:main.c        ****                                 printf("Invalid user \n");
 2797              		.loc 1 565 0 is_stmt 1
 2798 1ee4 BF000000 		movl	$.LC64, %edi
 2798      00
 2799 1ee9 E8000000 		call	puts
 2799      00
 566:main.c        ****                                 *statusOnChan9 = 4;
 2800              		.loc 1 566 0
 2801 1eee 488B45A8 		movq	-88(%rbp), %rax
 2802 1ef2 C60004   		movb	$4, (%rax)
 567:main.c        ****                                 flSleep(1000);
 2803              		.loc 1 567 0
 2804 1ef5 BFE80300 		movl	$1000, %edi
 2804      00
 2805 1efa E8000000 		call	flSleep
 2805      00
 568:main.c        ****                                 if (LOG) printf("Write to channel %u = %u \n", 9, *statusOnChan9);
 2806              		.loc 1 568 0
 2807 1eff 0FB60500 		movzbl	LOG(%rip), %eax
 2807      000000
 2808 1f06 84C0     		testb	%al, %al
 2809 1f08 7420     		je	.L181
 2810              		.loc 1 568 0 is_stmt 0 discriminator 1
 2811 1f0a 488B45A8 		movq	-88(%rbp), %rax
 2812 1f0e 0FB600   		movzbl	(%rax), %eax
 2813 1f11 0FB6C0   		movzbl	%al, %eax
 2814 1f14 89C2     		movl	%eax, %edx
 2815 1f16 BE090000 		movl	$9, %esi
 2815      00
 2816 1f1b BF000000 		movl	$.LC52, %edi
 2816      00
 2817 1f20 B8000000 		movl	$0, %eax
 2817      00
 2818 1f25 E8000000 		call	printf
 2818      00
 2819              	.L181:
 569:main.c        ****                                 fStatus = flWriteChannel(handle, (uint8_t) 9, length, statusOnChan9
 2820              		.loc 1 569 0 is_stmt 1
 2821 1f2a 8B95E4FE 		movl	-284(%rbp), %edx
 2821      FFFF
 2822 1f30 488B8518 		movq	-232(%rbp), %rax
 2822      FFFFFF
 2823 1f37 488DB520 		leaq	-224(%rbp), %rsi
 2823      FFFFFF
 2824 1f3e 488B4DA8 		movq	-88(%rbp), %rcx
 2825 1f42 4989F0   		movq	%rsi, %r8
 2826 1f45 BE090000 		movl	$9, %esi
 2826      00
 2827 1f4a 4889C7   		movq	%rax, %rdi
 2828 1f4d E8000000 		call	flWriteChannel
 2828      00
 2829 1f52 8985E0FE 		movl	%eax, -288(%rbp)
 2829      FFFF
 570:main.c        ****                                 CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2830              		.loc 1 570 0
 2831 1f58 83BDE0FE 		cmpl	$0, -288(%rbp)
 2831      FFFF00
 2832 1f5f 740F     		je	.L182
 2833              		.loc 1 570 0 is_stmt 0 discriminator 1
 2834 1f61 C785A8FE 		movl	$1, -344(%rbp)
 2834      FFFF0100 
 2834      0000
 2835 1f6b E9AC0000 		jmp	.L95
 2835      00
 2836              	.L182:
 2837              	.LBB59:
 571:main.c        ****                                 for (int i = 10; i <= 17; i++) {
 2838              		.loc 1 571 0 is_stmt 1
 2839 1f70 C785D8FE 		movl	$10, -296(%rbp)
 2839      FFFF0A00 
 2839      0000
 2840 1f7a E98E0000 		jmp	.L183
 2840      00
 2841              	.L186:
 2842              	.LBB60:
 572:main.c        ****                                     uint8_t tempSto = 0;
 2843              		.loc 1 572 0
 2844 1f7f C68510FF 		movb	$0, -240(%rbp)
 2844      FFFF00
 573:main.c        ****                                     flSleep(1000);
 2845              		.loc 1 573 0
 2846 1f86 BFE80300 		movl	$1000, %edi
 2846      00
 2847 1f8b E8000000 		call	flSleep
 2847      00
 574:main.c        ****                                     if (LOG) printf("Write to channel %u = %u \n", i, tempSto);
 2848              		.loc 1 574 0
 2849 1f90 0FB60500 		movzbl	LOG(%rip), %eax
 2849      000000
 2850 1f97 84C0     		testb	%al, %al
 2851 1f99 7421     		je	.L184
 2852              		.loc 1 574 0 is_stmt 0 discriminator 1
 2853 1f9b 0FB68510 		movzbl	-240(%rbp), %eax
 2853      FFFFFF
 2854 1fa2 0FB6D0   		movzbl	%al, %edx
 2855 1fa5 8B85D8FE 		movl	-296(%rbp), %eax
 2855      FFFF
 2856 1fab 89C6     		movl	%eax, %esi
 2857 1fad BF000000 		movl	$.LC52, %edi
 2857      00
 2858 1fb2 B8000000 		movl	$0, %eax
 2858      00
 2859 1fb7 E8000000 		call	printf
 2859      00
 2860              	.L184:
 575:main.c        ****                                     fStatus = flWriteChannel(handle, (uint8_t) i, length, &tempSto,
 2861              		.loc 1 575 0 is_stmt 1
 2862 1fbc 8B95E4FE 		movl	-284(%rbp), %edx
 2862      FFFF
 2863 1fc2 8B85D8FE 		movl	-296(%rbp), %eax
 2863      FFFF
 2864 1fc8 0FB6F0   		movzbl	%al, %esi
 2865 1fcb 488B8518 		movq	-232(%rbp), %rax
 2865      FFFFFF
 2866 1fd2 488DBD20 		leaq	-224(%rbp), %rdi
 2866      FFFFFF
 2867 1fd9 488D8D10 		leaq	-240(%rbp), %rcx
 2867      FFFFFF
 2868 1fe0 4989F8   		movq	%rdi, %r8
 2869 1fe3 4889C7   		movq	%rax, %rdi
 2870 1fe6 E8000000 		call	flWriteChannel
 2870      00
 2871 1feb 8985E0FE 		movl	%eax, -288(%rbp)
 2871      FFFF
 576:main.c        ****                                     CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2872              		.loc 1 576 0
 2873 1ff1 83BDE0FE 		cmpl	$0, -288(%rbp)
 2873      FFFF00
 2874 1ff8 740C     		je	.L185
 2875              		.loc 1 576 0 is_stmt 0 discriminator 1
 2876 1ffa C785A8FE 		movl	$1, -344(%rbp)
 2876      FFFF0100 
 2876      0000
 2877              	.LBE60:
 2878              	.LBE59:
 396:main.c        ****                                 if (LOG) printf("Read from channel %u = %u \n", i, *readFromChannel
 2879              		.loc 1 396 0 is_stmt 1 discriminator 1
 2880 2004 EB27     		jmp	.L72
 2881              	.L185:
 2882              	.LBB61:
 571:main.c        ****                                     uint8_t tempSto = 0;
 2883              		.loc 1 571 0
 2884 2006 8385D8FE 		addl	$1, -296(%rbp)
 2884      FFFF01
 2885              	.L183:
 571:main.c        ****                                     uint8_t tempSto = 0;
 2886              		.loc 1 571 0 is_stmt 0 discriminator 1
 2887 200d 83BDD8FE 		cmpl	$17, -296(%rbp)
 2887      FFFF11
 2888 2014 0F8E65FF 		jle	.L186
 2888      FFFF
 2889              	.L180:
 2890              	.LBE61:
 2891 201a EB02     		jmp	.L84
 2892              	.L95:
 2893              	.LBE22:
 2894              	.LBE21:
 2895              	.LBE20:
 2896 201c EB63     		jmp	.L29
 2897              	.L84:
 2898              	.LBB62:
 577:main.c        ****                                 }
 578:main.c        ****                             }
 579:main.c        ****                         }
 580:main.c        ****                     }
 581:main.c        ****                     flSleep(1000);
 2899              		.loc 1 581 0 is_stmt 1
 2900 201e BFE80300 		movl	$1000, %edi
 2900      00
 2901 2023 E8000000 		call	flSleep
 2901      00
 2902              	.LBE62:
 582:main.c        ****                 }
 2903              		.loc 1 582 0
 2904 2028 E9C4EEFF 		jmp	.L187
 2904      FF
 2905              	.L72:
 2906              	.LBE7:
 291:main.c        ****             fStatus = flIsFPGARunning(handle, &isRunning, &error);
 2907              		.loc 1 291 0
 2908 202d EB52     		jmp	.L29
 2909              	.L50:
 583:main.c        **** 
 584:main.c        ****             } else {
 585:main.c        ****                 fprintf(stderr, "The FPGALink device at %s is not ready to talk - did you forget --
 2910              		.loc 1 585 0
 2911 202f 488B0500 		movq	stderr(%rip), %rax
 2911      000000
 2912 2036 488B5580 		movq	-128(%rbp), %rdx
 2913 203a BE000000 		movl	$.LC65, %esi
 2913      00
 2914 203f 4889C7   		movq	%rax, %rdi
 2915 2042 B8000000 		movl	$0, %eax
 2915      00
 2916 2047 E8000000 		call	fprintf
 2916      00
 586:main.c        ****                 FAIL(FLP_ARGS, cleanup);
 2917              		.loc 1 586 0
 2918 204c C785A8FE 		movl	$12, -344(%rbp)
 2918      FFFF0C00 
 2918      0000
 2919 2056 90       		nop
 2920 2057 EB28     		jmp	.L29
 2921              	.L46:
 2922              	.LBE6:
 587:main.c        ****             }
 588:main.c        ****         } else {
 589:main.c        ****             fprintf(stderr, "Action requested but device at %s does not support CommFPGA\n", vp);
 2923              		.loc 1 589 0
 2924 2059 488B0500 		movq	stderr(%rip), %rax
 2924      000000
 2925 2060 488B5580 		movq	-128(%rbp), %rdx
 2926 2064 BE000000 		movl	$.LC66, %esi
 2926      00
 2927 2069 4889C7   		movq	%rax, %rdi
 2928 206c B8000000 		movl	$0, %eax
 2928      00
 2929 2071 E8000000 		call	fprintf
 2929      00
 590:main.c        ****             FAIL(FLP_ARGS, cleanup);
 2930              		.loc 1 590 0
 2931 2076 C785A8FE 		movl	$12, -344(%rbp)
 2931      FFFF0C00 
 2931      0000
 2932 2080 90       		nop
 2933              	.L29:
 591:main.c        ****         }
 592:main.c        ****     }
 593:main.c        **** 
 594:main.c        ****     cleanup:
 595:main.c        ****     free((void *) line);
 2934              		.loc 1 595 0
 2935 2081 488B4588 		movq	-120(%rbp), %rax
 2936 2085 4889C7   		movq	%rax, %rdi
 2937 2088 E8000000 		call	free
 2937      00
 596:main.c        ****     flClose(handle);
 2938              		.loc 1 596 0
 2939 208d 488B8518 		movq	-232(%rbp), %rax
 2939      FFFFFF
 2940 2094 4889C7   		movq	%rax, %rdi
 2941 2097 E8000000 		call	flClose
 2941      00
 597:main.c        ****     if (error) {
 2942              		.loc 1 597 0
 2943 209c 488B8520 		movq	-224(%rbp), %rax
 2943      FFFFFF
 2944 20a3 4885C0   		testq	%rax, %rax
 2945 20a6 742F     		je	.L188
 598:main.c        ****         fprintf(stderr, "%s\n", error);
 2946              		.loc 1 598 0
 2947 20a8 488B9520 		movq	-224(%rbp), %rdx
 2947      FFFFFF
 2948 20af 488B0500 		movq	stderr(%rip), %rax
 2948      000000
 2949 20b6 BE000000 		movl	$.LC67, %esi
 2949      00
 2950 20bb 4889C7   		movq	%rax, %rdi
 2951 20be B8000000 		movl	$0, %eax
 2951      00
 2952 20c3 E8000000 		call	fprintf
 2952      00
 599:main.c        ****         flFreeError(error);
 2953              		.loc 1 599 0
 2954 20c8 488B8520 		movq	-224(%rbp), %rax
 2954      FFFFFF
 2955 20cf 4889C7   		movq	%rax, %rdi
 2956 20d2 E8000000 		call	flFreeError
 2956      00
 2957              	.L188:
 600:main.c        ****     }
 601:main.c        ****     return retVal;
 2958              		.loc 1 601 0
 2959 20d7 8B85A8FE 		movl	-344(%rbp), %eax
 2959      FFFF
 2960              	.L189:
 602:main.c        **** }
 2961              		.loc 1 602 0
 2962 20dd 4881C498 		addq	$408, %rsp
 2962      010000
 2963 20e4 5B       		popq	%rbx
 2964 20e5 5D       		popq	%rbp
 2965              		.cfi_def_cfa 7, 8
 2966 20e6 C3       		ret
 2967              		.cfi_endproc
 2968              	.LFE14:
 2970              	.Letext0:
 2971              		.file 2 "/usr/include/stdint.h"
 2972              		.file 3 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
 2973              		.file 4 "/usr/include/x86_64-linux-gnu/bits/types.h"
 2974              		.file 5 "/usr/include/stdio.h"
 2975              		.file 6 "/usr/include/libio.h"
 2976              		.file 7 "/home/anirudh/Downloads/DLD-LAB/04-connectingatms/backend/libs/libargtable2/argtable2.h"
 2977              		.file 8 "/home/anirudh/Downloads/DLD-LAB/04-connectingatms/backend/common/makestuff.h"
 2978              		.file 9 "/home/anirudh/Downloads/DLD-LAB/04-connectingatms/backend/libs/libfpgalink/libfpgalink.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
                            *COM*:0000000000186a50 dataFromCSV
     /tmp/ccZLdKH2.s:10     .bss:0000000000000000 numLines
     /tmp/ccZLdKH2.s:15     .bss:0000000000000004 LOG
     /tmp/ccZLdKH2.s:22     .data:0000000000000000 bankID
     /tmp/ccZLdKH2.s:28     .data:0000000000000004 maxAmountCanBeDispensed
     /tmp/ccZLdKH2.s:33     .data:0000000000000008 max2000Limit
     /tmp/ccZLdKH2.s:38     .data:0000000000000009 max1000Limit
     /tmp/ccZLdKH2.s:43     .data:000000000000000a max500Limit
     /tmp/ccZLdKH2.s:48     .data:000000000000000b max100Limit
     /tmp/ccZLdKH2.s:53     .text:0000000000000000 decrypt
     /tmp/ccZLdKH2.s:155    .text:00000000000000dd encrypt
     /tmp/ccZLdKH2.s:256    .text:00000000000001ba decrypt64
     /tmp/ccZLdKH2.s:290    .text:00000000000001f7 encrypt64
     /tmp/ccZLdKH2.s:324    .text:0000000000000234 myHash
     /tmp/ccZLdKH2.s:397    .text:00000000000002aa format
     /tmp/ccZLdKH2.s:453    .text:000000000000032a find
     /tmp/ccZLdKH2.s:540    .text:00000000000003d7 suffBalUser
     /tmp/ccZLdKH2.s:596    .rodata:00000000000000e0 errMessages
     /tmp/ccZLdKH2.s:740    .text:00000000000003fb main

UNDEFINED SYMBOLS
strtok
sscanf
arg_str0
arg_str1
arg_lit0
arg_end
arg_nullcheck
stderr
fprintf
arg_parse
atoi
puts
printf
stdout
arg_print_syntax
arg_print_glossary
arg_print_errors
flInitialise
flOpen
flLoadStandardFirmware
flSleep
putchar
fflush
flIsDeviceAvailable
flGetFirmwareVersion
flGetFirmwareID
flIsCommCapable
flSelectConduit
flIsFPGARunning
fopen
malloc
getline
free
fclose
flWriteChannel
flReadChannel
fwrite
fputc
flClose
flFreeError
