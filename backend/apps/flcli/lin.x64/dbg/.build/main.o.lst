   1              		.file	"main.c"
   2              		.text
   3              	.Ltext0:
   4              		.comm	dataFromCSV,1600080,32
   5              		.globl	numLines
   6              		.bss
   7              		.align 4
  10              	numLines:
  11 0000 00000000 		.zero	4
  12              		.globl	LOG
  15              	LOG:
  16 0004 00       		.zero	1
  17              		.globl	bankID
  18              		.data
  19              		.align 4
  22              	bankID:
  23 0000 FFFFFFFF 		.long	-1
  24              		.globl	maxAmountCanBeDispensed
  25              		.align 4
  28              	maxAmountCanBeDispensed:
  29 0004 FFFFFFFF 		.long	-1
  30              		.globl	max2000Limit
  33              	max2000Limit:
  34 0008 FF       		.byte	-1
  35              		.globl	max1000Limit
  38              	max1000Limit:
  39 0009 FF       		.byte	-1
  40              		.globl	max500Limit
  43              	max500Limit:
  44 000a FF       		.byte	-1
  45              		.globl	max100Limit
  48              	max100Limit:
  49 000b FF       		.byte	-1
  50              		.text
  51              		.globl	decrypt
  53              	decrypt:
  54              	.LFB6:
  55              		.file 1 "main.c"
   1:main.c        **** /*
   2:main.c        ****    If the user is an admin : 
   3:main.c        ****    Original 64 bit -> | User ID 16-bit | Password 16-bit | 2k 8-bit | 1k 8-bit | 500 8-bit | 100 8-
   4:main.c        ****    (in VHDL before encryption)  8 7 6 5 4 3 2 1
   5:main.c        **** 
   6:main.c        ****    If the user is an accountee : 
   7:main.c        ****    Original 64 bit -> | User ID 16-bit | Password 16-bit | Amount in 32 bit |
   8:main.c        ****    (in VHDL before encryption)  8 7 6 5 4 3 2 1
   9:main.c        **** 
  10:main.c        ****    User ID 16-bit -> Least 5 significant bits indicate bankID
  11:main.c        **** */
  12:main.c        **** 
  13:main.c        **** #define _GNU_SOURCE
  14:main.c        **** 
  15:main.c        **** #include <stdint.h>
  16:main.c        **** #include <stdbool.h>
  17:main.c        **** #include <stdio.h>
  18:main.c        **** #include <stdlib.h>
  19:main.c        **** #include <argtable2.h>
  20:main.c        **** #include <string.h>
  21:main.c        **** #include <libfpgalink.h>
  22:main.c        **** #include <errno.h>
  23:main.c        **** #include <makestuff.h>
  24:main.c        **** #include <libbuffer.h>
  25:main.c        **** #include <liberror.h>
  26:main.c        **** #include <libdump.h>
  27:main.c        **** #include <readline/readline.h>
  28:main.c        **** #include <readline/history.h>
  29:main.c        **** 
  30:main.c        **** #ifdef WIN32
  31:main.c        **** #include <Windows.h>
  32:main.c        **** #else
  33:main.c        **** #include <sys/time.h>
  34:main.c        **** #endif
  35:main.c        **** 
  36:main.c        **** #define N 100005
  37:main.c        **** #define M (((ll)1 << 32)-1)
  38:main.c        **** #define maxNotes 255
  39:main.c        **** #define ll long long
  40:main.c        **** 
  41:main.c        **** int dataFromCSV[N][4];
  42:main.c        **** int numLines = 0;
  43:main.c        **** bool LOG = false;
  44:main.c        **** int bankID = -1;
  45:main.c        **** uint32_t maxAmountCanBeDispensed = M;
  46:main.c        **** uint8_t max2000Limit = maxNotes, max1000Limit = maxNotes, max500Limit = maxNotes, max100Limit = max
  47:main.c        **** 
  48:main.c        **** /* Adapted from tiny encryption algorithm wikipedia */
  49:main.c        **** void decrypt(uint32_t *v, uint32_t *k) {
  56              		.loc 1 49 0
  57              		.cfi_startproc
  58 0000 55       		pushq	%rbp
  59              		.cfi_def_cfa_offset 16
  60              		.cfi_offset 6, -16
  61 0001 4889E5   		movq	%rsp, %rbp
  62              		.cfi_def_cfa_register 6
  63 0004 48897DC8 		movq	%rdi, -56(%rbp)
  64 0008 488975C0 		movq	%rsi, -64(%rbp)
  50:main.c        ****     uint32_t v0 = v[0], v1 = v[1], sum = 0xC6EF3720, i;  /* set up */
  65              		.loc 1 50 0
  66 000c 488B45C8 		movq	-56(%rbp), %rax
  67 0010 8B00     		movl	(%rax), %eax
  68 0012 8945DC   		movl	%eax, -36(%rbp)
  69 0015 488B45C8 		movq	-56(%rbp), %rax
  70 0019 8B4004   		movl	4(%rax), %eax
  71 001c 8945E0   		movl	%eax, -32(%rbp)
  72 001f C745E420 		movl	$-957401312, -28(%rbp)
  72      37EFC6
  51:main.c        ****     uint32_t delta = 0x9e3779b9;                     /* a key schedule constant */
  73              		.loc 1 51 0
  74 0026 C745ECB9 		movl	$-1640531527, -20(%rbp)
  74      79379E
  52:main.c        ****     uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3];   /* cache key */
  75              		.loc 1 52 0
  76 002d 488B45C0 		movq	-64(%rbp), %rax
  77 0031 8B00     		movl	(%rax), %eax
  78 0033 8945F0   		movl	%eax, -16(%rbp)
  79 0036 488B45C0 		movq	-64(%rbp), %rax
  80 003a 8B4004   		movl	4(%rax), %eax
  81 003d 8945F4   		movl	%eax, -12(%rbp)
  82 0040 488B45C0 		movq	-64(%rbp), %rax
  83 0044 8B4008   		movl	8(%rax), %eax
  84 0047 8945F8   		movl	%eax, -8(%rbp)
  85 004a 488B45C0 		movq	-64(%rbp), %rax
  86 004e 8B400C   		movl	12(%rax), %eax
  87 0051 8945FC   		movl	%eax, -4(%rbp)
  53:main.c        ****     /* basic cycle start */
  54:main.c        ****     for (i = 0; i < 32; i++) {
  88              		.loc 1 54 0
  89 0054 C745E800 		movl	$0, -24(%rbp)
  89      000000
  90 005b EB62     		jmp	.L2
  91              	.L3:
  55:main.c        ****         v1 -= ((v0 << 4) + k2) ^ (v0 + sum) ^ ((v0 >> 5) + k3);
  92              		.loc 1 55 0 discriminator 2
  93 005d 8B45DC   		movl	-36(%rbp), %eax
  94 0060 C1E004   		sall	$4, %eax
  95 0063 89C2     		movl	%eax, %edx
  96 0065 8B45F8   		movl	-8(%rbp), %eax
  97 0068 8D0C02   		leal	(%rdx,%rax), %ecx
  98 006b 8B45E4   		movl	-28(%rbp), %eax
  99 006e 8B55DC   		movl	-36(%rbp), %edx
 100 0071 01D0     		addl	%edx, %eax
 101 0073 31C1     		xorl	%eax, %ecx
 102 0075 89CA     		movl	%ecx, %edx
 103 0077 8B45DC   		movl	-36(%rbp), %eax
 104 007a C1E805   		shrl	$5, %eax
 105 007d 89C1     		movl	%eax, %ecx
 106 007f 8B45FC   		movl	-4(%rbp), %eax
 107 0082 01C8     		addl	%ecx, %eax
 108 0084 31D0     		xorl	%edx, %eax
 109 0086 2945E0   		subl	%eax, -32(%rbp)
  56:main.c        ****         v0 -= ((v1 << 4) + k0) ^ (v1 + sum) ^ ((v1 >> 5) + k1);
 110              		.loc 1 56 0 discriminator 2
 111 0089 8B45E0   		movl	-32(%rbp), %eax
 112 008c C1E004   		sall	$4, %eax
 113 008f 89C2     		movl	%eax, %edx
 114 0091 8B45F0   		movl	-16(%rbp), %eax
 115 0094 8D0C02   		leal	(%rdx,%rax), %ecx
 116 0097 8B45E4   		movl	-28(%rbp), %eax
 117 009a 8B55E0   		movl	-32(%rbp), %edx
 118 009d 01D0     		addl	%edx, %eax
 119 009f 31C1     		xorl	%eax, %ecx
 120 00a1 89CA     		movl	%ecx, %edx
 121 00a3 8B45E0   		movl	-32(%rbp), %eax
 122 00a6 C1E805   		shrl	$5, %eax
 123 00a9 89C1     		movl	%eax, %ecx
 124 00ab 8B45F4   		movl	-12(%rbp), %eax
 125 00ae 01C8     		addl	%ecx, %eax
 126 00b0 31D0     		xorl	%edx, %eax
 127 00b2 2945DC   		subl	%eax, -36(%rbp)
  57:main.c        ****         sum -= delta;
 128              		.loc 1 57 0 discriminator 2
 129 00b5 8B45EC   		movl	-20(%rbp), %eax
 130 00b8 2945E4   		subl	%eax, -28(%rbp)
  54:main.c        ****         v1 -= ((v0 << 4) + k2) ^ (v0 + sum) ^ ((v0 >> 5) + k3);
 131              		.loc 1 54 0 discriminator 2
 132 00bb 8345E801 		addl	$1, -24(%rbp)
 133              	.L2:
  54:main.c        ****         v1 -= ((v0 << 4) + k2) ^ (v0 + sum) ^ ((v0 >> 5) + k3);
 134              		.loc 1 54 0 is_stmt 0 discriminator 1
 135 00bf 837DE81F 		cmpl	$31, -24(%rbp)
 136 00c3 7698     		jbe	.L3
  58:main.c        ****     }
  59:main.c        ****     /* end cycle */
  60:main.c        ****     v[0] = v0;
 137              		.loc 1 60 0 is_stmt 1
 138 00c5 488B45C8 		movq	-56(%rbp), %rax
 139 00c9 8B55DC   		movl	-36(%rbp), %edx
 140 00cc 8910     		movl	%edx, (%rax)
  61:main.c        ****     v[1] = v1;
 141              		.loc 1 61 0
 142 00ce 488B45C8 		movq	-56(%rbp), %rax
 143 00d2 488D5004 		leaq	4(%rax), %rdx
 144 00d6 8B45E0   		movl	-32(%rbp), %eax
 145 00d9 8902     		movl	%eax, (%rdx)
  62:main.c        **** }
 146              		.loc 1 62 0
 147 00db 5D       		popq	%rbp
 148              		.cfi_def_cfa 7, 8
 149 00dc C3       		ret
 150              		.cfi_endproc
 151              	.LFE6:
 153              		.globl	encrypt
 155              	encrypt:
 156              	.LFB7:
  63:main.c        **** 
  64:main.c        **** /* Adapted from tiny encryption algorithm wikipedia */
  65:main.c        **** void encrypt(uint32_t *v, uint32_t *k) {
 157              		.loc 1 65 0
 158              		.cfi_startproc
 159 00dd 55       		pushq	%rbp
 160              		.cfi_def_cfa_offset 16
 161              		.cfi_offset 6, -16
 162 00de 4889E5   		movq	%rsp, %rbp
 163              		.cfi_def_cfa_register 6
 164 00e1 48897DC8 		movq	%rdi, -56(%rbp)
 165 00e5 488975C0 		movq	%rsi, -64(%rbp)
  66:main.c        ****     uint32_t v0 = v[0], v1 = v[1], sum = 0, i;           /* set up */
 166              		.loc 1 66 0
 167 00e9 488B45C8 		movq	-56(%rbp), %rax
 168 00ed 8B00     		movl	(%rax), %eax
 169 00ef 8945DC   		movl	%eax, -36(%rbp)
 170 00f2 488B45C8 		movq	-56(%rbp), %rax
 171 00f6 8B4004   		movl	4(%rax), %eax
 172 00f9 8945E0   		movl	%eax, -32(%rbp)
 173 00fc C745E400 		movl	$0, -28(%rbp)
 173      000000
  67:main.c        ****     uint32_t delta = 0x9e3779b9;                     /* a key schedule constant */
 174              		.loc 1 67 0
 175 0103 C745ECB9 		movl	$-1640531527, -20(%rbp)
 175      79379E
  68:main.c        ****     uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3];   /* cache key */
 176              		.loc 1 68 0
 177 010a 488B45C0 		movq	-64(%rbp), %rax
 178 010e 8B00     		movl	(%rax), %eax
 179 0110 8945F0   		movl	%eax, -16(%rbp)
 180 0113 488B45C0 		movq	-64(%rbp), %rax
 181 0117 8B4004   		movl	4(%rax), %eax
 182 011a 8945F4   		movl	%eax, -12(%rbp)
 183 011d 488B45C0 		movq	-64(%rbp), %rax
 184 0121 8B4008   		movl	8(%rax), %eax
 185 0124 8945F8   		movl	%eax, -8(%rbp)
 186 0127 488B45C0 		movq	-64(%rbp), %rax
 187 012b 8B400C   		movl	12(%rax), %eax
 188 012e 8945FC   		movl	%eax, -4(%rbp)
  69:main.c        ****     /* basic cycle start */
  70:main.c        ****     for (i = 0; i < 32; i++) {
 189              		.loc 1 70 0
 190 0131 C745E800 		movl	$0, -24(%rbp)
 190      000000
 191 0138 EB62     		jmp	.L5
 192              	.L6:
  71:main.c        ****         sum += delta;
 193              		.loc 1 71 0 discriminator 2
 194 013a 8B45EC   		movl	-20(%rbp), %eax
 195 013d 0145E4   		addl	%eax, -28(%rbp)
  72:main.c        ****         v0 += ((v1 << 4) + k0) ^ (v1 + sum) ^ ((v1 >> 5) + k1);
 196              		.loc 1 72 0 discriminator 2
 197 0140 8B45E0   		movl	-32(%rbp), %eax
 198 0143 C1E004   		sall	$4, %eax
 199 0146 89C2     		movl	%eax, %edx
 200 0148 8B45F0   		movl	-16(%rbp), %eax
 201 014b 8D0C02   		leal	(%rdx,%rax), %ecx
 202 014e 8B45E4   		movl	-28(%rbp), %eax
 203 0151 8B55E0   		movl	-32(%rbp), %edx
 204 0154 01D0     		addl	%edx, %eax
 205 0156 31C1     		xorl	%eax, %ecx
 206 0158 89CA     		movl	%ecx, %edx
 207 015a 8B45E0   		movl	-32(%rbp), %eax
 208 015d C1E805   		shrl	$5, %eax
 209 0160 89C1     		movl	%eax, %ecx
 210 0162 8B45F4   		movl	-12(%rbp), %eax
 211 0165 01C8     		addl	%ecx, %eax
 212 0167 31D0     		xorl	%edx, %eax
 213 0169 0145DC   		addl	%eax, -36(%rbp)
  73:main.c        ****         v1 += ((v0 << 4) + k2) ^ (v0 + sum) ^ ((v0 >> 5) + k3);
 214              		.loc 1 73 0 discriminator 2
 215 016c 8B45DC   		movl	-36(%rbp), %eax
 216 016f C1E004   		sall	$4, %eax
 217 0172 89C2     		movl	%eax, %edx
 218 0174 8B45F8   		movl	-8(%rbp), %eax
 219 0177 8D0C02   		leal	(%rdx,%rax), %ecx
 220 017a 8B45E4   		movl	-28(%rbp), %eax
 221 017d 8B55DC   		movl	-36(%rbp), %edx
 222 0180 01D0     		addl	%edx, %eax
 223 0182 31C1     		xorl	%eax, %ecx
 224 0184 89CA     		movl	%ecx, %edx
 225 0186 8B45DC   		movl	-36(%rbp), %eax
 226 0189 C1E805   		shrl	$5, %eax
 227 018c 89C1     		movl	%eax, %ecx
 228 018e 8B45FC   		movl	-4(%rbp), %eax
 229 0191 01C8     		addl	%ecx, %eax
 230 0193 31D0     		xorl	%edx, %eax
 231 0195 0145E0   		addl	%eax, -32(%rbp)
  70:main.c        ****         sum += delta;
 232              		.loc 1 70 0 discriminator 2
 233 0198 8345E801 		addl	$1, -24(%rbp)
 234              	.L5:
  70:main.c        ****         sum += delta;
 235              		.loc 1 70 0 is_stmt 0 discriminator 1
 236 019c 837DE81F 		cmpl	$31, -24(%rbp)
 237 01a0 7698     		jbe	.L6
  74:main.c        ****     }
  75:main.c        ****     /* end cycle */
  76:main.c        ****     v[0] = v0;
 238              		.loc 1 76 0 is_stmt 1
 239 01a2 488B45C8 		movq	-56(%rbp), %rax
 240 01a6 8B55DC   		movl	-36(%rbp), %edx
 241 01a9 8910     		movl	%edx, (%rax)
  77:main.c        ****     v[1] = v1;
 242              		.loc 1 77 0
 243 01ab 488B45C8 		movq	-56(%rbp), %rax
 244 01af 488D5004 		leaq	4(%rax), %rdx
 245 01b3 8B45E0   		movl	-32(%rbp), %eax
 246 01b6 8902     		movl	%eax, (%rdx)
  78:main.c        **** }
 247              		.loc 1 78 0
 248 01b8 5D       		popq	%rbp
 249              		.cfi_def_cfa 7, 8
 250 01b9 C3       		ret
 251              		.cfi_endproc
 252              	.LFE7:
 254              		.globl	decrypt64
 256              	decrypt64:
 257              	.LFB8:
  79:main.c        **** 
  80:main.c        **** void decrypt64(uint32_t *inpData) {
 258              		.loc 1 80 0
 259              		.cfi_startproc
 260 01ba 55       		pushq	%rbp
 261              		.cfi_def_cfa_offset 16
 262              		.cfi_offset 6, -16
 263 01bb 4889E5   		movq	%rsp, %rbp
 264              		.cfi_def_cfa_register 6
 265 01be 4883EC18 		subq	$24, %rsp
 266 01c2 48897DE8 		movq	%rdi, -24(%rbp)
  81:main.c        ****     uint32_t key[4];
  82:main.c        ****     key[0] = 0x2927c18c;
 267              		.loc 1 82 0
 268 01c6 C745F08C 		movl	$690471308, -16(%rbp)
 268      C12729
  83:main.c        ****     key[1] = 0x75f8c48f;
 269              		.loc 1 83 0
 270 01cd C745F48F 		movl	$1979237519, -12(%rbp)
 270      C4F875
  84:main.c        ****     key[2] = 0x43fd99f7;
 271              		.loc 1 84 0
 272 01d4 C745F8F7 		movl	$1140693495, -8(%rbp)
 272      99FD43
  85:main.c        ****     key[3] = 0xff0f7457;
 273              		.loc 1 85 0
 274 01db C745FC57 		movl	$-15764393, -4(%rbp)
 274      740FFF
  86:main.c        ****     decrypt(inpData, key);
 275              		.loc 1 86 0
 276 01e2 488D55F0 		leaq	-16(%rbp), %rdx
 277 01e6 488B45E8 		movq	-24(%rbp), %rax
 278 01ea 4889D6   		movq	%rdx, %rsi
 279 01ed 4889C7   		movq	%rax, %rdi
 280 01f0 E8000000 		call	decrypt
 280      00
  87:main.c        **** }
 281              		.loc 1 87 0
 282 01f5 C9       		leave
 283              		.cfi_def_cfa 7, 8
 284 01f6 C3       		ret
 285              		.cfi_endproc
 286              	.LFE8:
 288              		.globl	encrypt64
 290              	encrypt64:
 291              	.LFB9:
  88:main.c        **** 
  89:main.c        **** void encrypt64(uint32_t *inpData) {
 292              		.loc 1 89 0
 293              		.cfi_startproc
 294 01f7 55       		pushq	%rbp
 295              		.cfi_def_cfa_offset 16
 296              		.cfi_offset 6, -16
 297 01f8 4889E5   		movq	%rsp, %rbp
 298              		.cfi_def_cfa_register 6
 299 01fb 4883EC18 		subq	$24, %rsp
 300 01ff 48897DE8 		movq	%rdi, -24(%rbp)
  90:main.c        ****     uint32_t key[4];
  91:main.c        ****     key[0] = 0x2927c18c;
 301              		.loc 1 91 0
 302 0203 C745F08C 		movl	$690471308, -16(%rbp)
 302      C12729
  92:main.c        ****     key[1] = 0x75f8c48f;
 303              		.loc 1 92 0
 304 020a C745F48F 		movl	$1979237519, -12(%rbp)
 304      C4F875
  93:main.c        ****     key[2] = 0x43fd99f7;
 305              		.loc 1 93 0
 306 0211 C745F8F7 		movl	$1140693495, -8(%rbp)
 306      99FD43
  94:main.c        ****     key[3] = 0xff0f7457;
 307              		.loc 1 94 0
 308 0218 C745FC57 		movl	$-15764393, -4(%rbp)
 308      740FFF
  95:main.c        ****     encrypt(inpData, key);
 309              		.loc 1 95 0
 310 021f 488D55F0 		leaq	-16(%rbp), %rdx
 311 0223 488B45E8 		movq	-24(%rbp), %rax
 312 0227 4889D6   		movq	%rdx, %rsi
 313 022a 4889C7   		movq	%rax, %rdi
 314 022d E8000000 		call	encrypt
 314      00
  96:main.c        **** }
 315              		.loc 1 96 0
 316 0232 C9       		leave
 317              		.cfi_def_cfa 7, 8
 318 0233 C3       		ret
 319              		.cfi_endproc
 320              	.LFE9:
 322              		.globl	myHash
 324              	myHash:
 325              	.LFB10:
  97:main.c        **** 
  98:main.c        **** uint16_t myHash(uint16_t befHash) {
 326              		.loc 1 98 0
 327              		.cfi_startproc
 328 0234 55       		pushq	%rbp
 329              		.cfi_def_cfa_offset 16
 330              		.cfi_offset 6, -16
 331 0235 4889E5   		movq	%rsp, %rbp
 332              		.cfi_def_cfa_register 6
 333 0238 89F8     		movl	%edi, %eax
 334 023a 668945EC 		movw	%ax, -20(%rbp)
  99:main.c        ****     uint16_t ret = 0;
 335              		.loc 1 99 0
 336 023e 66C745F8 		movw	$0, -8(%rbp)
 336      0000
 337              	.LBB2:
 100:main.c        ****     for (uint16_t i = 0; i <= 15; i++) {
 338              		.loc 1 100 0
 339 0244 66C745FA 		movw	$0, -6(%rbp)
 339      0000
 340 024a EB51     		jmp	.L10
 341              	.L12:
 101:main.c        ****         if ((befHash & (1 << i)) != 0) {
 342              		.loc 1 101 0
 343 024c 0FB755EC 		movzwl	-20(%rbp), %edx
 344 0250 0FB745FA 		movzwl	-6(%rbp), %eax
 345 0254 89C1     		movl	%eax, %ecx
 346 0256 D3FA     		sarl	%cl, %edx
 347 0258 89D0     		movl	%edx, %eax
 348 025a 83E001   		andl	$1, %eax
 349 025d 85C0     		testl	%eax, %eax
 350 025f 7431     		je	.L11
 351              	.LBB3:
 102:main.c        ****             uint16_t leftShift = (uint16_t)bankID % 16;
 352              		.loc 1 102 0
 353 0261 8B050000 		movl	bankID(%rip), %eax
 353      0000
 354 0267 83E00F   		andl	$15, %eax
 355 026a 668945FC 		movw	%ax, -4(%rbp)
 103:main.c        ****             uint16_t j = ((i + leftShift) % 16);
 356              		.loc 1 103 0
 357 026e 0FB745FC 		movzwl	-4(%rbp), %eax
 358 0272 0FB755FA 		movzwl	-6(%rbp), %edx
 359 0276 01D0     		addl	%edx, %eax
 360 0278 83E00F   		andl	$15, %eax
 361 027b 668945FE 		movw	%ax, -2(%rbp)
 104:main.c        ****             ret += (1 << j);
 362              		.loc 1 104 0
 363 027f 0FB745FE 		movzwl	-2(%rbp), %eax
 364 0283 BA010000 		movl	$1, %edx
 364      00
 365 0288 89C1     		movl	%eax, %ecx
 366 028a D3E2     		sall	%cl, %edx
 367 028c 89D0     		movl	%edx, %eax
 368 028e 660145F8 		addw	%ax, -8(%rbp)
 369              	.L11:
 370              	.LBE3:
 100:main.c        ****         if ((befHash & (1 << i)) != 0) {
 371              		.loc 1 100 0
 372 0292 0FB745FA 		movzwl	-6(%rbp), %eax
 373 0296 83C001   		addl	$1, %eax
 374 0299 668945FA 		movw	%ax, -6(%rbp)
 375              	.L10:
 100:main.c        ****         if ((befHash & (1 << i)) != 0) {
 376              		.loc 1 100 0 is_stmt 0 discriminator 1
 377 029d 66837DFA 		cmpw	$15, -6(%rbp)
 377      0F
 378 02a2 76A8     		jbe	.L12
 379              	.LBE2:
 105:main.c        ****         }
 106:main.c        ****     }
 107:main.c        ****     return ret;
 380              		.loc 1 107 0 is_stmt 1
 381 02a4 0FB745F8 		movzwl	-8(%rbp), %eax
 108:main.c        **** }
 382              		.loc 1 108 0
 383 02a8 5D       		popq	%rbp
 384              		.cfi_def_cfa 7, 8
 385 02a9 C3       		ret
 386              		.cfi_endproc
 387              	.LFE10:
 389              		.section	.rodata
 390              	.LC0:
 391 0000 2C00     		.string	","
 392              	.LC1:
 393 0002 256400   		.string	"%d"
 394              		.text
 395              		.globl	format
 397              	format:
 398              	.LFB11:
 109:main.c        **** 
 110:main.c        **** void format(char *line) {
 399              		.loc 1 110 0
 400              		.cfi_startproc
 401 02aa 55       		pushq	%rbp
 402              		.cfi_def_cfa_offset 16
 403              		.cfi_offset 6, -16
 404 02ab 4889E5   		movq	%rsp, %rbp
 405              		.cfi_def_cfa_register 6
 406 02ae 4883EC20 		subq	$32, %rsp
 407 02b2 48897DE8 		movq	%rdi, -24(%rbp)
 111:main.c        ****     char *wordPtr;
 112:main.c        ****     wordPtr = strtok(line, ",");
 408              		.loc 1 112 0
 409 02b6 488B45E8 		movq	-24(%rbp), %rax
 410 02ba BE000000 		movl	$.LC0, %esi
 410      00
 411 02bf 4889C7   		movq	%rax, %rdi
 412 02c2 E8000000 		call	strtok
 412      00
 413 02c7 488945F8 		movq	%rax, -8(%rbp)
 113:main.c        ****     int cnt = 0;
 414              		.loc 1 113 0
 415 02cb C745F400 		movl	$0, -12(%rbp)
 415      000000
 114:main.c        ****     while (wordPtr != NULL) {
 416              		.loc 1 114 0
 417 02d2 EB4D     		jmp	.L15
 418              	.L16:
 115:main.c        ****         sscanf(wordPtr, "%d", &dataFromCSV[numLines][cnt]);
 419              		.loc 1 115 0
 420 02d4 8B150000 		movl	numLines(%rip), %edx
 420      0000
 421 02da 8B45F4   		movl	-12(%rbp), %eax
 422 02dd 4898     		cltq
 423 02df 4863D2   		movslq	%edx, %rdx
 424 02e2 48C1E202 		salq	$2, %rdx
 425 02e6 4801D0   		addq	%rdx, %rax
 426 02e9 48C1E002 		salq	$2, %rax
 427 02ed 488D9000 		leaq	dataFromCSV(%rax), %rdx
 427      000000
 428 02f4 488B45F8 		movq	-8(%rbp), %rax
 429 02f8 BE000000 		movl	$.LC1, %esi
 429      00
 430 02fd 4889C7   		movq	%rax, %rdi
 431 0300 B8000000 		movl	$0, %eax
 431      00
 432 0305 E8000000 		call	sscanf
 432      00
 116:main.c        ****         wordPtr = strtok(NULL, ",");
 433              		.loc 1 116 0
 434 030a BE000000 		movl	$.LC0, %esi
 434      00
 435 030f BF000000 		movl	$0, %edi
 435      00
 436 0314 E8000000 		call	strtok
 436      00
 437 0319 488945F8 		movq	%rax, -8(%rbp)
 117:main.c        ****         cnt++;
 438              		.loc 1 117 0
 439 031d 8345F401 		addl	$1, -12(%rbp)
 440              	.L15:
 114:main.c        ****         sscanf(wordPtr, "%d", &dataFromCSV[numLines][cnt]);
 441              		.loc 1 114 0 discriminator 1
 442 0321 48837DF8 		cmpq	$0, -8(%rbp)
 442      00
 443 0326 75AC     		jne	.L16
 118:main.c        ****     }
 119:main.c        **** }
 444              		.loc 1 119 0
 445 0328 C9       		leave
 446              		.cfi_def_cfa 7, 8
 447 0329 C3       		ret
 448              		.cfi_endproc
 449              	.LFE11:
 451              		.globl	find
 453              	find:
 454              	.LFB12:
 120:main.c        **** 
 121:main.c        **** bool find(uint16_t userID, uint16_t hashedPin, bool *isAdmin, int *bal, int *inLineNum) {
 455              		.loc 1 121 0
 456              		.cfi_startproc
 457 032a 55       		pushq	%rbp
 458              		.cfi_def_cfa_offset 16
 459              		.cfi_offset 6, -16
 460 032b 4889E5   		movq	%rsp, %rbp
 461              		.cfi_def_cfa_register 6
 462 032e 89F0     		movl	%esi, %eax
 463 0330 488955E0 		movq	%rdx, -32(%rbp)
 464 0334 48894DD8 		movq	%rcx, -40(%rbp)
 465 0338 4C8945D0 		movq	%r8, -48(%rbp)
 466 033c 66897DEC 		movw	%di, -20(%rbp)
 467 0340 668945E8 		movw	%ax, -24(%rbp)
 122:main.c        ****     bool pos = false;
 468              		.loc 1 122 0
 469 0344 C645FB00 		movb	$0, -5(%rbp)
 470              	.LBB4:
 123:main.c        ****     for (int i = 1; i <= numLines; i++) {
 471              		.loc 1 123 0
 472 0348 C745FC01 		movl	$1, -4(%rbp)
 472      000000
 473 034f EB75     		jmp	.L18
 474              	.L22:
 124:main.c        ****         if (userID == (uint16_t) dataFromCSV[i][0] && hashedPin == (uint16_t) dataFromCSV[i][1]) {
 475              		.loc 1 124 0
 476 0351 8B45FC   		movl	-4(%rbp), %eax
 477 0354 4898     		cltq
 478 0356 48C1E004 		salq	$4, %rax
 479 035a 48050000 		addq	$dataFromCSV, %rax
 479      0000
 480 0360 8B00     		movl	(%rax), %eax
 481 0362 663B45EC 		cmpw	-20(%rbp), %ax
 482 0366 755A     		jne	.L19
 483              		.loc 1 124 0 is_stmt 0 discriminator 1
 484 0368 8B45FC   		movl	-4(%rbp), %eax
 485 036b 4898     		cltq
 486 036d 48C1E004 		salq	$4, %rax
 487 0371 48050000 		addq	$dataFromCSV+4, %rax
 487      0000
 488 0377 8B00     		movl	(%rax), %eax
 489 0379 663B45E8 		cmpw	-24(%rbp), %ax
 490 037d 7543     		jne	.L19
 125:main.c        ****             pos = true;
 491              		.loc 1 125 0 is_stmt 1
 492 037f C645FB01 		movb	$1, -5(%rbp)
 126:main.c        ****             if (dataFromCSV[i][2] == 1) *isAdmin = true;
 493              		.loc 1 126 0
 494 0383 8B45FC   		movl	-4(%rbp), %eax
 495 0386 4898     		cltq
 496 0388 48C1E004 		salq	$4, %rax
 497 038c 48050000 		addq	$dataFromCSV+8, %rax
 497      0000
 498 0392 8B00     		movl	(%rax), %eax
 499 0394 83F801   		cmpl	$1, %eax
 500 0397 7507     		jne	.L20
 501              		.loc 1 126 0 is_stmt 0 discriminator 1
 502 0399 488B45E0 		movq	-32(%rbp), %rax
 503 039d C60001   		movb	$1, (%rax)
 504              	.L20:
 127:main.c        ****             *bal = dataFromCSV[i][3];
 505              		.loc 1 127 0 is_stmt 1
 506 03a0 8B45FC   		movl	-4(%rbp), %eax
 507 03a3 4898     		cltq
 508 03a5 48C1E004 		salq	$4, %rax
 509 03a9 48050000 		addq	$dataFromCSV+12, %rax
 509      0000
 510 03af 8B10     		movl	(%rax), %edx
 511 03b1 488B45D8 		movq	-40(%rbp), %rax
 512 03b5 8910     		movl	%edx, (%rax)
 128:main.c        ****             *inLineNum = i;
 513              		.loc 1 128 0
 514 03b7 488B45D0 		movq	-48(%rbp), %rax
 515 03bb 8B55FC   		movl	-4(%rbp), %edx
 516 03be 8910     		movl	%edx, (%rax)
 129:main.c        ****             break;
 517              		.loc 1 129 0
 518 03c0 EB0F     		jmp	.L21
 519              	.L19:
 123:main.c        ****         if (userID == (uint16_t) dataFromCSV[i][0] && hashedPin == (uint16_t) dataFromCSV[i][1]) {
 520              		.loc 1 123 0
 521 03c2 8345FC01 		addl	$1, -4(%rbp)
 522              	.L18:
 123:main.c        ****         if (userID == (uint16_t) dataFromCSV[i][0] && hashedPin == (uint16_t) dataFromCSV[i][1]) {
 523              		.loc 1 123 0 is_stmt 0 discriminator 1
 524 03c6 8B050000 		movl	numLines(%rip), %eax
 524      0000
 525 03cc 3945FC   		cmpl	%eax, -4(%rbp)
 526 03cf 7E80     		jle	.L22
 527              	.L21:
 528              	.LBE4:
 130:main.c        ****         }
 131:main.c        ****     }
 132:main.c        ****     return pos;
 529              		.loc 1 132 0 is_stmt 1
 530 03d1 0FB645FB 		movzbl	-5(%rbp), %eax
 133:main.c        **** }
 531              		.loc 1 133 0
 532 03d5 5D       		popq	%rbp
 533              		.cfi_def_cfa 7, 8
 534 03d6 C3       		ret
 535              		.cfi_endproc
 536              	.LFE12:
 538              		.globl	suffBalUser
 540              	suffBalUser:
 541              	.LFB13:
 134:main.c        **** 
 135:main.c        **** bool suffBalUser(int bal, int *reqAmo) {
 542              		.loc 1 135 0
 543              		.cfi_startproc
 544 03d7 55       		pushq	%rbp
 545              		.cfi_def_cfa_offset 16
 546              		.cfi_offset 6, -16
 547 03d8 4889E5   		movq	%rsp, %rbp
 548              		.cfi_def_cfa_register 6
 549 03db 897DEC   		movl	%edi, -20(%rbp)
 550 03de 488975E0 		movq	%rsi, -32(%rbp)
 136:main.c        ****     bool hasSuffBal = true;
 551              		.loc 1 136 0
 552 03e2 C645FF01 		movb	$1, -1(%rbp)
 137:main.c        ****     if (*reqAmo > bal) hasSuffBal = false;
 553              		.loc 1 137 0
 554 03e6 488B45E0 		movq	-32(%rbp), %rax
 555 03ea 8B00     		movl	(%rax), %eax
 556 03ec 3B45EC   		cmpl	-20(%rbp), %eax
 557 03ef 7E04     		jle	.L25
 558              		.loc 1 137 0 is_stmt 0 discriminator 1
 559 03f1 C645FF00 		movb	$0, -1(%rbp)
 560              	.L25:
 138:main.c        ****     return hasSuffBal;
 561              		.loc 1 138 0 is_stmt 1
 562 03f5 0FB645FF 		movzbl	-1(%rbp), %eax
 139:main.c        **** }
 563              		.loc 1 139 0
 564 03f9 5D       		popq	%rbp
 565              		.cfi_def_cfa 7, 8
 566 03fa C3       		ret
 567              		.cfi_endproc
 568              	.LFE13:
 570              		.section	.rodata
 571              	.LC2:
 572 0005 556E7061 		.string	"Unparseable hex number"
 572      72736561 
 572      626C6520 
 572      68657820 
 572      6E756D62 
 573              	.LC3:
 574 001c 4368616E 		.string	"Channel out of range"
 574      6E656C20 
 574      6F757420 
 574      6F662072 
 574      616E6765 
 575              	.LC4:
 576 0031 436F6E64 		.string	"Conduit out of range"
 576      75697420 
 576      6F757420 
 576      6F662072 
 576      616E6765 
 577              	.LC5:
 578 0046 496C6C65 		.string	"Illegal character"
 578      67616C20 
 578      63686172 
 578      61637465 
 578      7200
 579              	.LC6:
 580 0058 556E7465 		.string	"Unterminated string"
 580      726D696E 
 580      61746564 
 580      20737472 
 580      696E6700 
 581              	.LC7:
 582 006c 4E6F206D 		.string	"No memory"
 582      656D6F72 
 582      7900
 583              	.LC8:
 584 0076 456D7074 		.string	"Empty string"
 584      79207374 
 584      72696E67 
 584      00
 585              	.LC9:
 586 0083 4F646420 		.string	"Odd number of digits"
 586      6E756D62 
 586      6572206F 
 586      66206469 
 586      67697473 
 587              	.LC10:
 588 0098 43616E6E 		.string	"Cannot load file"
 588      6F74206C 
 588      6F616420 
 588      66696C65 
 588      00
 589              	.LC11:
 590 00a9 43616E6E 		.string	"Cannot save file"
 590      6F742073 
 590      61766520 
 590      66696C65 
 590      00
 591              	.LC12:
 592 00ba 42616420 		.string	"Bad arguments"
 592      61726775 
 592      6D656E74 
 592      7300
 593 00c8 00000000 		.align 32
 593      00000000 
 593      00000000 
 593      00000000 
 593      00000000 
 596              	errMessages:
 597 00e0 00000000 		.quad	0
 597      00000000 
 598 00e8 00000000 		.quad	0
 598      00000000 
 599 00f0 00000000 		.quad	.LC2
 599      00000000 
 600 00f8 00000000 		.quad	.LC3
 600      00000000 
 601 0100 00000000 		.quad	.LC4
 601      00000000 
 602 0108 00000000 		.quad	.LC5
 602      00000000 
 603 0110 00000000 		.quad	.LC6
 603      00000000 
 604 0118 00000000 		.quad	.LC7
 604      00000000 
 605 0120 00000000 		.quad	.LC8
 605      00000000 
 606 0128 00000000 		.quad	.LC9
 606      00000000 
 607 0130 00000000 		.quad	.LC10
 607      00000000 
 608 0138 00000000 		.quad	.LC11
 608      00000000 
 609 0140 00000000 		.quad	.LC12
 609      00000000 
 610              		.align 8
 611              	.LC13:
 612 0148 20202020 		.string	"            vendor ID and product ID (e.g 04B4:8613)"
 612      20202020 
 612      20202020 
 612      76656E64 
 612      6F722049 
 613              	.LC14:
 614 017d 3C564944 		.string	"<VID:PID>"
 614      3A504944 
 614      3E00
 615              	.LC15:
 616 0187 69767000 		.string	"ivp"
 617              	.LC16:
 618 018b 6900     		.string	"i"
 619 018d 000000   		.align 8
 620              	.LC17:
 621 0190 20202020 		.string	"       VID, PID and opt. dev ID (e.g 1D50:602B:0001)"
 621      20202056 
 621      49442C20 
 621      50494420 
 621      616E6420 
 622              	.LC18:
 623 01c5 3C564944 		.string	"<VID:PID[:DID]>"
 623      3A504944 
 623      5B3A4449 
 623      445D3E00 
 624              	.LC19:
 625 01d5 767000   		.string	"vp"
 626              	.LC20:
 627 01d8 7600     		.string	"v"
 628 01da 00000000 		.align 8
 628      0000
 629              	.LC21:
 630 01e0 20202020 		.string	"                    sets bank id"
 630      20202020 
 630      20202020 
 630      20202020 
 630      20202020 
 631              	.LC22:
 632 0201 62616E6B 		.string	"bank id in decimal"
 632      20696420 
 632      696E2064 
 632      6563696D 
 632      616C00
 633              	.LC23:
 634 0214 62696400 		.string	"bid"
 635              	.LC24:
 636 0218 6200     		.string	"b"
 637 021a 00000000 		.align 8
 637      0000
 638              	.LC25:
 639 0220 20202020 		.string	"                    starts atm service"
 639      20202020 
 639      20202020 
 639      20202020 
 639      20202020 
 640              	.LC26:
 641 0247 61746D00 		.string	"atm"
 642              	.LC27:
 643 024b 7900     		.string	"y"
 644 024d 000000   		.align 8
 645              	.LC28:
 646 0250 20202020 		.string	"        gives log on more events"
 646      20202020 
 646      67697665 
 646      73206C6F 
 646      67206F6E 
 647              	.LC29:
 648 0271 6C6F6700 		.string	"log"
 649              	.LC30:
 650 0275 6C00     		.string	"l"
 651 0277 00       		.align 8
 652              	.LC31:
 653 0278 20202020 		.string	"                     print this help and exit"
 653      20202020 
 653      20202020 
 653      20202020 
 653      20202020 
 654              	.LC32:
 655 02a6 68656C70 		.string	"help"
 655      00
 656              	.LC33:
 657 02ab 6800     		.string	"h"
 658              	.LC34:
 659 02ad 666C636C 		.string	"flcli"
 659      6900
 660              	.LC35:
 661 02b3 25733A20 		.string	"%s: insufficient memory\n"
 661      696E7375 
 661      66666963 
 661      69656E74 
 661      206D656D 
 662              	.LC36:
 663 02cc 496E7661 		.string	"Invalid bankID"
 663      6C696420 
 663      62616E6B 
 663      494400
 664 02db 00000000 		.align 8
 664      00
 665              	.LC37:
 666 02e0 46504741 		.string	"FPGALink Command-Line Interface Copyright (C) 2017 Jarvis \n\n Usage: %s"
 666      4C696E6B 
 666      20436F6D 
 666      6D616E64 
 666      2D4C696E 
 667              	.LC38:
 668 0327 0A00     		.string	"\n"
 669 0329 00000000 		.align 8
 669      000000
 670              	.LC39:
 671 0330 0A496E74 		.string	"\nInteract with an FPGALink device.\n"
 671      65726163 
 671      74207769 
 671      74682061 
 671      6E204650 
 672              	.LC40:
 673 0354 2020252D 		.string	"  %-10s %s\n"
 673      31307320 
 673      25730A00 
 674              		.align 8
 675              	.LC41:
 676 0360 54727920 		.string	"Try '%s --help' for more information.\n"
 676      27257320 
 676      2D2D6865 
 676      6C702720 
 676      666F7220 
 677 0387 00       		.align 8
 678              	.LC42:
 679 0388 41747465 		.string	"Attempting to open connection to FPGALink device %s...\n"
 679      6D707469 
 679      6E672074 
 679      6F206F70 
 679      656E2063 
 680              	.LC43:
 681 03c0 4C6F6164 		.string	"Loading firmware into %s...\n"
 681      696E6720 
 681      6669726D 
 681      77617265 
 681      20696E74 
 682              	.LC44:
 683 03dd 41776169 		.string	"Awaiting renumeration"
 683      74696E67 
 683      2072656E 
 683      756D6572 
 683      6174696F 
 684 03f3 00000000 		.align 8
 684      00
 685              	.LC45:
 686 03f8 46504741 		.string	"FPGALink device did not renumerate properly as %s\n"
 686      4C696E6B 
 686      20646576 
 686      69636520 
 686      64696420 
 687 042b 00000000 		.align 8
 687      00
 688              	.LC46:
 689 0430 41747465 		.string	"Attempting to open connection to FPGLink device %s again...\n"
 689      6D707469 
 689      6E672074 
 689      6F206F70 
 689      656E2063 
 690 046d 000000   		.align 8
 691              	.LC47:
 692 0470 436F756C 		.string	"Could not open FPGALink device at %s and no initial VID:PID was supplied\n"
 692      64206E6F 
 692      74206F70 
 692      656E2046 
 692      5047414C 
 693 04ba 00000000 		.align 8
 693      0000
 694              	.LC48:
 695 04c0 436F6E6E 		.string	"Connected to FPGALink device %s (firmwareID: 0x%04X, firmwareVersion: 0x%08X)\n"
 695      65637465 
 695      6420746F 
 695      20465047 
 695      414C696E 
 696              	.LC49:
 697 050f 722B00   		.string	"r+"
 698              	.LC50:
 699 0512 53616D70 		.string	"SampleBackEndDatabase.csv"
 699      6C654261 
 699      636B456E 
 699      64446174 
 699      61626173 
 700              	.LC51:
 701 052c 43737620 		.string	"Csv doesn't exist "
 701      646F6573 
 701      6E277420 
 701      65786973 
 701      742000
 702              	.LC52:
 703 053f 52656164 		.string	"Read from channel 0 = %u \n"
 703      2066726F 
 703      6D206368 
 703      616E6E65 
 703      6C203020 
 704              	.LC53:
 705 055a 52656164 		.string	"Read from channel %u = %u \n"
 705      2066726F 
 705      6D206368 
 705      616E6E65 
 705      6C202575 
 706              	.LC54:
 707 0576 56616C69 		.string	"Valid user found "
 707      64207573 
 707      65722066 
 707      6F756E64 
 707      2000
 708              	.LC55:
 709 0588 62616C20 		.string	"bal %u\n"
 709      25750A00 
 710              	.LC56:
 711 0590 72657120 		.string	"req %u\n"
 711      25750A00 
 712              	.LC57:
 713 0598 53756666 		.string	"Sufficient Balance in account"
 713      69636965 
 713      6E742042 
 713      616C616E 
 713      63652069 
 714              	.LC58:
 715 05b6 57726974 		.string	"Write to channel %u = %u \n"
 715      6520746F 
 715      20636861 
 715      6E6E656C 
 715      20257520 
 716              	.LC59:
 717 05d1 772B00   		.string	"w+"
 718 05d4 00000000 		.align 8
 719              	.LC60:
 720 05d8 22557365 		.string	"\"User ID (decimal)\",\"PIN Hash (decimal)\",\"Admin\",\"Balance (decimal)\""
 720      72204944 
 720      20286465 
 720      63696D61 
 720      6C29222C 
 721              	.LC61:
 722 061d 496E7375 		.string	"Insufficient Balance "
 722      66666963 
 722      69656E74 
 722      2042616C 
 722      616E6365 
 723              	.LC62:
 724 0633 55736572 		.string	"User has admin privileges "
 724      20686173 
 724      2061646D 
 724      696E2070 
 724      72697669 
 725              	.LC63:
 726 064e 6E756D5F 		.string	"num_2000_admin %u\n"
 726      32303030 
 726      5F61646D 
 726      696E2025 
 726      750A00
 727              	.LC64:
 728 0661 6E756D5F 		.string	"num_1000_admin %u\n"
 728      31303030 
 728      5F61646D 
 728      696E2025 
 728      750A00
 729              	.LC65:
 730 0674 6E756D5F 		.string	"num_500_admin %u\n"
 730      3530305F 
 730      61646D69 
 730      6E202575 
 730      0A00
 731              	.LC66:
 732 0686 6E756D5F 		.string	"num_100_admin %u\n"
 732      3130305F 
 732      61646D69 
 732      6E202575 
 732      0A00
 733              	.LC67:
 734 0698 496E7661 		.string	"Invalid user "
 734      6C696420 
 734      75736572 
 734      2000
 735 06a6 0000     		.align 8
 736              	.LC68:
 737 06a8 54686520 		.string	"The FPGALink device at %s is not ready to talk - did you forget --program?\n"
 737      46504741 
 737      4C696E6B 
 737      20646576 
 737      69636520 
 738 06f4 00000000 		.align 8
 739              	.LC69:
 740 06f8 41637469 		.string	"Action requested but device at %s does not support CommFPGA\n"
 740      6F6E2072 
 740      65717565 
 740      73746564 
 740      20627574 
 741              	.LC70:
 742 0735 25730A00 		.string	"%s\n"
 743              		.text
 744              		.globl	main
 746              	main:
 747              	.LFB14:
 140:main.c        **** 
 141:main.c        **** static const char *const errMessages[] = {
 142:main.c        ****         NULL,
 143:main.c        ****         NULL,
 144:main.c        ****         "Unparseable hex number",
 145:main.c        ****         "Channel out of range",
 146:main.c        ****         "Conduit out of range",
 147:main.c        ****         "Illegal character",
 148:main.c        ****         "Unterminated string",
 149:main.c        ****         "No memory",
 150:main.c        ****         "Empty string",
 151:main.c        ****         "Odd number of digits",
 152:main.c        ****         "Cannot load file",
 153:main.c        ****         "Cannot save file",
 154:main.c        ****         "Bad arguments"
 155:main.c        **** };
 156:main.c        **** 
 157:main.c        **** typedef enum {
 158:main.c        ****     FLP_SUCCESS,
 159:main.c        ****     FLP_LIBERR,
 160:main.c        ****     FLP_BAD_HEX,
 161:main.c        ****     FLP_CHAN_RANGE,
 162:main.c        ****     FLP_CONDUIT_RANGE,
 163:main.c        ****     FLP_ILL_CHAR,
 164:main.c        ****     FLP_UNTERM_STRING,
 165:main.c        ****     FLP_NO_MEMORY,
 166:main.c        ****     FLP_EMPTY_STRING,
 167:main.c        ****     FLP_ODD_DIGITS,
 168:main.c        ****     FLP_CANNOT_LOAD,
 169:main.c        ****     FLP_CANNOT_SAVE,
 170:main.c        ****     FLP_ARGS
 171:main.c        **** } ReturnCode;
 172:main.c        **** 
 173:main.c        **** int main(int argc, char *argv[]) {
 748              		.loc 1 173 0
 749              		.cfi_startproc
 750 03fb 55       		pushq	%rbp
 751              		.cfi_def_cfa_offset 16
 752              		.cfi_offset 6, -16
 753 03fc 4889E5   		movq	%rsp, %rbp
 754              		.cfi_def_cfa_register 6
 755 03ff 53       		pushq	%rbx
 756 0400 4881EC78 		subq	$376, %rsp
 756      010000
 757              		.cfi_offset 3, -24
 758 0407 89BD8CFE 		movl	%edi, -372(%rbp)
 758      FFFF
 759 040d 4889B580 		movq	%rsi, -384(%rbp)
 759      FEFFFF
 174:main.c        ****     ReturnCode retVal = FLP_SUCCESS;
 760              		.loc 1 174 0
 761 0414 C785C0FE 		movl	$0, -320(%rbp)
 761      FFFF0000 
 761      0000
 175:main.c        **** 
 176:main.c        ****     struct arg_str *ivpOpt = arg_str0("i", "ivp", "<VID:PID>", "            vendor ID and product I
 762              		.loc 1 176 0
 763 041e B9000000 		movl	$.LC13, %ecx
 763      00
 764 0423 BA000000 		movl	$.LC14, %edx
 764      00
 765 0428 BE000000 		movl	$.LC15, %esi
 765      00
 766 042d BF000000 		movl	$.LC16, %edi
 766      00
 767 0432 E8000000 		call	arg_str0
 767      00
 768 0437 48898538 		movq	%rax, -200(%rbp)
 768      FFFFFF
 177:main.c        ****     struct arg_str *vpOpt = arg_str1("v", "vp", "<VID:PID[:DID]>", "       VID, PID and opt. dev ID
 769              		.loc 1 177 0
 770 043e B9000000 		movl	$.LC17, %ecx
 770      00
 771 0443 BA000000 		movl	$.LC18, %edx
 771      00
 772 0448 BE000000 		movl	$.LC19, %esi
 772      00
 773 044d BF000000 		movl	$.LC20, %edi
 773      00
 774 0452 E8000000 		call	arg_str1
 774      00
 775 0457 48898540 		movq	%rax, -192(%rbp)
 775      FFFFFF
 178:main.c        ****     struct arg_str *bankIdOpt = arg_str0("b", "bid", "bank id in decimal", "                    set
 776              		.loc 1 178 0
 777 045e B9000000 		movl	$.LC21, %ecx
 777      00
 778 0463 BA000000 		movl	$.LC22, %edx
 778      00
 779 0468 BE000000 		movl	$.LC23, %esi
 779      00
 780 046d BF000000 		movl	$.LC24, %edi
 780      00
 781 0472 E8000000 		call	arg_str0
 781      00
 782 0477 48898548 		movq	%rax, -184(%rbp)
 782      FFFFFF
 179:main.c        ****     struct arg_lit *loopOpt = arg_lit0("y", "atm", "                    starts atm service");
 783              		.loc 1 179 0
 784 047e BA000000 		movl	$.LC25, %edx
 784      00
 785 0483 BE000000 		movl	$.LC26, %esi
 785      00
 786 0488 BF000000 		movl	$.LC27, %edi
 786      00
 787 048d E8000000 		call	arg_lit0
 787      00
 788 0492 48898550 		movq	%rax, -176(%rbp)
 788      FFFFFF
 180:main.c        ****     struct arg_lit *verboseOpt = arg_lit0("l", "log", "        gives log on more events");
 789              		.loc 1 180 0
 790 0499 BA000000 		movl	$.LC28, %edx
 790      00
 791 049e BE000000 		movl	$.LC29, %esi
 791      00
 792 04a3 BF000000 		movl	$.LC30, %edi
 792      00
 793 04a8 E8000000 		call	arg_lit0
 793      00
 794 04ad 48898558 		movq	%rax, -168(%rbp)
 794      FFFFFF
 181:main.c        ****     struct arg_lit *helpOpt = arg_lit0("h", "help", "                     print this help and exit"
 795              		.loc 1 181 0
 796 04b4 BA000000 		movl	$.LC31, %edx
 796      00
 797 04b9 BE000000 		movl	$.LC32, %esi
 797      00
 798 04be BF000000 		movl	$.LC33, %edi
 798      00
 799 04c3 E8000000 		call	arg_lit0
 799      00
 800 04c8 48898560 		movq	%rax, -160(%rbp)
 800      FFFFFF
 182:main.c        ****     struct arg_end *endOpt = arg_end(20);
 801              		.loc 1 182 0
 802 04cf BF140000 		movl	$20, %edi
 802      00
 803 04d4 E8000000 		call	arg_end
 803      00
 804 04d9 48898568 		movq	%rax, -152(%rbp)
 804      FFFFFF
 183:main.c        **** 
 184:main.c        ****     void *argTable[] = {
 805              		.loc 1 184 0
 806 04e0 488B8538 		movq	-200(%rbp), %rax
 806      FFFFFF
 807 04e7 488945B0 		movq	%rax, -80(%rbp)
 808 04eb 488B8540 		movq	-192(%rbp), %rax
 808      FFFFFF
 809 04f2 488945B8 		movq	%rax, -72(%rbp)
 810 04f6 488B8548 		movq	-184(%rbp), %rax
 810      FFFFFF
 811 04fd 488945C0 		movq	%rax, -64(%rbp)
 812 0501 488B8550 		movq	-176(%rbp), %rax
 812      FFFFFF
 813 0508 488945C8 		movq	%rax, -56(%rbp)
 814 050c 488B8558 		movq	-168(%rbp), %rax
 814      FFFFFF
 815 0513 488945D0 		movq	%rax, -48(%rbp)
 816 0517 488B8560 		movq	-160(%rbp), %rax
 816      FFFFFF
 817 051e 488945D8 		movq	%rax, -40(%rbp)
 818 0522 488B8568 		movq	-152(%rbp), %rax
 818      FFFFFF
 819 0529 488945E0 		movq	%rax, -32(%rbp)
 185:main.c        ****             ivpOpt,
 186:main.c        ****             vpOpt,
 187:main.c        ****             bankIdOpt,
 188:main.c        ****             loopOpt,
 189:main.c        ****             verboseOpt,
 190:main.c        ****             helpOpt,
 191:main.c        ****             endOpt
 192:main.c        ****     };
 193:main.c        **** 
 194:main.c        ****     const char *progName = "flcli";
 820              		.loc 1 194 0
 821 052d 48C78570 		movq	$.LC34, -144(%rbp)
 821      FFFFFF00 
 821      000000
 195:main.c        ****     int numErrors;
 196:main.c        ****     struct FLContext *handle = NULL;
 822              		.loc 1 196 0
 823 0538 48C78518 		movq	$0, -232(%rbp)
 823      FFFFFF00 
 823      000000
 197:main.c        ****     FLStatus fStatus;
 198:main.c        ****     const char *error = NULL;
 824              		.loc 1 198 0
 825 0543 48C78520 		movq	$0, -224(%rbp)
 825      FFFFFF00 
 825      000000
 199:main.c        ****     const char *ivp = NULL;
 826              		.loc 1 199 0
 827 054e 48C78578 		movq	$0, -136(%rbp)
 827      FFFFFF00 
 827      000000
 200:main.c        ****     const char *vp = NULL;
 828              		.loc 1 200 0
 829 0559 48C74580 		movq	$0, -128(%rbp)
 829      00000000 
 201:main.c        ****     bool isCommCapable;
 202:main.c        ****     const char *line = NULL;
 830              		.loc 1 202 0
 831 0561 48C74588 		movq	$0, -120(%rbp)
 831      00000000 
 203:main.c        ****     uint8 conduit = 0x01;
 832              		.loc 1 203 0
 833 0569 C685A5FE 		movb	$1, -347(%rbp)
 833      FFFF01
 204:main.c        **** 
 205:main.c        ****     if (arg_nullcheck(argTable) != 0) {
 834              		.loc 1 205 0
 835 0570 488D45B0 		leaq	-80(%rbp), %rax
 836 0574 4889C7   		movq	%rax, %rdi
 837 0577 E8000000 		call	arg_nullcheck
 837      00
 838 057c 85C0     		testl	%eax, %eax
 839 057e 742F     		je	.L28
 206:main.c        ****         fprintf(stderr, "%s: insufficient memory\n", progName);
 840              		.loc 1 206 0
 841 0580 488B0500 		movq	stderr(%rip), %rax
 841      000000
 842 0587 488B9570 		movq	-144(%rbp), %rdx
 842      FFFFFF
 843 058e BE000000 		movl	$.LC35, %esi
 843      00
 844 0593 4889C7   		movq	%rax, %rdi
 845 0596 B8000000 		movl	$0, %eax
 845      00
 846 059b E8000000 		call	fprintf
 846      00
 207:main.c        ****         FAIL(1, cleanup);
 847              		.loc 1 207 0
 848 05a0 C785C0FE 		movl	$1, -320(%rbp)
 848      FFFF0100 
 848      0000
 849 05aa E98D1700 		jmp	.L29
 849      00
 850              	.L28:
 208:main.c        ****     }
 209:main.c        **** 
 210:main.c        ****     numErrors = arg_parse(argc, argv, argTable);
 851              		.loc 1 210 0
 852 05af 488D55B0 		leaq	-80(%rbp), %rdx
 853 05b3 488B8D80 		movq	-384(%rbp), %rcx
 853      FEFFFF
 854 05ba 8B858CFE 		movl	-372(%rbp), %eax
 854      FFFF
 855 05c0 4889CE   		movq	%rcx, %rsi
 856 05c3 89C7     		movl	%eax, %edi
 857 05c5 E8000000 		call	arg_parse
 857      00
 858 05ca 8985ECFE 		movl	%eax, -276(%rbp)
 858      FFFF
 211:main.c        **** 
 212:main.c        ****     if (verboseOpt->count > 0) {
 859              		.loc 1 212 0
 860 05d0 488B8558 		movq	-168(%rbp), %rax
 860      FFFFFF
 861 05d7 8B4060   		movl	96(%rax), %eax
 862 05da 85C0     		testl	%eax, %eax
 863 05dc 7E07     		jle	.L30
 213:main.c        ****         LOG = true;
 864              		.loc 1 213 0
 865 05de C6050000 		movb	$1, LOG(%rip)
 865      000001
 866              	.L30:
 214:main.c        ****     }
 215:main.c        **** 
 216:main.c        ****     if (bankIdOpt->count > 0) {
 867              		.loc 1 216 0
 868 05e5 488B8548 		movq	-184(%rbp), %rax
 868      FFFFFF
 869 05ec 8B4060   		movl	96(%rax), %eax
 870 05ef 85C0     		testl	%eax, %eax
 871 05f1 7E45     		jle	.L31
 217:main.c        ****         bankID = atoi(bankIdOpt->sval[0]);
 872              		.loc 1 217 0
 873 05f3 488B8548 		movq	-184(%rbp), %rax
 873      FFFFFF
 874 05fa 488B4068 		movq	104(%rax), %rax
 875 05fe 488B00   		movq	(%rax), %rax
 876 0601 4889C7   		movq	%rax, %rdi
 877 0604 E8000000 		call	atoi
 877      00
 878 0609 89050000 		movl	%eax, bankID(%rip)
 878      0000
 218:main.c        ****         if(bankID < 0 || bankID > 31) {
 879              		.loc 1 218 0
 880 060f 8B050000 		movl	bankID(%rip), %eax
 880      0000
 881 0615 85C0     		testl	%eax, %eax
 882 0617 780B     		js	.L32
 883              		.loc 1 218 0 is_stmt 0 discriminator 1
 884 0619 8B050000 		movl	bankID(%rip), %eax
 884      0000
 885 061f 83F81F   		cmpl	$31, %eax
 886 0622 7E14     		jle	.L31
 887              	.L32:
 219:main.c        ****             printf("%s\n", "Invalid bankID");
 888              		.loc 1 219 0 is_stmt 1
 889 0624 BF000000 		movl	$.LC36, %edi
 889      00
 890 0629 E8000000 		call	puts
 890      00
 220:main.c        ****             return 0;
 891              		.loc 1 220 0
 892 062e B8000000 		movl	$0, %eax
 892      00
 893 0633 E9601700 		jmp	.L166
 893      00
 894              	.L31:
 221:main.c        ****         }
 222:main.c        ****     }
 223:main.c        **** 
 224:main.c        ****     if (helpOpt->count > 0) {
 895              		.loc 1 224 0
 896 0638 488B8560 		movq	-160(%rbp), %rax
 896      FFFFFF
 897 063f 8B4060   		movl	96(%rax), %eax
 898 0642 85C0     		testl	%eax, %eax
 899 0644 7E68     		jle	.L34
 225:main.c        ****         printf("FPGALink Command-Line Interface Copyright (C) 2017 Jarvis \n\n Usage: %s", progName
 900              		.loc 1 225 0
 901 0646 488B8570 		movq	-144(%rbp), %rax
 901      FFFFFF
 902 064d 4889C6   		movq	%rax, %rsi
 903 0650 BF000000 		movl	$.LC37, %edi
 903      00
 904 0655 B8000000 		movl	$0, %eax
 904      00
 905 065a E8000000 		call	printf
 905      00
 226:main.c        ****         arg_print_syntax(stdout, argTable, "\n");
 906              		.loc 1 226 0
 907 065f 488B0500 		movq	stdout(%rip), %rax
 907      000000
 908 0666 488D4DB0 		leaq	-80(%rbp), %rcx
 909 066a BA000000 		movl	$.LC38, %edx
 909      00
 910 066f 4889CE   		movq	%rcx, %rsi
 911 0672 4889C7   		movq	%rax, %rdi
 912 0675 E8000000 		call	arg_print_syntax
 912      00
 227:main.c        ****         printf("\nInteract with an FPGALink device.\n\n");
 913              		.loc 1 227 0
 914 067a BF000000 		movl	$.LC39, %edi
 914      00
 915 067f E8000000 		call	puts
 915      00
 228:main.c        ****         arg_print_glossary(stdout, argTable, "  %-10s %s\n");
 916              		.loc 1 228 0
 917 0684 488B0500 		movq	stdout(%rip), %rax
 917      000000
 918 068b 488D4DB0 		leaq	-80(%rbp), %rcx
 919 068f BA000000 		movl	$.LC40, %edx
 919      00
 920 0694 4889CE   		movq	%rcx, %rsi
 921 0697 4889C7   		movq	%rax, %rdi
 922 069a E8000000 		call	arg_print_glossary
 922      00
 229:main.c        ****         FAIL(FLP_SUCCESS, cleanup);
 923              		.loc 1 229 0
 924 069f C785C0FE 		movl	$0, -320(%rbp)
 924      FFFF0000 
 924      0000
 925 06a9 E98E1600 		jmp	.L29
 925      00
 926              	.L34:
 230:main.c        ****     }
 231:main.c        **** 
 232:main.c        ****     if (numErrors > 0) {
 927              		.loc 1 232 0
 928 06ae 83BDECFE 		cmpl	$0, -276(%rbp)
 928      FFFF00
 929 06b5 7E4F     		jle	.L35
 233:main.c        ****         arg_print_errors(stdout, endOpt, progName);
 930              		.loc 1 233 0
 931 06b7 488B0500 		movq	stdout(%rip), %rax
 931      000000
 932 06be 488B9570 		movq	-144(%rbp), %rdx
 932      FFFFFF
 933 06c5 488B8D68 		movq	-152(%rbp), %rcx
 933      FFFFFF
 934 06cc 4889CE   		movq	%rcx, %rsi
 935 06cf 4889C7   		movq	%rax, %rdi
 936 06d2 E8000000 		call	arg_print_errors
 936      00
 234:main.c        ****         fprintf(stderr, "Try '%s --help' for more information.\n", progName);
 937              		.loc 1 234 0
 938 06d7 488B0500 		movq	stderr(%rip), %rax
 938      000000
 939 06de 488B9570 		movq	-144(%rbp), %rdx
 939      FFFFFF
 940 06e5 BE000000 		movl	$.LC41, %esi
 940      00
 941 06ea 4889C7   		movq	%rax, %rdi
 942 06ed B8000000 		movl	$0, %eax
 942      00
 943 06f2 E8000000 		call	fprintf
 943      00
 235:main.c        ****         FAIL(FLP_ARGS, cleanup);
 944              		.loc 1 235 0
 945 06f7 C785C0FE 		movl	$12, -320(%rbp)
 945      FFFF0C00 
 945      0000
 946 0701 E9361600 		jmp	.L29
 946      00
 947              	.L35:
 236:main.c        ****     }
 237:main.c        **** 
 238:main.c        ****     fStatus = flInitialise(0, &error);
 948              		.loc 1 238 0
 949 0706 488D8520 		leaq	-224(%rbp), %rax
 949      FFFFFF
 950 070d 4889C6   		movq	%rax, %rsi
 951 0710 BF000000 		movl	$0, %edi
 951      00
 952 0715 E8000000 		call	flInitialise
 952      00
 953 071a 8985F0FE 		movl	%eax, -272(%rbp)
 953      FFFF
 239:main.c        ****     CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 954              		.loc 1 239 0
 955 0720 83BDF0FE 		cmpl	$0, -272(%rbp)
 955      FFFF00
 956 0727 740F     		je	.L36
 957              		.loc 1 239 0 is_stmt 0 discriminator 1
 958 0729 C785C0FE 		movl	$1, -320(%rbp)
 958      FFFF0100 
 958      0000
 959 0733 E9041600 		jmp	.L29
 959      00
 960              	.L36:
 240:main.c        **** 
 241:main.c        ****     vp = vpOpt->sval[0];
 961              		.loc 1 241 0 is_stmt 1
 962 0738 488B8540 		movq	-192(%rbp), %rax
 962      FFFFFF
 963 073f 488B4068 		movq	104(%rax), %rax
 964 0743 488B00   		movq	(%rax), %rax
 965 0746 48894580 		movq	%rax, -128(%rbp)
 242:main.c        **** 
 243:main.c        ****     printf("Attempting to open connection to FPGALink device %s...\n", vp);
 966              		.loc 1 243 0
 967 074a 488B4580 		movq	-128(%rbp), %rax
 968 074e 4889C6   		movq	%rax, %rsi
 969 0751 BF000000 		movl	$.LC42, %edi
 969      00
 970 0756 B8000000 		movl	$0, %eax
 970      00
 971 075b E8000000 		call	printf
 971      00
 244:main.c        ****     fStatus = flOpen(vp, &handle, NULL);
 972              		.loc 1 244 0
 973 0760 488D8D18 		leaq	-232(%rbp), %rcx
 973      FFFFFF
 974 0767 488B4580 		movq	-128(%rbp), %rax
 975 076b BA000000 		movl	$0, %edx
 975      00
 976 0770 4889CE   		movq	%rcx, %rsi
 977 0773 4889C7   		movq	%rax, %rdi
 978 0776 E8000000 		call	flOpen
 978      00
 979 077b 8985F0FE 		movl	%eax, -272(%rbp)
 979      FFFF
 245:main.c        ****     if (fStatus) {
 980              		.loc 1 245 0
 981 0781 83BDF0FE 		cmpl	$0, -272(%rbp)
 981      FFFF00
 982 0788 0F84D801 		je	.L37
 982      0000
 246:main.c        ****         if (ivpOpt->count) {
 983              		.loc 1 246 0
 984 078e 488B8538 		movq	-200(%rbp), %rax
 984      FFFFFF
 985 0795 8B4060   		movl	96(%rax), %eax
 986 0798 85C0     		testl	%eax, %eax
 987 079a 0F849A01 		je	.L38
 987      0000
 988              	.LBB5:
 247:main.c        ****             int count = 60;
 989              		.loc 1 247 0
 990 07a0 C785C4FE 		movl	$60, -316(%rbp)
 990      FFFF3C00 
 990      0000
 248:main.c        ****             uint8 flag;
 249:main.c        ****             ivp = ivpOpt->sval[0];
 991              		.loc 1 249 0
 992 07aa 488B8538 		movq	-200(%rbp), %rax
 992      FFFFFF
 993 07b1 488B4068 		movq	104(%rax), %rax
 994 07b5 488B00   		movq	(%rax), %rax
 995 07b8 48898578 		movq	%rax, -136(%rbp)
 995      FFFFFF
 250:main.c        ****             printf("Loading firmware into %s...\n", ivp);
 996              		.loc 1 250 0
 997 07bf 488B8578 		movq	-136(%rbp), %rax
 997      FFFFFF
 998 07c6 4889C6   		movq	%rax, %rsi
 999 07c9 BF000000 		movl	$.LC43, %edi
 999      00
 1000 07ce B8000000 		movl	$0, %eax
 1000      00
 1001 07d3 E8000000 		call	printf
 1001      00
 251:main.c        ****             fStatus = flLoadStandardFirmware(ivp, vp, &error);
 1002              		.loc 1 251 0
 1003 07d8 488D9520 		leaq	-224(%rbp), %rdx
 1003      FFFFFF
 1004 07df 488B4D80 		movq	-128(%rbp), %rcx
 1005 07e3 488B8578 		movq	-136(%rbp), %rax
 1005      FFFFFF
 1006 07ea 4889CE   		movq	%rcx, %rsi
 1007 07ed 4889C7   		movq	%rax, %rdi
 1008 07f0 E8000000 		call	flLoadStandardFirmware
 1008      00
 1009 07f5 8985F0FE 		movl	%eax, -272(%rbp)
 1009      FFFF
 252:main.c        ****             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1010              		.loc 1 252 0
 1011 07fb 83BDF0FE 		cmpl	$0, -272(%rbp)
 1011      FFFF00
 1012 0802 740F     		je	.L39
 1013              		.loc 1 252 0 is_stmt 0 discriminator 1
 1014 0804 C785C0FE 		movl	$1, -320(%rbp)
 1014      FFFF0100 
 1014      0000
 1015 080e E9291500 		jmp	.L29
 1015      00
 1016              	.L39:
 253:main.c        **** 
 254:main.c        ****             printf("Awaiting renumeration");
 1017              		.loc 1 254 0 is_stmt 1
 1018 0813 BF000000 		movl	$.LC44, %edi
 1018      00
 1019 0818 B8000000 		movl	$0, %eax
 1019      00
 1020 081d E8000000 		call	printf
 1020      00
 255:main.c        ****             flSleep(1000);
 1021              		.loc 1 255 0
 1022 0822 BFE80300 		movl	$1000, %edi
 1022      00
 1023 0827 E8000000 		call	flSleep
 1023      00
 1024              	.L43:
 256:main.c        ****             do {
 257:main.c        ****                 printf(".");
 1025              		.loc 1 257 0
 1026 082c BF2E0000 		movl	$46, %edi
 1026      00
 1027 0831 E8000000 		call	putchar
 1027      00
 258:main.c        ****                 fflush(stdout);
 1028              		.loc 1 258 0
 1029 0836 488B0500 		movq	stdout(%rip), %rax
 1029      000000
 1030 083d 4889C7   		movq	%rax, %rdi
 1031 0840 E8000000 		call	fflush
 1031      00
 259:main.c        ****                 fStatus = flIsDeviceAvailable(vp, &flag, &error);
 1032              		.loc 1 259 0
 1033 0845 488D9520 		leaq	-224(%rbp), %rdx
 1033      FFFFFF
 1034 084c 488D8D30 		leaq	-208(%rbp), %rcx
 1034      FFFFFF
 1035 0853 488B4580 		movq	-128(%rbp), %rax
 1036 0857 4889CE   		movq	%rcx, %rsi
 1037 085a 4889C7   		movq	%rax, %rdi
 1038 085d E8000000 		call	flIsDeviceAvailable
 1038      00
 1039 0862 8985F0FE 		movl	%eax, -272(%rbp)
 1039      FFFF
 260:main.c        ****                 CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1040              		.loc 1 260 0
 1041 0868 83BDF0FE 		cmpl	$0, -272(%rbp)
 1041      FFFF00
 1042 086f 740F     		je	.L41
 1043              		.loc 1 260 0 is_stmt 0 discriminator 1
 1044 0871 C785C0FE 		movl	$1, -320(%rbp)
 1044      FFFF0100 
 1044      0000
 1045 087b E9BC1400 		jmp	.L29
 1045      00
 1046              	.L41:
 261:main.c        ****                 flSleep(250);
 1047              		.loc 1 261 0 is_stmt 1
 1048 0880 BFFA0000 		movl	$250, %edi
 1048      00
 1049 0885 E8000000 		call	flSleep
 1049      00
 262:main.c        ****                 count--;
 1050              		.loc 1 262 0
 1051 088a 83ADC4FE 		subl	$1, -316(%rbp)
 1051      FFFF01
 263:main.c        ****             } while (!flag && count);
 1052              		.loc 1 263 0
 1053 0891 0FB68530 		movzbl	-208(%rbp), %eax
 1053      FFFFFF
 1054 0898 84C0     		testb	%al, %al
 1055 089a 7509     		jne	.L42
 1056              		.loc 1 263 0 is_stmt 0 discriminator 1
 1057 089c 83BDC4FE 		cmpl	$0, -316(%rbp)
 1057      FFFF00
 1058 08a3 7587     		jne	.L43
 1059              	.L42:
 264:main.c        ****             printf("\n");
 1060              		.loc 1 264 0 is_stmt 1
 1061 08a5 BF0A0000 		movl	$10, %edi
 1061      00
 1062 08aa E8000000 		call	putchar
 1062      00
 265:main.c        ****             if (!flag) {
 1063              		.loc 1 265 0
 1064 08af 0FB68530 		movzbl	-208(%rbp), %eax
 1064      FFFFFF
 1065 08b6 84C0     		testb	%al, %al
 1066 08b8 752C     		jne	.L44
 266:main.c        ****                 fprintf(stderr, "FPGALink device did not renumerate properly as %s\n", vp);
 1067              		.loc 1 266 0
 1068 08ba 488B0500 		movq	stderr(%rip), %rax
 1068      000000
 1069 08c1 488B5580 		movq	-128(%rbp), %rdx
 1070 08c5 BE000000 		movl	$.LC45, %esi
 1070      00
 1071 08ca 4889C7   		movq	%rax, %rdi
 1072 08cd B8000000 		movl	$0, %eax
 1072      00
 1073 08d2 E8000000 		call	fprintf
 1073      00
 267:main.c        ****                 FAIL(FLP_LIBERR, cleanup);
 1074              		.loc 1 267 0
 1075 08d7 C785C0FE 		movl	$1, -320(%rbp)
 1075      FFFF0100 
 1075      0000
 1076 08e1 E9561400 		jmp	.L29
 1076      00
 1077              	.L44:
 268:main.c        ****             }
 269:main.c        **** 
 270:main.c        ****             printf("Attempting to open connection to FPGLink device %s again...\n", vp);
 1078              		.loc 1 270 0
 1079 08e6 488B4580 		movq	-128(%rbp), %rax
 1080 08ea 4889C6   		movq	%rax, %rsi
 1081 08ed BF000000 		movl	$.LC46, %edi
 1081      00
 1082 08f2 B8000000 		movl	$0, %eax
 1082      00
 1083 08f7 E8000000 		call	printf
 1083      00
 271:main.c        ****             fStatus = flOpen(vp, &handle, &error);
 1084              		.loc 1 271 0
 1085 08fc 488D9520 		leaq	-224(%rbp), %rdx
 1085      FFFFFF
 1086 0903 488D8D18 		leaq	-232(%rbp), %rcx
 1086      FFFFFF
 1087 090a 488B4580 		movq	-128(%rbp), %rax
 1088 090e 4889CE   		movq	%rcx, %rsi
 1089 0911 4889C7   		movq	%rax, %rdi
 1090 0914 E8000000 		call	flOpen
 1090      00
 1091 0919 8985F0FE 		movl	%eax, -272(%rbp)
 1091      FFFF
 272:main.c        ****             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1092              		.loc 1 272 0
 1093 091f 83BDF0FE 		cmpl	$0, -272(%rbp)
 1093      FFFF00
 1094 0926 7410     		je	.L45
 1095              		.loc 1 272 0 is_stmt 0 discriminator 1
 1096 0928 C785C0FE 		movl	$1, -320(%rbp)
 1096      FFFF0100 
 1096      0000
 1097 0932 90       		nop
 1098 0933 E9041400 		jmp	.L29
 1098      00
 1099              	.L45:
 1100              	.LBE5:
 1101 0938 EB2C     		jmp	.L37
 1102              	.L38:
 273:main.c        ****         } else {
 274:main.c        ****             fprintf(stderr, "Could not open FPGALink device at %s and no initial VID:PID was suppli
 1103              		.loc 1 274 0 is_stmt 1
 1104 093a 488B0500 		movq	stderr(%rip), %rax
 1104      000000
 1105 0941 488B5580 		movq	-128(%rbp), %rdx
 1106 0945 BE000000 		movl	$.LC47, %esi
 1106      00
 1107 094a 4889C7   		movq	%rax, %rdi
 1108 094d B8000000 		movl	$0, %eax
 1108      00
 1109 0952 E8000000 		call	fprintf
 1109      00
 275:main.c        ****             FAIL(FLP_ARGS, cleanup);
 1110              		.loc 1 275 0
 1111 0957 C785C0FE 		movl	$12, -320(%rbp)
 1111      FFFF0C00 
 1111      0000
 1112 0961 E9D61300 		jmp	.L29
 1112      00
 1113              	.L37:
 276:main.c        ****         }
 277:main.c        ****     }
 278:main.c        **** 
 279:main.c        ****     printf(
 1114              		.loc 1 279 0
 1115 0966 488B8518 		movq	-232(%rbp), %rax
 1115      FFFFFF
 1116 096d 4889C7   		movq	%rax, %rdi
 1117 0970 E8000000 		call	flGetFirmwareVersion
 1117      00
 1118 0975 89C3     		movl	%eax, %ebx
 280:main.c        ****             "Connected to FPGALink device %s (firmwareID: 0x%04X, firmwareVersion: 0x%08X)\n",
 281:main.c        ****             vp, flGetFirmwareID(handle), flGetFirmwareVersion(handle)
 1119              		.loc 1 281 0
 1120 0977 488B8518 		movq	-232(%rbp), %rax
 1120      FFFFFF
 1121 097e 4889C7   		movq	%rax, %rdi
 1122 0981 E8000000 		call	flGetFirmwareID
 1122      00
 279:main.c        ****             "Connected to FPGALink device %s (firmwareID: 0x%04X, firmwareVersion: 0x%08X)\n",
 1123              		.loc 1 279 0
 1124 0986 0FB7D0   		movzwl	%ax, %edx
 1125 0989 488B4580 		movq	-128(%rbp), %rax
 1126 098d 89D9     		movl	%ebx, %ecx
 1127 098f 4889C6   		movq	%rax, %rsi
 1128 0992 BF000000 		movl	$.LC48, %edi
 1128      00
 1129 0997 B8000000 		movl	$0, %eax
 1129      00
 1130 099c E8000000 		call	printf
 1130      00
 282:main.c        ****     );
 283:main.c        **** 
 284:main.c        ****     isCommCapable = flIsCommCapable(handle, conduit);
 1131              		.loc 1 284 0
 1132 09a1 0FB695A5 		movzbl	-347(%rbp), %edx
 1132      FEFFFF
 1133 09a8 488B8518 		movq	-232(%rbp), %rax
 1133      FFFFFF
 1134 09af 89D6     		movl	%edx, %esi
 1135 09b1 4889C7   		movq	%rax, %rdi
 1136 09b4 E8000000 		call	flIsCommCapable
 1136      00
 1137 09b9 84C0     		testb	%al, %al
 1138 09bb 0F95C0   		setne	%al
 1139 09be 8885A6FE 		movb	%al, -346(%rbp)
 1139      FFFF
 285:main.c        **** 
 286:main.c        ****     // -y reads in from csv and initiates the while loop
 287:main.c        ****     if (loopOpt->count > 0) {
 1140              		.loc 1 287 0
 1141 09c4 488B8550 		movq	-176(%rbp), %rax
 1141      FFFFFF
 1142 09cb 8B4060   		movl	96(%rax), %eax
 1143 09ce 85C0     		testl	%eax, %eax
 1144 09d0 0F8E6613 		jle	.L29
 1144      0000
 288:main.c        ****         if (isCommCapable) {
 1145              		.loc 1 288 0
 1146 09d6 80BDA6FE 		cmpb	$0, -346(%rbp)
 1146      FFFF00
 1147 09dd 0F843113 		je	.L46
 1147      0000
 1148              	.LBB6:
 289:main.c        ****             uint8 isRunning;
 290:main.c        ****             fStatus = flSelectConduit(handle, conduit, &error);
 1149              		.loc 1 290 0
 1150 09e3 0FB68DA5 		movzbl	-347(%rbp), %ecx
 1150      FEFFFF
 1151 09ea 488B8518 		movq	-232(%rbp), %rax
 1151      FFFFFF
 1152 09f1 488D9520 		leaq	-224(%rbp), %rdx
 1152      FFFFFF
 1153 09f8 89CE     		movl	%ecx, %esi
 1154 09fa 4889C7   		movq	%rax, %rdi
 1155 09fd E8000000 		call	flSelectConduit
 1155      00
 1156 0a02 8985F0FE 		movl	%eax, -272(%rbp)
 1156      FFFF
 291:main.c        ****             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1157              		.loc 1 291 0
 1158 0a08 83BDF0FE 		cmpl	$0, -272(%rbp)
 1158      FFFF00
 1159 0a0f 740F     		je	.L47
 1160              		.loc 1 291 0 is_stmt 0 discriminator 1
 1161 0a11 C785C0FE 		movl	$1, -320(%rbp)
 1161      FFFF0100 
 1161      0000
 1162 0a1b E91C1300 		jmp	.L29
 1162      00
 1163              	.L47:
 292:main.c        ****             fStatus = flIsFPGARunning(handle, &isRunning, &error);
 1164              		.loc 1 292 0 is_stmt 1
 1165 0a20 488B8518 		movq	-232(%rbp), %rax
 1165      FFFFFF
 1166 0a27 488D9520 		leaq	-224(%rbp), %rdx
 1166      FFFFFF
 1167 0a2e 488D8D93 		leaq	-365(%rbp), %rcx
 1167      FEFFFF
 1168 0a35 4889CE   		movq	%rcx, %rsi
 1169 0a38 4889C7   		movq	%rax, %rdi
 1170 0a3b E8000000 		call	flIsFPGARunning
 1170      00
 1171 0a40 8985F0FE 		movl	%eax, -272(%rbp)
 1171      FFFF
 293:main.c        ****             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1172              		.loc 1 293 0
 1173 0a46 83BDF0FE 		cmpl	$0, -272(%rbp)
 1173      FFFF00
 1174 0a4d 740F     		je	.L49
 1175              		.loc 1 293 0 is_stmt 0 discriminator 1
 1176 0a4f C785C0FE 		movl	$1, -320(%rbp)
 1176      FFFF0100 
 1176      0000
 1177 0a59 E9DE1200 		jmp	.L29
 1177      00
 1178              	.L49:
 294:main.c        ****             if (isRunning) {
 1179              		.loc 1 294 0 is_stmt 1
 1180 0a5e 0FB68593 		movzbl	-365(%rbp), %eax
 1180      FEFFFF
 1181 0a65 84C0     		testb	%al, %al
 1182 0a67 0F847D12 		je	.L50
 1182      0000
 1183              	.LBB7:
 295:main.c        **** 
 296:main.c        ****                 FILE *fPtr;
 297:main.c        ****                 fPtr = fopen("SampleBackEndDatabase.csv", "r+"); // change flag according to need
 1184              		.loc 1 297 0
 1185 0a6d BE000000 		movl	$.LC49, %esi
 1185      00
 1186 0a72 BF000000 		movl	$.LC50, %edi
 1186      00
 1187 0a77 E8000000 		call	fopen
 1187      00
 1188 0a7c 48894590 		movq	%rax, -112(%rbp)
 298:main.c        ****                 if (fPtr == NULL) {
 1189              		.loc 1 298 0
 1190 0a80 48837D90 		cmpq	$0, -112(%rbp)
 1190      00
 1191 0a85 7514     		jne	.L51
 299:main.c        ****                     printf("Csv doesn't exist \n");
 1192              		.loc 1 299 0
 1193 0a87 BF000000 		movl	$.LC51, %edi
 1193      00
 1194 0a8c E8000000 		call	puts
 1194      00
 300:main.c        ****                     return 0;
 1195              		.loc 1 300 0
 1196 0a91 B8000000 		movl	$0, %eax
 1196      00
 1197 0a96 E9FD1200 		jmp	.L166
 1197      00
 1198              	.L51:
 301:main.c        ****                 }
 302:main.c        ****                 size_t lineSize = 100;
 1199              		.loc 1 302 0
 1200 0a9b 48C78528 		movq	$100, -216(%rbp)
 1200      FFFFFF64 
 1200      000000
 303:main.c        ****                 char *lineFromFile = malloc(lineSize * sizeof(char));
 1201              		.loc 1 303 0
 1202 0aa6 488B8528 		movq	-216(%rbp), %rax
 1202      FFFFFF
 1203 0aad 4889C7   		movq	%rax, %rdi
 1204 0ab0 E8000000 		call	malloc
 1204      00
 1205 0ab5 48898530 		movq	%rax, -208(%rbp)
 1205      FFFFFF
 304:main.c        **** 
 305:main.c        ****                 while ((getline(&lineFromFile, &lineSize, fPtr)) != -1) {
 1206              		.loc 1 305 0
 1207 0abc EB28     		jmp	.L53
 1208              	.L55:
 306:main.c        ****                     if (numLines != 0) format(lineFromFile);
 1209              		.loc 1 306 0
 1210 0abe 8B050000 		movl	numLines(%rip), %eax
 1210      0000
 1211 0ac4 85C0     		testl	%eax, %eax
 1212 0ac6 740F     		je	.L54
 1213              		.loc 1 306 0 is_stmt 0 discriminator 1
 1214 0ac8 488B8530 		movq	-208(%rbp), %rax
 1214      FFFFFF
 1215 0acf 4889C7   		movq	%rax, %rdi
 1216 0ad2 E8000000 		call	format
 1216      00
 1217              	.L54:
 307:main.c        ****                     numLines++;
 1218              		.loc 1 307 0 is_stmt 1
 1219 0ad7 8B050000 		movl	numLines(%rip), %eax
 1219      0000
 1220 0add 83C001   		addl	$1, %eax
 1221 0ae0 89050000 		movl	%eax, numLines(%rip)
 1221      0000
 1222              	.L53:
 305:main.c        ****                     if (numLines != 0) format(lineFromFile);
 1223              		.loc 1 305 0 discriminator 1
 1224 0ae6 488B5590 		movq	-112(%rbp), %rdx
 1225 0aea 488D8D28 		leaq	-216(%rbp), %rcx
 1225      FFFFFF
 1226 0af1 488D8530 		leaq	-208(%rbp), %rax
 1226      FFFFFF
 1227 0af8 4889CE   		movq	%rcx, %rsi
 1228 0afb 4889C7   		movq	%rax, %rdi
 1229 0afe E8000000 		call	getline
 1229      00
 1230 0b03 4883F8FF 		cmpq	$-1, %rax
 1231 0b07 75B5     		jne	.L55
 308:main.c        ****                 }
 309:main.c        ****                 numLines--;
 1232              		.loc 1 309 0
 1233 0b09 8B050000 		movl	numLines(%rip), %eax
 1233      0000
 1234 0b0f 83E801   		subl	$1, %eax
 1235 0b12 89050000 		movl	%eax, numLines(%rip)
 1235      0000
 310:main.c        ****                 free(lineFromFile);
 1236              		.loc 1 310 0
 1237 0b18 488B8530 		movq	-208(%rbp), %rax
 1237      FFFFFF
 1238 0b1f 4889C7   		movq	%rax, %rdi
 1239 0b22 E8000000 		call	free
 1239      00
 311:main.c        ****                 fclose(fPtr);
 1240              		.loc 1 311 0
 1241 0b27 488B4590 		movq	-112(%rbp), %rax
 1242 0b2b 4889C7   		movq	%rax, %rdi
 1243 0b2e E8000000 		call	fclose
 1243      00
 312:main.c        **** 
 313:main.c        ****                 // Bank id error handling
 314:main.c        ****                 if(bankID < 0 || bankID > 31) {
 1244              		.loc 1 314 0
 1245 0b33 8B050000 		movl	bankID(%rip), %eax
 1245      0000
 1246 0b39 85C0     		testl	%eax, %eax
 1247 0b3b 780B     		js	.L56
 1248              		.loc 1 314 0 is_stmt 0 discriminator 1
 1249 0b3d 8B050000 		movl	bankID(%rip), %eax
 1249      0000
 1250 0b43 83F81F   		cmpl	$31, %eax
 1251 0b46 7E14     		jle	.L57
 1252              	.L56:
 315:main.c        ****                     printf("%s\n", "Invalid bankID");
 1253              		.loc 1 315 0 is_stmt 1
 1254 0b48 BF000000 		movl	$.LC36, %edi
 1254      00
 1255 0b4d E8000000 		call	puts
 1255      00
 316:main.c        ****                     return 0;
 1256              		.loc 1 316 0
 1257 0b52 B8000000 		movl	$0, %eax
 1257      00
 1258 0b57 E93C1200 		jmp	.L166
 1258      00
 1259              	.L57:
 1260              	.LBB8:
 317:main.c        ****                 }
 318:main.c        ****                 
 319:main.c        ****                 while (true) {
 320:main.c        ****                     uint32_t length = 1;
 1261              		.loc 1 320 0
 1262 0b5c C785F4FE 		movl	$1, -268(%rbp)
 1262      FFFF0100 
 1262      0000
 321:main.c        ****                     uint8_t *readFromChannelZero = malloc(sizeof(uint8_t));
 1263              		.loc 1 321 0
 1264 0b66 BF010000 		movl	$1, %edi
 1264      00
 1265 0b6b E8000000 		call	malloc
 1265      00
 1266 0b70 48894598 		movq	%rax, -104(%rbp)
 322:main.c        **** 
 323:main.c        ****                     fStatus = flReadChannel(handle, (uint8_t) 0, length, readFromChannelZero, &erro
 1267              		.loc 1 323 0
 1268 0b74 8B95F4FE 		movl	-268(%rbp), %edx
 1268      FFFF
 1269 0b7a 488B8518 		movq	-232(%rbp), %rax
 1269      FFFFFF
 1270 0b81 488DB520 		leaq	-224(%rbp), %rsi
 1270      FFFFFF
 1271 0b88 488B4D98 		movq	-104(%rbp), %rcx
 1272 0b8c 4989F0   		movq	%rsi, %r8
 1273 0b8f BE000000 		movl	$0, %esi
 1273      00
 1274 0b94 4889C7   		movq	%rax, %rdi
 1275 0b97 E8000000 		call	flReadChannel
 1275      00
 1276 0b9c 8985F0FE 		movl	%eax, -272(%rbp)
 1276      FFFF
 324:main.c        ****                     CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1277              		.loc 1 324 0
 1278 0ba2 83BDF0FE 		cmpl	$0, -272(%rbp)
 1278      FFFF00
 1279 0ba9 740F     		je	.L58
 1280              		.loc 1 324 0 is_stmt 0 discriminator 1
 1281 0bab C785C0FE 		movl	$1, -320(%rbp)
 1281      FFFF0100 
 1281      0000
 1282 0bb5 E92E1100 		jmp	.L59
 1282      00
 1283              	.L58:
 325:main.c        ****                     if (LOG) printf("Read from channel 0 = %u \n", *readFromChannelZero);
 1284              		.loc 1 325 0 is_stmt 1
 1285 0bba 0FB60500 		movzbl	LOG(%rip), %eax
 1285      000000
 1286 0bc1 84C0     		testb	%al, %al
 1287 0bc3 741B     		je	.L60
 1288              		.loc 1 325 0 is_stmt 0 discriminator 1
 1289 0bc5 488B4598 		movq	-104(%rbp), %rax
 1290 0bc9 0FB600   		movzbl	(%rax), %eax
 1291 0bcc 0FB6C0   		movzbl	%al, %eax
 1292 0bcf 89C6     		movl	%eax, %esi
 1293 0bd1 BF000000 		movl	$.LC52, %edi
 1293      00
 1294 0bd6 B8000000 		movl	$0, %eax
 1294      00
 1295 0bdb E8000000 		call	printf
 1295      00
 1296              	.L60:
 326:main.c        **** 
 327:main.c        ****                     if (((*readFromChannelZero) == 1) || ((*readFromChannelZero) == 2)) {
 1297              		.loc 1 327 0 is_stmt 1
 1298 0be0 488B4598 		movq	-104(%rbp), %rax
 1299 0be4 0FB600   		movzbl	(%rax), %eax
 1300 0be7 3C01     		cmpb	$1, %al
 1301 0be9 740F     		je	.L61
 1302              		.loc 1 327 0 is_stmt 0 discriminator 1
 1303 0beb 488B4598 		movq	-104(%rbp), %rax
 1304 0bef 0FB600   		movzbl	(%rax), %eax
 1305 0bf2 3C02     		cmpb	$2, %al
 1306 0bf4 0F85DF10 		jne	.L62
 1306      0000
 1307              	.L61:
 1308              	.LBB9:
 328:main.c        ****                         uint8_t cnt = 1, valRead = *readFromChannelZero;
 1309              		.loc 1 328 0 is_stmt 1
 1310 0bfa C68596FE 		movb	$1, -362(%rbp)
 1310      FFFF01
 1311 0c01 488B4598 		movq	-104(%rbp), %rax
 1312 0c05 0FB600   		movzbl	(%rax), %eax
 1313 0c08 8885A7FE 		movb	%al, -345(%rbp)
 1313      FFFF
 329:main.c        ****                         bool cont = true;
 1314              		.loc 1 329 0
 1315 0c0e C68597FE 		movb	$1, -361(%rbp)
 1315      FFFF01
 330:main.c        ****                         while (cnt < 3) {
 1316              		.loc 1 330 0
 1317 0c15 E9A00000 		jmp	.L63
 1317      00
 1318              	.L68:
 331:main.c        ****                             flSleep(1000);
 1319              		.loc 1 331 0
 1320 0c1a BFE80300 		movl	$1000, %edi
 1320      00
 1321 0c1f E8000000 		call	flSleep
 1321      00
 332:main.c        ****                             fStatus = flReadChannel(handle, 0, length, readFromChannelZero, &error)
 1322              		.loc 1 332 0
 1323 0c24 8B95F4FE 		movl	-268(%rbp), %edx
 1323      FFFF
 1324 0c2a 488B8518 		movq	-232(%rbp), %rax
 1324      FFFFFF
 1325 0c31 488DB520 		leaq	-224(%rbp), %rsi
 1325      FFFFFF
 1326 0c38 488B4D98 		movq	-104(%rbp), %rcx
 1327 0c3c 4989F0   		movq	%rsi, %r8
 1328 0c3f BE000000 		movl	$0, %esi
 1328      00
 1329 0c44 4889C7   		movq	%rax, %rdi
 1330 0c47 E8000000 		call	flReadChannel
 1330      00
 1331 0c4c 8985F0FE 		movl	%eax, -272(%rbp)
 1331      FFFF
 333:main.c        ****                             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1332              		.loc 1 333 0
 1333 0c52 83BDF0FE 		cmpl	$0, -272(%rbp)
 1333      FFFF00
 1334 0c59 740F     		je	.L64
 1335              		.loc 1 333 0 is_stmt 0 discriminator 1
 1336 0c5b C785C0FE 		movl	$1, -320(%rbp)
 1336      FFFF0100 
 1336      0000
 1337 0c65 E97E1000 		jmp	.L59
 1337      00
 1338              	.L64:
 334:main.c        ****                             if (LOG) printf("Read from channel 0 = %u \n", *readFromChannelZero);
 1339              		.loc 1 334 0 is_stmt 1
 1340 0c6a 0FB60500 		movzbl	LOG(%rip), %eax
 1340      000000
 1341 0c71 84C0     		testb	%al, %al
 1342 0c73 741B     		je	.L65
 1343              		.loc 1 334 0 is_stmt 0 discriminator 1
 1344 0c75 488B4598 		movq	-104(%rbp), %rax
 1345 0c79 0FB600   		movzbl	(%rax), %eax
 1346 0c7c 0FB6C0   		movzbl	%al, %eax
 1347 0c7f 89C6     		movl	%eax, %esi
 1348 0c81 BF000000 		movl	$.LC52, %edi
 1348      00
 1349 0c86 B8000000 		movl	$0, %eax
 1349      00
 1350 0c8b E8000000 		call	printf
 1350      00
 1351              	.L65:
 335:main.c        **** 
 336:main.c        ****                             if (*readFromChannelZero == valRead) cnt++;
 1352              		.loc 1 336 0 is_stmt 1
 1353 0c90 488B4598 		movq	-104(%rbp), %rax
 1354 0c94 0FB600   		movzbl	(%rax), %eax
 1355 0c97 3A85A7FE 		cmpb	-345(%rbp), %al
 1355      FFFF
 1356 0c9d 7512     		jne	.L66
 1357              		.loc 1 336 0 is_stmt 0 discriminator 1
 1358 0c9f 0FB68596 		movzbl	-362(%rbp), %eax
 1358      FEFFFF
 1359 0ca6 83C001   		addl	$1, %eax
 1360 0ca9 888596FE 		movb	%al, -362(%rbp)
 1360      FFFF
 1361 0caf EB09     		jmp	.L63
 1362              	.L66:
 337:main.c        ****                             else {
 338:main.c        ****                                 cont = false;
 1363              		.loc 1 338 0 is_stmt 1
 1364 0cb1 C68597FE 		movb	$0, -361(%rbp)
 1364      FFFF00
 339:main.c        ****                                 break;
 1365              		.loc 1 339 0
 1366 0cb8 EB0D     		jmp	.L67
 1367              	.L63:
 330:main.c        ****                             flSleep(1000);
 1368              		.loc 1 330 0 discriminator 1
 1369 0cba 80BD96FE 		cmpb	$2, -362(%rbp)
 1369      FFFF02
 1370 0cc1 0F8653FF 		jbe	.L68
 1370      FFFF
 1371              	.L67:
 340:main.c        ****                             }
 341:main.c        ****                         }
 342:main.c        ****                         if (cont) {
 1372              		.loc 1 342 0
 1373 0cc7 80BD97FE 		cmpb	$0, -361(%rbp)
 1373      FFFF00
 1374 0cce 0F840510 		je	.L62
 1374      0000
 1375              	.LBB10:
 1376              	.LBB11:
 343:main.c        ****                             uint32_t inpFromFrontEnd[2];
 344:main.c        ****                             for (int i = 0; i < 2; i++) inpFromFrontEnd[i] = 0;
 1377              		.loc 1 344 0
 1378 0cd4 C785C8FE 		movl	$0, -312(%rbp)
 1378      FFFF0000 
 1378      0000
 1379 0cde EB1A     		jmp	.L69
 1380              	.L70:
 1381              		.loc 1 344 0 is_stmt 0 discriminator 2
 1382 0ce0 8B85C8FE 		movl	-312(%rbp), %eax
 1382      FFFF
 1383 0ce6 4898     		cltq
 1384 0ce8 C7848500 		movl	$0, -256(%rbp,%rax,4)
 1384      FFFFFF00 
 1384      000000
 1385 0cf3 8385C8FE 		addl	$1, -312(%rbp)
 1385      FFFF01
 1386              	.L69:
 1387              		.loc 1 344 0 discriminator 1
 1388 0cfa 83BDC8FE 		cmpl	$1, -312(%rbp)
 1388      FFFF01
 1389 0d01 7EDD     		jle	.L70
 1390              	.LBE11:
 1391              	.LBB12:
 345:main.c        ****                             for (uint32_t i = 1; i <= 8; i++) {
 1392              		.loc 1 345 0 is_stmt 1
 1393 0d03 C785CCFE 		movl	$1, -308(%rbp)
 1393      FFFF0100 
 1393      0000
 1394 0d0d E9100100 		jmp	.L71
 1394      00
 1395              	.L77:
 1396              	.LBB13:
 346:main.c        ****                                 uint8_t *readFromChannel_i = malloc(sizeof(uint8_t));
 1397              		.loc 1 346 0
 1398 0d12 BF010000 		movl	$1, %edi
 1398      00
 1399 0d17 E8000000 		call	malloc
 1399      00
 1400 0d1c 488945A0 		movq	%rax, -96(%rbp)
 347:main.c        **** 
 348:main.c        ****                                 flSleep(1000);
 1401              		.loc 1 348 0
 1402 0d20 BFE80300 		movl	$1000, %edi
 1402      00
 1403 0d25 E8000000 		call	flSleep
 1403      00
 349:main.c        ****                                 fStatus = flReadChannel(handle, (uint8_t) i, length, readFromChanne
 1404              		.loc 1 349 0
 1405 0d2a 8B95F4FE 		movl	-268(%rbp), %edx
 1405      FFFF
 1406 0d30 8B85CCFE 		movl	-308(%rbp), %eax
 1406      FFFF
 1407 0d36 0FB6F0   		movzbl	%al, %esi
 1408 0d39 488B8518 		movq	-232(%rbp), %rax
 1408      FFFFFF
 1409 0d40 488DBD20 		leaq	-224(%rbp), %rdi
 1409      FFFFFF
 1410 0d47 488B4DA0 		movq	-96(%rbp), %rcx
 1411 0d4b 4989F8   		movq	%rdi, %r8
 1412 0d4e 4889C7   		movq	%rax, %rdi
 1413 0d51 E8000000 		call	flReadChannel
 1413      00
 1414 0d56 8985F0FE 		movl	%eax, -272(%rbp)
 1414      FFFF
 350:main.c        ****                                 CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1415              		.loc 1 350 0
 1416 0d5c 83BDF0FE 		cmpl	$0, -272(%rbp)
 1416      FFFF00
 1417 0d63 740F     		je	.L72
 1418              		.loc 1 350 0 is_stmt 0 discriminator 1
 1419 0d65 C785C0FE 		movl	$1, -320(%rbp)
 1419      FFFF0100 
 1419      0000
 1420 0d6f E9630F00 		jmp	.L73
 1420      00
 1421              	.L72:
 351:main.c        ****                                 if (LOG) printf("Read from channel %u = %u \n", i, *readFromChannel
 1422              		.loc 1 351 0 is_stmt 1
 1423 0d74 0FB60500 		movzbl	LOG(%rip), %eax
 1423      000000
 1424 0d7b 84C0     		testb	%al, %al
 1425 0d7d 7421     		je	.L74
 1426              		.loc 1 351 0 is_stmt 0 discriminator 1
 1427 0d7f 488B45A0 		movq	-96(%rbp), %rax
 1428 0d83 0FB600   		movzbl	(%rax), %eax
 1429 0d86 0FB6D0   		movzbl	%al, %edx
 1430 0d89 8B85CCFE 		movl	-308(%rbp), %eax
 1430      FFFF
 1431 0d8f 89C6     		movl	%eax, %esi
 1432 0d91 BF000000 		movl	$.LC53, %edi
 1432      00
 1433 0d96 B8000000 		movl	$0, %eax
 1433      00
 1434 0d9b E8000000 		call	printf
 1434      00
 1435              	.L74:
 352:main.c        ****                                 uint32_t temp1 = 8 * (i - 1), temp2 = 8 * (i - 5);
 1436              		.loc 1 352 0 is_stmt 1
 1437 0da0 8B85CCFE 		movl	-308(%rbp), %eax
 1437      FFFF
 1438 0da6 05FFFFFF 		addl	$536870911, %eax
 1438      1F
 1439 0dab C1E003   		sall	$3, %eax
 1440 0dae 8985F8FE 		movl	%eax, -264(%rbp)
 1440      FFFF
 1441 0db4 8B85CCFE 		movl	-308(%rbp), %eax
 1441      FFFF
 1442 0dba 05FBFFFF 		addl	$536870907, %eax
 1442      1F
 1443 0dbf C1E003   		sall	$3, %eax
 1444 0dc2 8985FCFE 		movl	%eax, -260(%rbp)
 1444      FFFF
 353:main.c        ****                                 if (i <= 4) inpFromFrontEnd[0] += (*readFromChannel_i) * (1 << temp
 1445              		.loc 1 353 0
 1446 0dc8 83BDCCFE 		cmpl	$4, -308(%rbp)
 1446      FFFF04
 1447 0dcf 7726     		ja	.L75
 1448              		.loc 1 353 0 is_stmt 0 discriminator 1
 1449 0dd1 8B9500FF 		movl	-256(%rbp), %edx
 1449      FFFF
 1450 0dd7 488B45A0 		movq	-96(%rbp), %rax
 1451 0ddb 0FB600   		movzbl	(%rax), %eax
 1452 0dde 0FB6F0   		movzbl	%al, %esi
 1453 0de1 8B85F8FE 		movl	-264(%rbp), %eax
 1453      FFFF
 1454 0de7 89C1     		movl	%eax, %ecx
 1455 0de9 D3E6     		sall	%cl, %esi
 1456 0deb 89F0     		movl	%esi, %eax
 1457 0ded 01D0     		addl	%edx, %eax
 1458 0def 898500FF 		movl	%eax, -256(%rbp)
 1458      FFFF
 1459 0df5 EB24     		jmp	.L76
 1460              	.L75:
 354:main.c        ****                                 else inpFromFrontEnd[1] += (*readFromChannel_i) * (1 << temp2);
 1461              		.loc 1 354 0 is_stmt 1
 1462 0df7 8B9504FF 		movl	-252(%rbp), %edx
 1462      FFFF
 1463 0dfd 488B45A0 		movq	-96(%rbp), %rax
 1464 0e01 0FB600   		movzbl	(%rax), %eax
 1465 0e04 0FB6F0   		movzbl	%al, %esi
 1466 0e07 8B85FCFE 		movl	-260(%rbp), %eax
 1466      FFFF
 1467 0e0d 89C1     		movl	%eax, %ecx
 1468 0e0f D3E6     		sall	%cl, %esi
 1469 0e11 89F0     		movl	%esi, %eax
 1470 0e13 01D0     		addl	%edx, %eax
 1471 0e15 898504FF 		movl	%eax, -252(%rbp)
 1471      FFFF
 1472              	.L76:
 1473              	.LBE13:
 345:main.c        ****                                 uint8_t *readFromChannel_i = malloc(sizeof(uint8_t));
 1474              		.loc 1 345 0
 1475 0e1b 8385CCFE 		addl	$1, -308(%rbp)
 1475      FFFF01
 1476              	.L71:
 345:main.c        ****                                 uint8_t *readFromChannel_i = malloc(sizeof(uint8_t));
 1477              		.loc 1 345 0 is_stmt 0 discriminator 1
 1478 0e22 83BDCCFE 		cmpl	$8, -308(%rbp)
 1478      FFFF08
 1479 0e29 0F86E3FE 		jbe	.L77
 1479      FFFF
 1480              	.LBE12:
 355:main.c        ****                             }
 356:main.c        ****                             decrypt64(inpFromFrontEnd);
 1481              		.loc 1 356 0 is_stmt 1
 1482 0e2f 488D8500 		leaq	-256(%rbp), %rax
 1482      FFFFFF
 1483 0e36 4889C7   		movq	%rax, %rdi
 1484 0e39 E8000000 		call	decrypt64
 1484      00
 357:main.c        ****                             uint8_t num_100_admin = 0, num_500_admin = 0, num_1000_admin = 0, num_2
 1485              		.loc 1 357 0
 1486 0e3e C68598FE 		movb	$0, -360(%rbp)
 1486      FFFF00
 1487 0e45 C68599FE 		movb	$0, -359(%rbp)
 1487      FFFF00
 1488 0e4c C6859AFE 		movb	$0, -358(%rbp)
 1488      FFFF00
 1489 0e53 C6859BFE 		movb	$0, -357(%rbp)
 1489      FFFF00
 358:main.c        ****                             uint16_t userID = 0, unhashedPin = 0;
 1490              		.loc 1 358 0
 1491 0e5a 66C785AC 		movw	$0, -340(%rbp)
 1491      FEFFFF00 
 1491      00
 1492 0e63 66C785AE 		movw	$0, -338(%rbp)
 1492      FEFFFF00 
 1492      00
 1493              	.LBB14:
 359:main.c        **** 
 360:main.c        ****                             for (uint16_t i = 1; i <= 32; i++) {
 1494              		.loc 1 360 0
 1495 0e6c 66C785B0 		movw	$1, -336(%rbp)
 1495      FEFFFF01 
 1495      00
 1496 0e75 E9970000 		jmp	.L78
 1496      00
 1497              	.L82:
 361:main.c        ****                                 if (i <= 16) {
 1498              		.loc 1 361 0
 1499 0e7a 6683BDB0 		cmpw	$16, -336(%rbp)
 1499      FEFFFF10 
 1500 0e82 773F     		ja	.L79
 362:main.c        ****                                     if ((inpFromFrontEnd[1] & (1 << (i - 1))) != 0) unhashedPin += 
 1501              		.loc 1 362 0
 1502 0e84 8B9504FF 		movl	-252(%rbp), %edx
 1502      FFFF
 1503 0e8a 0FB785B0 		movzwl	-336(%rbp), %eax
 1503      FEFFFF
 1504 0e91 83E801   		subl	$1, %eax
 1505 0e94 BE010000 		movl	$1, %esi
 1505      00
 1506 0e99 89C1     		movl	%eax, %ecx
 1507 0e9b D3E6     		sall	%cl, %esi
 1508 0e9d 89F0     		movl	%esi, %eax
 1509 0e9f 21D0     		andl	%edx, %eax
 1510 0ea1 85C0     		testl	%eax, %eax
 1511 0ea3 745B     		je	.L81
 1512              		.loc 1 362 0 is_stmt 0 discriminator 1
 1513 0ea5 0FB785B0 		movzwl	-336(%rbp), %eax
 1513      FEFFFF
 1514 0eac 83E801   		subl	$1, %eax
 1515 0eaf BA010000 		movl	$1, %edx
 1515      00
 1516 0eb4 89C1     		movl	%eax, %ecx
 1517 0eb6 D3E2     		sall	%cl, %edx
 1518 0eb8 89D0     		movl	%edx, %eax
 1519 0eba 660185AE 		addw	%ax, -338(%rbp)
 1519      FEFFFF
 1520 0ec1 EB3D     		jmp	.L81
 1521              	.L79:
 363:main.c        ****                                 } else {
 364:main.c        ****                                     if ((inpFromFrontEnd[1] & (1 << (i - 1))) != 0) userID += ((1 <
 1522              		.loc 1 364 0 is_stmt 1
 1523 0ec3 8B9504FF 		movl	-252(%rbp), %edx
 1523      FFFF
 1524 0ec9 0FB785B0 		movzwl	-336(%rbp), %eax
 1524      FEFFFF
 1525 0ed0 83E801   		subl	$1, %eax
 1526 0ed3 BE010000 		movl	$1, %esi
 1526      00
 1527 0ed8 89C1     		movl	%eax, %ecx
 1528 0eda D3E6     		sall	%cl, %esi
 1529 0edc 89F0     		movl	%esi, %eax
 1530 0ede 21D0     		andl	%edx, %eax
 1531 0ee0 85C0     		testl	%eax, %eax
 1532 0ee2 741C     		je	.L81
 1533              		.loc 1 364 0 is_stmt 0 discriminator 1
 1534 0ee4 0FB785B0 		movzwl	-336(%rbp), %eax
 1534      FEFFFF
 1535 0eeb 83E811   		subl	$17, %eax
 1536 0eee BA010000 		movl	$1, %edx
 1536      00
 1537 0ef3 89C1     		movl	%eax, %ecx
 1538 0ef5 D3E2     		sall	%cl, %edx
 1539 0ef7 89D0     		movl	%edx, %eax
 1540 0ef9 660185AC 		addw	%ax, -340(%rbp)
 1540      FEFFFF
 1541              	.L81:
 360:main.c        ****                                 if (i <= 16) {
 1542              		.loc 1 360 0 is_stmt 1
 1543 0f00 0FB785B0 		movzwl	-336(%rbp), %eax
 1543      FEFFFF
 1544 0f07 83C001   		addl	$1, %eax
 1545 0f0a 668985B0 		movw	%ax, -336(%rbp)
 1545      FEFFFF
 1546              	.L78:
 360:main.c        ****                                 if (i <= 16) {
 1547              		.loc 1 360 0 is_stmt 0 discriminator 1
 1548 0f11 6683BDB0 		cmpw	$32, -336(%rbp)
 1548      FEFFFF20 
 1549 0f19 0F865BFF 		jbe	.L82
 1549      FFFF
 1550              	.LBE14:
 365:main.c        ****                                 }
 366:main.c        ****                             }
 367:main.c        **** //                            printf("unhashedPin %u\n", unhashedPin);
 368:main.c        **** //                            printf("userID %u\n", userID);
 369:main.c        ****                             uint16_t hashedPin = myHash(unhashedPin);
 1551              		.loc 1 369 0 is_stmt 1
 1552 0f1f 0FB785AE 		movzwl	-338(%rbp), %eax
 1552      FEFFFF
 1553 0f26 89C7     		movl	%eax, %edi
 1554 0f28 E8000000 		call	myHash
 1554      00
 1555 0f2d 668985B2 		movw	%ax, -334(%rbp)
 1555      FEFFFF
 370:main.c        **** //                            printf("hashedPin %u\n", hashedPin);
 371:main.c        **** 
 372:main.c        ****                             int bal = -1;
 1556              		.loc 1 372 0
 1557 0f34 C785B4FE 		movl	$-1, -332(%rbp)
 1557      FFFFFFFF 
 1557      FFFF
 373:main.c        ****                             bool isAdmin = false;
 1558              		.loc 1 373 0
 1559 0f3e C68594FE 		movb	$0, -364(%rbp)
 1559      FFFF00
 374:main.c        ****                             int inLineNum = -1;
 1560              		.loc 1 374 0
 1561 0f45 C785B8FE 		movl	$-1, -328(%rbp)
 1561      FFFFFFFF 
 1561      FFFF
 375:main.c        ****                             uint8_t *statusOnChan9 = malloc(sizeof(uint8_t));
 1562              		.loc 1 375 0
 1563 0f4f BF010000 		movl	$1, %edi
 1563      00
 1564 0f54 E8000000 		call	malloc
 1564      00
 1565 0f59 488945A8 		movq	%rax, -88(%rbp)
 376:main.c        ****                             if (find(userID, hashedPin, &isAdmin, &bal, &inLineNum)) {
 1566              		.loc 1 376 0
 1567 0f5d 0FB7B5B2 		movzwl	-334(%rbp), %esi
 1567      FEFFFF
 1568 0f64 0FB785AC 		movzwl	-340(%rbp), %eax
 1568      FEFFFF
 1569 0f6b 488DBDB8 		leaq	-328(%rbp), %rdi
 1569      FEFFFF
 1570 0f72 488D8DB4 		leaq	-332(%rbp), %rcx
 1570      FEFFFF
 1571 0f79 488D9594 		leaq	-364(%rbp), %rdx
 1571      FEFFFF
 1572 0f80 4989F8   		movq	%rdi, %r8
 1573 0f83 89C7     		movl	%eax, %edi
 1574 0f85 E8000000 		call	find
 1574      00
 1575 0f8a 84C0     		testb	%al, %al
 1576 0f8c 0F840D0C 		je	.L83
 1576      0000
 377:main.c        ****                                 printf("Valid user found \n");
 1577              		.loc 1 377 0
 1578 0f92 BF000000 		movl	$.LC54, %edi
 1578      00
 1579 0f97 E8000000 		call	puts
 1579      00
 378:main.c        ****                                 if (!isAdmin) {
 1580              		.loc 1 378 0
 1581 0f9c 0FB68594 		movzbl	-364(%rbp), %eax
 1581      FEFFFF
 1582 0fa3 83F001   		xorl	$1, %eax
 1583 0fa6 84C0     		testb	%al, %al
 1584 0fa8 0F844806 		je	.L84
 1584      0000
 1585              	.LBB15:
 379:main.c        ****                                     int reqAmo = inpFromFrontEnd[0];
 1586              		.loc 1 379 0
 1587 0fae 8B8500FF 		movl	-256(%rbp), %eax
 1587      FFFF
 1588 0fb4 8985BCFE 		movl	%eax, -324(%rbp)
 1588      FFFF
 380:main.c        ****                                     if (suffBalUser(bal, &reqAmo)) {
 1589              		.loc 1 380 0
 1590 0fba 8B85B4FE 		movl	-332(%rbp), %eax
 1590      FFFF
 1591 0fc0 488D95BC 		leaq	-324(%rbp), %rdx
 1591      FEFFFF
 1592 0fc7 4889D6   		movq	%rdx, %rsi
 1593 0fca 89C7     		movl	%eax, %edi
 1594 0fcc E8000000 		call	suffBalUser
 1594      00
 1595 0fd1 84C0     		testb	%al, %al
 1596 0fd3 0F84CF04 		je	.L85
 1596      0000
 1597              	.LBB16:
 381:main.c        ****                                        printf("bal %u\n", bal);
 1598              		.loc 1 381 0
 1599 0fd9 8B85B4FE 		movl	-332(%rbp), %eax
 1599      FFFF
 1600 0fdf 89C6     		movl	%eax, %esi
 1601 0fe1 BF000000 		movl	$.LC55, %edi
 1601      00
 1602 0fe6 B8000000 		movl	$0, %eax
 1602      00
 1603 0feb E8000000 		call	printf
 1603      00
 382:main.c        ****                                        printf("req %u\n", reqAmo);
 1604              		.loc 1 382 0
 1605 0ff0 8B85BCFE 		movl	-324(%rbp), %eax
 1605      FFFF
 1606 0ff6 89C6     		movl	%eax, %esi
 1607 0ff8 BF000000 		movl	$.LC56, %edi
 1607      00
 1608 0ffd B8000000 		movl	$0, %eax
 1608      00
 1609 1002 E8000000 		call	printf
 1609      00
 383:main.c        ****                                         if (LOG) printf("Sufficient Balance in account\n");
 1610              		.loc 1 383 0
 1611 1007 0FB60500 		movzbl	LOG(%rip), %eax
 1611      000000
 1612 100e 84C0     		testb	%al, %al
 1613 1010 740A     		je	.L86
 1614              		.loc 1 383 0 is_stmt 0 discriminator 1
 1615 1012 BF000000 		movl	$.LC57, %edi
 1615      00
 1616 1017 E8000000 		call	puts
 1616      00
 1617              	.L86:
 384:main.c        ****                                         *statusOnChan9 = 1;
 1618              		.loc 1 384 0 is_stmt 1
 1619 101c 488B45A8 		movq	-88(%rbp), %rax
 1620 1020 C60001   		movb	$1, (%rax)
 385:main.c        ****                                         flSleep(1000);
 1621              		.loc 1 385 0
 1622 1023 BFE80300 		movl	$1000, %edi
 1622      00
 1623 1028 E8000000 		call	flSleep
 1623      00
 386:main.c        ****                                         if (LOG) printf("Write to channel %u = %u \n", 9, *statusOn
 1624              		.loc 1 386 0
 1625 102d 0FB60500 		movzbl	LOG(%rip), %eax
 1625      000000
 1626 1034 84C0     		testb	%al, %al
 1627 1036 7420     		je	.L87
 1628              		.loc 1 386 0 is_stmt 0 discriminator 1
 1629 1038 488B45A8 		movq	-88(%rbp), %rax
 1630 103c 0FB600   		movzbl	(%rax), %eax
 1631 103f 0FB6C0   		movzbl	%al, %eax
 1632 1042 89C2     		movl	%eax, %edx
 1633 1044 BE090000 		movl	$9, %esi
 1633      00
 1634 1049 BF000000 		movl	$.LC58, %edi
 1634      00
 1635 104e B8000000 		movl	$0, %eax
 1635      00
 1636 1053 E8000000 		call	printf
 1636      00
 1637              	.L87:
 387:main.c        ****                                         fStatus = flWriteChannel(handle, (uint8_t) 9, length, statu
 1638              		.loc 1 387 0 is_stmt 1
 1639 1058 8B95F4FE 		movl	-268(%rbp), %edx
 1639      FFFF
 1640 105e 488B8518 		movq	-232(%rbp), %rax
 1640      FFFFFF
 1641 1065 488DB520 		leaq	-224(%rbp), %rsi
 1641      FFFFFF
 1642 106c 488B4DA8 		movq	-88(%rbp), %rcx
 1643 1070 4989F0   		movq	%rsi, %r8
 1644 1073 BE090000 		movl	$9, %esi
 1644      00
 1645 1078 4889C7   		movq	%rax, %rdi
 1646 107b E8000000 		call	flWriteChannel
 1646      00
 1647 1080 8985F0FE 		movl	%eax, -272(%rbp)
 1647      FFFF
 388:main.c        ****                                         CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1648              		.loc 1 388 0
 1649 1086 83BDF0FE 		cmpl	$0, -272(%rbp)
 1649      FFFF00
 1650 108d 740F     		je	.L88
 1651              		.loc 1 388 0 is_stmt 0 discriminator 1
 1652 108f C785C0FE 		movl	$1, -320(%rbp)
 1652      FFFF0100 
 1652      0000
 1653 1099 E9530500 		jmp	.L115
 1653      00
 1654              	.L88:
 389:main.c        ****                                         flSleep(1000);
 1655              		.loc 1 389 0 is_stmt 1
 1656 109e BFE80300 		movl	$1000, %edi
 1656      00
 1657 10a3 E8000000 		call	flSleep
 1657      00
 1658              	.LBB17:
 390:main.c        ****                                         uint32_t befEncSen[2];
 391:main.c        ****                                         for (int i = 0; i < 2; i++) befEncSen[i] = 0;
 1659              		.loc 1 391 0
 1660 10a8 C785D0FE 		movl	$0, -304(%rbp)
 1660      FFFF0000 
 1660      0000
 1661 10b2 EB1A     		jmp	.L90
 1662              	.L91:
 1663              		.loc 1 391 0 is_stmt 0 discriminator 2
 1664 10b4 8B85D0FE 		movl	-304(%rbp), %eax
 1664      FFFF
 1665 10ba 4898     		cltq
 1666 10bc C7848510 		movl	$0, -240(%rbp,%rax,4)
 1666      FFFFFF00 
 1666      000000
 1667 10c7 8385D0FE 		addl	$1, -304(%rbp)
 1667      FFFF01
 1668              	.L90:
 1669              		.loc 1 391 0 discriminator 1
 1670 10ce 83BDD0FE 		cmpl	$1, -304(%rbp)
 1670      FFFF01
 1671 10d5 7EDD     		jle	.L91
 1672              	.LBE17:
 392:main.c        ****                                         befEncSen[0] = reqAmo;
 1673              		.loc 1 392 0 is_stmt 1
 1674 10d7 8B85BCFE 		movl	-324(%rbp), %eax
 1674      FFFF
 1675 10dd 898510FF 		movl	%eax, -240(%rbp)
 1675      FFFF
 393:main.c        ****                                         encrypt64(befEncSen);
 1676              		.loc 1 393 0
 1677 10e3 488D8510 		leaq	-240(%rbp), %rax
 1677      FFFFFF
 1678 10ea 4889C7   		movq	%rax, %rdi
 1679 10ed E8000000 		call	encrypt64
 1679      00
 1680              	.LBB18:
 394:main.c        ****                                         for (uint8_t i = 10; i <= 13; i++) {
 1681              		.loc 1 394 0
 1682 10f2 C6859CFE 		movb	$10, -356(%rbp)
 1682      FFFF0A
 1683 10f9 E91C0100 		jmp	.L92
 1683      00
 1684              	.L98:
 1685              	.LBB19:
 395:main.c        ****                                             uint8_t tempSto = 0;
 1686              		.loc 1 395 0
 1687 10fe C68595FE 		movb	$0, -363(%rbp)
 1687      FFFF00
 1688              	.LBB20:
 396:main.c        ****                                             for (uint8_t j = 0; j <= 7; j++) {
 1689              		.loc 1 396 0
 1690 1105 C6859DFE 		movb	$0, -355(%rbp)
 1690      FFFF00
 1691 110c EB71     		jmp	.L93
 1692              	.L95:
 1693              	.LBB21:
 397:main.c        ****                                                 uint8_t temp = j + (i - 10) * 8;
 1694              		.loc 1 397 0
 1695 110e 0FB6859C 		movzbl	-356(%rbp), %eax
 1695      FEFFFF
 1696 1115 83E80A   		subl	$10, %eax
 1697 1118 8D14C500 		leal	0(,%rax,8), %edx
 1697      000000
 1698 111f 0FB6859D 		movzbl	-355(%rbp), %eax
 1698      FEFFFF
 1699 1126 01D0     		addl	%edx, %eax
 1700 1128 8885A8FE 		movb	%al, -344(%rbp)
 1700      FFFF
 398:main.c        ****                                                 if ((befEncSen[0] & (1 << temp)) != 0) {
 1701              		.loc 1 398 0
 1702 112e 8B9510FF 		movl	-240(%rbp), %edx
 1702      FFFF
 1703 1134 0FB685A8 		movzbl	-344(%rbp), %eax
 1703      FEFFFF
 1704 113b BE010000 		movl	$1, %esi
 1704      00
 1705 1140 89C1     		movl	%eax, %ecx
 1706 1142 D3E6     		sall	%cl, %esi
 1707 1144 89F0     		movl	%esi, %eax
 1708 1146 21D0     		andl	%edx, %eax
 1709 1148 85C0     		testl	%eax, %eax
 1710 114a 7423     		je	.L94
 399:main.c        ****                                                     tempSto += (1 << j);
 1711              		.loc 1 399 0
 1712 114c 0FB6859D 		movzbl	-355(%rbp), %eax
 1712      FEFFFF
 1713 1153 BA010000 		movl	$1, %edx
 1713      00
 1714 1158 89C1     		movl	%eax, %ecx
 1715 115a D3E2     		sall	%cl, %edx
 1716 115c 89D0     		movl	%edx, %eax
 1717 115e 89C2     		movl	%eax, %edx
 1718 1160 0FB68595 		movzbl	-363(%rbp), %eax
 1718      FEFFFF
 1719 1167 01D0     		addl	%edx, %eax
 1720 1169 888595FE 		movb	%al, -363(%rbp)
 1720      FFFF
 1721              	.L94:
 1722              	.LBE21:
 396:main.c        ****                                                 uint8_t temp = j + (i - 10) * 8;
 1723              		.loc 1 396 0
 1724 116f 0FB6859D 		movzbl	-355(%rbp), %eax
 1724      FEFFFF
 1725 1176 83C001   		addl	$1, %eax
 1726 1179 88859DFE 		movb	%al, -355(%rbp)
 1726      FFFF
 1727              	.L93:
 396:main.c        ****                                                 uint8_t temp = j + (i - 10) * 8;
 1728              		.loc 1 396 0 is_stmt 0 discriminator 1
 1729 117f 80BD9DFE 		cmpb	$7, -355(%rbp)
 1729      FFFF07
 1730 1186 7686     		jbe	.L95
 1731              	.LBE20:
 400:main.c        ****                                                 }
 401:main.c        ****                                             }
 402:main.c        ****                                             flSleep(1000);
 1732              		.loc 1 402 0 is_stmt 1
 1733 1188 BFE80300 		movl	$1000, %edi
 1733      00
 1734 118d E8000000 		call	flSleep
 1734      00
 403:main.c        ****                                             fStatus = flWriteChannel(handle, (uint8_t) i, length, &
 1735              		.loc 1 403 0
 1736 1192 8B95F4FE 		movl	-268(%rbp), %edx
 1736      FFFF
 1737 1198 0FB6B59C 		movzbl	-356(%rbp), %esi
 1737      FEFFFF
 1738 119f 488B8518 		movq	-232(%rbp), %rax
 1738      FFFFFF
 1739 11a6 488DBD20 		leaq	-224(%rbp), %rdi
 1739      FFFFFF
 1740 11ad 488D8D95 		leaq	-363(%rbp), %rcx
 1740      FEFFFF
 1741 11b4 4989F8   		movq	%rdi, %r8
 1742 11b7 4889C7   		movq	%rax, %rdi
 1743 11ba E8000000 		call	flWriteChannel
 1743      00
 1744 11bf 8985F0FE 		movl	%eax, -272(%rbp)
 1744      FFFF
 404:main.c        ****                                             if (LOG) printf("Write to channel %u = %u \n", i, tempS
 1745              		.loc 1 404 0
 1746 11c5 0FB60500 		movzbl	LOG(%rip), %eax
 1746      000000
 1747 11cc 84C0     		testb	%al, %al
 1748 11ce 7422     		je	.L96
 1749              		.loc 1 404 0 is_stmt 0 discriminator 1
 1750 11d0 0FB68595 		movzbl	-363(%rbp), %eax
 1750      FEFFFF
 1751 11d7 0FB6D0   		movzbl	%al, %edx
 1752 11da 0FB6859C 		movzbl	-356(%rbp), %eax
 1752      FEFFFF
 1753 11e1 89C6     		movl	%eax, %esi
 1754 11e3 BF000000 		movl	$.LC58, %edi
 1754      00
 1755 11e8 B8000000 		movl	$0, %eax
 1755      00
 1756 11ed E8000000 		call	printf
 1756      00
 1757              	.L96:
 405:main.c        ****                                             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1758              		.loc 1 405 0 is_stmt 1
 1759 11f2 83BDF0FE 		cmpl	$0, -272(%rbp)
 1759      FFFF00
 1760 11f9 740F     		je	.L97
 1761              		.loc 1 405 0 is_stmt 0 discriminator 1
 1762 11fb C785C0FE 		movl	$1, -320(%rbp)
 1762      FFFF0100 
 1762      0000
 1763              	.LBE19:
 1764              	.LBE18:
 388:main.c        ****                                         flSleep(1000);
 1765              		.loc 1 388 0 is_stmt 1 discriminator 1
 1766 1205 E9E70300 		jmp	.L115
 1766      00
 1767              	.L97:
 1768              	.LBB22:
 394:main.c        ****                                             uint8_t tempSto = 0;
 1769              		.loc 1 394 0
 1770 120a 0FB6859C 		movzbl	-356(%rbp), %eax
 1770      FEFFFF
 1771 1211 83C001   		addl	$1, %eax
 1772 1214 88859CFE 		movb	%al, -356(%rbp)
 1772      FFFF
 1773              	.L92:
 394:main.c        ****                                             uint8_t tempSto = 0;
 1774              		.loc 1 394 0 is_stmt 0 discriminator 1
 1775 121a 80BD9CFE 		cmpb	$13, -356(%rbp)
 1775      FFFF0D
 1776 1221 0F86D7FE 		jbe	.L98
 1776      FFFF
 1777              	.LBE22:
 1778              	.LBB23:
 406:main.c        ****                                         }
 407:main.c        **** 
 408:main.c        ****                                         for (uint8_t i = 14; i <= 17; i++) {
 1779              		.loc 1 408 0 is_stmt 1
 1780 1227 C6859EFE 		movb	$14, -354(%rbp)
 1780      FFFF0E
 1781 122e E91C0100 		jmp	.L99
 1781      00
 1782              	.L105:
 1783              	.LBB24:
 409:main.c        ****                                             uint8_t tempSto = 0;
 1784              		.loc 1 409 0
 1785 1233 C68595FE 		movb	$0, -363(%rbp)
 1785      FFFF00
 1786              	.LBB25:
 410:main.c        ****                                             for (uint8_t j = 0; j <= 7; j++) {
 1787              		.loc 1 410 0
 1788 123a C6859FFE 		movb	$0, -353(%rbp)
 1788      FFFF00
 1789 1241 EB71     		jmp	.L100
 1790              	.L102:
 1791              	.LBB26:
 411:main.c        ****                                                 uint8_t temp = j + (i - 14) * 8;
 1792              		.loc 1 411 0
 1793 1243 0FB6859E 		movzbl	-354(%rbp), %eax
 1793      FEFFFF
 1794 124a 83E80E   		subl	$14, %eax
 1795 124d 8D14C500 		leal	0(,%rax,8), %edx
 1795      000000
 1796 1254 0FB6859F 		movzbl	-353(%rbp), %eax
 1796      FEFFFF
 1797 125b 01D0     		addl	%edx, %eax
 1798 125d 8885A9FE 		movb	%al, -343(%rbp)
 1798      FFFF
 412:main.c        ****                                                 if ((befEncSen[1] & (1 << temp)) != 0) {
 1799              		.loc 1 412 0
 1800 1263 8B9514FF 		movl	-236(%rbp), %edx
 1800      FFFF
 1801 1269 0FB685A9 		movzbl	-343(%rbp), %eax
 1801      FEFFFF
 1802 1270 BE010000 		movl	$1, %esi
 1802      00
 1803 1275 89C1     		movl	%eax, %ecx
 1804 1277 D3E6     		sall	%cl, %esi
 1805 1279 89F0     		movl	%esi, %eax
 1806 127b 21D0     		andl	%edx, %eax
 1807 127d 85C0     		testl	%eax, %eax
 1808 127f 7423     		je	.L101
 413:main.c        ****                                                     tempSto += (1 << j);
 1809              		.loc 1 413 0
 1810 1281 0FB6859F 		movzbl	-353(%rbp), %eax
 1810      FEFFFF
 1811 1288 BA010000 		movl	$1, %edx
 1811      00
 1812 128d 89C1     		movl	%eax, %ecx
 1813 128f D3E2     		sall	%cl, %edx
 1814 1291 89D0     		movl	%edx, %eax
 1815 1293 89C2     		movl	%eax, %edx
 1816 1295 0FB68595 		movzbl	-363(%rbp), %eax
 1816      FEFFFF
 1817 129c 01D0     		addl	%edx, %eax
 1818 129e 888595FE 		movb	%al, -363(%rbp)
 1818      FFFF
 1819              	.L101:
 1820              	.LBE26:
 410:main.c        ****                                                 uint8_t temp = j + (i - 14) * 8;
 1821              		.loc 1 410 0
 1822 12a4 0FB6859F 		movzbl	-353(%rbp), %eax
 1822      FEFFFF
 1823 12ab 83C001   		addl	$1, %eax
 1824 12ae 88859FFE 		movb	%al, -353(%rbp)
 1824      FFFF
 1825              	.L100:
 410:main.c        ****                                                 uint8_t temp = j + (i - 14) * 8;
 1826              		.loc 1 410 0 is_stmt 0 discriminator 1
 1827 12b4 80BD9FFE 		cmpb	$7, -353(%rbp)
 1827      FFFF07
 1828 12bb 7686     		jbe	.L102
 1829              	.LBE25:
 414:main.c        ****                                                 }
 415:main.c        ****                                             }
 416:main.c        ****                                             flSleep(1000);
 1830              		.loc 1 416 0 is_stmt 1
 1831 12bd BFE80300 		movl	$1000, %edi
 1831      00
 1832 12c2 E8000000 		call	flSleep
 1832      00
 417:main.c        ****                                             fStatus = flWriteChannel(handle, (uint8_t) i, length, &
 1833              		.loc 1 417 0
 1834 12c7 8B95F4FE 		movl	-268(%rbp), %edx
 1834      FFFF
 1835 12cd 0FB6B59E 		movzbl	-354(%rbp), %esi
 1835      FEFFFF
 1836 12d4 488B8518 		movq	-232(%rbp), %rax
 1836      FFFFFF
 1837 12db 488DBD20 		leaq	-224(%rbp), %rdi
 1837      FFFFFF
 1838 12e2 488D8D95 		leaq	-363(%rbp), %rcx
 1838      FEFFFF
 1839 12e9 4989F8   		movq	%rdi, %r8
 1840 12ec 4889C7   		movq	%rax, %rdi
 1841 12ef E8000000 		call	flWriteChannel
 1841      00
 1842 12f4 8985F0FE 		movl	%eax, -272(%rbp)
 1842      FFFF
 418:main.c        ****                                             if (LOG) printf("Write to channel %u = %u \n", i, tempS
 1843              		.loc 1 418 0
 1844 12fa 0FB60500 		movzbl	LOG(%rip), %eax
 1844      000000
 1845 1301 84C0     		testb	%al, %al
 1846 1303 7422     		je	.L103
 1847              		.loc 1 418 0 is_stmt 0 discriminator 1
 1848 1305 0FB68595 		movzbl	-363(%rbp), %eax
 1848      FEFFFF
 1849 130c 0FB6D0   		movzbl	%al, %edx
 1850 130f 0FB6859E 		movzbl	-354(%rbp), %eax
 1850      FEFFFF
 1851 1316 89C6     		movl	%eax, %esi
 1852 1318 BF000000 		movl	$.LC58, %edi
 1852      00
 1853 131d B8000000 		movl	$0, %eax
 1853      00
 1854 1322 E8000000 		call	printf
 1854      00
 1855              	.L103:
 419:main.c        ****                                             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1856              		.loc 1 419 0 is_stmt 1
 1857 1327 83BDF0FE 		cmpl	$0, -272(%rbp)
 1857      FFFF00
 1858 132e 740F     		je	.L104
 1859              		.loc 1 419 0 is_stmt 0 discriminator 1
 1860 1330 C785C0FE 		movl	$1, -320(%rbp)
 1860      FFFF0100 
 1860      0000
 1861              	.LBE24:
 1862              	.LBE23:
 388:main.c        ****                                         flSleep(1000);
 1863              		.loc 1 388 0 is_stmt 1 discriminator 1
 1864 133a E9B20200 		jmp	.L115
 1864      00
 1865              	.L104:
 1866              	.LBB27:
 408:main.c        ****                                             uint8_t tempSto = 0;
 1867              		.loc 1 408 0
 1868 133f 0FB6859E 		movzbl	-354(%rbp), %eax
 1868      FEFFFF
 1869 1346 83C001   		addl	$1, %eax
 1870 1349 88859EFE 		movb	%al, -354(%rbp)
 1870      FFFF
 1871              	.L99:
 408:main.c        ****                                             uint8_t tempSto = 0;
 1872              		.loc 1 408 0 is_stmt 0 discriminator 1
 1873 134f 80BD9EFE 		cmpb	$17, -354(%rbp)
 1873      FFFF11
 1874 1356 0F86D7FE 		jbe	.L105
 1874      FFFF
 1875              	.LBE27:
 420:main.c        ****                                         }
 421:main.c        ****                                         /* update the balance in the global variable now and update
 422:main.c        ****                                         if ((*readFromChannelZero) == 1) {
 1876              		.loc 1 422 0 is_stmt 1
 1877 135c 488B4598 		movq	-104(%rbp), %rax
 1878 1360 0FB600   		movzbl	(%rax), %eax
 1879 1363 3C01     		cmpb	$1, %al
 1880 1365 0F853801 		jne	.L106
 1880      0000
 423:main.c        ****                                             dataFromCSV[inLineNum][3] -= reqAmo;
 1881              		.loc 1 423 0
 1882 136b 8B85B8FE 		movl	-328(%rbp), %eax
 1882      FFFF
 1883 1371 8B95B8FE 		movl	-328(%rbp), %edx
 1883      FFFF
 1884 1377 4863D2   		movslq	%edx, %rdx
 1885 137a 48C1E204 		salq	$4, %rdx
 1886 137e 4881C200 		addq	$dataFromCSV+12, %rdx
 1886      000000
 1887 1385 8B0A     		movl	(%rdx), %ecx
 1888 1387 8B95BCFE 		movl	-324(%rbp), %edx
 1888      FFFF
 1889 138d 29D1     		subl	%edx, %ecx
 1890 138f 89CA     		movl	%ecx, %edx
 1891 1391 4898     		cltq
 1892 1393 48C1E004 		salq	$4, %rax
 1893 1397 48050000 		addq	$dataFromCSV+12, %rax
 1893      0000
 1894 139d 8910     		movl	%edx, (%rax)
 424:main.c        **** 
 425:main.c        ****                                             /* Updating csv file in place */
 426:main.c        ****                                             fPtr = fopen("SampleBackEndDatabase.csv", "w+"); // cha
 1895              		.loc 1 426 0
 1896 139f BE000000 		movl	$.LC59, %esi
 1896      00
 1897 13a4 BF000000 		movl	$.LC50, %edi
 1897      00
 1898 13a9 E8000000 		call	fopen
 1898      00
 1899 13ae 48894590 		movq	%rax, -112(%rbp)
 427:main.c        ****                                             fprintf(fPtr, "%s", "\"User ID (decimal)\",\"PIN Hash (
 1900              		.loc 1 427 0
 1901 13b2 488B4590 		movq	-112(%rbp), %rax
 1902 13b6 4889C1   		movq	%rax, %rcx
 1903 13b9 BA440000 		movl	$68, %edx
 1903      00
 1904 13be BE010000 		movl	$1, %esi
 1904      00
 1905 13c3 BF000000 		movl	$.LC60, %edi
 1905      00
 1906 13c8 E8000000 		call	fwrite
 1906      00
 428:main.c        ****                                             fprintf(fPtr, "\n");
 1907              		.loc 1 428 0
 1908 13cd 488B4590 		movq	-112(%rbp), %rax
 1909 13d1 4889C6   		movq	%rax, %rsi
 1910 13d4 BF0A0000 		movl	$10, %edi
 1910      00
 1911 13d9 E8000000 		call	fputc
 1911      00
 1912              	.LBB28:
 429:main.c        ****                                             for (int i = 1; i <= numLines; i++) {
 1913              		.loc 1 429 0
 1914 13de C785D4FE 		movl	$1, -300(%rbp)
 1914      FFFF0100 
 1914      0000
 1915 13e8 E9930000 		jmp	.L107
 1915      00
 1916              	.L113:
 1917              	.LBB29:
 430:main.c        ****                                                 for (int k = 0; k < 4; k++) {
 1918              		.loc 1 430 0
 1919 13ed C785D8FE 		movl	$0, -296(%rbp)
 1919      FFFF0000 
 1919      0000
 1920 13f7 EB77     		jmp	.L108
 1921              	.L112:
 431:main.c        ****                                                     fprintf(fPtr, "%d", dataFromCSV[i][k]);
 1922              		.loc 1 431 0
 1923 13f9 8B85D8FE 		movl	-296(%rbp), %eax
 1923      FFFF
 1924 13ff 4898     		cltq
 1925 1401 8B95D4FE 		movl	-300(%rbp), %edx
 1925      FFFF
 1926 1407 4863D2   		movslq	%edx, %rdx
 1927 140a 48C1E202 		salq	$2, %rdx
 1928 140e 4801D0   		addq	%rdx, %rax
 1929 1411 8B148500 		movl	dataFromCSV(,%rax,4), %edx
 1929      000000
 1930 1418 488B4590 		movq	-112(%rbp), %rax
 1931 141c BE000000 		movl	$.LC1, %esi
 1931      00
 1932 1421 4889C7   		movq	%rax, %rdi
 1933 1424 B8000000 		movl	$0, %eax
 1933      00
 1934 1429 E8000000 		call	fprintf
 1934      00
 432:main.c        ****                                                     if (k == 3) {
 1935              		.loc 1 432 0
 1936 142e 83BDD8FE 		cmpl	$3, -296(%rbp)
 1936      FFFF03
 1937 1435 7521     		jne	.L109
 433:main.c        ****                                                         if (i != numLines) fprintf(fPtr, "\n");
 1938              		.loc 1 433 0
 1939 1437 8B050000 		movl	numLines(%rip), %eax
 1939      0000
 1940 143d 3985D4FE 		cmpl	%eax, -300(%rbp)
 1940      FFFF
 1941 1443 7424     		je	.L111
 1942              		.loc 1 433 0 is_stmt 0 discriminator 1
 1943 1445 488B4590 		movq	-112(%rbp), %rax
 1944 1449 4889C6   		movq	%rax, %rsi
 1945 144c BF0A0000 		movl	$10, %edi
 1945      00
 1946 1451 E8000000 		call	fputc
 1946      00
 1947 1456 EB11     		jmp	.L111
 1948              	.L109:
 434:main.c        ****                                                     } else fprintf(fPtr, ",");
 1949              		.loc 1 434 0 is_stmt 1
 1950 1458 488B4590 		movq	-112(%rbp), %rax
 1951 145c 4889C6   		movq	%rax, %rsi
 1952 145f BF2C0000 		movl	$44, %edi
 1952      00
 1953 1464 E8000000 		call	fputc
 1953      00
 1954              	.L111:
 430:main.c        ****                                                     fprintf(fPtr, "%d", dataFromCSV[i][k]);
 1955              		.loc 1 430 0
 1956 1469 8385D8FE 		addl	$1, -296(%rbp)
 1956      FFFF01
 1957              	.L108:
 430:main.c        ****                                                     fprintf(fPtr, "%d", dataFromCSV[i][k]);
 1958              		.loc 1 430 0 is_stmt 0 discriminator 1
 1959 1470 83BDD8FE 		cmpl	$3, -296(%rbp)
 1959      FFFF03
 1960 1477 7E80     		jle	.L112
 1961              	.LBE29:
 429:main.c        ****                                                 for (int k = 0; k < 4; k++) {
 1962              		.loc 1 429 0 is_stmt 1
 1963 1479 8385D4FE 		addl	$1, -300(%rbp)
 1963      FFFF01
 1964              	.L107:
 429:main.c        ****                                                 for (int k = 0; k < 4; k++) {
 1965              		.loc 1 429 0 is_stmt 0 discriminator 1
 1966 1480 8B050000 		movl	numLines(%rip), %eax
 1966      0000
 1967 1486 3985D4FE 		cmpl	%eax, -300(%rbp)
 1967      FFFF
 1968 148c 0F8E5BFF 		jle	.L113
 1968      FFFF
 1969              	.LBE28:
 435:main.c        ****                                                 }
 436:main.c        ****                                             }
 437:main.c        ****                                             fclose(fPtr);
 1970              		.loc 1 437 0 is_stmt 1
 1971 1492 488B4590 		movq	-112(%rbp), %rax
 1972 1496 4889C7   		movq	%rax, %rdi
 1973 1499 E8000000 		call	fclose
 1973      00
 1974              	.LBE16:
 1975 149e E9490100 		jmp	.L114
 1975      00
 1976              	.L106:
 1977 14a3 E9440100 		jmp	.L114
 1977      00
 1978              	.L85:
 438:main.c        ****                                         }
 439:main.c        ****                                     } else {
 440:main.c        **** //                                        printf("bal %u\n", bal);
 441:main.c        **** //                                        printf("req %u\n", reqAmo);
 442:main.c        ****                                         if (LOG) printf("Insufficient Balance \n");
 1979              		.loc 1 442 0
 1980 14a8 0FB60500 		movzbl	LOG(%rip), %eax
 1980      000000
 1981 14af 84C0     		testb	%al, %al
 1982 14b1 740A     		je	.L116
 1983              		.loc 1 442 0 is_stmt 0 discriminator 1
 1984 14b3 BF000000 		movl	$.LC61, %edi
 1984      00
 1985 14b8 E8000000 		call	puts
 1985      00
 1986              	.L116:
 443:main.c        ****                                         *statusOnChan9 = 2;
 1987              		.loc 1 443 0 is_stmt 1
 1988 14bd 488B45A8 		movq	-88(%rbp), %rax
 1989 14c1 C60002   		movb	$2, (%rax)
 444:main.c        ****                                         flSleep(1000);
 1990              		.loc 1 444 0
 1991 14c4 BFE80300 		movl	$1000, %edi
 1991      00
 1992 14c9 E8000000 		call	flSleep
 1992      00
 445:main.c        ****                                         if (LOG) printf("Write to channel %u = %u \n", 9, *statusOn
 1993              		.loc 1 445 0
 1994 14ce 0FB60500 		movzbl	LOG(%rip), %eax
 1994      000000
 1995 14d5 84C0     		testb	%al, %al
 1996 14d7 7420     		je	.L117
 1997              		.loc 1 445 0 is_stmt 0 discriminator 1
 1998 14d9 488B45A8 		movq	-88(%rbp), %rax
 1999 14dd 0FB600   		movzbl	(%rax), %eax
 2000 14e0 0FB6C0   		movzbl	%al, %eax
 2001 14e3 89C2     		movl	%eax, %edx
 2002 14e5 BE090000 		movl	$9, %esi
 2002      00
 2003 14ea BF000000 		movl	$.LC58, %edi
 2003      00
 2004 14ef B8000000 		movl	$0, %eax
 2004      00
 2005 14f4 E8000000 		call	printf
 2005      00
 2006              	.L117:
 446:main.c        ****                                         fStatus = flWriteChannel(handle, (uint8_t) 9, length, statu
 2007              		.loc 1 446 0 is_stmt 1
 2008 14f9 8B95F4FE 		movl	-268(%rbp), %edx
 2008      FFFF
 2009 14ff 488B8518 		movq	-232(%rbp), %rax
 2009      FFFFFF
 2010 1506 488DB520 		leaq	-224(%rbp), %rsi
 2010      FFFFFF
 2011 150d 488B4DA8 		movq	-88(%rbp), %rcx
 2012 1511 4989F0   		movq	%rsi, %r8
 2013 1514 BE090000 		movl	$9, %esi
 2013      00
 2014 1519 4889C7   		movq	%rax, %rdi
 2015 151c E8000000 		call	flWriteChannel
 2015      00
 2016 1521 8985F0FE 		movl	%eax, -272(%rbp)
 2016      FFFF
 447:main.c        ****                                         CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2017              		.loc 1 447 0
 2018 1527 83BDF0FE 		cmpl	$0, -272(%rbp)
 2018      FFFF00
 2019 152e 740F     		je	.L118
 2020              		.loc 1 447 0 is_stmt 0 discriminator 1
 2021 1530 C785C0FE 		movl	$1, -320(%rbp)
 2021      FFFF0100 
 2021      0000
 2022 153a E9B20000 		jmp	.L115
 2022      00
 2023              	.L118:
 2024              	.LBB30:
 448:main.c        ****                                         for (int i = 10; i <= 17; i++) {
 2025              		.loc 1 448 0 is_stmt 1
 2026 153f C785DCFE 		movl	$10, -292(%rbp)
 2026      FFFF0A00 
 2026      0000
 2027 1549 E9910000 		jmp	.L119
 2027      00
 2028              	.L122:
 2029              	.LBB31:
 449:main.c        ****                                             uint8_t tempSto = 0;
 2030              		.loc 1 449 0
 2031 154e C68510FF 		movb	$0, -240(%rbp)
 2031      FFFF00
 450:main.c        ****                                             flSleep(1000);
 2032              		.loc 1 450 0
 2033 1555 BFE80300 		movl	$1000, %edi
 2033      00
 2034 155a E8000000 		call	flSleep
 2034      00
 451:main.c        ****                                             if (LOG) printf("Write to channel %u = %u \n", i, tempS
 2035              		.loc 1 451 0
 2036 155f 0FB60500 		movzbl	LOG(%rip), %eax
 2036      000000
 2037 1566 84C0     		testb	%al, %al
 2038 1568 7421     		je	.L120
 2039              		.loc 1 451 0 is_stmt 0 discriminator 1
 2040 156a 0FB68510 		movzbl	-240(%rbp), %eax
 2040      FFFFFF
 2041 1571 0FB6D0   		movzbl	%al, %edx
 2042 1574 8B85DCFE 		movl	-292(%rbp), %eax
 2042      FFFF
 2043 157a 89C6     		movl	%eax, %esi
 2044 157c BF000000 		movl	$.LC58, %edi
 2044      00
 2045 1581 B8000000 		movl	$0, %eax
 2045      00
 2046 1586 E8000000 		call	printf
 2046      00
 2047              	.L120:
 452:main.c        ****                                             fStatus = flWriteChannel(handle, (uint8_t) i, length, &
 2048              		.loc 1 452 0 is_stmt 1
 2049 158b 8B95F4FE 		movl	-268(%rbp), %edx
 2049      FFFF
 2050 1591 8B85DCFE 		movl	-292(%rbp), %eax
 2050      FFFF
 2051 1597 0FB6F0   		movzbl	%al, %esi
 2052 159a 488B8518 		movq	-232(%rbp), %rax
 2052      FFFFFF
 2053 15a1 488DBD20 		leaq	-224(%rbp), %rdi
 2053      FFFFFF
 2054 15a8 488D8D10 		leaq	-240(%rbp), %rcx
 2054      FFFFFF
 2055 15af 4989F8   		movq	%rdi, %r8
 2056 15b2 4889C7   		movq	%rax, %rdi
 2057 15b5 E8000000 		call	flWriteChannel
 2057      00
 2058 15ba 8985F0FE 		movl	%eax, -272(%rbp)
 2058      FFFF
 453:main.c        ****                                             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2059              		.loc 1 453 0
 2060 15c0 83BDF0FE 		cmpl	$0, -272(%rbp)
 2060      FFFF00
 2061 15c7 740F     		je	.L121
 2062              		.loc 1 453 0 is_stmt 0 discriminator 1
 2063 15c9 C785C0FE 		movl	$1, -320(%rbp)
 2063      FFFF0100 
 2063      0000
 2064              	.LBE31:
 2065              	.LBE30:
 2066 15d3 E9FF0600 		jmp	.L73
 2066      00
 2067              	.L121:
 2068              	.LBB32:
 448:main.c        ****                                             uint8_t tempSto = 0;
 2069              		.loc 1 448 0 is_stmt 1
 2070 15d8 8385DCFE 		addl	$1, -292(%rbp)
 2070      FFFF01
 2071              	.L119:
 448:main.c        ****                                             uint8_t tempSto = 0;
 2072              		.loc 1 448 0 is_stmt 0 discriminator 1
 2073 15df 83BDDCFE 		cmpl	$17, -292(%rbp)
 2073      FFFF11
 2074 15e6 0F8E62FF 		jle	.L122
 2074      FFFF
 2075              	.L114:
 2076              	.LBE32:
 2077              	.LBE15:
 2078 15ec E9E80600 		jmp	.L62
 2078      00
 2079              	.L115:
 350:main.c        ****                                 if (LOG) printf("Read from channel %u = %u \n", i, *readFromChannel
 2080              		.loc 1 350 0 is_stmt 1
 2081 15f1 E9F20600 		jmp	.L59
 2081      00
 2082              	.L84:
 2083              	.LBB33:
 454:main.c        ****                                         }
 455:main.c        ****                                     }
 456:main.c        ****                                 } else {
 457:main.c        ****                                     printf("User has admin privileges \n");
 2084              		.loc 1 457 0
 2085 15f6 BF000000 		movl	$.LC62, %edi
 2085      00
 2086 15fb E8000000 		call	puts
 2086      00
 458:main.c        ****                                     *statusOnChan9 = 3;
 2087              		.loc 1 458 0
 2088 1600 488B45A8 		movq	-88(%rbp), %rax
 2089 1604 C60003   		movb	$3, (%rax)
 459:main.c        ****                                     flSleep(1000);
 2090              		.loc 1 459 0
 2091 1607 BFE80300 		movl	$1000, %edi
 2091      00
 2092 160c E8000000 		call	flSleep
 2092      00
 460:main.c        ****                                     if (LOG) printf("Write to channel %u = %u \n", 9, *statusOnChan
 2093              		.loc 1 460 0
 2094 1611 0FB60500 		movzbl	LOG(%rip), %eax
 2094      000000
 2095 1618 84C0     		testb	%al, %al
 2096 161a 7420     		je	.L124
 2097              		.loc 1 460 0 is_stmt 0 discriminator 1
 2098 161c 488B45A8 		movq	-88(%rbp), %rax
 2099 1620 0FB600   		movzbl	(%rax), %eax
 2100 1623 0FB6C0   		movzbl	%al, %eax
 2101 1626 89C2     		movl	%eax, %edx
 2102 1628 BE090000 		movl	$9, %esi
 2102      00
 2103 162d BF000000 		movl	$.LC58, %edi
 2103      00
 2104 1632 B8000000 		movl	$0, %eax
 2104      00
 2105 1637 E8000000 		call	printf
 2105      00
 2106              	.L124:
 461:main.c        ****                                     fStatus = flWriteChannel(handle, (uint8_t) 9, length, statusOnC
 2107              		.loc 1 461 0 is_stmt 1
 2108 163c 8B95F4FE 		movl	-268(%rbp), %edx
 2108      FFFF
 2109 1642 488B8518 		movq	-232(%rbp), %rax
 2109      FFFFFF
 2110 1649 488DB520 		leaq	-224(%rbp), %rsi
 2110      FFFFFF
 2111 1650 488B4DA8 		movq	-88(%rbp), %rcx
 2112 1654 4989F0   		movq	%rsi, %r8
 2113 1657 BE090000 		movl	$9, %esi
 2113      00
 2114 165c 4889C7   		movq	%rax, %rdi
 2115 165f E8000000 		call	flWriteChannel
 2115      00
 2116 1664 8985F0FE 		movl	%eax, -272(%rbp)
 2116      FFFF
 462:main.c        ****                                     CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2117              		.loc 1 462 0
 2118 166a 83BDF0FE 		cmpl	$0, -272(%rbp)
 2118      FFFF00
 2119 1671 740F     		je	.L125
 2120              		.loc 1 462 0 is_stmt 0 discriminator 1
 2121 1673 C785C0FE 		movl	$1, -320(%rbp)
 2121      FFFF0100 
 2121      0000
 2122 167d E9550600 		jmp	.L73
 2122      00
 2123              	.L125:
 2124              	.LBB34:
 463:main.c        **** 
 464:main.c        ****                                     for (uint8_t i = 1; i <= 32; i++) {
 2125              		.loc 1 464 0 is_stmt 1
 2126 1682 C685A0FE 		movb	$1, -352(%rbp)
 2126      FFFF01
 2127 1689 E92F0100 		jmp	.L127
 2127      00
 2128              	.L135:
 465:main.c        ****                                         if (i <= 8) {
 2129              		.loc 1 465 0
 2130 168e 80BDA0FE 		cmpb	$8, -352(%rbp)
 2130      FFFF08
 2131 1695 7745     		ja	.L128
 466:main.c        ****                                             if ((inpFromFrontEnd[0] & (1 << (i - 1))) != 0) num_100
 2132              		.loc 1 466 0
 2133 1697 8B9500FF 		movl	-256(%rbp), %edx
 2133      FFFF
 2134 169d 0FB685A0 		movzbl	-352(%rbp), %eax
 2134      FEFFFF
 2135 16a4 83E801   		subl	$1, %eax
 2136 16a7 BE010000 		movl	$1, %esi
 2136      00
 2137 16ac 89C1     		movl	%eax, %ecx
 2138 16ae D3E6     		sall	%cl, %esi
 2139 16b0 89F0     		movl	%esi, %eax
 2140 16b2 21D0     		andl	%edx, %eax
 2141 16b4 85C0     		testl	%eax, %eax
 2142 16b6 0F84F100 		je	.L130
 2142      0000
 2143              		.loc 1 466 0 is_stmt 0 discriminator 1
 2144 16bc 0FB685A0 		movzbl	-352(%rbp), %eax
 2144      FEFFFF
 2145 16c3 83E801   		subl	$1, %eax
 2146 16c6 BA010000 		movl	$1, %edx
 2146      00
 2147 16cb 89C1     		movl	%eax, %ecx
 2148 16cd D3E2     		sall	%cl, %edx
 2149 16cf 89D0     		movl	%edx, %eax
 2150 16d1 008598FE 		addb	%al, -360(%rbp)
 2150      FFFF
 2151 16d7 E9D10000 		jmp	.L130
 2151      00
 2152              	.L128:
 467:main.c        ****                                         } else if (i <= 16) {
 2153              		.loc 1 467 0 is_stmt 1
 2154 16dc 80BDA0FE 		cmpb	$16, -352(%rbp)
 2154      FFFF10
 2155 16e3 7745     		ja	.L131
 468:main.c        ****                                             if ((inpFromFrontEnd[0] & (1 << (i - 1))) != 0) num_500
 2156              		.loc 1 468 0
 2157 16e5 8B9500FF 		movl	-256(%rbp), %edx
 2157      FFFF
 2158 16eb 0FB685A0 		movzbl	-352(%rbp), %eax
 2158      FEFFFF
 2159 16f2 83E801   		subl	$1, %eax
 2160 16f5 BE010000 		movl	$1, %esi
 2160      00
 2161 16fa 89C1     		movl	%eax, %ecx
 2162 16fc D3E6     		sall	%cl, %esi
 2163 16fe 89F0     		movl	%esi, %eax
 2164 1700 21D0     		andl	%edx, %eax
 2165 1702 85C0     		testl	%eax, %eax
 2166 1704 0F84A300 		je	.L130
 2166      0000
 2167              		.loc 1 468 0 is_stmt 0 discriminator 1
 2168 170a 0FB685A0 		movzbl	-352(%rbp), %eax
 2168      FEFFFF
 2169 1711 83E809   		subl	$9, %eax
 2170 1714 BA010000 		movl	$1, %edx
 2170      00
 2171 1719 89C1     		movl	%eax, %ecx
 2172 171b D3E2     		sall	%cl, %edx
 2173 171d 89D0     		movl	%edx, %eax
 2174 171f 008599FE 		addb	%al, -359(%rbp)
 2174      FFFF
 2175 1725 E9830000 		jmp	.L130
 2175      00
 2176              	.L131:
 469:main.c        ****                                         } else if (i <= 24) {
 2177              		.loc 1 469 0 is_stmt 1
 2178 172a 80BDA0FE 		cmpb	$24, -352(%rbp)
 2178      FFFF18
 2179 1731 773E     		ja	.L133
 470:main.c        ****                                             if ((inpFromFrontEnd[0] & (1 << (i - 1))) != 0) num_100
 2180              		.loc 1 470 0
 2181 1733 8B9500FF 		movl	-256(%rbp), %edx
 2181      FFFF
 2182 1739 0FB685A0 		movzbl	-352(%rbp), %eax
 2182      FEFFFF
 2183 1740 83E801   		subl	$1, %eax
 2184 1743 BE010000 		movl	$1, %esi
 2184      00
 2185 1748 89C1     		movl	%eax, %ecx
 2186 174a D3E6     		sall	%cl, %esi
 2187 174c 89F0     		movl	%esi, %eax
 2188 174e 21D0     		andl	%edx, %eax
 2189 1750 85C0     		testl	%eax, %eax
 2190 1752 7459     		je	.L130
 2191              		.loc 1 470 0 is_stmt 0 discriminator 1
 2192 1754 0FB685A0 		movzbl	-352(%rbp), %eax
 2192      FEFFFF
 2193 175b 83E811   		subl	$17, %eax
 2194 175e BA010000 		movl	$1, %edx
 2194      00
 2195 1763 89C1     		movl	%eax, %ecx
 2196 1765 D3E2     		sall	%cl, %edx
 2197 1767 89D0     		movl	%edx, %eax
 2198 1769 00859AFE 		addb	%al, -358(%rbp)
 2198      FFFF
 2199 176f EB3C     		jmp	.L130
 2200              	.L133:
 471:main.c        ****                                         } else {
 472:main.c        ****                                             if ((inpFromFrontEnd[0] & (1 << (i - 1))) != 0) num_200
 2201              		.loc 1 472 0 is_stmt 1
 2202 1771 8B9500FF 		movl	-256(%rbp), %edx
 2202      FFFF
 2203 1777 0FB685A0 		movzbl	-352(%rbp), %eax
 2203      FEFFFF
 2204 177e 83E801   		subl	$1, %eax
 2205 1781 BE010000 		movl	$1, %esi
 2205      00
 2206 1786 89C1     		movl	%eax, %ecx
 2207 1788 D3E6     		sall	%cl, %esi
 2208 178a 89F0     		movl	%esi, %eax
 2209 178c 21D0     		andl	%edx, %eax
 2210 178e 85C0     		testl	%eax, %eax
 2211 1790 741B     		je	.L130
 2212              		.loc 1 472 0 is_stmt 0 discriminator 1
 2213 1792 0FB685A0 		movzbl	-352(%rbp), %eax
 2213      FEFFFF
 2214 1799 83E819   		subl	$25, %eax
 2215 179c BA010000 		movl	$1, %edx
 2215      00
 2216 17a1 89C1     		movl	%eax, %ecx
 2217 17a3 D3E2     		sall	%cl, %edx
 2218 17a5 89D0     		movl	%edx, %eax
 2219 17a7 00859BFE 		addb	%al, -357(%rbp)
 2219      FFFF
 2220              	.L130:
 464:main.c        ****                                         if (i <= 8) {
 2221              		.loc 1 464 0 is_stmt 1
 2222 17ad 0FB685A0 		movzbl	-352(%rbp), %eax
 2222      FEFFFF
 2223 17b4 83C001   		addl	$1, %eax
 2224 17b7 8885A0FE 		movb	%al, -352(%rbp)
 2224      FFFF
 2225              	.L127:
 464:main.c        ****                                         if (i <= 8) {
 2226              		.loc 1 464 0 is_stmt 0 discriminator 1
 2227 17bd 80BDA0FE 		cmpb	$32, -352(%rbp)
 2227      FFFF20
 2228 17c4 0F86C4FE 		jbe	.L135
 2228      FFFF
 2229              	.LBE34:
 473:main.c        ****                                         }
 474:main.c        ****                                     }
 475:main.c        **** 
 476:main.c        ****                            printf("num_2000_admin %u\n", num_2000_admin);
 2230              		.loc 1 476 0 is_stmt 1
 2231 17ca 0FB6859B 		movzbl	-357(%rbp), %eax
 2231      FEFFFF
 2232 17d1 89C6     		movl	%eax, %esi
 2233 17d3 BF000000 		movl	$.LC63, %edi
 2233      00
 2234 17d8 B8000000 		movl	$0, %eax
 2234      00
 2235 17dd E8000000 		call	printf
 2235      00
 477:main.c        ****                            printf("num_1000_admin %u\n", num_1000_admin);
 2236              		.loc 1 477 0
 2237 17e2 0FB6859A 		movzbl	-358(%rbp), %eax
 2237      FEFFFF
 2238 17e9 89C6     		movl	%eax, %esi
 2239 17eb BF000000 		movl	$.LC64, %edi
 2239      00
 2240 17f0 B8000000 		movl	$0, %eax
 2240      00
 2241 17f5 E8000000 		call	printf
 2241      00
 478:main.c        ****                            printf("num_500_admin %u\n", num_500_admin);
 2242              		.loc 1 478 0
 2243 17fa 0FB68599 		movzbl	-359(%rbp), %eax
 2243      FEFFFF
 2244 1801 89C6     		movl	%eax, %esi
 2245 1803 BF000000 		movl	$.LC65, %edi
 2245      00
 2246 1808 B8000000 		movl	$0, %eax
 2246      00
 2247 180d E8000000 		call	printf
 2247      00
 479:main.c        ****                            printf("num_100_admin %u\n", num_100_admin);
 2248              		.loc 1 479 0
 2249 1812 0FB68598 		movzbl	-360(%rbp), %eax
 2249      FEFFFF
 2250 1819 89C6     		movl	%eax, %esi
 2251 181b BF000000 		movl	$.LC66, %edi
 2251      00
 2252 1820 B8000000 		movl	$0, %eax
 2252      00
 2253 1825 E8000000 		call	printf
 2253      00
 2254              	.LBB35:
 480:main.c        **** 
 481:main.c        ****                                     uint32_t befEncSen[2];
 482:main.c        ****                                     for (int i = 0; i < 2; i++) befEncSen[i] = 0;
 2255              		.loc 1 482 0
 2256 182a C785E0FE 		movl	$0, -288(%rbp)
 2256      FFFF0000 
 2256      0000
 2257 1834 EB1A     		jmp	.L136
 2258              	.L137:
 2259              		.loc 1 482 0 is_stmt 0 discriminator 2
 2260 1836 8B85E0FE 		movl	-288(%rbp), %eax
 2260      FFFF
 2261 183c 4898     		cltq
 2262 183e C7848510 		movl	$0, -240(%rbp,%rax,4)
 2262      FFFFFF00 
 2262      000000
 2263 1849 8385E0FE 		addl	$1, -288(%rbp)
 2263      FFFF01
 2264              	.L136:
 2265              		.loc 1 482 0 discriminator 1
 2266 1850 83BDE0FE 		cmpl	$1, -288(%rbp)
 2266      FFFF01
 2267 1857 7EDD     		jle	.L137
 2268              	.LBE35:
 2269              	.LBB36:
 483:main.c        ****                                     for (uint32_t i = 0; i <= 31; i += 8) {
 2270              		.loc 1 483 0 is_stmt 1
 2271 1859 C785E4FE 		movl	$0, -284(%rbp)
 2271      FFFF0000 
 2271      0000
 2272 1863 E9AC0000 		jmp	.L138
 2272      00
 2273              	.L143:
 484:main.c        ****                                         if (i == 0) befEncSen[0] += ((1 << i) * ((uint32_t) num_100
 2274              		.loc 1 484 0
 2275 1868 83BDE4FE 		cmpl	$0, -284(%rbp)
 2275      FFFF00
 2276 186f 7523     		jne	.L139
 2277              		.loc 1 484 0 is_stmt 0 discriminator 1
 2278 1871 8B9510FF 		movl	-240(%rbp), %edx
 2278      FFFF
 2279 1877 0FB6B598 		movzbl	-360(%rbp), %esi
 2279      FEFFFF
 2280 187e 8B85E4FE 		movl	-284(%rbp), %eax
 2280      FFFF
 2281 1884 89C1     		movl	%eax, %ecx
 2282 1886 D3E6     		sall	%cl, %esi
 2283 1888 89F0     		movl	%esi, %eax
 2284 188a 01D0     		addl	%edx, %eax
 2285 188c 898510FF 		movl	%eax, -240(%rbp)
 2285      FFFF
 2286 1892 EB79     		jmp	.L140
 2287              	.L139:
 485:main.c        ****                                         else if (i == 8) befEncSen[0] += ((1 << i) * ((uint32_t) nu
 2288              		.loc 1 485 0 is_stmt 1
 2289 1894 83BDE4FE 		cmpl	$8, -284(%rbp)
 2289      FFFF08
 2290 189b 7523     		jne	.L141
 2291              		.loc 1 485 0 is_stmt 0 discriminator 1
 2292 189d 8B9510FF 		movl	-240(%rbp), %edx
 2292      FFFF
 2293 18a3 0FB6B599 		movzbl	-359(%rbp), %esi
 2293      FEFFFF
 2294 18aa 8B85E4FE 		movl	-284(%rbp), %eax
 2294      FFFF
 2295 18b0 89C1     		movl	%eax, %ecx
 2296 18b2 D3E6     		sall	%cl, %esi
 2297 18b4 89F0     		movl	%esi, %eax
 2298 18b6 01D0     		addl	%edx, %eax
 2299 18b8 898510FF 		movl	%eax, -240(%rbp)
 2299      FFFF
 2300 18be EB4D     		jmp	.L140
 2301              	.L141:
 486:main.c        ****                                         else if (i == 16) befEncSen[0] += ((1 << i) * ((uint32_t) n
 2302              		.loc 1 486 0 is_stmt 1
 2303 18c0 83BDE4FE 		cmpl	$16, -284(%rbp)
 2303      FFFF10
 2304 18c7 7523     		jne	.L142
 2305              		.loc 1 486 0 is_stmt 0 discriminator 1
 2306 18c9 8B9510FF 		movl	-240(%rbp), %edx
 2306      FFFF
 2307 18cf 0FB6B59A 		movzbl	-358(%rbp), %esi
 2307      FEFFFF
 2308 18d6 8B85E4FE 		movl	-284(%rbp), %eax
 2308      FFFF
 2309 18dc 89C1     		movl	%eax, %ecx
 2310 18de D3E6     		sall	%cl, %esi
 2311 18e0 89F0     		movl	%esi, %eax
 2312 18e2 01D0     		addl	%edx, %eax
 2313 18e4 898510FF 		movl	%eax, -240(%rbp)
 2313      FFFF
 2314 18ea EB21     		jmp	.L140
 2315              	.L142:
 487:main.c        ****                                         else befEncSen[0] += ((1 << i) * ((uint32_t) num_2000_admin
 2316              		.loc 1 487 0 is_stmt 1
 2317 18ec 8B9510FF 		movl	-240(%rbp), %edx
 2317      FFFF
 2318 18f2 0FB6B59B 		movzbl	-357(%rbp), %esi
 2318      FEFFFF
 2319 18f9 8B85E4FE 		movl	-284(%rbp), %eax
 2319      FFFF
 2320 18ff 89C1     		movl	%eax, %ecx
 2321 1901 D3E6     		sall	%cl, %esi
 2322 1903 89F0     		movl	%esi, %eax
 2323 1905 01D0     		addl	%edx, %eax
 2324 1907 898510FF 		movl	%eax, -240(%rbp)
 2324      FFFF
 2325              	.L140:
 483:main.c        ****                                         if (i == 0) befEncSen[0] += ((1 << i) * ((uint32_t) num_100
 2326              		.loc 1 483 0
 2327 190d 8385E4FE 		addl	$8, -284(%rbp)
 2327      FFFF08
 2328              	.L138:
 483:main.c        ****                                         if (i == 0) befEncSen[0] += ((1 << i) * ((uint32_t) num_100
 2329              		.loc 1 483 0 is_stmt 0 discriminator 1
 2330 1914 83BDE4FE 		cmpl	$31, -284(%rbp)
 2330      FFFF1F
 2331 191b 0F8647FF 		jbe	.L143
 2331      FFFF
 2332              	.LBE36:
 488:main.c        ****                                     }
 489:main.c        ****                                     encrypt64(befEncSen);
 2333              		.loc 1 489 0 is_stmt 1
 2334 1921 488D8510 		leaq	-240(%rbp), %rax
 2334      FFFFFF
 2335 1928 4889C7   		movq	%rax, %rdi
 2336 192b E8000000 		call	encrypt64
 2336      00
 2337              	.LBB37:
 490:main.c        ****                                     for (uint8_t i = 10; i <= 13; i++) {
 2338              		.loc 1 490 0
 2339 1930 C685A1FE 		movb	$10, -351(%rbp)
 2339      FFFF0A
 2340 1937 E91C0100 		jmp	.L144
 2340      00
 2341              	.L150:
 2342              	.LBB38:
 491:main.c        ****                                         uint8_t tempSto = 0;
 2343              		.loc 1 491 0
 2344 193c C685BCFE 		movb	$0, -324(%rbp)
 2344      FFFF00
 2345              	.LBB39:
 492:main.c        ****                                         for (uint8_t j = 0; j <= 7; j++) {
 2346              		.loc 1 492 0
 2347 1943 C685A2FE 		movb	$0, -350(%rbp)
 2347      FFFF00
 2348 194a EB71     		jmp	.L145
 2349              	.L147:
 2350              	.LBB40:
 493:main.c        ****                                             uint8_t temp = j + (i - 10) * 8;
 2351              		.loc 1 493 0
 2352 194c 0FB685A1 		movzbl	-351(%rbp), %eax
 2352      FEFFFF
 2353 1953 83E80A   		subl	$10, %eax
 2354 1956 8D14C500 		leal	0(,%rax,8), %edx
 2354      000000
 2355 195d 0FB685A2 		movzbl	-350(%rbp), %eax
 2355      FEFFFF
 2356 1964 01D0     		addl	%edx, %eax
 2357 1966 8885AAFE 		movb	%al, -342(%rbp)
 2357      FFFF
 494:main.c        ****                                             if ((befEncSen[0] & (1 << temp)) != 0) {
 2358              		.loc 1 494 0
 2359 196c 8B9510FF 		movl	-240(%rbp), %edx
 2359      FFFF
 2360 1972 0FB685AA 		movzbl	-342(%rbp), %eax
 2360      FEFFFF
 2361 1979 BE010000 		movl	$1, %esi
 2361      00
 2362 197e 89C1     		movl	%eax, %ecx
 2363 1980 D3E6     		sall	%cl, %esi
 2364 1982 89F0     		movl	%esi, %eax
 2365 1984 21D0     		andl	%edx, %eax
 2366 1986 85C0     		testl	%eax, %eax
 2367 1988 7423     		je	.L146
 495:main.c        ****                                                 tempSto += (1 << j);
 2368              		.loc 1 495 0
 2369 198a 0FB685A2 		movzbl	-350(%rbp), %eax
 2369      FEFFFF
 2370 1991 BA010000 		movl	$1, %edx
 2370      00
 2371 1996 89C1     		movl	%eax, %ecx
 2372 1998 D3E2     		sall	%cl, %edx
 2373 199a 89D0     		movl	%edx, %eax
 2374 199c 89C2     		movl	%eax, %edx
 2375 199e 0FB685BC 		movzbl	-324(%rbp), %eax
 2375      FEFFFF
 2376 19a5 01D0     		addl	%edx, %eax
 2377 19a7 8885BCFE 		movb	%al, -324(%rbp)
 2377      FFFF
 2378              	.L146:
 2379              	.LBE40:
 492:main.c        ****                                             uint8_t temp = j + (i - 10) * 8;
 2380              		.loc 1 492 0
 2381 19ad 0FB685A2 		movzbl	-350(%rbp), %eax
 2381      FEFFFF
 2382 19b4 83C001   		addl	$1, %eax
 2383 19b7 8885A2FE 		movb	%al, -350(%rbp)
 2383      FFFF
 2384              	.L145:
 492:main.c        ****                                             uint8_t temp = j + (i - 10) * 8;
 2385              		.loc 1 492 0 is_stmt 0 discriminator 1
 2386 19bd 80BDA2FE 		cmpb	$7, -350(%rbp)
 2386      FFFF07
 2387 19c4 7686     		jbe	.L147
 2388              	.LBE39:
 496:main.c        ****                                             }
 497:main.c        ****                                         }
 498:main.c        ****                                         flSleep(1000);
 2389              		.loc 1 498 0 is_stmt 1
 2390 19c6 BFE80300 		movl	$1000, %edi
 2390      00
 2391 19cb E8000000 		call	flSleep
 2391      00
 499:main.c        ****                                         if (LOG) printf("Write to channel %u = %u \n", i, tempSto);
 2392              		.loc 1 499 0
 2393 19d0 0FB60500 		movzbl	LOG(%rip), %eax
 2393      000000
 2394 19d7 84C0     		testb	%al, %al
 2395 19d9 7422     		je	.L148
 2396              		.loc 1 499 0 is_stmt 0 discriminator 1
 2397 19db 0FB685BC 		movzbl	-324(%rbp), %eax
 2397      FEFFFF
 2398 19e2 0FB6D0   		movzbl	%al, %edx
 2399 19e5 0FB685A1 		movzbl	-351(%rbp), %eax
 2399      FEFFFF
 2400 19ec 89C6     		movl	%eax, %esi
 2401 19ee BF000000 		movl	$.LC58, %edi
 2401      00
 2402 19f3 B8000000 		movl	$0, %eax
 2402      00
 2403 19f8 E8000000 		call	printf
 2403      00
 2404              	.L148:
 500:main.c        ****                                         fStatus = flWriteChannel(handle, (uint8_t) i, length, &temp
 2405              		.loc 1 500 0 is_stmt 1
 2406 19fd 8B95F4FE 		movl	-268(%rbp), %edx
 2406      FFFF
 2407 1a03 0FB6B5A1 		movzbl	-351(%rbp), %esi
 2407      FEFFFF
 2408 1a0a 488B8518 		movq	-232(%rbp), %rax
 2408      FFFFFF
 2409 1a11 488DBD20 		leaq	-224(%rbp), %rdi
 2409      FFFFFF
 2410 1a18 488D8DBC 		leaq	-324(%rbp), %rcx
 2410      FEFFFF
 2411 1a1f 4989F8   		movq	%rdi, %r8
 2412 1a22 4889C7   		movq	%rax, %rdi
 2413 1a25 E8000000 		call	flWriteChannel
 2413      00
 2414 1a2a 8985F0FE 		movl	%eax, -272(%rbp)
 2414      FFFF
 501:main.c        ****                                         CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2415              		.loc 1 501 0
 2416 1a30 83BDF0FE 		cmpl	$0, -272(%rbp)
 2416      FFFF00
 2417 1a37 740F     		je	.L149
 2418              		.loc 1 501 0 is_stmt 0 discriminator 1
 2419 1a39 C785C0FE 		movl	$1, -320(%rbp)
 2419      FFFF0100 
 2419      0000
 2420              	.LBE38:
 2421              	.LBE37:
 462:main.c        **** 
 2422              		.loc 1 462 0 is_stmt 1 discriminator 1
 2423 1a43 E98F0200 		jmp	.L73
 2423      00
 2424              	.L149:
 2425              	.LBB41:
 490:main.c        ****                                         uint8_t tempSto = 0;
 2426              		.loc 1 490 0
 2427 1a48 0FB685A1 		movzbl	-351(%rbp), %eax
 2427      FEFFFF
 2428 1a4f 83C001   		addl	$1, %eax
 2429 1a52 8885A1FE 		movb	%al, -351(%rbp)
 2429      FFFF
 2430              	.L144:
 490:main.c        ****                                         uint8_t tempSto = 0;
 2431              		.loc 1 490 0 is_stmt 0 discriminator 1
 2432 1a58 80BDA1FE 		cmpb	$13, -351(%rbp)
 2432      FFFF0D
 2433 1a5f 0F86D7FE 		jbe	.L150
 2433      FFFF
 2434              	.LBE41:
 2435              	.LBB42:
 502:main.c        ****                                     }
 503:main.c        **** 
 504:main.c        ****                                     for (uint8_t i = 14; i <= 17; i++) {
 2436              		.loc 1 504 0 is_stmt 1
 2437 1a65 C685A3FE 		movb	$14, -349(%rbp)
 2437      FFFF0E
 2438 1a6c E91C0100 		jmp	.L151
 2438      00
 2439              	.L157:
 2440              	.LBB43:
 505:main.c        ****                                         uint8_t tempSto = 0;
 2441              		.loc 1 505 0
 2442 1a71 C685BCFE 		movb	$0, -324(%rbp)
 2442      FFFF00
 2443              	.LBB44:
 506:main.c        ****                                         for (uint8_t j = 0; j <= 7; j++) {
 2444              		.loc 1 506 0
 2445 1a78 C685A4FE 		movb	$0, -348(%rbp)
 2445      FFFF00
 2446 1a7f EB71     		jmp	.L152
 2447              	.L154:
 2448              	.LBB45:
 507:main.c        ****                                             uint8_t temp = j + (i - 14) * 8;
 2449              		.loc 1 507 0
 2450 1a81 0FB685A3 		movzbl	-349(%rbp), %eax
 2450      FEFFFF
 2451 1a88 83E80E   		subl	$14, %eax
 2452 1a8b 8D14C500 		leal	0(,%rax,8), %edx
 2452      000000
 2453 1a92 0FB685A4 		movzbl	-348(%rbp), %eax
 2453      FEFFFF
 2454 1a99 01D0     		addl	%edx, %eax
 2455 1a9b 8885ABFE 		movb	%al, -341(%rbp)
 2455      FFFF
 508:main.c        ****                                             if ((befEncSen[1] & (1 << temp)) != 0) {
 2456              		.loc 1 508 0
 2457 1aa1 8B9514FF 		movl	-236(%rbp), %edx
 2457      FFFF
 2458 1aa7 0FB685AB 		movzbl	-341(%rbp), %eax
 2458      FEFFFF
 2459 1aae BE010000 		movl	$1, %esi
 2459      00
 2460 1ab3 89C1     		movl	%eax, %ecx
 2461 1ab5 D3E6     		sall	%cl, %esi
 2462 1ab7 89F0     		movl	%esi, %eax
 2463 1ab9 21D0     		andl	%edx, %eax
 2464 1abb 85C0     		testl	%eax, %eax
 2465 1abd 7423     		je	.L153
 509:main.c        ****                                                 tempSto += (1 << j);
 2466              		.loc 1 509 0
 2467 1abf 0FB685A4 		movzbl	-348(%rbp), %eax
 2467      FEFFFF
 2468 1ac6 BA010000 		movl	$1, %edx
 2468      00
 2469 1acb 89C1     		movl	%eax, %ecx
 2470 1acd D3E2     		sall	%cl, %edx
 2471 1acf 89D0     		movl	%edx, %eax
 2472 1ad1 89C2     		movl	%eax, %edx
 2473 1ad3 0FB685BC 		movzbl	-324(%rbp), %eax
 2473      FEFFFF
 2474 1ada 01D0     		addl	%edx, %eax
 2475 1adc 8885BCFE 		movb	%al, -324(%rbp)
 2475      FFFF
 2476              	.L153:
 2477              	.LBE45:
 506:main.c        ****                                             uint8_t temp = j + (i - 14) * 8;
 2478              		.loc 1 506 0
 2479 1ae2 0FB685A4 		movzbl	-348(%rbp), %eax
 2479      FEFFFF
 2480 1ae9 83C001   		addl	$1, %eax
 2481 1aec 8885A4FE 		movb	%al, -348(%rbp)
 2481      FFFF
 2482              	.L152:
 506:main.c        ****                                             uint8_t temp = j + (i - 14) * 8;
 2483              		.loc 1 506 0 is_stmt 0 discriminator 1
 2484 1af2 80BDA4FE 		cmpb	$7, -348(%rbp)
 2484      FFFF07
 2485 1af9 7686     		jbe	.L154
 2486              	.LBE44:
 510:main.c        ****                                             }
 511:main.c        ****                                         }
 512:main.c        ****                                         flSleep(1000);
 2487              		.loc 1 512 0 is_stmt 1
 2488 1afb BFE80300 		movl	$1000, %edi
 2488      00
 2489 1b00 E8000000 		call	flSleep
 2489      00
 513:main.c        ****                                         if (LOG) printf("Write to channel %u = %u \n", i, tempSto);
 2490              		.loc 1 513 0
 2491 1b05 0FB60500 		movzbl	LOG(%rip), %eax
 2491      000000
 2492 1b0c 84C0     		testb	%al, %al
 2493 1b0e 7422     		je	.L155
 2494              		.loc 1 513 0 is_stmt 0 discriminator 1
 2495 1b10 0FB685BC 		movzbl	-324(%rbp), %eax
 2495      FEFFFF
 2496 1b17 0FB6D0   		movzbl	%al, %edx
 2497 1b1a 0FB685A3 		movzbl	-349(%rbp), %eax
 2497      FEFFFF
 2498 1b21 89C6     		movl	%eax, %esi
 2499 1b23 BF000000 		movl	$.LC58, %edi
 2499      00
 2500 1b28 B8000000 		movl	$0, %eax
 2500      00
 2501 1b2d E8000000 		call	printf
 2501      00
 2502              	.L155:
 514:main.c        ****                                         fStatus = flWriteChannel(handle, (uint8_t) i, length, &temp
 2503              		.loc 1 514 0 is_stmt 1
 2504 1b32 8B95F4FE 		movl	-268(%rbp), %edx
 2504      FFFF
 2505 1b38 0FB6B5A3 		movzbl	-349(%rbp), %esi
 2505      FEFFFF
 2506 1b3f 488B8518 		movq	-232(%rbp), %rax
 2506      FFFFFF
 2507 1b46 488DBD20 		leaq	-224(%rbp), %rdi
 2507      FFFFFF
 2508 1b4d 488D8DBC 		leaq	-324(%rbp), %rcx
 2508      FEFFFF
 2509 1b54 4989F8   		movq	%rdi, %r8
 2510 1b57 4889C7   		movq	%rax, %rdi
 2511 1b5a E8000000 		call	flWriteChannel
 2511      00
 2512 1b5f 8985F0FE 		movl	%eax, -272(%rbp)
 2512      FFFF
 515:main.c        ****                                         CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2513              		.loc 1 515 0
 2514 1b65 83BDF0FE 		cmpl	$0, -272(%rbp)
 2514      FFFF00
 2515 1b6c 740F     		je	.L156
 2516              		.loc 1 515 0 is_stmt 0 discriminator 1
 2517 1b6e C785C0FE 		movl	$1, -320(%rbp)
 2517      FFFF0100 
 2517      0000
 2518              	.LBE43:
 2519              	.LBE42:
 462:main.c        **** 
 2520              		.loc 1 462 0 is_stmt 1 discriminator 1
 2521 1b78 E95A0100 		jmp	.L73
 2521      00
 2522              	.L156:
 2523              	.LBB46:
 504:main.c        ****                                         uint8_t tempSto = 0;
 2524              		.loc 1 504 0
 2525 1b7d 0FB685A3 		movzbl	-349(%rbp), %eax
 2525      FEFFFF
 2526 1b84 83C001   		addl	$1, %eax
 2527 1b87 8885A3FE 		movb	%al, -349(%rbp)
 2527      FFFF
 2528              	.L151:
 504:main.c        ****                                         uint8_t tempSto = 0;
 2529              		.loc 1 504 0 is_stmt 0 discriminator 1
 2530 1b8d 80BDA3FE 		cmpb	$17, -349(%rbp)
 2530      FFFF11
 2531 1b94 0F86D7FE 		jbe	.L157
 2531      FFFF
 2532              	.LBE46:
 2533 1b9a E9360100 		jmp	.L158
 2533      00
 2534              	.L83:
 2535              	.LBE33:
 516:main.c        ****                                     }
 517:main.c        ****                                 }
 518:main.c        ****                             } else {
 519:main.c        ****                                 printf("Invalid user \n");
 2536              		.loc 1 519 0 is_stmt 1
 2537 1b9f BF000000 		movl	$.LC67, %edi
 2537      00
 2538 1ba4 E8000000 		call	puts
 2538      00
 520:main.c        ****                                 *statusOnChan9 = 4;
 2539              		.loc 1 520 0
 2540 1ba9 488B45A8 		movq	-88(%rbp), %rax
 2541 1bad C60004   		movb	$4, (%rax)
 521:main.c        ****                                 flSleep(1000);
 2542              		.loc 1 521 0
 2543 1bb0 BFE80300 		movl	$1000, %edi
 2543      00
 2544 1bb5 E8000000 		call	flSleep
 2544      00
 522:main.c        ****                                 if (LOG) printf("Write to channel %u = %u \n", 9, *statusOnChan9);
 2545              		.loc 1 522 0
 2546 1bba 0FB60500 		movzbl	LOG(%rip), %eax
 2546      000000
 2547 1bc1 84C0     		testb	%al, %al
 2548 1bc3 7420     		je	.L159
 2549              		.loc 1 522 0 is_stmt 0 discriminator 1
 2550 1bc5 488B45A8 		movq	-88(%rbp), %rax
 2551 1bc9 0FB600   		movzbl	(%rax), %eax
 2552 1bcc 0FB6C0   		movzbl	%al, %eax
 2553 1bcf 89C2     		movl	%eax, %edx
 2554 1bd1 BE090000 		movl	$9, %esi
 2554      00
 2555 1bd6 BF000000 		movl	$.LC58, %edi
 2555      00
 2556 1bdb B8000000 		movl	$0, %eax
 2556      00
 2557 1be0 E8000000 		call	printf
 2557      00
 2558              	.L159:
 523:main.c        ****                                 fStatus = flWriteChannel(handle, (uint8_t) 9, length, statusOnChan9
 2559              		.loc 1 523 0 is_stmt 1
 2560 1be5 8B95F4FE 		movl	-268(%rbp), %edx
 2560      FFFF
 2561 1beb 488B8518 		movq	-232(%rbp), %rax
 2561      FFFFFF
 2562 1bf2 488DB520 		leaq	-224(%rbp), %rsi
 2562      FFFFFF
 2563 1bf9 488B4DA8 		movq	-88(%rbp), %rcx
 2564 1bfd 4989F0   		movq	%rsi, %r8
 2565 1c00 BE090000 		movl	$9, %esi
 2565      00
 2566 1c05 4889C7   		movq	%rax, %rdi
 2567 1c08 E8000000 		call	flWriteChannel
 2567      00
 2568 1c0d 8985F0FE 		movl	%eax, -272(%rbp)
 2568      FFFF
 524:main.c        ****                                 CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2569              		.loc 1 524 0
 2570 1c13 83BDF0FE 		cmpl	$0, -272(%rbp)
 2570      FFFF00
 2571 1c1a 740F     		je	.L160
 2572              		.loc 1 524 0 is_stmt 0 discriminator 1
 2573 1c1c C785C0FE 		movl	$1, -320(%rbp)
 2573      FFFF0100 
 2573      0000
 2574 1c26 E9AC0000 		jmp	.L73
 2574      00
 2575              	.L160:
 2576              	.LBB47:
 525:main.c        ****                                 for (int i = 10; i <= 17; i++) {
 2577              		.loc 1 525 0 is_stmt 1
 2578 1c2b C785E8FE 		movl	$10, -280(%rbp)
 2578      FFFF0A00 
 2578      0000
 2579 1c35 E98E0000 		jmp	.L161
 2579      00
 2580              	.L164:
 2581              	.LBB48:
 526:main.c        ****                                     uint8_t tempSto = 0;
 2582              		.loc 1 526 0
 2583 1c3a C68510FF 		movb	$0, -240(%rbp)
 2583      FFFF00
 527:main.c        ****                                     flSleep(1000);
 2584              		.loc 1 527 0
 2585 1c41 BFE80300 		movl	$1000, %edi
 2585      00
 2586 1c46 E8000000 		call	flSleep
 2586      00
 528:main.c        ****                                     if (LOG) printf("Write to channel %u = %u \n", i, tempSto);
 2587              		.loc 1 528 0
 2588 1c4b 0FB60500 		movzbl	LOG(%rip), %eax
 2588      000000
 2589 1c52 84C0     		testb	%al, %al
 2590 1c54 7421     		je	.L162
 2591              		.loc 1 528 0 is_stmt 0 discriminator 1
 2592 1c56 0FB68510 		movzbl	-240(%rbp), %eax
 2592      FFFFFF
 2593 1c5d 0FB6D0   		movzbl	%al, %edx
 2594 1c60 8B85E8FE 		movl	-280(%rbp), %eax
 2594      FFFF
 2595 1c66 89C6     		movl	%eax, %esi
 2596 1c68 BF000000 		movl	$.LC58, %edi
 2596      00
 2597 1c6d B8000000 		movl	$0, %eax
 2597      00
 2598 1c72 E8000000 		call	printf
 2598      00
 2599              	.L162:
 529:main.c        ****                                     fStatus = flWriteChannel(handle, (uint8_t) i, length, &tempSto,
 2600              		.loc 1 529 0 is_stmt 1
 2601 1c77 8B95F4FE 		movl	-268(%rbp), %edx
 2601      FFFF
 2602 1c7d 8B85E8FE 		movl	-280(%rbp), %eax
 2602      FFFF
 2603 1c83 0FB6F0   		movzbl	%al, %esi
 2604 1c86 488B8518 		movq	-232(%rbp), %rax
 2604      FFFFFF
 2605 1c8d 488DBD20 		leaq	-224(%rbp), %rdi
 2605      FFFFFF
 2606 1c94 488D8D10 		leaq	-240(%rbp), %rcx
 2606      FFFFFF
 2607 1c9b 4989F8   		movq	%rdi, %r8
 2608 1c9e 4889C7   		movq	%rax, %rdi
 2609 1ca1 E8000000 		call	flWriteChannel
 2609      00
 2610 1ca6 8985F0FE 		movl	%eax, -272(%rbp)
 2610      FFFF
 530:main.c        ****                                     CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2611              		.loc 1 530 0
 2612 1cac 83BDF0FE 		cmpl	$0, -272(%rbp)
 2612      FFFF00
 2613 1cb3 740C     		je	.L163
 2614              		.loc 1 530 0 is_stmt 0 discriminator 1
 2615 1cb5 C785C0FE 		movl	$1, -320(%rbp)
 2615      FFFF0100 
 2615      0000
 2616              	.LBE48:
 2617              	.LBE47:
 350:main.c        ****                                 if (LOG) printf("Read from channel %u = %u \n", i, *readFromChannel
 2618              		.loc 1 350 0 is_stmt 1 discriminator 1
 2619 1cbf EB27     		jmp	.L59
 2620              	.L163:
 2621              	.LBB49:
 525:main.c        ****                                     uint8_t tempSto = 0;
 2622              		.loc 1 525 0
 2623 1cc1 8385E8FE 		addl	$1, -280(%rbp)
 2623      FFFF01
 2624              	.L161:
 525:main.c        ****                                     uint8_t tempSto = 0;
 2625              		.loc 1 525 0 is_stmt 0 discriminator 1
 2626 1cc8 83BDE8FE 		cmpl	$17, -280(%rbp)
 2626      FFFF11
 2627 1ccf 0F8E65FF 		jle	.L164
 2627      FFFF
 2628              	.L158:
 2629              	.LBE49:
 2630 1cd5 EB02     		jmp	.L62
 2631              	.L73:
 2632              	.LBE10:
 2633              	.LBE9:
 2634              	.LBE8:
 324:main.c        ****                     if (LOG) printf("Read from channel 0 = %u \n", *readFromChannelZero);
 2635              		.loc 1 324 0 is_stmt 1 discriminator 1
 2636 1cd7 EB63     		jmp	.L29
 2637              	.L62:
 2638              	.LBB50:
 531:main.c        ****                                 }
 532:main.c        ****                             }
 533:main.c        ****                         }
 534:main.c        ****                     }
 535:main.c        ****                     flSleep(1000);
 2639              		.loc 1 535 0
 2640 1cd9 BFE80300 		movl	$1000, %edi
 2640      00
 2641 1cde E8000000 		call	flSleep
 2641      00
 2642              	.LBE50:
 536:main.c        ****                 }
 2643              		.loc 1 536 0
 2644 1ce3 E974EEFF 		jmp	.L57
 2644      FF
 2645              	.L59:
 2646              	.LBE7:
 291:main.c        ****             fStatus = flIsFPGARunning(handle, &isRunning, &error);
 2647              		.loc 1 291 0 discriminator 1
 2648 1ce8 EB52     		jmp	.L29
 2649              	.L50:
 537:main.c        **** 
 538:main.c        ****             } else {
 539:main.c        ****                 fprintf(stderr, "The FPGALink device at %s is not ready to talk - did you forget --
 2650              		.loc 1 539 0
 2651 1cea 488B0500 		movq	stderr(%rip), %rax
 2651      000000
 2652 1cf1 488B5580 		movq	-128(%rbp), %rdx
 2653 1cf5 BE000000 		movl	$.LC68, %esi
 2653      00
 2654 1cfa 4889C7   		movq	%rax, %rdi
 2655 1cfd B8000000 		movl	$0, %eax
 2655      00
 2656 1d02 E8000000 		call	fprintf
 2656      00
 540:main.c        ****                 FAIL(FLP_ARGS, cleanup);
 2657              		.loc 1 540 0
 2658 1d07 C785C0FE 		movl	$12, -320(%rbp)
 2658      FFFF0C00 
 2658      0000
 2659 1d11 90       		nop
 2660 1d12 EB28     		jmp	.L29
 2661              	.L46:
 2662              	.LBE6:
 541:main.c        ****             }
 542:main.c        ****         } else {
 543:main.c        ****             fprintf(stderr, "Action requested but device at %s does not support CommFPGA\n", vp);
 2663              		.loc 1 543 0
 2664 1d14 488B0500 		movq	stderr(%rip), %rax
 2664      000000
 2665 1d1b 488B5580 		movq	-128(%rbp), %rdx
 2666 1d1f BE000000 		movl	$.LC69, %esi
 2666      00
 2667 1d24 4889C7   		movq	%rax, %rdi
 2668 1d27 B8000000 		movl	$0, %eax
 2668      00
 2669 1d2c E8000000 		call	fprintf
 2669      00
 544:main.c        ****             FAIL(FLP_ARGS, cleanup);
 2670              		.loc 1 544 0
 2671 1d31 C785C0FE 		movl	$12, -320(%rbp)
 2671      FFFF0C00 
 2671      0000
 2672 1d3b 90       		nop
 2673              	.L29:
 545:main.c        ****         }
 546:main.c        ****     }
 547:main.c        **** 
 548:main.c        ****     cleanup:
 549:main.c        ****     free((void *) line);
 2674              		.loc 1 549 0
 2675 1d3c 488B4588 		movq	-120(%rbp), %rax
 2676 1d40 4889C7   		movq	%rax, %rdi
 2677 1d43 E8000000 		call	free
 2677      00
 550:main.c        ****     flClose(handle);
 2678              		.loc 1 550 0
 2679 1d48 488B8518 		movq	-232(%rbp), %rax
 2679      FFFFFF
 2680 1d4f 4889C7   		movq	%rax, %rdi
 2681 1d52 E8000000 		call	flClose
 2681      00
 551:main.c        ****     if (error) {
 2682              		.loc 1 551 0
 2683 1d57 488B8520 		movq	-224(%rbp), %rax
 2683      FFFFFF
 2684 1d5e 4885C0   		testq	%rax, %rax
 2685 1d61 742F     		je	.L165
 552:main.c        ****         fprintf(stderr, "%s\n", error);
 2686              		.loc 1 552 0
 2687 1d63 488B9520 		movq	-224(%rbp), %rdx
 2687      FFFFFF
 2688 1d6a 488B0500 		movq	stderr(%rip), %rax
 2688      000000
 2689 1d71 BE000000 		movl	$.LC70, %esi
 2689      00
 2690 1d76 4889C7   		movq	%rax, %rdi
 2691 1d79 B8000000 		movl	$0, %eax
 2691      00
 2692 1d7e E8000000 		call	fprintf
 2692      00
 553:main.c        ****         flFreeError(error);
 2693              		.loc 1 553 0
 2694 1d83 488B8520 		movq	-224(%rbp), %rax
 2694      FFFFFF
 2695 1d8a 4889C7   		movq	%rax, %rdi
 2696 1d8d E8000000 		call	flFreeError
 2696      00
 2697              	.L165:
 554:main.c        ****     }
 555:main.c        ****     return retVal;
 2698              		.loc 1 555 0
 2699 1d92 8B85C0FE 		movl	-320(%rbp), %eax
 2699      FFFF
 2700              	.L166:
 556:main.c        **** }...
 2701              		.loc 1 556 0
 2702 1d98 4881C478 		addq	$376, %rsp
 2702      010000
 2703 1d9f 5B       		popq	%rbx
 2704 1da0 5D       		popq	%rbp
 2705              		.cfi_def_cfa 7, 8
 2706 1da1 C3       		ret
 2707              		.cfi_endproc
 2708              	.LFE14:
 2710              	.Letext0:
 2711              		.file 2 "/usr/include/stdint.h"
 2712              		.file 3 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
 2713              		.file 4 "/usr/include/x86_64-linux-gnu/bits/types.h"
 2714              		.file 5 "/usr/include/stdio.h"
 2715              		.file 6 "/usr/include/libio.h"
 2716              		.file 7 "/home/pandu/Desktop/DigitalLogicDesign/Lab/04-connectingatms/backend/libs/libargtable2/ar
 2717              		.file 8 "/home/pandu/Desktop/DigitalLogicDesign/Lab/04-connectingatms/backend/common/makestuff.h"
 2718              		.file 9 "/home/pandu/Desktop/DigitalLogicDesign/Lab/04-connectingatms/backend/libs/libfpgalink/lib
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
                            *COM*:0000000000186a50 dataFromCSV
     /tmp/cc7xEbWb.s:10     .bss:0000000000000000 numLines
     /tmp/cc7xEbWb.s:15     .bss:0000000000000004 LOG
     /tmp/cc7xEbWb.s:22     .data:0000000000000000 bankID
     /tmp/cc7xEbWb.s:28     .data:0000000000000004 maxAmountCanBeDispensed
     /tmp/cc7xEbWb.s:33     .data:0000000000000008 max2000Limit
     /tmp/cc7xEbWb.s:38     .data:0000000000000009 max1000Limit
     /tmp/cc7xEbWb.s:43     .data:000000000000000a max500Limit
     /tmp/cc7xEbWb.s:48     .data:000000000000000b max100Limit
     /tmp/cc7xEbWb.s:53     .text:0000000000000000 decrypt
     /tmp/cc7xEbWb.s:155    .text:00000000000000dd encrypt
     /tmp/cc7xEbWb.s:256    .text:00000000000001ba decrypt64
     /tmp/cc7xEbWb.s:290    .text:00000000000001f7 encrypt64
     /tmp/cc7xEbWb.s:324    .text:0000000000000234 myHash
     /tmp/cc7xEbWb.s:397    .text:00000000000002aa format
     /tmp/cc7xEbWb.s:453    .text:000000000000032a find
     /tmp/cc7xEbWb.s:540    .text:00000000000003d7 suffBalUser
     /tmp/cc7xEbWb.s:596    .rodata:00000000000000e0 errMessages
     /tmp/cc7xEbWb.s:746    .text:00000000000003fb main

UNDEFINED SYMBOLS
strtok
sscanf
arg_str0
arg_str1
arg_lit0
arg_end
arg_nullcheck
stderr
fprintf
arg_parse
atoi
puts
printf
stdout
arg_print_syntax
arg_print_glossary
arg_print_errors
flInitialise
flOpen
flLoadStandardFirmware
flSleep
putchar
fflush
flIsDeviceAvailable
flGetFirmwareVersion
flGetFirmwareID
flIsCommCapable
flSelectConduit
flIsFPGARunning
fopen
malloc
getline
free
fclose
flReadChannel
flWriteChannel
fwrite
fputc
flClose
flFreeError
