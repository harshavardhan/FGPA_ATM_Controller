   1              		.file	"main.c"
   2              		.text
   3              	.Ltext0:
   4              		.comm	dataFromCSV,1600080,32
   5              		.globl	numLines
   6              		.bss
   7              		.align 4
  10              	numLines:
  11 0000 00000000 		.zero	4
  12              		.globl	LOG
  15              	LOG:
  16 0004 00       		.zero	1
  17              		.text
  18              		.globl	decrypt
  20              	decrypt:
  21              	.LFB6:
  22              		.file 1 "main.c"
   1:main.c        **** /*
   2:main.c        ****    Original 64 bit -> | User 16-bit | Password 16-bit | 2k 8-bit | 1k 8-bit | 500 8-bit | 100 8-bit
   3:main.c        ****    (in VHDL before encryption)  8 7 6 5 4 3 2 1	
   4:main.c        **** */
   5:main.c        **** #define _GNU_SOURCE
   6:main.c        **** 
   7:main.c        **** #include <stdint.h>
   8:main.c        **** #include <stdbool.h>
   9:main.c        **** #include <stdio.h>
  10:main.c        **** #include <stdlib.h>
  11:main.c        **** #include <argtable2.h>
  12:main.c        **** #include <string.h>
  13:main.c        **** #include <libfpgalink.h>
  14:main.c        **** 
  15:main.c        **** #include <errno.h>
  16:main.c        **** #include <makestuff.h>
  17:main.c        **** #include <libbuffer.h>
  18:main.c        **** #include <liberror.h>
  19:main.c        **** #include <libdump.h>
  20:main.c        **** #include <readline/readline.h>
  21:main.c        **** #include <readline/history.h>
  22:main.c        **** 
  23:main.c        **** #ifdef WIN32
  24:main.c        **** #include <Windows.h>
  25:main.c        **** #else
  26:main.c        **** 
  27:main.c        **** #include <sys/time.h>
  28:main.c        **** 
  29:main.c        **** #endif
  30:main.c        **** #define N 100005
  31:main.c        **** 
  32:main.c        **** int dataFromCSV[N][4];
  33:main.c        **** int numLines = 0;
  34:main.c        **** bool LOG = false;
  35:main.c        **** 
  36:main.c        **** /* Adapted from tiny encryption algorithm wikipedia */
  37:main.c        **** void decrypt(uint32_t *v, uint32_t *k) {
  23              		.loc 1 37 0
  24              		.cfi_startproc
  25 0000 55       		pushq	%rbp
  26              		.cfi_def_cfa_offset 16
  27              		.cfi_offset 6, -16
  28 0001 4889E5   		movq	%rsp, %rbp
  29              		.cfi_def_cfa_register 6
  30 0004 48897DC8 		movq	%rdi, -56(%rbp)
  31 0008 488975C0 		movq	%rsi, -64(%rbp)
  38:main.c        ****     uint32_t v0 = v[0], v1 = v[1], sum = 0xC6EF3720, i;  /* set up */
  32              		.loc 1 38 0
  33 000c 488B45C8 		movq	-56(%rbp), %rax
  34 0010 8B00     		movl	(%rax), %eax
  35 0012 8945DC   		movl	%eax, -36(%rbp)
  36 0015 488B45C8 		movq	-56(%rbp), %rax
  37 0019 8B4004   		movl	4(%rax), %eax
  38 001c 8945E0   		movl	%eax, -32(%rbp)
  39 001f C745E420 		movl	$-957401312, -28(%rbp)
  39      37EFC6
  39:main.c        ****     uint32_t delta = 0x9e3779b9;                     /* a key schedule constant */
  40              		.loc 1 39 0
  41 0026 C745ECB9 		movl	$-1640531527, -20(%rbp)
  41      79379E
  40:main.c        ****     uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3];   /* cache key */
  42              		.loc 1 40 0
  43 002d 488B45C0 		movq	-64(%rbp), %rax
  44 0031 8B00     		movl	(%rax), %eax
  45 0033 8945F0   		movl	%eax, -16(%rbp)
  46 0036 488B45C0 		movq	-64(%rbp), %rax
  47 003a 8B4004   		movl	4(%rax), %eax
  48 003d 8945F4   		movl	%eax, -12(%rbp)
  49 0040 488B45C0 		movq	-64(%rbp), %rax
  50 0044 8B4008   		movl	8(%rax), %eax
  51 0047 8945F8   		movl	%eax, -8(%rbp)
  52 004a 488B45C0 		movq	-64(%rbp), %rax
  53 004e 8B400C   		movl	12(%rax), %eax
  54 0051 8945FC   		movl	%eax, -4(%rbp)
  41:main.c        ****     /* basic cycle start */
  42:main.c        ****     for (i = 0; i < 32; i++) {
  55              		.loc 1 42 0
  56 0054 C745E800 		movl	$0, -24(%rbp)
  56      000000
  57 005b EB62     		jmp	.L2
  58              	.L3:
  43:main.c        ****         v1 -= ((v0 << 4) + k2) ^ (v0 + sum) ^ ((v0 >> 5) + k3);
  59              		.loc 1 43 0 discriminator 2
  60 005d 8B45DC   		movl	-36(%rbp), %eax
  61 0060 C1E004   		sall	$4, %eax
  62 0063 89C2     		movl	%eax, %edx
  63 0065 8B45F8   		movl	-8(%rbp), %eax
  64 0068 8D0C02   		leal	(%rdx,%rax), %ecx
  65 006b 8B45E4   		movl	-28(%rbp), %eax
  66 006e 8B55DC   		movl	-36(%rbp), %edx
  67 0071 01D0     		addl	%edx, %eax
  68 0073 31C1     		xorl	%eax, %ecx
  69 0075 89CA     		movl	%ecx, %edx
  70 0077 8B45DC   		movl	-36(%rbp), %eax
  71 007a C1E805   		shrl	$5, %eax
  72 007d 89C1     		movl	%eax, %ecx
  73 007f 8B45FC   		movl	-4(%rbp), %eax
  74 0082 01C8     		addl	%ecx, %eax
  75 0084 31D0     		xorl	%edx, %eax
  76 0086 2945E0   		subl	%eax, -32(%rbp)
  44:main.c        ****         v0 -= ((v1 << 4) + k0) ^ (v1 + sum) ^ ((v1 >> 5) + k1);
  77              		.loc 1 44 0 discriminator 2
  78 0089 8B45E0   		movl	-32(%rbp), %eax
  79 008c C1E004   		sall	$4, %eax
  80 008f 89C2     		movl	%eax, %edx
  81 0091 8B45F0   		movl	-16(%rbp), %eax
  82 0094 8D0C02   		leal	(%rdx,%rax), %ecx
  83 0097 8B45E4   		movl	-28(%rbp), %eax
  84 009a 8B55E0   		movl	-32(%rbp), %edx
  85 009d 01D0     		addl	%edx, %eax
  86 009f 31C1     		xorl	%eax, %ecx
  87 00a1 89CA     		movl	%ecx, %edx
  88 00a3 8B45E0   		movl	-32(%rbp), %eax
  89 00a6 C1E805   		shrl	$5, %eax
  90 00a9 89C1     		movl	%eax, %ecx
  91 00ab 8B45F4   		movl	-12(%rbp), %eax
  92 00ae 01C8     		addl	%ecx, %eax
  93 00b0 31D0     		xorl	%edx, %eax
  94 00b2 2945DC   		subl	%eax, -36(%rbp)
  45:main.c        ****         sum -= delta;
  95              		.loc 1 45 0 discriminator 2
  96 00b5 8B45EC   		movl	-20(%rbp), %eax
  97 00b8 2945E4   		subl	%eax, -28(%rbp)
  42:main.c        ****         v1 -= ((v0 << 4) + k2) ^ (v0 + sum) ^ ((v0 >> 5) + k3);
  98              		.loc 1 42 0 discriminator 2
  99 00bb 8345E801 		addl	$1, -24(%rbp)
 100              	.L2:
  42:main.c        ****         v1 -= ((v0 << 4) + k2) ^ (v0 + sum) ^ ((v0 >> 5) + k3);
 101              		.loc 1 42 0 is_stmt 0 discriminator 1
 102 00bf 837DE81F 		cmpl	$31, -24(%rbp)
 103 00c3 7698     		jbe	.L3
  46:main.c        ****     }
  47:main.c        ****     /* end cycle */
  48:main.c        ****     v[0] = v0;
 104              		.loc 1 48 0 is_stmt 1
 105 00c5 488B45C8 		movq	-56(%rbp), %rax
 106 00c9 8B55DC   		movl	-36(%rbp), %edx
 107 00cc 8910     		movl	%edx, (%rax)
  49:main.c        ****     v[1] = v1;
 108              		.loc 1 49 0
 109 00ce 488B45C8 		movq	-56(%rbp), %rax
 110 00d2 488D5004 		leaq	4(%rax), %rdx
 111 00d6 8B45E0   		movl	-32(%rbp), %eax
 112 00d9 8902     		movl	%eax, (%rdx)
  50:main.c        **** }
 113              		.loc 1 50 0
 114 00db 5D       		popq	%rbp
 115              		.cfi_def_cfa 7, 8
 116 00dc C3       		ret
 117              		.cfi_endproc
 118              	.LFE6:
 120              		.globl	encrypt
 122              	encrypt:
 123              	.LFB7:
  51:main.c        **** 
  52:main.c        **** /* Adapted from tiny encryption algorithm wikipedia */
  53:main.c        **** void encrypt(uint32_t *v, uint32_t *k) {
 124              		.loc 1 53 0
 125              		.cfi_startproc
 126 00dd 55       		pushq	%rbp
 127              		.cfi_def_cfa_offset 16
 128              		.cfi_offset 6, -16
 129 00de 4889E5   		movq	%rsp, %rbp
 130              		.cfi_def_cfa_register 6
 131 00e1 48897DC8 		movq	%rdi, -56(%rbp)
 132 00e5 488975C0 		movq	%rsi, -64(%rbp)
  54:main.c        ****     uint32_t v0 = v[0], v1 = v[1], sum = 0, i;           /* set up */
 133              		.loc 1 54 0
 134 00e9 488B45C8 		movq	-56(%rbp), %rax
 135 00ed 8B00     		movl	(%rax), %eax
 136 00ef 8945DC   		movl	%eax, -36(%rbp)
 137 00f2 488B45C8 		movq	-56(%rbp), %rax
 138 00f6 8B4004   		movl	4(%rax), %eax
 139 00f9 8945E0   		movl	%eax, -32(%rbp)
 140 00fc C745E400 		movl	$0, -28(%rbp)
 140      000000
  55:main.c        ****     uint32_t delta = 0x9e3779b9;                     /* a key schedule constant */
 141              		.loc 1 55 0
 142 0103 C745ECB9 		movl	$-1640531527, -20(%rbp)
 142      79379E
  56:main.c        ****     uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3];   /* cache key */
 143              		.loc 1 56 0
 144 010a 488B45C0 		movq	-64(%rbp), %rax
 145 010e 8B00     		movl	(%rax), %eax
 146 0110 8945F0   		movl	%eax, -16(%rbp)
 147 0113 488B45C0 		movq	-64(%rbp), %rax
 148 0117 8B4004   		movl	4(%rax), %eax
 149 011a 8945F4   		movl	%eax, -12(%rbp)
 150 011d 488B45C0 		movq	-64(%rbp), %rax
 151 0121 8B4008   		movl	8(%rax), %eax
 152 0124 8945F8   		movl	%eax, -8(%rbp)
 153 0127 488B45C0 		movq	-64(%rbp), %rax
 154 012b 8B400C   		movl	12(%rax), %eax
 155 012e 8945FC   		movl	%eax, -4(%rbp)
  57:main.c        ****     /* basic cycle start */
  58:main.c        ****     for (i = 0; i < 32; i++) {
 156              		.loc 1 58 0
 157 0131 C745E800 		movl	$0, -24(%rbp)
 157      000000
 158 0138 EB62     		jmp	.L5
 159              	.L6:
  59:main.c        ****         sum += delta;
 160              		.loc 1 59 0 discriminator 2
 161 013a 8B45EC   		movl	-20(%rbp), %eax
 162 013d 0145E4   		addl	%eax, -28(%rbp)
  60:main.c        ****         v0 += ((v1 << 4) + k0) ^ (v1 + sum) ^ ((v1 >> 5) + k1);
 163              		.loc 1 60 0 discriminator 2
 164 0140 8B45E0   		movl	-32(%rbp), %eax
 165 0143 C1E004   		sall	$4, %eax
 166 0146 89C2     		movl	%eax, %edx
 167 0148 8B45F0   		movl	-16(%rbp), %eax
 168 014b 8D0C02   		leal	(%rdx,%rax), %ecx
 169 014e 8B45E4   		movl	-28(%rbp), %eax
 170 0151 8B55E0   		movl	-32(%rbp), %edx
 171 0154 01D0     		addl	%edx, %eax
 172 0156 31C1     		xorl	%eax, %ecx
 173 0158 89CA     		movl	%ecx, %edx
 174 015a 8B45E0   		movl	-32(%rbp), %eax
 175 015d C1E805   		shrl	$5, %eax
 176 0160 89C1     		movl	%eax, %ecx
 177 0162 8B45F4   		movl	-12(%rbp), %eax
 178 0165 01C8     		addl	%ecx, %eax
 179 0167 31D0     		xorl	%edx, %eax
 180 0169 0145DC   		addl	%eax, -36(%rbp)
  61:main.c        ****         v1 += ((v0 << 4) + k2) ^ (v0 + sum) ^ ((v0 >> 5) + k3);
 181              		.loc 1 61 0 discriminator 2
 182 016c 8B45DC   		movl	-36(%rbp), %eax
 183 016f C1E004   		sall	$4, %eax
 184 0172 89C2     		movl	%eax, %edx
 185 0174 8B45F8   		movl	-8(%rbp), %eax
 186 0177 8D0C02   		leal	(%rdx,%rax), %ecx
 187 017a 8B45E4   		movl	-28(%rbp), %eax
 188 017d 8B55DC   		movl	-36(%rbp), %edx
 189 0180 01D0     		addl	%edx, %eax
 190 0182 31C1     		xorl	%eax, %ecx
 191 0184 89CA     		movl	%ecx, %edx
 192 0186 8B45DC   		movl	-36(%rbp), %eax
 193 0189 C1E805   		shrl	$5, %eax
 194 018c 89C1     		movl	%eax, %ecx
 195 018e 8B45FC   		movl	-4(%rbp), %eax
 196 0191 01C8     		addl	%ecx, %eax
 197 0193 31D0     		xorl	%edx, %eax
 198 0195 0145E0   		addl	%eax, -32(%rbp)
  58:main.c        ****         sum += delta;
 199              		.loc 1 58 0 discriminator 2
 200 0198 8345E801 		addl	$1, -24(%rbp)
 201              	.L5:
  58:main.c        ****         sum += delta;
 202              		.loc 1 58 0 is_stmt 0 discriminator 1
 203 019c 837DE81F 		cmpl	$31, -24(%rbp)
 204 01a0 7698     		jbe	.L6
  62:main.c        ****     }
  63:main.c        ****     /* end cycle */
  64:main.c        ****     v[0] = v0;
 205              		.loc 1 64 0 is_stmt 1
 206 01a2 488B45C8 		movq	-56(%rbp), %rax
 207 01a6 8B55DC   		movl	-36(%rbp), %edx
 208 01a9 8910     		movl	%edx, (%rax)
  65:main.c        ****     v[1] = v1;
 209              		.loc 1 65 0
 210 01ab 488B45C8 		movq	-56(%rbp), %rax
 211 01af 488D5004 		leaq	4(%rax), %rdx
 212 01b3 8B45E0   		movl	-32(%rbp), %eax
 213 01b6 8902     		movl	%eax, (%rdx)
  66:main.c        **** }
 214              		.loc 1 66 0
 215 01b8 5D       		popq	%rbp
 216              		.cfi_def_cfa 7, 8
 217 01b9 C3       		ret
 218              		.cfi_endproc
 219              	.LFE7:
 221              		.globl	decrypt64
 223              	decrypt64:
 224              	.LFB8:
  67:main.c        **** 
  68:main.c        **** void decrypt64(uint32_t *inpData) {
 225              		.loc 1 68 0
 226              		.cfi_startproc
 227 01ba 55       		pushq	%rbp
 228              		.cfi_def_cfa_offset 16
 229              		.cfi_offset 6, -16
 230 01bb 4889E5   		movq	%rsp, %rbp
 231              		.cfi_def_cfa_register 6
 232 01be 4883EC18 		subq	$24, %rsp
 233 01c2 48897DE8 		movq	%rdi, -24(%rbp)
  69:main.c        ****     uint32_t key[4];
  70:main.c        ****     key[0] = 0x2927c18c;
 234              		.loc 1 70 0
 235 01c6 C745F08C 		movl	$690471308, -16(%rbp)
 235      C12729
  71:main.c        ****     key[1] = 0x75f8c48f;
 236              		.loc 1 71 0
 237 01cd C745F48F 		movl	$1979237519, -12(%rbp)
 237      C4F875
  72:main.c        ****     key[2] = 0x43fd99f7;
 238              		.loc 1 72 0
 239 01d4 C745F8F7 		movl	$1140693495, -8(%rbp)
 239      99FD43
  73:main.c        ****     key[3] = 0xff0f7457;
 240              		.loc 1 73 0
 241 01db C745FC57 		movl	$-15764393, -4(%rbp)
 241      740FFF
  74:main.c        ****     decrypt(inpData, key);
 242              		.loc 1 74 0
 243 01e2 488D55F0 		leaq	-16(%rbp), %rdx
 244 01e6 488B45E8 		movq	-24(%rbp), %rax
 245 01ea 4889D6   		movq	%rdx, %rsi
 246 01ed 4889C7   		movq	%rax, %rdi
 247 01f0 E8000000 		call	decrypt
 247      00
  75:main.c        **** }
 248              		.loc 1 75 0
 249 01f5 C9       		leave
 250              		.cfi_def_cfa 7, 8
 251 01f6 C3       		ret
 252              		.cfi_endproc
 253              	.LFE8:
 255              		.globl	encrypt64
 257              	encrypt64:
 258              	.LFB9:
  76:main.c        **** 
  77:main.c        **** void encrypt64(uint32_t *inpData) {
 259              		.loc 1 77 0
 260              		.cfi_startproc
 261 01f7 55       		pushq	%rbp
 262              		.cfi_def_cfa_offset 16
 263              		.cfi_offset 6, -16
 264 01f8 4889E5   		movq	%rsp, %rbp
 265              		.cfi_def_cfa_register 6
 266 01fb 4883EC18 		subq	$24, %rsp
 267 01ff 48897DE8 		movq	%rdi, -24(%rbp)
  78:main.c        ****     uint32_t key[4];
  79:main.c        ****     key[0] = 0x2927c18c;
 268              		.loc 1 79 0
 269 0203 C745F08C 		movl	$690471308, -16(%rbp)
 269      C12729
  80:main.c        ****     key[1] = 0x75f8c48f;
 270              		.loc 1 80 0
 271 020a C745F48F 		movl	$1979237519, -12(%rbp)
 271      C4F875
  81:main.c        ****     key[2] = 0x43fd99f7;
 272              		.loc 1 81 0
 273 0211 C745F8F7 		movl	$1140693495, -8(%rbp)
 273      99FD43
  82:main.c        ****     key[3] = 0xff0f7457;
 274              		.loc 1 82 0
 275 0218 C745FC57 		movl	$-15764393, -4(%rbp)
 275      740FFF
  83:main.c        ****     encrypt(inpData, key);
 276              		.loc 1 83 0
 277 021f 488D55F0 		leaq	-16(%rbp), %rdx
 278 0223 488B45E8 		movq	-24(%rbp), %rax
 279 0227 4889D6   		movq	%rdx, %rsi
 280 022a 4889C7   		movq	%rax, %rdi
 281 022d E8000000 		call	encrypt
 281      00
  84:main.c        **** }
 282              		.loc 1 84 0
 283 0232 C9       		leave
 284              		.cfi_def_cfa 7, 8
 285 0233 C3       		ret
 286              		.cfi_endproc
 287              	.LFE9:
 289              		.globl	myHash
 291              	myHash:
 292              	.LFB10:
  85:main.c        **** 
  86:main.c        **** uint16_t myHash(uint16_t befHash) {
 293              		.loc 1 86 0
 294              		.cfi_startproc
 295 0234 55       		pushq	%rbp
 296              		.cfi_def_cfa_offset 16
 297              		.cfi_offset 6, -16
 298 0235 4889E5   		movq	%rsp, %rbp
 299              		.cfi_def_cfa_register 6
 300 0238 89F8     		movl	%edi, %eax
 301 023a 668945EC 		movw	%ax, -20(%rbp)
  87:main.c        ****     uint16_t ret = 0;
 302              		.loc 1 87 0
 303 023e 66C745FA 		movw	$0, -6(%rbp)
 303      0000
 304              	.LBB2:
  88:main.c        ****     for (uint16_t i = 0; i <= 15; i++) {
 305              		.loc 1 88 0
 306 0244 66C745FC 		movw	$0, -4(%rbp)
 306      0000
 307 024a EB4F     		jmp	.L10
 308              	.L12:
  89:main.c        ****         if ((befHash & (1 << i)) != 0) {
 309              		.loc 1 89 0
 310 024c 0FB755EC 		movzwl	-20(%rbp), %edx
 311 0250 0FB745FC 		movzwl	-4(%rbp), %eax
 312 0254 89C1     		movl	%eax, %ecx
 313 0256 D3FA     		sarl	%cl, %edx
 314 0258 89D0     		movl	%edx, %eax
 315 025a 83E001   		andl	$1, %eax
 316 025d 85C0     		testl	%eax, %eax
 317 025f 742F     		je	.L11
 318              	.LBB3:
  90:main.c        ****             uint16_t j = ((i + 11) % 16);
 319              		.loc 1 90 0
 320 0261 0FB745FC 		movzwl	-4(%rbp), %eax
 321 0265 8D500B   		leal	11(%rax), %edx
 322 0268 89D0     		movl	%edx, %eax
 323 026a C1F81F   		sarl	$31, %eax
 324 026d C1E81C   		shrl	$28, %eax
 325 0270 01C2     		addl	%eax, %edx
 326 0272 83E20F   		andl	$15, %edx
 327 0275 29C2     		subl	%eax, %edx
 328 0277 89D0     		movl	%edx, %eax
 329 0279 668945FE 		movw	%ax, -2(%rbp)
  91:main.c        ****             ret += (1 << j);
 330              		.loc 1 91 0
 331 027d 0FB745FE 		movzwl	-2(%rbp), %eax
 332 0281 BA010000 		movl	$1, %edx
 332      00
 333 0286 89C1     		movl	%eax, %ecx
 334 0288 D3E2     		sall	%cl, %edx
 335 028a 89D0     		movl	%edx, %eax
 336 028c 660145FA 		addw	%ax, -6(%rbp)
 337              	.L11:
 338              	.LBE3:
  88:main.c        ****         if ((befHash & (1 << i)) != 0) {
 339              		.loc 1 88 0
 340 0290 0FB745FC 		movzwl	-4(%rbp), %eax
 341 0294 83C001   		addl	$1, %eax
 342 0297 668945FC 		movw	%ax, -4(%rbp)
 343              	.L10:
  88:main.c        ****         if ((befHash & (1 << i)) != 0) {
 344              		.loc 1 88 0 is_stmt 0 discriminator 1
 345 029b 66837DFC 		cmpw	$15, -4(%rbp)
 345      0F
 346 02a0 76AA     		jbe	.L12
 347              	.LBE2:
  92:main.c        ****         }
  93:main.c        ****     }
  94:main.c        ****     return ret;
 348              		.loc 1 94 0 is_stmt 1
 349 02a2 0FB745FA 		movzwl	-6(%rbp), %eax
  95:main.c        **** }
 350              		.loc 1 95 0
 351 02a6 5D       		popq	%rbp
 352              		.cfi_def_cfa 7, 8
 353 02a7 C3       		ret
 354              		.cfi_endproc
 355              	.LFE10:
 357              		.section	.rodata
 358              	.LC0:
 359 0000 2C00     		.string	","
 360              	.LC1:
 361 0002 256400   		.string	"%d"
 362              		.text
 363              		.globl	format
 365              	format:
 366              	.LFB11:
  96:main.c        **** 
  97:main.c        **** void format(char *line) {
 367              		.loc 1 97 0
 368              		.cfi_startproc
 369 02a8 55       		pushq	%rbp
 370              		.cfi_def_cfa_offset 16
 371              		.cfi_offset 6, -16
 372 02a9 4889E5   		movq	%rsp, %rbp
 373              		.cfi_def_cfa_register 6
 374 02ac 4883EC20 		subq	$32, %rsp
 375 02b0 48897DE8 		movq	%rdi, -24(%rbp)
  98:main.c        ****     char *wordPtr;
  99:main.c        ****     wordPtr = strtok(line, ",");
 376              		.loc 1 99 0
 377 02b4 488B45E8 		movq	-24(%rbp), %rax
 378 02b8 BE000000 		movl	$.LC0, %esi
 378      00
 379 02bd 4889C7   		movq	%rax, %rdi
 380 02c0 E8000000 		call	strtok
 380      00
 381 02c5 488945F8 		movq	%rax, -8(%rbp)
 100:main.c        ****     int cnt = 0;
 382              		.loc 1 100 0
 383 02c9 C745F400 		movl	$0, -12(%rbp)
 383      000000
 101:main.c        ****     while (wordPtr != NULL) {
 384              		.loc 1 101 0
 385 02d0 EB4D     		jmp	.L15
 386              	.L16:
 102:main.c        ****         sscanf(wordPtr, "%d", &dataFromCSV[numLines][cnt]);
 387              		.loc 1 102 0
 388 02d2 8B150000 		movl	numLines(%rip), %edx
 388      0000
 389 02d8 8B45F4   		movl	-12(%rbp), %eax
 390 02db 4898     		cltq
 391 02dd 4863D2   		movslq	%edx, %rdx
 392 02e0 48C1E202 		salq	$2, %rdx
 393 02e4 4801D0   		addq	%rdx, %rax
 394 02e7 48C1E002 		salq	$2, %rax
 395 02eb 488D9000 		leaq	dataFromCSV(%rax), %rdx
 395      000000
 396 02f2 488B45F8 		movq	-8(%rbp), %rax
 397 02f6 BE000000 		movl	$.LC1, %esi
 397      00
 398 02fb 4889C7   		movq	%rax, %rdi
 399 02fe B8000000 		movl	$0, %eax
 399      00
 400 0303 E8000000 		call	sscanf
 400      00
 103:main.c        ****         // printf("%d\n",dataFromCSV[numLines][cnt]);
 104:main.c        ****         wordPtr = strtok(NULL, ",");
 401              		.loc 1 104 0
 402 0308 BE000000 		movl	$.LC0, %esi
 402      00
 403 030d BF000000 		movl	$0, %edi
 403      00
 404 0312 E8000000 		call	strtok
 404      00
 405 0317 488945F8 		movq	%rax, -8(%rbp)
 105:main.c        ****         cnt++;
 406              		.loc 1 105 0
 407 031b 8345F401 		addl	$1, -12(%rbp)
 408              	.L15:
 101:main.c        ****         sscanf(wordPtr, "%d", &dataFromCSV[numLines][cnt]);
 409              		.loc 1 101 0 discriminator 1
 410 031f 48837DF8 		cmpq	$0, -8(%rbp)
 410      00
 411 0324 75AC     		jne	.L16
 106:main.c        ****     }
 107:main.c        **** }
 412              		.loc 1 107 0
 413 0326 C9       		leave
 414              		.cfi_def_cfa 7, 8
 415 0327 C3       		ret
 416              		.cfi_endproc
 417              	.LFE11:
 419              		.globl	find
 421              	find:
 422              	.LFB12:
 108:main.c        **** 
 109:main.c        **** bool find(uint16_t userID, uint16_t hashedPin, bool *isAdmin, int *bal, int *inLineNum) {
 423              		.loc 1 109 0
 424              		.cfi_startproc
 425 0328 55       		pushq	%rbp
 426              		.cfi_def_cfa_offset 16
 427              		.cfi_offset 6, -16
 428 0329 4889E5   		movq	%rsp, %rbp
 429              		.cfi_def_cfa_register 6
 430 032c 89F0     		movl	%esi, %eax
 431 032e 488955E0 		movq	%rdx, -32(%rbp)
 432 0332 48894DD8 		movq	%rcx, -40(%rbp)
 433 0336 4C8945D0 		movq	%r8, -48(%rbp)
 434 033a 66897DEC 		movw	%di, -20(%rbp)
 435 033e 668945E8 		movw	%ax, -24(%rbp)
 110:main.c        ****     bool pos = false;
 436              		.loc 1 110 0
 437 0342 C645FB00 		movb	$0, -5(%rbp)
 438              	.LBB4:
 111:main.c        ****     for (int i = 1; i <= numLines; i++) {
 439              		.loc 1 111 0
 440 0346 C745FC01 		movl	$1, -4(%rbp)
 440      000000
 441 034d EB75     		jmp	.L18
 442              	.L22:
 112:main.c        ****         if (userID == (uint16_t) dataFromCSV[i][0] && hashedPin == (uint16_t) dataFromCSV[i][1]) {
 443              		.loc 1 112 0
 444 034f 8B45FC   		movl	-4(%rbp), %eax
 445 0352 4898     		cltq
 446 0354 48C1E004 		salq	$4, %rax
 447 0358 48050000 		addq	$dataFromCSV, %rax
 447      0000
 448 035e 8B00     		movl	(%rax), %eax
 449 0360 663B45EC 		cmpw	-20(%rbp), %ax
 450 0364 755A     		jne	.L19
 451              		.loc 1 112 0 is_stmt 0 discriminator 1
 452 0366 8B45FC   		movl	-4(%rbp), %eax
 453 0369 4898     		cltq
 454 036b 48C1E004 		salq	$4, %rax
 455 036f 48050000 		addq	$dataFromCSV+4, %rax
 455      0000
 456 0375 8B00     		movl	(%rax), %eax
 457 0377 663B45E8 		cmpw	-24(%rbp), %ax
 458 037b 7543     		jne	.L19
 113:main.c        ****             pos = true;
 459              		.loc 1 113 0 is_stmt 1
 460 037d C645FB01 		movb	$1, -5(%rbp)
 114:main.c        ****             if (dataFromCSV[i][2] == 1) *isAdmin = true;
 461              		.loc 1 114 0
 462 0381 8B45FC   		movl	-4(%rbp), %eax
 463 0384 4898     		cltq
 464 0386 48C1E004 		salq	$4, %rax
 465 038a 48050000 		addq	$dataFromCSV+8, %rax
 465      0000
 466 0390 8B00     		movl	(%rax), %eax
 467 0392 83F801   		cmpl	$1, %eax
 468 0395 7507     		jne	.L20
 469              		.loc 1 114 0 is_stmt 0 discriminator 1
 470 0397 488B45E0 		movq	-32(%rbp), %rax
 471 039b C60001   		movb	$1, (%rax)
 472              	.L20:
 115:main.c        ****             *bal = dataFromCSV[i][3];
 473              		.loc 1 115 0 is_stmt 1
 474 039e 8B45FC   		movl	-4(%rbp), %eax
 475 03a1 4898     		cltq
 476 03a3 48C1E004 		salq	$4, %rax
 477 03a7 48050000 		addq	$dataFromCSV+12, %rax
 477      0000
 478 03ad 8B10     		movl	(%rax), %edx
 479 03af 488B45D8 		movq	-40(%rbp), %rax
 480 03b3 8910     		movl	%edx, (%rax)
 116:main.c        ****             *inLineNum = i;
 481              		.loc 1 116 0
 482 03b5 488B45D0 		movq	-48(%rbp), %rax
 483 03b9 8B55FC   		movl	-4(%rbp), %edx
 484 03bc 8910     		movl	%edx, (%rax)
 117:main.c        ****             break;
 485              		.loc 1 117 0
 486 03be EB0F     		jmp	.L21
 487              	.L19:
 111:main.c        ****         if (userID == (uint16_t) dataFromCSV[i][0] && hashedPin == (uint16_t) dataFromCSV[i][1]) {
 488              		.loc 1 111 0
 489 03c0 8345FC01 		addl	$1, -4(%rbp)
 490              	.L18:
 111:main.c        ****         if (userID == (uint16_t) dataFromCSV[i][0] && hashedPin == (uint16_t) dataFromCSV[i][1]) {
 491              		.loc 1 111 0 is_stmt 0 discriminator 1
 492 03c4 8B050000 		movl	numLines(%rip), %eax
 492      0000
 493 03ca 3945FC   		cmpl	%eax, -4(%rbp)
 494 03cd 7E80     		jle	.L22
 495              	.L21:
 496              	.LBE4:
 118:main.c        ****         }
 119:main.c        ****     }
 120:main.c        ****     return pos;
 497              		.loc 1 120 0 is_stmt 1
 498 03cf 0FB645FB 		movzbl	-5(%rbp), %eax
 121:main.c        **** }
 499              		.loc 1 121 0
 500 03d3 5D       		popq	%rbp
 501              		.cfi_def_cfa 7, 8
 502 03d4 C3       		ret
 503              		.cfi_endproc
 504              	.LFE12:
 506              		.globl	suffBal
 508              	suffBal:
 509              	.LFB13:
 122:main.c        **** 
 123:main.c        **** bool suffBal(int bal, int *reqAmo, uint8_t num_100, uint8_t num_500, uint8_t num_1000, uint8_t num_
 510              		.loc 1 123 0
 511              		.cfi_startproc
 512 03d5 55       		pushq	%rbp
 513              		.cfi_def_cfa_offset 16
 514              		.cfi_offset 6, -16
 515 03d6 4889E5   		movq	%rsp, %rbp
 516              		.cfi_def_cfa_register 6
 517 03d9 897DEC   		movl	%edi, -20(%rbp)
 518 03dc 488975E0 		movq	%rsi, -32(%rbp)
 519 03e0 89C8     		movl	%ecx, %eax
 520 03e2 4489C6   		movl	%r8d, %esi
 521 03e5 4489C9   		movl	%r9d, %ecx
 522 03e8 8855E8   		movb	%dl, -24(%rbp)
 523 03eb 8845DC   		movb	%al, -36(%rbp)
 524 03ee 408875D8 		movb	%sil, -40(%rbp)
 525 03f2 884DD4   		movb	%cl, -44(%rbp)
 124:main.c        ****     bool hasSuffBal = true;
 526              		.loc 1 124 0
 527 03f5 C645FF01 		movb	$1, -1(%rbp)
 125:main.c        ****     *reqAmo += 100 * ((int) num_100);
 528              		.loc 1 125 0
 529 03f9 488B45E0 		movq	-32(%rbp), %rax
 530 03fd 8B10     		movl	(%rax), %edx
 531 03ff 0FB645E8 		movzbl	-24(%rbp), %eax
 532 0403 6BC064   		imull	$100, %eax, %eax
 533 0406 01C2     		addl	%eax, %edx
 534 0408 488B45E0 		movq	-32(%rbp), %rax
 535 040c 8910     		movl	%edx, (%rax)
 126:main.c        ****     *reqAmo += 500 * ((int) num_500);
 536              		.loc 1 126 0
 537 040e 488B45E0 		movq	-32(%rbp), %rax
 538 0412 8B10     		movl	(%rax), %edx
 539 0414 0FB645DC 		movzbl	-36(%rbp), %eax
 540 0418 69C0F401 		imull	$500, %eax, %eax
 540      0000
 541 041e 01C2     		addl	%eax, %edx
 542 0420 488B45E0 		movq	-32(%rbp), %rax
 543 0424 8910     		movl	%edx, (%rax)
 127:main.c        ****     *reqAmo += 1000 * ((int) num_1000);
 544              		.loc 1 127 0
 545 0426 488B45E0 		movq	-32(%rbp), %rax
 546 042a 8B10     		movl	(%rax), %edx
 547 042c 0FB645D8 		movzbl	-40(%rbp), %eax
 548 0430 69C0E803 		imull	$1000, %eax, %eax
 548      0000
 549 0436 01C2     		addl	%eax, %edx
 550 0438 488B45E0 		movq	-32(%rbp), %rax
 551 043c 8910     		movl	%edx, (%rax)
 128:main.c        ****     *reqAmo += 2000 * ((int) num_2000);
 552              		.loc 1 128 0
 553 043e 488B45E0 		movq	-32(%rbp), %rax
 554 0442 8B10     		movl	(%rax), %edx
 555 0444 0FB645D4 		movzbl	-44(%rbp), %eax
 556 0448 69C0D007 		imull	$2000, %eax, %eax
 556      0000
 557 044e 01C2     		addl	%eax, %edx
 558 0450 488B45E0 		movq	-32(%rbp), %rax
 559 0454 8910     		movl	%edx, (%rax)
 129:main.c        ****     if (*reqAmo > bal) hasSuffBal = false;
 560              		.loc 1 129 0
 561 0456 488B45E0 		movq	-32(%rbp), %rax
 562 045a 8B00     		movl	(%rax), %eax
 563 045c 3B45EC   		cmpl	-20(%rbp), %eax
 564 045f 7E04     		jle	.L25
 565              		.loc 1 129 0 is_stmt 0 discriminator 1
 566 0461 C645FF00 		movb	$0, -1(%rbp)
 567              	.L25:
 130:main.c        ****     return hasSuffBal;
 568              		.loc 1 130 0 is_stmt 1
 569 0465 0FB645FF 		movzbl	-1(%rbp), %eax
 131:main.c        **** }
 570              		.loc 1 131 0
 571 0469 5D       		popq	%rbp
 572              		.cfi_def_cfa 7, 8
 573 046a C3       		ret
 574              		.cfi_endproc
 575              	.LFE13:
 577              		.section	.rodata
 578              	.LC2:
 579 0005 556E7061 		.string	"Unparseable hex number"
 579      72736561 
 579      626C6520 
 579      68657820 
 579      6E756D62 
 580              	.LC3:
 581 001c 4368616E 		.string	"Channel out of range"
 581      6E656C20 
 581      6F757420 
 581      6F662072 
 581      616E6765 
 582              	.LC4:
 583 0031 436F6E64 		.string	"Conduit out of range"
 583      75697420 
 583      6F757420 
 583      6F662072 
 583      616E6765 
 584              	.LC5:
 585 0046 496C6C65 		.string	"Illegal character"
 585      67616C20 
 585      63686172 
 585      61637465 
 585      7200
 586              	.LC6:
 587 0058 556E7465 		.string	"Unterminated string"
 587      726D696E 
 587      61746564 
 587      20737472 
 587      696E6700 
 588              	.LC7:
 589 006c 4E6F206D 		.string	"No memory"
 589      656D6F72 
 589      7900
 590              	.LC8:
 591 0076 456D7074 		.string	"Empty string"
 591      79207374 
 591      72696E67 
 591      00
 592              	.LC9:
 593 0083 4F646420 		.string	"Odd number of digits"
 593      6E756D62 
 593      6572206F 
 593      66206469 
 593      67697473 
 594              	.LC10:
 595 0098 43616E6E 		.string	"Cannot load file"
 595      6F74206C 
 595      6F616420 
 595      66696C65 
 595      00
 596              	.LC11:
 597 00a9 43616E6E 		.string	"Cannot save file"
 597      6F742073 
 597      61766520 
 597      66696C65 
 597      00
 598              	.LC12:
 599 00ba 42616420 		.string	"Bad arguments"
 599      61726775 
 599      6D656E74 
 599      7300
 600 00c8 00000000 		.align 32
 600      00000000 
 600      00000000 
 600      00000000 
 600      00000000 
 603              	errMessages:
 604 00e0 00000000 		.quad	0
 604      00000000 
 605 00e8 00000000 		.quad	0
 605      00000000 
 606 00f0 00000000 		.quad	.LC2
 606      00000000 
 607 00f8 00000000 		.quad	.LC3
 607      00000000 
 608 0100 00000000 		.quad	.LC4
 608      00000000 
 609 0108 00000000 		.quad	.LC5
 609      00000000 
 610 0110 00000000 		.quad	.LC6
 610      00000000 
 611 0118 00000000 		.quad	.LC7
 611      00000000 
 612 0120 00000000 		.quad	.LC8
 612      00000000 
 613 0128 00000000 		.quad	.LC9
 613      00000000 
 614 0130 00000000 		.quad	.LC10
 614      00000000 
 615 0138 00000000 		.quad	.LC11
 615      00000000 
 616 0140 00000000 		.quad	.LC12
 616      00000000 
 617              		.align 8
 618              	.LC13:
 619 0148 20202020 		.string	"            vendor ID and product ID (e.g 04B4:8613)"
 619      20202020 
 619      20202020 
 619      76656E64 
 619      6F722049 
 620              	.LC14:
 621 017d 3C564944 		.string	"<VID:PID>"
 621      3A504944 
 621      3E00
 622              	.LC15:
 623 0187 69767000 		.string	"ivp"
 624              	.LC16:
 625 018b 6900     		.string	"i"
 626 018d 000000   		.align 8
 627              	.LC17:
 628 0190 20202020 		.string	"       VID, PID and opt. dev ID (e.g 1D50:602B:0001)"
 628      20202056 
 628      49442C20 
 628      50494420 
 628      616E6420 
 629              	.LC18:
 630 01c5 3C564944 		.string	"<VID:PID[:DID]>"
 630      3A504944 
 630      5B3A4449 
 630      445D3E00 
 631              	.LC19:
 632 01d5 767000   		.string	"vp"
 633              	.LC20:
 634 01d8 7600     		.string	"v"
 635 01da 00000000 		.align 8
 635      0000
 636              	.LC21:
 637 01e0 20202020 		.string	"        firmware to RAM-load (or use std fw)"
 637      20202020 
 637      6669726D 
 637      77617265 
 637      20746F20 
 638              	.LC22:
 639 020d 3C666972 		.string	"<firmware.hex>"
 639      6D776172 
 639      652E6865 
 639      783E00
 640              	.LC23:
 641 021c 667700   		.string	"fw"
 642              	.LC24:
 643 021f 6600     		.string	"f"
 644 0221 00000000 		.align 8
 644      000000
 645              	.LC25:
 646 0228 20202020 		.string	"                    communicates with the atm module"
 646      20202020 
 646      20202020 
 646      20202020 
 646      20202020 
 647              	.LC26:
 648 025d 61746D00 		.string	"atm"
 649              	.LC27:
 650 0261 7900     		.string	"y"
 651 0263 00000000 		.align 8
 651      00
 652              	.LC28:
 653 0268 20202020 		.string	"        gives log on more events"
 653      20202020 
 653      67697665 
 653      73206C6F 
 653      67206F6E 
 654              	.LC29:
 655 0289 6C6F6700 		.string	"log"
 656              	.LC30:
 657 028d 6C00     		.string	"l"
 658 028f 00       		.align 8
 659              	.LC31:
 660 0290 20202020 		.string	"                     print this help and exit"
 660      20202020 
 660      20202020 
 660      20202020 
 660      20202020 
 661              	.LC32:
 662 02be 68656C70 		.string	"help"
 662      00
 663              	.LC33:
 664 02c3 6800     		.string	"h"
 665              	.LC34:
 666 02c5 666C636C 		.string	"flcli"
 666      6900
 667              	.LC35:
 668 02cb 25733A20 		.string	"%s: insufficient memory\n"
 668      696E7375 
 668      66666963 
 668      69656E74 
 668      206D656D 
 669 02e4 00000000 		.align 8
 670              	.LC36:
 671 02e8 46504741 		.string	"FPGALink Command-Line Interface Copyright (C) 2017 Jarvis \n\n Usage: %s"
 671      4C696E6B 
 671      20436F6D 
 671      6D616E64 
 671      2D4C696E 
 672              	.LC37:
 673 032f 0A00     		.string	"\n"
 674 0331 00000000 		.align 8
 674      000000
 675              	.LC38:
 676 0338 0A496E74 		.string	"\nInteract with an FPGALink device.\n"
 676      65726163 
 676      74207769 
 676      74682061 
 676      6E204650 
 677              	.LC39:
 678 035c 2020252D 		.string	"  %-10s %s\n"
 678      31307320 
 678      25730A00 
 679              		.align 8
 680              	.LC40:
 681 0368 54727920 		.string	"Try '%s --help' for more information.\n"
 681      27257320 
 681      2D2D6865 
 681      6C702720 
 681      666F7220 
 682 038f 00       		.align 8
 683              	.LC41:
 684 0390 41747465 		.string	"Attempting to open connection to FPGALink device %s...\n"
 684      6D707469 
 684      6E672074 
 684      6F206F70 
 684      656E2063 
 685              	.LC42:
 686 03c8 4C6F6164 		.string	"Loading firmware into %s...\n"
 686      696E6720 
 686      6669726D 
 686      77617265 
 686      20696E74 
 687              	.LC43:
 688 03e5 41776169 		.string	"Awaiting renumeration"
 688      74696E67 
 688      2072656E 
 688      756D6572 
 688      6174696F 
 689 03fb 00000000 		.align 8
 689      00
 690              	.LC44:
 691 0400 46504741 		.string	"FPGALink device did not renumerate properly as %s\n"
 691      4C696E6B 
 691      20646576 
 691      69636520 
 691      64696420 
 692 0433 00000000 		.align 8
 692      00
 693              	.LC45:
 694 0438 41747465 		.string	"Attempting to open connection to FPGLink device %s again...\n"
 694      6D707469 
 694      6E672074 
 694      6F206F70 
 694      656E2063 
 695 0475 000000   		.align 8
 696              	.LC46:
 697 0478 436F756C 		.string	"Could not open FPGALink device at %s and no initial VID:PID was supplied\n"
 697      64206E6F 
 697      74206F70 
 697      656E2046 
 697      5047414C 
 698 04c2 00000000 		.align 8
 698      0000
 699              	.LC47:
 700 04c8 436F6E6E 		.string	"Connected to FPGALink device %s (firmwareID: 0x%04X, firmwareVersion: 0x%08X)\n"
 700      65637465 
 700      6420746F 
 700      20465047 
 700      414C696E 
 701              	.LC48:
 702 0517 722B00   		.string	"r+"
 703              	.LC49:
 704 051a 53616D70 		.string	"SampleBackEndDatabase.csv"
 704      6C654261 
 704      636B456E 
 704      64446174 
 704      61626173 
 705              	.LC50:
 706 0534 43737620 		.string	"Csv doesn't exist "
 706      646F6573 
 706      6E277420 
 706      65786973 
 706      742000
 707              	.LC51:
 708 0547 52656164 		.string	"Read from channel 0 = %u \n"
 708      2066726F 
 708      6D206368 
 708      616E6E65 
 708      6C203020 
 709              	.LC52:
 710 0562 52656164 		.string	"Read from channel %u = %u \n"
 710      2066726F 
 710      6D206368 
 710      616E6E65 
 710      6C202575 
 711              	.LC53:
 712 057e 56616C69 		.string	"Valid user found "
 712      64207573 
 712      65722066 
 712      6F756E64 
 712      2000
 713              	.LC54:
 714 0590 53756666 		.string	"Sufficient Balance in account"
 714      69636965 
 714      6E742042 
 714      616C616E 
 714      63652069 
 715              	.LC55:
 716 05ae 57726974 		.string	"Write to channel %u = %u \n"
 716      6520746F 
 716      20636861 
 716      6E6E656C 
 716      20257520 
 717              	.LC56:
 718 05c9 772B00   		.string	"w+"
 719 05cc 00000000 		.align 8
 720              	.LC57:
 721 05d0 22557365 		.string	"\"User ID (decimal)\",\"PIN Hash (decimal)\",\"Admin\",\"Balance (decimal)\""
 721      72204944 
 721      20286465 
 721      63696D61 
 721      6C29222C 
 722              	.LC58:
 723 0615 496E7375 		.string	"Insufficient Balance "
 723      66666963 
 723      69656E74 
 723      2042616C 
 723      616E6365 
 724              	.LC59:
 725 062b 55736572 		.string	"User has admin privileges "
 725      20686173 
 725      2061646D 
 725      696E2070 
 725      72697669 
 726              	.LC60:
 727 0646 496E7661 		.string	"Invalid user "
 727      6C696420 
 727      75736572 
 727      2000
 728 0654 00000000 		.align 8
 729              	.LC61:
 730 0658 54686520 		.string	"The FPGALink device at %s is not ready to talk - did you forget --program?\n"
 730      46504741 
 730      4C696E6B 
 730      20646576 
 730      69636520 
 731 06a4 00000000 		.align 8
 732              	.LC62:
 733 06a8 41637469 		.string	"Action requested but device at %s does not support CommFPGA\n"
 733      6F6E2072 
 733      65717565 
 733      73746564 
 733      20627574 
 734              	.LC63:
 735 06e5 25730A00 		.string	"%s\n"
 736              		.text
 737              		.globl	main
 739              	main:
 740              	.LFB14:
 132:main.c        **** 
 133:main.c        **** static const char *const errMessages[] = {
 134:main.c        ****         NULL,
 135:main.c        ****         NULL,
 136:main.c        ****         "Unparseable hex number",
 137:main.c        ****         "Channel out of range",
 138:main.c        ****         "Conduit out of range",
 139:main.c        ****         "Illegal character",
 140:main.c        ****         "Unterminated string",
 141:main.c        ****         "No memory",
 142:main.c        ****         "Empty string",
 143:main.c        ****         "Odd number of digits",
 144:main.c        ****         "Cannot load file",
 145:main.c        ****         "Cannot save file",
 146:main.c        ****         "Bad arguments"
 147:main.c        **** };
 148:main.c        **** 
 149:main.c        **** typedef enum {
 150:main.c        ****     FLP_SUCCESS,
 151:main.c        ****     FLP_LIBERR,
 152:main.c        ****     FLP_BAD_HEX,
 153:main.c        ****     FLP_CHAN_RANGE,
 154:main.c        ****     FLP_CONDUIT_RANGE,
 155:main.c        ****     FLP_ILL_CHAR,
 156:main.c        ****     FLP_UNTERM_STRING,
 157:main.c        ****     FLP_NO_MEMORY,
 158:main.c        ****     FLP_EMPTY_STRING,
 159:main.c        ****     FLP_ODD_DIGITS,
 160:main.c        ****     FLP_CANNOT_LOAD,
 161:main.c        ****     FLP_CANNOT_SAVE,
 162:main.c        ****     FLP_ARGS
 163:main.c        **** } ReturnCode;
 164:main.c        **** 
 165:main.c        **** int main(int argc, char *argv[]) {
 741              		.loc 1 165 0
 742              		.cfi_startproc
 743 046b 55       		pushq	%rbp
 744              		.cfi_def_cfa_offset 16
 745              		.cfi_offset 6, -16
 746 046c 4889E5   		movq	%rsp, %rbp
 747              		.cfi_def_cfa_register 6
 748 046f 53       		pushq	%rbx
 749 0470 4881EC88 		subq	$392, %rsp
 749      010000
 750              		.cfi_offset 3, -24
 751 0477 89BD7CFE 		movl	%edi, -388(%rbp)
 751      FFFF
 752 047d 4889B570 		movq	%rsi, -400(%rbp)
 752      FEFFFF
 166:main.c        ****     ReturnCode retVal = FLP_SUCCESS;
 753              		.loc 1 166 0
 754 0484 C785BCFE 		movl	$0, -324(%rbp)
 754      FFFF0000 
 754      0000
 167:main.c        **** 
 168:main.c        ****     struct arg_str *ivpOpt = arg_str0("i", "ivp", "<VID:PID>", "            vendor ID and product I
 755              		.loc 1 168 0
 756 048e B9000000 		movl	$.LC13, %ecx
 756      00
 757 0493 BA000000 		movl	$.LC14, %edx
 757      00
 758 0498 BE000000 		movl	$.LC15, %esi
 758      00
 759 049d BF000000 		movl	$.LC16, %edi
 759      00
 760 04a2 E8000000 		call	arg_str0
 760      00
 761 04a7 48898538 		movq	%rax, -200(%rbp)
 761      FFFFFF
 169:main.c        ****     struct arg_str *vpOpt = arg_str1("v", "vp", "<VID:PID[:DID]>", "       VID, PID and opt. dev ID
 762              		.loc 1 169 0
 763 04ae B9000000 		movl	$.LC17, %ecx
 763      00
 764 04b3 BA000000 		movl	$.LC18, %edx
 764      00
 765 04b8 BE000000 		movl	$.LC19, %esi
 765      00
 766 04bd BF000000 		movl	$.LC20, %edi
 766      00
 767 04c2 E8000000 		call	arg_str1
 767      00
 768 04c7 48898540 		movq	%rax, -192(%rbp)
 768      FFFFFF
 170:main.c        ****     struct arg_str *fwOpt = arg_str0("f", "fw", "<firmware.hex>", "        firmware to RAM-load (or
 769              		.loc 1 170 0
 770 04ce B9000000 		movl	$.LC21, %ecx
 770      00
 771 04d3 BA000000 		movl	$.LC22, %edx
 771      00
 772 04d8 BE000000 		movl	$.LC23, %esi
 772      00
 773 04dd BF000000 		movl	$.LC24, %edi
 773      00
 774 04e2 E8000000 		call	arg_str0
 774      00
 775 04e7 48898548 		movq	%rax, -184(%rbp)
 775      FFFFFF
 171:main.c        ****     struct arg_lit *loopOpt = arg_lit0("y", "atm", "                    communicates with the atm m
 776              		.loc 1 171 0
 777 04ee BA000000 		movl	$.LC25, %edx
 777      00
 778 04f3 BE000000 		movl	$.LC26, %esi
 778      00
 779 04f8 BF000000 		movl	$.LC27, %edi
 779      00
 780 04fd E8000000 		call	arg_lit0
 780      00
 781 0502 48898550 		movq	%rax, -176(%rbp)
 781      FFFFFF
 172:main.c        ****     struct arg_lit *verboseOpt = arg_lit0("l", "log", "        gives log on more events");
 782              		.loc 1 172 0
 783 0509 BA000000 		movl	$.LC28, %edx
 783      00
 784 050e BE000000 		movl	$.LC29, %esi
 784      00
 785 0513 BF000000 		movl	$.LC30, %edi
 785      00
 786 0518 E8000000 		call	arg_lit0
 786      00
 787 051d 48898558 		movq	%rax, -168(%rbp)
 787      FFFFFF
 173:main.c        ****     struct arg_lit *helpOpt = arg_lit0("h", "help", "                     print this help and exit"
 788              		.loc 1 173 0
 789 0524 BA000000 		movl	$.LC31, %edx
 789      00
 790 0529 BE000000 		movl	$.LC32, %esi
 790      00
 791 052e BF000000 		movl	$.LC33, %edi
 791      00
 792 0533 E8000000 		call	arg_lit0
 792      00
 793 0538 48898560 		movq	%rax, -160(%rbp)
 793      FFFFFF
 174:main.c        ****     struct arg_end *endOpt = arg_end(20);
 794              		.loc 1 174 0
 795 053f BF140000 		movl	$20, %edi
 795      00
 796 0544 E8000000 		call	arg_end
 796      00
 797 0549 48898568 		movq	%rax, -152(%rbp)
 797      FFFFFF
 175:main.c        **** 
 176:main.c        ****     void *argTable[] = {
 798              		.loc 1 176 0
 799 0550 488B8538 		movq	-200(%rbp), %rax
 799      FFFFFF
 800 0557 488945B0 		movq	%rax, -80(%rbp)
 801 055b 488B8540 		movq	-192(%rbp), %rax
 801      FFFFFF
 802 0562 488945B8 		movq	%rax, -72(%rbp)
 803 0566 488B8548 		movq	-184(%rbp), %rax
 803      FFFFFF
 804 056d 488945C0 		movq	%rax, -64(%rbp)
 805 0571 488B8550 		movq	-176(%rbp), %rax
 805      FFFFFF
 806 0578 488945C8 		movq	%rax, -56(%rbp)
 807 057c 488B8558 		movq	-168(%rbp), %rax
 807      FFFFFF
 808 0583 488945D0 		movq	%rax, -48(%rbp)
 809 0587 488B8560 		movq	-160(%rbp), %rax
 809      FFFFFF
 810 058e 488945D8 		movq	%rax, -40(%rbp)
 811 0592 488B8568 		movq	-152(%rbp), %rax
 811      FFFFFF
 812 0599 488945E0 		movq	%rax, -32(%rbp)
 177:main.c        ****             ivpOpt,
 178:main.c        ****             vpOpt,
 179:main.c        ****             fwOpt,
 180:main.c        ****             loopOpt,
 181:main.c        ****             verboseOpt,
 182:main.c        ****             helpOpt,
 183:main.c        ****             endOpt
 184:main.c        ****     };
 185:main.c        **** 
 186:main.c        ****     const char *progName = "flcli";
 813              		.loc 1 186 0
 814 059d 48C78570 		movq	$.LC34, -144(%rbp)
 814      FFFFFF00 
 814      000000
 187:main.c        ****     int numErrors;
 188:main.c        ****     struct FLContext *handle = NULL;
 815              		.loc 1 188 0
 816 05a8 48C78518 		movq	$0, -232(%rbp)
 816      FFFFFF00 
 816      000000
 189:main.c        ****     FLStatus fStatus;
 190:main.c        ****     const char *error = NULL;
 817              		.loc 1 190 0
 818 05b3 48C78520 		movq	$0, -224(%rbp)
 818      FFFFFF00 
 818      000000
 191:main.c        ****     const char *ivp = NULL;
 819              		.loc 1 191 0
 820 05be 48C78578 		movq	$0, -136(%rbp)
 820      FFFFFF00 
 820      000000
 192:main.c        ****     const char *vp = NULL;
 821              		.loc 1 192 0
 822 05c9 48C74580 		movq	$0, -128(%rbp)
 822      00000000 
 193:main.c        ****     bool isCommCapable;
 194:main.c        ****     const char *line = NULL;
 823              		.loc 1 194 0
 824 05d1 48C74588 		movq	$0, -120(%rbp)
 824      00000000 
 195:main.c        ****     uint8 conduit = 0x01;
 825              		.loc 1 195 0
 826 05d9 C685A1FE 		movb	$1, -351(%rbp)
 826      FFFF01
 196:main.c        **** 
 197:main.c        ****     if (arg_nullcheck(argTable) != 0) {
 827              		.loc 1 197 0
 828 05e0 488D45B0 		leaq	-80(%rbp), %rax
 829 05e4 4889C7   		movq	%rax, %rdi
 830 05e7 E8000000 		call	arg_nullcheck
 830      00
 831 05ec 85C0     		testl	%eax, %eax
 832 05ee 742F     		je	.L28
 198:main.c        ****         fprintf(stderr, "%s: insufficient memory\n", progName);
 833              		.loc 1 198 0
 834 05f0 488B0500 		movq	stderr(%rip), %rax
 834      000000
 835 05f7 488B9570 		movq	-144(%rbp), %rdx
 835      FFFFFF
 836 05fe BE000000 		movl	$.LC35, %esi
 836      00
 837 0603 4889C7   		movq	%rax, %rdi
 838 0606 B8000000 		movl	$0, %eax
 838      00
 839 060b E8000000 		call	fprintf
 839      00
 199:main.c        ****         FAIL(1, cleanup);
 840              		.loc 1 199 0
 841 0610 C785BCFE 		movl	$1, -324(%rbp)
 841      FFFF0100 
 841      0000
 842 061a E99A1700 		jmp	.L29
 842      00
 843              	.L28:
 200:main.c        ****     }
 201:main.c        **** 
 202:main.c        ****     numErrors = arg_parse(argc, argv, argTable);
 844              		.loc 1 202 0
 845 061f 488D55B0 		leaq	-80(%rbp), %rdx
 846 0623 488B8D70 		movq	-400(%rbp), %rcx
 846      FEFFFF
 847 062a 8B857CFE 		movl	-388(%rbp), %eax
 847      FFFF
 848 0630 4889CE   		movq	%rcx, %rsi
 849 0633 89C7     		movl	%eax, %edi
 850 0635 E8000000 		call	arg_parse
 850      00
 851 063a 8985F0FE 		movl	%eax, -272(%rbp)
 851      FFFF
 203:main.c        **** 
 204:main.c        ****     if (verboseOpt->count > 0) {
 852              		.loc 1 204 0
 853 0640 488B8558 		movq	-168(%rbp), %rax
 853      FFFFFF
 854 0647 8B4060   		movl	96(%rax), %eax
 855 064a 85C0     		testl	%eax, %eax
 856 064c 7E07     		jle	.L30
 205:main.c        ****         LOG = true;
 857              		.loc 1 205 0
 858 064e C6050000 		movb	$1, LOG(%rip)
 858      000001
 859              	.L30:
 206:main.c        ****     }
 207:main.c        **** 
 208:main.c        ****     if (helpOpt->count > 0) {
 860              		.loc 1 208 0
 861 0655 488B8560 		movq	-160(%rbp), %rax
 861      FFFFFF
 862 065c 8B4060   		movl	96(%rax), %eax
 863 065f 85C0     		testl	%eax, %eax
 864 0661 7E68     		jle	.L31
 209:main.c        ****         printf("FPGALink Command-Line Interface Copyright (C) 2017 Jarvis \n\n Usage: %s", progName
 865              		.loc 1 209 0
 866 0663 488B8570 		movq	-144(%rbp), %rax
 866      FFFFFF
 867 066a 4889C6   		movq	%rax, %rsi
 868 066d BF000000 		movl	$.LC36, %edi
 868      00
 869 0672 B8000000 		movl	$0, %eax
 869      00
 870 0677 E8000000 		call	printf
 870      00
 210:main.c        ****         arg_print_syntax(stdout, argTable, "\n");
 871              		.loc 1 210 0
 872 067c 488B0500 		movq	stdout(%rip), %rax
 872      000000
 873 0683 488D4DB0 		leaq	-80(%rbp), %rcx
 874 0687 BA000000 		movl	$.LC37, %edx
 874      00
 875 068c 4889CE   		movq	%rcx, %rsi
 876 068f 4889C7   		movq	%rax, %rdi
 877 0692 E8000000 		call	arg_print_syntax
 877      00
 211:main.c        ****         printf("\nInteract with an FPGALink device.\n\n");
 878              		.loc 1 211 0
 879 0697 BF000000 		movl	$.LC38, %edi
 879      00
 880 069c E8000000 		call	puts
 880      00
 212:main.c        ****         arg_print_glossary(stdout, argTable, "  %-10s %s\n");
 881              		.loc 1 212 0
 882 06a1 488B0500 		movq	stdout(%rip), %rax
 882      000000
 883 06a8 488D4DB0 		leaq	-80(%rbp), %rcx
 884 06ac BA000000 		movl	$.LC39, %edx
 884      00
 885 06b1 4889CE   		movq	%rcx, %rsi
 886 06b4 4889C7   		movq	%rax, %rdi
 887 06b7 E8000000 		call	arg_print_glossary
 887      00
 213:main.c        ****         FAIL(FLP_SUCCESS, cleanup);
 888              		.loc 1 213 0
 889 06bc C785BCFE 		movl	$0, -324(%rbp)
 889      FFFF0000 
 889      0000
 890 06c6 E9EE1600 		jmp	.L29
 890      00
 891              	.L31:
 214:main.c        ****     }
 215:main.c        **** 
 216:main.c        ****     if (numErrors > 0) {
 892              		.loc 1 216 0
 893 06cb 83BDF0FE 		cmpl	$0, -272(%rbp)
 893      FFFF00
 894 06d2 7E4F     		jle	.L32
 217:main.c        ****         arg_print_errors(stdout, endOpt, progName);
 895              		.loc 1 217 0
 896 06d4 488B0500 		movq	stdout(%rip), %rax
 896      000000
 897 06db 488B9570 		movq	-144(%rbp), %rdx
 897      FFFFFF
 898 06e2 488B8D68 		movq	-152(%rbp), %rcx
 898      FFFFFF
 899 06e9 4889CE   		movq	%rcx, %rsi
 900 06ec 4889C7   		movq	%rax, %rdi
 901 06ef E8000000 		call	arg_print_errors
 901      00
 218:main.c        ****         fprintf(stderr, "Try '%s --help' for more information.\n", progName);
 902              		.loc 1 218 0
 903 06f4 488B0500 		movq	stderr(%rip), %rax
 903      000000
 904 06fb 488B9570 		movq	-144(%rbp), %rdx
 904      FFFFFF
 905 0702 BE000000 		movl	$.LC40, %esi
 905      00
 906 0707 4889C7   		movq	%rax, %rdi
 907 070a B8000000 		movl	$0, %eax
 907      00
 908 070f E8000000 		call	fprintf
 908      00
 219:main.c        ****         FAIL(FLP_ARGS, cleanup);
 909              		.loc 1 219 0
 910 0714 C785BCFE 		movl	$12, -324(%rbp)
 910      FFFF0C00 
 910      0000
 911 071e E9961600 		jmp	.L29
 911      00
 912              	.L32:
 220:main.c        ****     }
 221:main.c        **** 
 222:main.c        ****     fStatus = flInitialise(0, &error);
 913              		.loc 1 222 0
 914 0723 488D8520 		leaq	-224(%rbp), %rax
 914      FFFFFF
 915 072a 4889C6   		movq	%rax, %rsi
 916 072d BF000000 		movl	$0, %edi
 916      00
 917 0732 E8000000 		call	flInitialise
 917      00
 918 0737 8985C0FE 		movl	%eax, -320(%rbp)
 918      FFFF
 223:main.c        ****     CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 919              		.loc 1 223 0
 920 073d 83BDC0FE 		cmpl	$0, -320(%rbp)
 920      FFFF00
 921 0744 740F     		je	.L33
 922              		.loc 1 223 0 is_stmt 0 discriminator 1
 923 0746 C785BCFE 		movl	$1, -324(%rbp)
 923      FFFF0100 
 923      0000
 924 0750 E9641600 		jmp	.L29
 924      00
 925              	.L33:
 224:main.c        **** 
 225:main.c        ****     vp = vpOpt->sval[0];
 926              		.loc 1 225 0 is_stmt 1
 927 0755 488B8540 		movq	-192(%rbp), %rax
 927      FFFFFF
 928 075c 488B4068 		movq	104(%rax), %rax
 929 0760 488B00   		movq	(%rax), %rax
 930 0763 48894580 		movq	%rax, -128(%rbp)
 226:main.c        **** 
 227:main.c        ****     printf("Attempting to open connection to FPGALink device %s...\n", vp);
 931              		.loc 1 227 0
 932 0767 488B4580 		movq	-128(%rbp), %rax
 933 076b 4889C6   		movq	%rax, %rsi
 934 076e BF000000 		movl	$.LC41, %edi
 934      00
 935 0773 B8000000 		movl	$0, %eax
 935      00
 936 0778 E8000000 		call	printf
 936      00
 228:main.c        ****     fStatus = flOpen(vp, &handle, NULL);
 937              		.loc 1 228 0
 938 077d 488D8D18 		leaq	-232(%rbp), %rcx
 938      FFFFFF
 939 0784 488B4580 		movq	-128(%rbp), %rax
 940 0788 BA000000 		movl	$0, %edx
 940      00
 941 078d 4889CE   		movq	%rcx, %rsi
 942 0790 4889C7   		movq	%rax, %rdi
 943 0793 E8000000 		call	flOpen
 943      00
 944 0798 8985C0FE 		movl	%eax, -320(%rbp)
 944      FFFF
 229:main.c        ****     if (fStatus) {
 945              		.loc 1 229 0
 946 079e 83BDC0FE 		cmpl	$0, -320(%rbp)
 946      FFFF00
 947 07a5 0F841502 		je	.L34
 947      0000
 230:main.c        ****         if (ivpOpt->count) {
 948              		.loc 1 230 0
 949 07ab 488B8538 		movq	-200(%rbp), %rax
 949      FFFFFF
 950 07b2 8B4060   		movl	96(%rax), %eax
 951 07b5 85C0     		testl	%eax, %eax
 952 07b7 0F84D701 		je	.L35
 952      0000
 953              	.LBB5:
 231:main.c        ****             int count = 60;
 954              		.loc 1 231 0
 955 07bd C785C4FE 		movl	$60, -316(%rbp)
 955      FFFF3C00 
 955      0000
 232:main.c        ****             uint8 flag;
 233:main.c        ****             ivp = ivpOpt->sval[0];
 956              		.loc 1 233 0
 957 07c7 488B8538 		movq	-200(%rbp), %rax
 957      FFFFFF
 958 07ce 488B4068 		movq	104(%rax), %rax
 959 07d2 488B00   		movq	(%rax), %rax
 960 07d5 48898578 		movq	%rax, -136(%rbp)
 960      FFFFFF
 234:main.c        ****             printf("Loading firmware into %s...\n", ivp);
 961              		.loc 1 234 0
 962 07dc 488B8578 		movq	-136(%rbp), %rax
 962      FFFFFF
 963 07e3 4889C6   		movq	%rax, %rsi
 964 07e6 BF000000 		movl	$.LC42, %edi
 964      00
 965 07eb B8000000 		movl	$0, %eax
 965      00
 966 07f0 E8000000 		call	printf
 966      00
 235:main.c        ****             if (fwOpt->count) {
 967              		.loc 1 235 0
 968 07f5 488B8548 		movq	-184(%rbp), %rax
 968      FFFFFF
 969 07fc 8B4060   		movl	96(%rax), %eax
 970 07ff 85C0     		testl	%eax, %eax
 971 0801 742F     		je	.L36
 236:main.c        ****                 fStatus = flLoadCustomFirmware(ivp, fwOpt->sval[0], &error);
 972              		.loc 1 236 0
 973 0803 488B8548 		movq	-184(%rbp), %rax
 973      FFFFFF
 974 080a 488B4068 		movq	104(%rax), %rax
 975 080e 488B08   		movq	(%rax), %rcx
 976 0811 488D9520 		leaq	-224(%rbp), %rdx
 976      FFFFFF
 977 0818 488B8578 		movq	-136(%rbp), %rax
 977      FFFFFF
 978 081f 4889CE   		movq	%rcx, %rsi
 979 0822 4889C7   		movq	%rax, %rdi
 980 0825 E8000000 		call	flLoadCustomFirmware
 980      00
 981 082a 8985C0FE 		movl	%eax, -320(%rbp)
 981      FFFF
 982 0830 EB23     		jmp	.L37
 983              	.L36:
 237:main.c        ****             } else {
 238:main.c        ****                 fStatus = flLoadStandardFirmware(ivp, vp, &error);
 984              		.loc 1 238 0
 985 0832 488D9520 		leaq	-224(%rbp), %rdx
 985      FFFFFF
 986 0839 488B4D80 		movq	-128(%rbp), %rcx
 987 083d 488B8578 		movq	-136(%rbp), %rax
 987      FFFFFF
 988 0844 4889CE   		movq	%rcx, %rsi
 989 0847 4889C7   		movq	%rax, %rdi
 990 084a E8000000 		call	flLoadStandardFirmware
 990      00
 991 084f 8985C0FE 		movl	%eax, -320(%rbp)
 991      FFFF
 992              	.L37:
 239:main.c        ****             }
 240:main.c        ****             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 993              		.loc 1 240 0
 994 0855 83BDC0FE 		cmpl	$0, -320(%rbp)
 994      FFFF00
 995 085c 740F     		je	.L38
 996              		.loc 1 240 0 is_stmt 0 discriminator 1
 997 085e C785BCFE 		movl	$1, -324(%rbp)
 997      FFFF0100 
 997      0000
 998 0868 E94C1500 		jmp	.L29
 998      00
 999              	.L38:
 241:main.c        **** 
 242:main.c        ****             printf("Awaiting renumeration");
 1000              		.loc 1 242 0 is_stmt 1
 1001 086d BF000000 		movl	$.LC43, %edi
 1001      00
 1002 0872 B8000000 		movl	$0, %eax
 1002      00
 1003 0877 E8000000 		call	printf
 1003      00
 243:main.c        ****             flSleep(1000);
 1004              		.loc 1 243 0
 1005 087c BFE80300 		movl	$1000, %edi
 1005      00
 1006 0881 E8000000 		call	flSleep
 1006      00
 1007              	.L42:
 244:main.c        ****             do {
 245:main.c        ****                 printf(".");
 1008              		.loc 1 245 0
 1009 0886 BF2E0000 		movl	$46, %edi
 1009      00
 1010 088b E8000000 		call	putchar
 1010      00
 246:main.c        ****                 fflush(stdout);
 1011              		.loc 1 246 0
 1012 0890 488B0500 		movq	stdout(%rip), %rax
 1012      000000
 1013 0897 4889C7   		movq	%rax, %rdi
 1014 089a E8000000 		call	fflush
 1014      00
 247:main.c        ****                 fStatus = flIsDeviceAvailable(vp, &flag, &error);
 1015              		.loc 1 247 0
 1016 089f 488D9520 		leaq	-224(%rbp), %rdx
 1016      FFFFFF
 1017 08a6 488D8D30 		leaq	-208(%rbp), %rcx
 1017      FFFFFF
 1018 08ad 488B4580 		movq	-128(%rbp), %rax
 1019 08b1 4889CE   		movq	%rcx, %rsi
 1020 08b4 4889C7   		movq	%rax, %rdi
 1021 08b7 E8000000 		call	flIsDeviceAvailable
 1021      00
 1022 08bc 8985C0FE 		movl	%eax, -320(%rbp)
 1022      FFFF
 248:main.c        ****                 CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1023              		.loc 1 248 0
 1024 08c2 83BDC0FE 		cmpl	$0, -320(%rbp)
 1024      FFFF00
 1025 08c9 740F     		je	.L40
 1026              		.loc 1 248 0 is_stmt 0 discriminator 1
 1027 08cb C785BCFE 		movl	$1, -324(%rbp)
 1027      FFFF0100 
 1027      0000
 1028 08d5 E9DF1400 		jmp	.L29
 1028      00
 1029              	.L40:
 249:main.c        ****                 flSleep(250);
 1030              		.loc 1 249 0 is_stmt 1
 1031 08da BFFA0000 		movl	$250, %edi
 1031      00
 1032 08df E8000000 		call	flSleep
 1032      00
 250:main.c        ****                 count--;
 1033              		.loc 1 250 0
 1034 08e4 83ADC4FE 		subl	$1, -316(%rbp)
 1034      FFFF01
 251:main.c        ****             } while (!flag && count);
 1035              		.loc 1 251 0
 1036 08eb 0FB68530 		movzbl	-208(%rbp), %eax
 1036      FFFFFF
 1037 08f2 84C0     		testb	%al, %al
 1038 08f4 7509     		jne	.L41
 1039              		.loc 1 251 0 is_stmt 0 discriminator 1
 1040 08f6 83BDC4FE 		cmpl	$0, -316(%rbp)
 1040      FFFF00
 1041 08fd 7587     		jne	.L42
 1042              	.L41:
 252:main.c        ****             printf("\n");
 1043              		.loc 1 252 0 is_stmt 1
 1044 08ff BF0A0000 		movl	$10, %edi
 1044      00
 1045 0904 E8000000 		call	putchar
 1045      00
 253:main.c        ****             if (!flag) {
 1046              		.loc 1 253 0
 1047 0909 0FB68530 		movzbl	-208(%rbp), %eax
 1047      FFFFFF
 1048 0910 84C0     		testb	%al, %al
 1049 0912 752C     		jne	.L43
 254:main.c        ****                 fprintf(stderr, "FPGALink device did not renumerate properly as %s\n", vp);
 1050              		.loc 1 254 0
 1051 0914 488B0500 		movq	stderr(%rip), %rax
 1051      000000
 1052 091b 488B5580 		movq	-128(%rbp), %rdx
 1053 091f BE000000 		movl	$.LC44, %esi
 1053      00
 1054 0924 4889C7   		movq	%rax, %rdi
 1055 0927 B8000000 		movl	$0, %eax
 1055      00
 1056 092c E8000000 		call	fprintf
 1056      00
 255:main.c        ****                 FAIL(FLP_LIBERR, cleanup);
 1057              		.loc 1 255 0
 1058 0931 C785BCFE 		movl	$1, -324(%rbp)
 1058      FFFF0100 
 1058      0000
 1059 093b E9791400 		jmp	.L29
 1059      00
 1060              	.L43:
 256:main.c        ****             }
 257:main.c        **** 
 258:main.c        ****             printf("Attempting to open connection to FPGLink device %s again...\n", vp);
 1061              		.loc 1 258 0
 1062 0940 488B4580 		movq	-128(%rbp), %rax
 1063 0944 4889C6   		movq	%rax, %rsi
 1064 0947 BF000000 		movl	$.LC45, %edi
 1064      00
 1065 094c B8000000 		movl	$0, %eax
 1065      00
 1066 0951 E8000000 		call	printf
 1066      00
 259:main.c        ****             fStatus = flOpen(vp, &handle, &error);
 1067              		.loc 1 259 0
 1068 0956 488D9520 		leaq	-224(%rbp), %rdx
 1068      FFFFFF
 1069 095d 488D8D18 		leaq	-232(%rbp), %rcx
 1069      FFFFFF
 1070 0964 488B4580 		movq	-128(%rbp), %rax
 1071 0968 4889CE   		movq	%rcx, %rsi
 1072 096b 4889C7   		movq	%rax, %rdi
 1073 096e E8000000 		call	flOpen
 1073      00
 1074 0973 8985C0FE 		movl	%eax, -320(%rbp)
 1074      FFFF
 260:main.c        ****             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1075              		.loc 1 260 0
 1076 0979 83BDC0FE 		cmpl	$0, -320(%rbp)
 1076      FFFF00
 1077 0980 7410     		je	.L44
 1078              		.loc 1 260 0 is_stmt 0 discriminator 1
 1079 0982 C785BCFE 		movl	$1, -324(%rbp)
 1079      FFFF0100 
 1079      0000
 1080 098c 90       		nop
 1081 098d E9271400 		jmp	.L29
 1081      00
 1082              	.L44:
 1083              	.LBE5:
 1084 0992 EB2C     		jmp	.L34
 1085              	.L35:
 261:main.c        ****         } else {
 262:main.c        ****             fprintf(stderr, "Could not open FPGALink device at %s and no initial VID:PID was suppli
 1086              		.loc 1 262 0 is_stmt 1
 1087 0994 488B0500 		movq	stderr(%rip), %rax
 1087      000000
 1088 099b 488B5580 		movq	-128(%rbp), %rdx
 1089 099f BE000000 		movl	$.LC46, %esi
 1089      00
 1090 09a4 4889C7   		movq	%rax, %rdi
 1091 09a7 B8000000 		movl	$0, %eax
 1091      00
 1092 09ac E8000000 		call	fprintf
 1092      00
 263:main.c        ****             FAIL(FLP_ARGS, cleanup);
 1093              		.loc 1 263 0
 1094 09b1 C785BCFE 		movl	$12, -324(%rbp)
 1094      FFFF0C00 
 1094      0000
 1095 09bb E9F91300 		jmp	.L29
 1095      00
 1096              	.L34:
 264:main.c        ****         }
 265:main.c        ****     }
 266:main.c        **** 
 267:main.c        ****     printf(
 1097              		.loc 1 267 0
 1098 09c0 488B8518 		movq	-232(%rbp), %rax
 1098      FFFFFF
 1099 09c7 4889C7   		movq	%rax, %rdi
 1100 09ca E8000000 		call	flGetFirmwareVersion
 1100      00
 1101 09cf 89C3     		movl	%eax, %ebx
 268:main.c        ****             "Connected to FPGALink device %s (firmwareID: 0x%04X, firmwareVersion: 0x%08X)\n",
 269:main.c        ****             vp, flGetFirmwareID(handle), flGetFirmwareVersion(handle)
 1102              		.loc 1 269 0
 1103 09d1 488B8518 		movq	-232(%rbp), %rax
 1103      FFFFFF
 1104 09d8 4889C7   		movq	%rax, %rdi
 1105 09db E8000000 		call	flGetFirmwareID
 1105      00
 267:main.c        ****             "Connected to FPGALink device %s (firmwareID: 0x%04X, firmwareVersion: 0x%08X)\n",
 1106              		.loc 1 267 0
 1107 09e0 0FB7D0   		movzwl	%ax, %edx
 1108 09e3 488B4580 		movq	-128(%rbp), %rax
 1109 09e7 89D9     		movl	%ebx, %ecx
 1110 09e9 4889C6   		movq	%rax, %rsi
 1111 09ec BF000000 		movl	$.LC47, %edi
 1111      00
 1112 09f1 B8000000 		movl	$0, %eax
 1112      00
 1113 09f6 E8000000 		call	printf
 1113      00
 270:main.c        ****     );
 271:main.c        **** 
 272:main.c        ****     isCommCapable = flIsCommCapable(handle, conduit);
 1114              		.loc 1 272 0
 1115 09fb 0FB695A1 		movzbl	-351(%rbp), %edx
 1115      FEFFFF
 1116 0a02 488B8518 		movq	-232(%rbp), %rax
 1116      FFFFFF
 1117 0a09 89D6     		movl	%edx, %esi
 1118 0a0b 4889C7   		movq	%rax, %rdi
 1119 0a0e E8000000 		call	flIsCommCapable
 1119      00
 1120 0a13 84C0     		testb	%al, %al
 1121 0a15 0F95C0   		setne	%al
 1122 0a18 8885A2FE 		movb	%al, -350(%rbp)
 1122      FFFF
 273:main.c        **** 
 274:main.c        ****     // -y reads in from csv and initiates the while loop
 275:main.c        ****     if (loopOpt->count > 0) {
 1123              		.loc 1 275 0
 1124 0a1e 488B8550 		movq	-176(%rbp), %rax
 1124      FFFFFF
 1125 0a25 8B4060   		movl	96(%rax), %eax
 1126 0a28 85C0     		testl	%eax, %eax
 1127 0a2a 0F8E8913 		jle	.L29
 1127      0000
 276:main.c        ****         if (isCommCapable) {
 1128              		.loc 1 276 0
 1129 0a30 80BDA2FE 		cmpb	$0, -350(%rbp)
 1129      FFFF00
 1130 0a37 0F845413 		je	.L45
 1130      0000
 1131              	.LBB6:
 277:main.c        ****             uint8 isRunning;
 278:main.c        ****             fStatus = flSelectConduit(handle, conduit, &error);
 1132              		.loc 1 278 0
 1133 0a3d 0FB68DA1 		movzbl	-351(%rbp), %ecx
 1133      FEFFFF
 1134 0a44 488B8518 		movq	-232(%rbp), %rax
 1134      FFFFFF
 1135 0a4b 488D9520 		leaq	-224(%rbp), %rdx
 1135      FFFFFF
 1136 0a52 89CE     		movl	%ecx, %esi
 1137 0a54 4889C7   		movq	%rax, %rdi
 1138 0a57 E8000000 		call	flSelectConduit
 1138      00
 1139 0a5c 8985C0FE 		movl	%eax, -320(%rbp)
 1139      FFFF
 279:main.c        ****             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1140              		.loc 1 279 0
 1141 0a62 83BDC0FE 		cmpl	$0, -320(%rbp)
 1141      FFFF00
 1142 0a69 740F     		je	.L46
 1143              		.loc 1 279 0 is_stmt 0 discriminator 1
 1144 0a6b C785BCFE 		movl	$1, -324(%rbp)
 1144      FFFF0100 
 1144      0000
 1145 0a75 E93F1300 		jmp	.L29
 1145      00
 1146              	.L46:
 280:main.c        ****             fStatus = flIsFPGARunning(handle, &isRunning, &error);
 1147              		.loc 1 280 0 is_stmt 1
 1148 0a7a 488B8518 		movq	-232(%rbp), %rax
 1148      FFFFFF
 1149 0a81 488D9520 		leaq	-224(%rbp), %rdx
 1149      FFFFFF
 1150 0a88 488D8D8F 		leaq	-369(%rbp), %rcx
 1150      FEFFFF
 1151 0a8f 4889CE   		movq	%rcx, %rsi
 1152 0a92 4889C7   		movq	%rax, %rdi
 1153 0a95 E8000000 		call	flIsFPGARunning
 1153      00
 1154 0a9a 8985C0FE 		movl	%eax, -320(%rbp)
 1154      FFFF
 281:main.c        ****             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1155              		.loc 1 281 0
 1156 0aa0 83BDC0FE 		cmpl	$0, -320(%rbp)
 1156      FFFF00
 1157 0aa7 740F     		je	.L48
 1158              		.loc 1 281 0 is_stmt 0 discriminator 1
 1159 0aa9 C785BCFE 		movl	$1, -324(%rbp)
 1159      FFFF0100 
 1159      0000
 1160 0ab3 E9011300 		jmp	.L29
 1160      00
 1161              	.L48:
 282:main.c        ****             if (isRunning) {
 1162              		.loc 1 282 0 is_stmt 1
 1163 0ab8 0FB6858F 		movzbl	-369(%rbp), %eax
 1163      FEFFFF
 1164 0abf 84C0     		testb	%al, %al
 1165 0ac1 0F84A012 		je	.L49
 1165      0000
 1166              	.LBB7:
 283:main.c        **** 
 284:main.c        ****                 FILE *fPtr;
 285:main.c        ****                 fPtr = fopen("SampleBackEndDatabase.csv", "r+"); // change flag according to need
 1167              		.loc 1 285 0
 1168 0ac7 BE000000 		movl	$.LC48, %esi
 1168      00
 1169 0acc BF000000 		movl	$.LC49, %edi
 1169      00
 1170 0ad1 E8000000 		call	fopen
 1170      00
 1171 0ad6 48894590 		movq	%rax, -112(%rbp)
 286:main.c        ****                 if (fPtr == NULL) {
 1172              		.loc 1 286 0
 1173 0ada 48837D90 		cmpq	$0, -112(%rbp)
 1173      00
 1174 0adf 7514     		jne	.L50
 287:main.c        ****                     printf("Csv doesn't exist \n");
 1175              		.loc 1 287 0
 1176 0ae1 BF000000 		movl	$.LC50, %edi
 1176      00
 1177 0ae6 E8000000 		call	puts
 1177      00
 288:main.c        ****                     return 0;
 1178              		.loc 1 288 0
 1179 0aeb B8000000 		movl	$0, %eax
 1179      00
 1180 0af0 E9201300 		jmp	.L170
 1180      00
 1181              	.L50:
 289:main.c        ****                 }
 290:main.c        ****                 size_t lineSize = 100;
 1182              		.loc 1 290 0
 1183 0af5 48C78528 		movq	$100, -216(%rbp)
 1183      FFFFFF64 
 1183      000000
 291:main.c        ****                 char *lineFromFile = malloc(lineSize * sizeof(char));
 1184              		.loc 1 291 0
 1185 0b00 488B8528 		movq	-216(%rbp), %rax
 1185      FFFFFF
 1186 0b07 4889C7   		movq	%rax, %rdi
 1187 0b0a E8000000 		call	malloc
 1187      00
 1188 0b0f 48898530 		movq	%rax, -208(%rbp)
 1188      FFFFFF
 292:main.c        **** 
 293:main.c        ****                 while ((getline(&lineFromFile, &lineSize, fPtr)) != -1) {
 1189              		.loc 1 293 0
 1190 0b16 EB28     		jmp	.L52
 1191              	.L54:
 294:main.c        ****                     if (numLines != 0) format(lineFromFile);
 1192              		.loc 1 294 0
 1193 0b18 8B050000 		movl	numLines(%rip), %eax
 1193      0000
 1194 0b1e 85C0     		testl	%eax, %eax
 1195 0b20 740F     		je	.L53
 1196              		.loc 1 294 0 is_stmt 0 discriminator 1
 1197 0b22 488B8530 		movq	-208(%rbp), %rax
 1197      FFFFFF
 1198 0b29 4889C7   		movq	%rax, %rdi
 1199 0b2c E8000000 		call	format
 1199      00
 1200              	.L53:
 295:main.c        ****                     numLines++;
 1201              		.loc 1 295 0 is_stmt 1
 1202 0b31 8B050000 		movl	numLines(%rip), %eax
 1202      0000
 1203 0b37 83C001   		addl	$1, %eax
 1204 0b3a 89050000 		movl	%eax, numLines(%rip)
 1204      0000
 1205              	.L52:
 293:main.c        ****                     if (numLines != 0) format(lineFromFile);
 1206              		.loc 1 293 0 discriminator 1
 1207 0b40 488B5590 		movq	-112(%rbp), %rdx
 1208 0b44 488D8D28 		leaq	-216(%rbp), %rcx
 1208      FFFFFF
 1209 0b4b 488D8530 		leaq	-208(%rbp), %rax
 1209      FFFFFF
 1210 0b52 4889CE   		movq	%rcx, %rsi
 1211 0b55 4889C7   		movq	%rax, %rdi
 1212 0b58 E8000000 		call	getline
 1212      00
 1213 0b5d 4883F8FF 		cmpq	$-1, %rax
 1214 0b61 75B5     		jne	.L54
 296:main.c        ****                 }
 297:main.c        ****                 numLines--;
 1215              		.loc 1 297 0
 1216 0b63 8B050000 		movl	numLines(%rip), %eax
 1216      0000
 1217 0b69 83E801   		subl	$1, %eax
 1218 0b6c 89050000 		movl	%eax, numLines(%rip)
 1218      0000
 298:main.c        ****                 free(lineFromFile);
 1219              		.loc 1 298 0
 1220 0b72 488B8530 		movq	-208(%rbp), %rax
 1220      FFFFFF
 1221 0b79 4889C7   		movq	%rax, %rdi
 1222 0b7c E8000000 		call	free
 1222      00
 299:main.c        ****                 fclose(fPtr);
 1223              		.loc 1 299 0
 1224 0b81 488B4590 		movq	-112(%rbp), %rax
 1225 0b85 4889C7   		movq	%rax, %rdi
 1226 0b88 E8000000 		call	fclose
 1226      00
 1227              	.L168:
 1228              	.LBB8:
 300:main.c        **** 
 301:main.c        ****                 while (true) {
 302:main.c        ****                     uint32_t length = 1;
 1229              		.loc 1 302 0
 1230 0b8d C785F4FE 		movl	$1, -268(%rbp)
 1230      FFFF0100 
 1230      0000
 303:main.c        ****                     uint8_t *readFromChannelZero = malloc(sizeof(uint8_t));
 1231              		.loc 1 303 0
 1232 0b97 BF010000 		movl	$1, %edi
 1232      00
 1233 0b9c E8000000 		call	malloc
 1233      00
 1234 0ba1 48894598 		movq	%rax, -104(%rbp)
 304:main.c        **** 
 305:main.c        ****                     fStatus = flReadChannel(handle, (uint8_t) 0, length, readFromChannelZero, &erro
 1235              		.loc 1 305 0
 1236 0ba5 8B95F4FE 		movl	-268(%rbp), %edx
 1236      FFFF
 1237 0bab 488B8518 		movq	-232(%rbp), %rax
 1237      FFFFFF
 1238 0bb2 488DB520 		leaq	-224(%rbp), %rsi
 1238      FFFFFF
 1239 0bb9 488B4D98 		movq	-104(%rbp), %rcx
 1240 0bbd 4989F0   		movq	%rsi, %r8
 1241 0bc0 BE000000 		movl	$0, %esi
 1241      00
 1242 0bc5 4889C7   		movq	%rax, %rdi
 1243 0bc8 E8000000 		call	flReadChannel
 1243      00
 1244 0bcd 8985C0FE 		movl	%eax, -320(%rbp)
 1244      FFFF
 306:main.c        ****                     CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1245              		.loc 1 306 0
 1246 0bd3 83BDC0FE 		cmpl	$0, -320(%rbp)
 1246      FFFF00
 1247 0bda 740F     		je	.L55
 1248              		.loc 1 306 0 is_stmt 0 discriminator 1
 1249 0bdc C785BCFE 		movl	$1, -324(%rbp)
 1249      FFFF0100 
 1249      0000
 1250 0be6 E97A1100 		jmp	.L56
 1250      00
 1251              	.L55:
 307:main.c        ****                     if (LOG) printf("Read from channel 0 = %u \n", *readFromChannelZero);
 1252              		.loc 1 307 0 is_stmt 1
 1253 0beb 0FB60500 		movzbl	LOG(%rip), %eax
 1253      000000
 1254 0bf2 84C0     		testb	%al, %al
 1255 0bf4 741B     		je	.L57
 1256              		.loc 1 307 0 is_stmt 0 discriminator 1
 1257 0bf6 488B4598 		movq	-104(%rbp), %rax
 1258 0bfa 0FB600   		movzbl	(%rax), %eax
 1259 0bfd 0FB6C0   		movzbl	%al, %eax
 1260 0c00 89C6     		movl	%eax, %esi
 1261 0c02 BF000000 		movl	$.LC51, %edi
 1261      00
 1262 0c07 B8000000 		movl	$0, %eax
 1262      00
 1263 0c0c E8000000 		call	printf
 1263      00
 1264              	.L57:
 308:main.c        **** 
 309:main.c        ****                     if (((*readFromChannelZero) == 1) || ((*readFromChannelZero) == 2)) {
 1265              		.loc 1 309 0 is_stmt 1
 1266 0c11 488B4598 		movq	-104(%rbp), %rax
 1267 0c15 0FB600   		movzbl	(%rax), %eax
 1268 0c18 3C01     		cmpb	$1, %al
 1269 0c1a 740F     		je	.L58
 1270              		.loc 1 309 0 is_stmt 0 discriminator 1
 1271 0c1c 488B4598 		movq	-104(%rbp), %rax
 1272 0c20 0FB600   		movzbl	(%rax), %eax
 1273 0c23 3C02     		cmpb	$2, %al
 1274 0c25 0F852B11 		jne	.L59
 1274      0000
 1275              	.L58:
 1276              	.LBB9:
 310:main.c        ****                         uint8_t cnt = 1, valRead = *readFromChannelZero;
 1277              		.loc 1 310 0 is_stmt 1
 1278 0c2b C68592FE 		movb	$1, -366(%rbp)
 1278      FFFF01
 1279 0c32 488B4598 		movq	-104(%rbp), %rax
 1280 0c36 0FB600   		movzbl	(%rax), %eax
 1281 0c39 8885A3FE 		movb	%al, -349(%rbp)
 1281      FFFF
 311:main.c        ****                         bool cont = true;
 1282              		.loc 1 311 0
 1283 0c3f C68593FE 		movb	$1, -365(%rbp)
 1283      FFFF01
 312:main.c        ****                         while (cnt < 3) {
 1284              		.loc 1 312 0
 1285 0c46 E9A00000 		jmp	.L60
 1285      00
 1286              	.L65:
 313:main.c        **** 
 314:main.c        ****                             flSleep(1000);
 1287              		.loc 1 314 0
 1288 0c4b BFE80300 		movl	$1000, %edi
 1288      00
 1289 0c50 E8000000 		call	flSleep
 1289      00
 315:main.c        ****                             fStatus = flReadChannel(handle, 0, length, readFromChannelZero, &error)
 1290              		.loc 1 315 0
 1291 0c55 8B95F4FE 		movl	-268(%rbp), %edx
 1291      FFFF
 1292 0c5b 488B8518 		movq	-232(%rbp), %rax
 1292      FFFFFF
 1293 0c62 488DB520 		leaq	-224(%rbp), %rsi
 1293      FFFFFF
 1294 0c69 488B4D98 		movq	-104(%rbp), %rcx
 1295 0c6d 4989F0   		movq	%rsi, %r8
 1296 0c70 BE000000 		movl	$0, %esi
 1296      00
 1297 0c75 4889C7   		movq	%rax, %rdi
 1298 0c78 E8000000 		call	flReadChannel
 1298      00
 1299 0c7d 8985C0FE 		movl	%eax, -320(%rbp)
 1299      FFFF
 316:main.c        ****                             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1300              		.loc 1 316 0
 1301 0c83 83BDC0FE 		cmpl	$0, -320(%rbp)
 1301      FFFF00
 1302 0c8a 740F     		je	.L61
 1303              		.loc 1 316 0 is_stmt 0 discriminator 1
 1304 0c8c C785BCFE 		movl	$1, -324(%rbp)
 1304      FFFF0100 
 1304      0000
 1305 0c96 E9CA1000 		jmp	.L56
 1305      00
 1306              	.L61:
 317:main.c        ****                             if (LOG) printf("Read from channel 0 = %u \n", *readFromChannelZero);
 1307              		.loc 1 317 0 is_stmt 1
 1308 0c9b 0FB60500 		movzbl	LOG(%rip), %eax
 1308      000000
 1309 0ca2 84C0     		testb	%al, %al
 1310 0ca4 741B     		je	.L62
 1311              		.loc 1 317 0 is_stmt 0 discriminator 1
 1312 0ca6 488B4598 		movq	-104(%rbp), %rax
 1313 0caa 0FB600   		movzbl	(%rax), %eax
 1314 0cad 0FB6C0   		movzbl	%al, %eax
 1315 0cb0 89C6     		movl	%eax, %esi
 1316 0cb2 BF000000 		movl	$.LC51, %edi
 1316      00
 1317 0cb7 B8000000 		movl	$0, %eax
 1317      00
 1318 0cbc E8000000 		call	printf
 1318      00
 1319              	.L62:
 318:main.c        **** 
 319:main.c        ****                             if (*readFromChannelZero == valRead) cnt++;
 1320              		.loc 1 319 0 is_stmt 1
 1321 0cc1 488B4598 		movq	-104(%rbp), %rax
 1322 0cc5 0FB600   		movzbl	(%rax), %eax
 1323 0cc8 3A85A3FE 		cmpb	-349(%rbp), %al
 1323      FFFF
 1324 0cce 7512     		jne	.L63
 1325              		.loc 1 319 0 is_stmt 0 discriminator 1
 1326 0cd0 0FB68592 		movzbl	-366(%rbp), %eax
 1326      FEFFFF
 1327 0cd7 83C001   		addl	$1, %eax
 1328 0cda 888592FE 		movb	%al, -366(%rbp)
 1328      FFFF
 1329 0ce0 EB09     		jmp	.L60
 1330              	.L63:
 320:main.c        ****                             else {
 321:main.c        ****                                 cont = false;
 1331              		.loc 1 321 0 is_stmt 1
 1332 0ce2 C68593FE 		movb	$0, -365(%rbp)
 1332      FFFF00
 322:main.c        ****                                 break;
 1333              		.loc 1 322 0
 1334 0ce9 EB0D     		jmp	.L64
 1335              	.L60:
 312:main.c        **** 
 1336              		.loc 1 312 0 discriminator 1
 1337 0ceb 80BD92FE 		cmpb	$2, -366(%rbp)
 1337      FFFF02
 1338 0cf2 0F8653FF 		jbe	.L65
 1338      FFFF
 1339              	.L64:
 323:main.c        ****                             }
 324:main.c        ****                         }
 325:main.c        ****                         if (cont) {
 1340              		.loc 1 325 0
 1341 0cf8 80BD93FE 		cmpb	$0, -365(%rbp)
 1341      FFFF00
 1342 0cff 0F845110 		je	.L59
 1342      0000
 1343              	.LBB10:
 1344              	.LBB11:
 326:main.c        ****                             uint32_t inpFromFrontEnd[2];
 327:main.c        ****                             for (int i = 0; i < 2; i++) inpFromFrontEnd[i] = 0;
 1345              		.loc 1 327 0
 1346 0d05 C785C8FE 		movl	$0, -312(%rbp)
 1346      FFFF0000 
 1346      0000
 1347 0d0f EB1A     		jmp	.L66
 1348              	.L67:
 1349              		.loc 1 327 0 is_stmt 0 discriminator 2
 1350 0d11 8B85C8FE 		movl	-312(%rbp), %eax
 1350      FFFF
 1351 0d17 4898     		cltq
 1352 0d19 C7848500 		movl	$0, -256(%rbp,%rax,4)
 1352      FFFFFF00 
 1352      000000
 1353 0d24 8385C8FE 		addl	$1, -312(%rbp)
 1353      FFFF01
 1354              	.L66:
 1355              		.loc 1 327 0 discriminator 1
 1356 0d2b 83BDC8FE 		cmpl	$1, -312(%rbp)
 1356      FFFF01
 1357 0d32 7EDD     		jle	.L67
 1358              	.LBE11:
 1359              	.LBB12:
 328:main.c        ****                             for (uint32_t i = 1; i <= 8; i++) {
 1360              		.loc 1 328 0 is_stmt 1
 1361 0d34 C785CCFE 		movl	$1, -308(%rbp)
 1361      FFFF0100 
 1361      0000
 1362 0d3e E9100100 		jmp	.L68
 1362      00
 1363              	.L74:
 1364              	.LBB13:
 329:main.c        ****                                 uint8_t *readFromChannel_i = malloc(sizeof(uint8_t));
 1365              		.loc 1 329 0
 1366 0d43 BF010000 		movl	$1, %edi
 1366      00
 1367 0d48 E8000000 		call	malloc
 1367      00
 1368 0d4d 488945A0 		movq	%rax, -96(%rbp)
 330:main.c        **** 
 331:main.c        ****                                 flSleep(1000);
 1369              		.loc 1 331 0
 1370 0d51 BFE80300 		movl	$1000, %edi
 1370      00
 1371 0d56 E8000000 		call	flSleep
 1371      00
 332:main.c        ****                                 fStatus = flReadChannel(handle, (uint8_t) i, length, readFromChanne
 1372              		.loc 1 332 0
 1373 0d5b 8B95F4FE 		movl	-268(%rbp), %edx
 1373      FFFF
 1374 0d61 8B85CCFE 		movl	-308(%rbp), %eax
 1374      FFFF
 1375 0d67 0FB6F0   		movzbl	%al, %esi
 1376 0d6a 488B8518 		movq	-232(%rbp), %rax
 1376      FFFFFF
 1377 0d71 488DBD20 		leaq	-224(%rbp), %rdi
 1377      FFFFFF
 1378 0d78 488B4DA0 		movq	-96(%rbp), %rcx
 1379 0d7c 4989F8   		movq	%rdi, %r8
 1380 0d7f 4889C7   		movq	%rax, %rdi
 1381 0d82 E8000000 		call	flReadChannel
 1381      00
 1382 0d87 8985C0FE 		movl	%eax, -320(%rbp)
 1382      FFFF
 333:main.c        ****                                 CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1383              		.loc 1 333 0
 1384 0d8d 83BDC0FE 		cmpl	$0, -320(%rbp)
 1384      FFFF00
 1385 0d94 740F     		je	.L69
 1386              		.loc 1 333 0 is_stmt 0 discriminator 1
 1387 0d96 C785BCFE 		movl	$1, -324(%rbp)
 1387      FFFF0100 
 1387      0000
 1388 0da0 E9AF0F00 		jmp	.L70
 1388      00
 1389              	.L69:
 334:main.c        ****                                 if (LOG) printf("Read from channel %u = %u \n", i, *readFromChannel
 1390              		.loc 1 334 0 is_stmt 1
 1391 0da5 0FB60500 		movzbl	LOG(%rip), %eax
 1391      000000
 1392 0dac 84C0     		testb	%al, %al
 1393 0dae 7421     		je	.L71
 1394              		.loc 1 334 0 is_stmt 0 discriminator 1
 1395 0db0 488B45A0 		movq	-96(%rbp), %rax
 1396 0db4 0FB600   		movzbl	(%rax), %eax
 1397 0db7 0FB6D0   		movzbl	%al, %edx
 1398 0dba 8B85CCFE 		movl	-308(%rbp), %eax
 1398      FFFF
 1399 0dc0 89C6     		movl	%eax, %esi
 1400 0dc2 BF000000 		movl	$.LC52, %edi
 1400      00
 1401 0dc7 B8000000 		movl	$0, %eax
 1401      00
 1402 0dcc E8000000 		call	printf
 1402      00
 1403              	.L71:
 335:main.c        ****                                 uint32_t temp1 = 8 * (i - 1), temp2 = 8 * (i - 5);
 1404              		.loc 1 335 0 is_stmt 1
 1405 0dd1 8B85CCFE 		movl	-308(%rbp), %eax
 1405      FFFF
 1406 0dd7 05FFFFFF 		addl	$536870911, %eax
 1406      1F
 1407 0ddc C1E003   		sall	$3, %eax
 1408 0ddf 8985F8FE 		movl	%eax, -264(%rbp)
 1408      FFFF
 1409 0de5 8B85CCFE 		movl	-308(%rbp), %eax
 1409      FFFF
 1410 0deb 05FBFFFF 		addl	$536870907, %eax
 1410      1F
 1411 0df0 C1E003   		sall	$3, %eax
 1412 0df3 8985FCFE 		movl	%eax, -260(%rbp)
 1412      FFFF
 336:main.c        ****                                 if (i <= 4) inpFromFrontEnd[0] += (*readFromChannel_i) * (1 << temp
 1413              		.loc 1 336 0
 1414 0df9 83BDCCFE 		cmpl	$4, -308(%rbp)
 1414      FFFF04
 1415 0e00 7726     		ja	.L72
 1416              		.loc 1 336 0 is_stmt 0 discriminator 1
 1417 0e02 8B9500FF 		movl	-256(%rbp), %edx
 1417      FFFF
 1418 0e08 488B45A0 		movq	-96(%rbp), %rax
 1419 0e0c 0FB600   		movzbl	(%rax), %eax
 1420 0e0f 0FB6F0   		movzbl	%al, %esi
 1421 0e12 8B85F8FE 		movl	-264(%rbp), %eax
 1421      FFFF
 1422 0e18 89C1     		movl	%eax, %ecx
 1423 0e1a D3E6     		sall	%cl, %esi
 1424 0e1c 89F0     		movl	%esi, %eax
 1425 0e1e 01D0     		addl	%edx, %eax
 1426 0e20 898500FF 		movl	%eax, -256(%rbp)
 1426      FFFF
 1427 0e26 EB24     		jmp	.L73
 1428              	.L72:
 337:main.c        ****                                 else inpFromFrontEnd[1] += (*readFromChannel_i) * (1 << temp2);
 1429              		.loc 1 337 0 is_stmt 1
 1430 0e28 8B9504FF 		movl	-252(%rbp), %edx
 1430      FFFF
 1431 0e2e 488B45A0 		movq	-96(%rbp), %rax
 1432 0e32 0FB600   		movzbl	(%rax), %eax
 1433 0e35 0FB6F0   		movzbl	%al, %esi
 1434 0e38 8B85FCFE 		movl	-260(%rbp), %eax
 1434      FFFF
 1435 0e3e 89C1     		movl	%eax, %ecx
 1436 0e40 D3E6     		sall	%cl, %esi
 1437 0e42 89F0     		movl	%esi, %eax
 1438 0e44 01D0     		addl	%edx, %eax
 1439 0e46 898504FF 		movl	%eax, -252(%rbp)
 1439      FFFF
 1440              	.L73:
 1441              	.LBE13:
 328:main.c        ****                                 uint8_t *readFromChannel_i = malloc(sizeof(uint8_t));
 1442              		.loc 1 328 0
 1443 0e4c 8385CCFE 		addl	$1, -308(%rbp)
 1443      FFFF01
 1444              	.L68:
 328:main.c        ****                                 uint8_t *readFromChannel_i = malloc(sizeof(uint8_t));
 1445              		.loc 1 328 0 is_stmt 0 discriminator 1
 1446 0e53 83BDCCFE 		cmpl	$8, -308(%rbp)
 1446      FFFF08
 1447 0e5a 0F86E3FE 		jbe	.L74
 1447      FFFF
 1448              	.LBE12:
 338:main.c        ****                             }
 339:main.c        ****                             decrypt64(inpFromFrontEnd);
 1449              		.loc 1 339 0 is_stmt 1
 1450 0e60 488D8500 		leaq	-256(%rbp), %rax
 1450      FFFFFF
 1451 0e67 4889C7   		movq	%rax, %rdi
 1452 0e6a E8000000 		call	decrypt64
 1452      00
 340:main.c        ****                             uint8_t num_100 = 0, num_500 = 0, num_1000 = 0, num_2000 = 0;
 1453              		.loc 1 340 0
 1454 0e6f C68594FE 		movb	$0, -364(%rbp)
 1454      FFFF00
 1455 0e76 C68595FE 		movb	$0, -363(%rbp)
 1455      FFFF00
 1456 0e7d C68596FE 		movb	$0, -362(%rbp)
 1456      FFFF00
 1457 0e84 C68597FE 		movb	$0, -361(%rbp)
 1457      FFFF00
 341:main.c        ****                             uint16_t userID = 0, unhashedPin = 0;
 1458              		.loc 1 341 0
 1459 0e8b 66C785A8 		movw	$0, -344(%rbp)
 1459      FEFFFF00 
 1459      00
 1460 0e94 66C785AA 		movw	$0, -342(%rbp)
 1460      FEFFFF00 
 1460      00
 1461              	.LBB14:
 342:main.c        ****                             for (uint8_t i = 1; i <= 32; i++) {
 1462              		.loc 1 342 0
 1463 0e9d C68598FE 		movb	$1, -360(%rbp)
 1463      FFFF01
 1464 0ea4 E92F0100 		jmp	.L75
 1464      00
 1465              	.L83:
 343:main.c        ****                                 if (i <= 8) {
 1466              		.loc 1 343 0
 1467 0ea9 80BD98FE 		cmpb	$8, -360(%rbp)
 1467      FFFF08
 1468 0eb0 7745     		ja	.L76
 344:main.c        ****                                     if ((inpFromFrontEnd[0] & (1 << (i - 1))) != 0) num_100 += ((1 
 1469              		.loc 1 344 0
 1470 0eb2 8B9500FF 		movl	-256(%rbp), %edx
 1470      FFFF
 1471 0eb8 0FB68598 		movzbl	-360(%rbp), %eax
 1471      FEFFFF
 1472 0ebf 83E801   		subl	$1, %eax
 1473 0ec2 BE010000 		movl	$1, %esi
 1473      00
 1474 0ec7 89C1     		movl	%eax, %ecx
 1475 0ec9 D3E6     		sall	%cl, %esi
 1476 0ecb 89F0     		movl	%esi, %eax
 1477 0ecd 21D0     		andl	%edx, %eax
 1478 0ecf 85C0     		testl	%eax, %eax
 1479 0ed1 0F84F100 		je	.L78
 1479      0000
 1480              		.loc 1 344 0 is_stmt 0 discriminator 1
 1481 0ed7 0FB68598 		movzbl	-360(%rbp), %eax
 1481      FEFFFF
 1482 0ede 83E801   		subl	$1, %eax
 1483 0ee1 BA010000 		movl	$1, %edx
 1483      00
 1484 0ee6 89C1     		movl	%eax, %ecx
 1485 0ee8 D3E2     		sall	%cl, %edx
 1486 0eea 89D0     		movl	%edx, %eax
 1487 0eec 008594FE 		addb	%al, -364(%rbp)
 1487      FFFF
 1488 0ef2 E9D10000 		jmp	.L78
 1488      00
 1489              	.L76:
 345:main.c        ****                                 } else if (i <= 16) {
 1490              		.loc 1 345 0 is_stmt 1
 1491 0ef7 80BD98FE 		cmpb	$16, -360(%rbp)
 1491      FFFF10
 1492 0efe 7745     		ja	.L79
 346:main.c        ****                                     if ((inpFromFrontEnd[0] & (1 << (i - 1))) != 0) num_500 += ((1 
 1493              		.loc 1 346 0
 1494 0f00 8B9500FF 		movl	-256(%rbp), %edx
 1494      FFFF
 1495 0f06 0FB68598 		movzbl	-360(%rbp), %eax
 1495      FEFFFF
 1496 0f0d 83E801   		subl	$1, %eax
 1497 0f10 BE010000 		movl	$1, %esi
 1497      00
 1498 0f15 89C1     		movl	%eax, %ecx
 1499 0f17 D3E6     		sall	%cl, %esi
 1500 0f19 89F0     		movl	%esi, %eax
 1501 0f1b 21D0     		andl	%edx, %eax
 1502 0f1d 85C0     		testl	%eax, %eax
 1503 0f1f 0F84A300 		je	.L78
 1503      0000
 1504              		.loc 1 346 0 is_stmt 0 discriminator 1
 1505 0f25 0FB68598 		movzbl	-360(%rbp), %eax
 1505      FEFFFF
 1506 0f2c 83E809   		subl	$9, %eax
 1507 0f2f BA010000 		movl	$1, %edx
 1507      00
 1508 0f34 89C1     		movl	%eax, %ecx
 1509 0f36 D3E2     		sall	%cl, %edx
 1510 0f38 89D0     		movl	%edx, %eax
 1511 0f3a 008595FE 		addb	%al, -363(%rbp)
 1511      FFFF
 1512 0f40 E9830000 		jmp	.L78
 1512      00
 1513              	.L79:
 347:main.c        ****                                 } else if (i <= 24) {
 1514              		.loc 1 347 0 is_stmt 1
 1515 0f45 80BD98FE 		cmpb	$24, -360(%rbp)
 1515      FFFF18
 1516 0f4c 773E     		ja	.L81
 348:main.c        ****                                     if ((inpFromFrontEnd[0] & (1 << (i - 1))) != 0) num_1000 += ((1
 1517              		.loc 1 348 0
 1518 0f4e 8B9500FF 		movl	-256(%rbp), %edx
 1518      FFFF
 1519 0f54 0FB68598 		movzbl	-360(%rbp), %eax
 1519      FEFFFF
 1520 0f5b 83E801   		subl	$1, %eax
 1521 0f5e BE010000 		movl	$1, %esi
 1521      00
 1522 0f63 89C1     		movl	%eax, %ecx
 1523 0f65 D3E6     		sall	%cl, %esi
 1524 0f67 89F0     		movl	%esi, %eax
 1525 0f69 21D0     		andl	%edx, %eax
 1526 0f6b 85C0     		testl	%eax, %eax
 1527 0f6d 7459     		je	.L78
 1528              		.loc 1 348 0 is_stmt 0 discriminator 1
 1529 0f6f 0FB68598 		movzbl	-360(%rbp), %eax
 1529      FEFFFF
 1530 0f76 83E811   		subl	$17, %eax
 1531 0f79 BA010000 		movl	$1, %edx
 1531      00
 1532 0f7e 89C1     		movl	%eax, %ecx
 1533 0f80 D3E2     		sall	%cl, %edx
 1534 0f82 89D0     		movl	%edx, %eax
 1535 0f84 008596FE 		addb	%al, -362(%rbp)
 1535      FFFF
 1536 0f8a EB3C     		jmp	.L78
 1537              	.L81:
 349:main.c        ****                                 } else {
 350:main.c        ****                                     if ((inpFromFrontEnd[0] & (1 << (i - 1))) != 0) num_2000 += ((1
 1538              		.loc 1 350 0 is_stmt 1
 1539 0f8c 8B9500FF 		movl	-256(%rbp), %edx
 1539      FFFF
 1540 0f92 0FB68598 		movzbl	-360(%rbp), %eax
 1540      FEFFFF
 1541 0f99 83E801   		subl	$1, %eax
 1542 0f9c BE010000 		movl	$1, %esi
 1542      00
 1543 0fa1 89C1     		movl	%eax, %ecx
 1544 0fa3 D3E6     		sall	%cl, %esi
 1545 0fa5 89F0     		movl	%esi, %eax
 1546 0fa7 21D0     		andl	%edx, %eax
 1547 0fa9 85C0     		testl	%eax, %eax
 1548 0fab 741B     		je	.L78
 1549              		.loc 1 350 0 is_stmt 0 discriminator 1
 1550 0fad 0FB68598 		movzbl	-360(%rbp), %eax
 1550      FEFFFF
 1551 0fb4 83E819   		subl	$25, %eax
 1552 0fb7 BA010000 		movl	$1, %edx
 1552      00
 1553 0fbc 89C1     		movl	%eax, %ecx
 1554 0fbe D3E2     		sall	%cl, %edx
 1555 0fc0 89D0     		movl	%edx, %eax
 1556 0fc2 008597FE 		addb	%al, -361(%rbp)
 1556      FFFF
 1557              	.L78:
 342:main.c        ****                                 if (i <= 8) {
 1558              		.loc 1 342 0 is_stmt 1
 1559 0fc8 0FB68598 		movzbl	-360(%rbp), %eax
 1559      FEFFFF
 1560 0fcf 83C001   		addl	$1, %eax
 1561 0fd2 888598FE 		movb	%al, -360(%rbp)
 1561      FFFF
 1562              	.L75:
 342:main.c        ****                                 if (i <= 8) {
 1563              		.loc 1 342 0 is_stmt 0 discriminator 1
 1564 0fd8 80BD98FE 		cmpb	$32, -360(%rbp)
 1564      FFFF20
 1565 0fdf 0F86C4FE 		jbe	.L83
 1565      FFFF
 1566              	.LBE14:
 1567              	.LBB15:
 351:main.c        ****                                 }
 352:main.c        ****                             }
 353:main.c        ****                             for (uint16_t i = 1; i <= 32; i++) {
 1568              		.loc 1 353 0 is_stmt 1
 1569 0fe5 66C785AC 		movw	$1, -340(%rbp)
 1569      FEFFFF01 
 1569      00
 1570 0fee E9970000 		jmp	.L84
 1570      00
 1571              	.L88:
 354:main.c        ****                                 if (i <= 16) {
 1572              		.loc 1 354 0
 1573 0ff3 6683BDAC 		cmpw	$16, -340(%rbp)
 1573      FEFFFF10 
 1574 0ffb 773F     		ja	.L85
 355:main.c        ****                                     if ((inpFromFrontEnd[1] & (1 << (i - 1))) != 0) unhashedPin += 
 1575              		.loc 1 355 0
 1576 0ffd 8B9504FF 		movl	-252(%rbp), %edx
 1576      FFFF
 1577 1003 0FB785AC 		movzwl	-340(%rbp), %eax
 1577      FEFFFF
 1578 100a 83E801   		subl	$1, %eax
 1579 100d BE010000 		movl	$1, %esi
 1579      00
 1580 1012 89C1     		movl	%eax, %ecx
 1581 1014 D3E6     		sall	%cl, %esi
 1582 1016 89F0     		movl	%esi, %eax
 1583 1018 21D0     		andl	%edx, %eax
 1584 101a 85C0     		testl	%eax, %eax
 1585 101c 745B     		je	.L87
 1586              		.loc 1 355 0 is_stmt 0 discriminator 1
 1587 101e 0FB785AC 		movzwl	-340(%rbp), %eax
 1587      FEFFFF
 1588 1025 83E801   		subl	$1, %eax
 1589 1028 BA010000 		movl	$1, %edx
 1589      00
 1590 102d 89C1     		movl	%eax, %ecx
 1591 102f D3E2     		sall	%cl, %edx
 1592 1031 89D0     		movl	%edx, %eax
 1593 1033 660185AA 		addw	%ax, -342(%rbp)
 1593      FEFFFF
 1594 103a EB3D     		jmp	.L87
 1595              	.L85:
 356:main.c        ****                                 } else {
 357:main.c        ****                                     if ((inpFromFrontEnd[1] & (1 << (i - 1))) != 0) userID += ((1 <
 1596              		.loc 1 357 0 is_stmt 1
 1597 103c 8B9504FF 		movl	-252(%rbp), %edx
 1597      FFFF
 1598 1042 0FB785AC 		movzwl	-340(%rbp), %eax
 1598      FEFFFF
 1599 1049 83E801   		subl	$1, %eax
 1600 104c BE010000 		movl	$1, %esi
 1600      00
 1601 1051 89C1     		movl	%eax, %ecx
 1602 1053 D3E6     		sall	%cl, %esi
 1603 1055 89F0     		movl	%esi, %eax
 1604 1057 21D0     		andl	%edx, %eax
 1605 1059 85C0     		testl	%eax, %eax
 1606 105b 741C     		je	.L87
 1607              		.loc 1 357 0 is_stmt 0 discriminator 1
 1608 105d 0FB785AC 		movzwl	-340(%rbp), %eax
 1608      FEFFFF
 1609 1064 83E811   		subl	$17, %eax
 1610 1067 BA010000 		movl	$1, %edx
 1610      00
 1611 106c 89C1     		movl	%eax, %ecx
 1612 106e D3E2     		sall	%cl, %edx
 1613 1070 89D0     		movl	%edx, %eax
 1614 1072 660185A8 		addw	%ax, -344(%rbp)
 1614      FEFFFF
 1615              	.L87:
 353:main.c        ****                                 if (i <= 16) {
 1616              		.loc 1 353 0 is_stmt 1
 1617 1079 0FB785AC 		movzwl	-340(%rbp), %eax
 1617      FEFFFF
 1618 1080 83C001   		addl	$1, %eax
 1619 1083 668985AC 		movw	%ax, -340(%rbp)
 1619      FEFFFF
 1620              	.L84:
 353:main.c        ****                                 if (i <= 16) {
 1621              		.loc 1 353 0 is_stmt 0 discriminator 1
 1622 108a 6683BDAC 		cmpw	$32, -340(%rbp)
 1622      FEFFFF20 
 1623 1092 0F865BFF 		jbe	.L88
 1623      FFFF
 1624              	.LBE15:
 358:main.c        ****                                 }
 359:main.c        ****                             }
 360:main.c        **** //                            printf("unhashedPin %u\n", unhashedPin);
 361:main.c        **** //                            printf("userID %u\n", userID);
 362:main.c        ****                             uint16_t hashedPin = myHash(unhashedPin);
 1625              		.loc 1 362 0 is_stmt 1
 1626 1098 0FB785AA 		movzwl	-342(%rbp), %eax
 1626      FEFFFF
 1627 109f 89C7     		movl	%eax, %edi
 1628 10a1 E8000000 		call	myHash
 1628      00
 1629 10a6 668985AE 		movw	%ax, -338(%rbp)
 1629      FEFFFF
 363:main.c        **** //                            printf("hashedPin %u\n", hashedPin);
 364:main.c        **** //                            printf("num_2000 %u\n", num_2000);
 365:main.c        **** //                            printf("num_1000 %u\n", num_1000);
 366:main.c        **** //                            printf("num_500 %u\n", num_500);
 367:main.c        **** //                            printf("num_100 %u\n", num_100);
 368:main.c        **** 
 369:main.c        ****                             int bal = -1;
 1630              		.loc 1 369 0
 1631 10ad C785B0FE 		movl	$-1, -336(%rbp)
 1631      FFFFFFFF 
 1631      FFFF
 370:main.c        ****                             bool isAdmin = false;
 1632              		.loc 1 370 0
 1633 10b7 C68590FE 		movb	$0, -368(%rbp)
 1633      FFFF00
 371:main.c        ****                             int inLineNum = -1;
 1634              		.loc 1 371 0
 1635 10be C785B4FE 		movl	$-1, -332(%rbp)
 1635      FFFFFFFF 
 1635      FFFF
 372:main.c        ****                             uint8_t *statusOnChan9 = malloc(sizeof(uint8_t));
 1636              		.loc 1 372 0
 1637 10c8 BF010000 		movl	$1, %edi
 1637      00
 1638 10cd E8000000 		call	malloc
 1638      00
 1639 10d2 488945A8 		movq	%rax, -88(%rbp)
 373:main.c        ****                             if (find(userID, hashedPin, &isAdmin, &bal, &inLineNum)) {
 1640              		.loc 1 373 0
 1641 10d6 0FB7B5AE 		movzwl	-338(%rbp), %esi
 1641      FEFFFF
 1642 10dd 0FB785A8 		movzwl	-344(%rbp), %eax
 1642      FEFFFF
 1643 10e4 488DBDB4 		leaq	-332(%rbp), %rdi
 1643      FEFFFF
 1644 10eb 488D8DB0 		leaq	-336(%rbp), %rcx
 1644      FEFFFF
 1645 10f2 488D9590 		leaq	-368(%rbp), %rdx
 1645      FEFFFF
 1646 10f9 4989F8   		movq	%rdi, %r8
 1647 10fc 89C7     		movl	%eax, %edi
 1648 10fe E8000000 		call	find
 1648      00
 1649 1103 84C0     		testb	%al, %al
 1650 1105 0F84110B 		je	.L89
 1650      0000
 374:main.c        ****                                 printf("Valid user found \n");
 1651              		.loc 1 374 0
 1652 110b BF000000 		movl	$.LC53, %edi
 1652      00
 1653 1110 E8000000 		call	puts
 1653      00
 375:main.c        ****                                 if (!isAdmin) {
 1654              		.loc 1 375 0
 1655 1115 0FB68590 		movzbl	-368(%rbp), %eax
 1655      FEFFFF
 1656 111c 83F001   		xorl	$1, %eax
 1657 111f 84C0     		testb	%al, %al
 1658 1121 0F84F406 		je	.L90
 1658      0000
 1659              	.LBB16:
 376:main.c        ****                                     int reqAmo = 0;
 1660              		.loc 1 376 0
 1661 1127 C785B8FE 		movl	$0, -328(%rbp)
 1661      FFFF0000 
 1661      0000
 377:main.c        ****                                     if (suffBal(bal, &reqAmo, num_100, num_500, num_1000, num_2000)
 1662              		.loc 1 377 0
 1663 1131 440FB685 		movzbl	-361(%rbp), %r8d
 1663      97FEFFFF 
 1664 1139 0FB6BD96 		movzbl	-362(%rbp), %edi
 1664      FEFFFF
 1665 1140 0FB68D95 		movzbl	-363(%rbp), %ecx
 1665      FEFFFF
 1666 1147 0FB69594 		movzbl	-364(%rbp), %edx
 1666      FEFFFF
 1667 114e 8B85B0FE 		movl	-336(%rbp), %eax
 1667      FFFF
 1668 1154 488DB5B8 		leaq	-328(%rbp), %rsi
 1668      FEFFFF
 1669 115b 4589C1   		movl	%r8d, %r9d
 1670 115e 4189F8   		movl	%edi, %r8d
 1671 1161 89C7     		movl	%eax, %edi
 1672 1163 E8000000 		call	suffBal
 1672      00
 1673 1168 84C0     		testb	%al, %al
 1674 116a 0F845D05 		je	.L91
 1674      0000
 1675              	.LBB17:
 378:main.c        **** //                                        printf("bal %u\n", bal);
 379:main.c        **** //                                        printf("req %u\n", reqAmo);
 380:main.c        ****                                         if (LOG) printf("Sufficient Balance in account\n");
 1676              		.loc 1 380 0
 1677 1170 0FB60500 		movzbl	LOG(%rip), %eax
 1677      000000
 1678 1177 84C0     		testb	%al, %al
 1679 1179 740A     		je	.L92
 1680              		.loc 1 380 0 is_stmt 0 discriminator 1
 1681 117b BF000000 		movl	$.LC54, %edi
 1681      00
 1682 1180 E8000000 		call	puts
 1682      00
 1683              	.L92:
 381:main.c        ****                                         *statusOnChan9 = 1;
 1684              		.loc 1 381 0 is_stmt 1
 1685 1185 488B45A8 		movq	-88(%rbp), %rax
 1686 1189 C60001   		movb	$1, (%rax)
 382:main.c        ****                                         flSleep(1000);
 1687              		.loc 1 382 0
 1688 118c BFE80300 		movl	$1000, %edi
 1688      00
 1689 1191 E8000000 		call	flSleep
 1689      00
 383:main.c        ****                                         if (LOG) printf("Write to channel %u = %u \n", 9, *statusOn
 1690              		.loc 1 383 0
 1691 1196 0FB60500 		movzbl	LOG(%rip), %eax
 1691      000000
 1692 119d 84C0     		testb	%al, %al
 1693 119f 7420     		je	.L93
 1694              		.loc 1 383 0 is_stmt 0 discriminator 1
 1695 11a1 488B45A8 		movq	-88(%rbp), %rax
 1696 11a5 0FB600   		movzbl	(%rax), %eax
 1697 11a8 0FB6C0   		movzbl	%al, %eax
 1698 11ab 89C2     		movl	%eax, %edx
 1699 11ad BE090000 		movl	$9, %esi
 1699      00
 1700 11b2 BF000000 		movl	$.LC55, %edi
 1700      00
 1701 11b7 B8000000 		movl	$0, %eax
 1701      00
 1702 11bc E8000000 		call	printf
 1702      00
 1703              	.L93:
 384:main.c        ****                                         fStatus = flWriteChannel(handle, (uint8_t) 9, length, statu
 1704              		.loc 1 384 0 is_stmt 1
 1705 11c1 8B95F4FE 		movl	-268(%rbp), %edx
 1705      FFFF
 1706 11c7 488B8518 		movq	-232(%rbp), %rax
 1706      FFFFFF
 1707 11ce 488DB520 		leaq	-224(%rbp), %rsi
 1707      FFFFFF
 1708 11d5 488B4DA8 		movq	-88(%rbp), %rcx
 1709 11d9 4989F0   		movq	%rsi, %r8
 1710 11dc BE090000 		movl	$9, %esi
 1710      00
 1711 11e1 4889C7   		movq	%rax, %rdi
 1712 11e4 E8000000 		call	flWriteChannel
 1712      00
 1713 11e9 8985C0FE 		movl	%eax, -320(%rbp)
 1713      FFFF
 385:main.c        ****                                         CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1714              		.loc 1 385 0
 1715 11ef 83BDC0FE 		cmpl	$0, -320(%rbp)
 1715      FFFF00
 1716 11f6 740F     		je	.L94
 1717              		.loc 1 385 0 is_stmt 0 discriminator 1
 1718 11f8 C785BCFE 		movl	$1, -324(%rbp)
 1718      FFFF0100 
 1718      0000
 1719 1202 E90F0600 		jmp	.L127
 1719      00
 1720              	.L94:
 386:main.c        ****                                         flSleep(1000);
 1721              		.loc 1 386 0 is_stmt 1
 1722 1207 BFE80300 		movl	$1000, %edi
 1722      00
 1723 120c E8000000 		call	flSleep
 1723      00
 1724              	.LBB18:
 387:main.c        ****                                         uint32_t befEncSen[2];
 388:main.c        ****                                         for (int i = 0; i < 2; i++) befEncSen[i] = 0;
 1725              		.loc 1 388 0
 1726 1211 C785D0FE 		movl	$0, -304(%rbp)
 1726      FFFF0000 
 1726      0000
 1727 121b EB1A     		jmp	.L96
 1728              	.L97:
 1729              		.loc 1 388 0 is_stmt 0 discriminator 2
 1730 121d 8B85D0FE 		movl	-304(%rbp), %eax
 1730      FFFF
 1731 1223 4898     		cltq
 1732 1225 C7848510 		movl	$0, -240(%rbp,%rax,4)
 1732      FFFFFF00 
 1732      000000
 1733 1230 8385D0FE 		addl	$1, -304(%rbp)
 1733      FFFF01
 1734              	.L96:
 1735              		.loc 1 388 0 discriminator 1
 1736 1237 83BDD0FE 		cmpl	$1, -304(%rbp)
 1736      FFFF01
 1737 123e 7EDD     		jle	.L97
 1738              	.LBE18:
 1739              	.LBB19:
 389:main.c        ****                                         for (uint32_t i = 0; i <= 31; i += 8) {
 1740              		.loc 1 389 0 is_stmt 1
 1741 1240 C785D4FE 		movl	$0, -300(%rbp)
 1741      FFFF0000 
 1741      0000
 1742 124a E9AC0000 		jmp	.L98
 1742      00
 1743              	.L103:
 390:main.c        ****                                             if (i == 0) befEncSen[0] += ((1 << i) * ((uint32_t) num
 1744              		.loc 1 390 0
 1745 124f 83BDD4FE 		cmpl	$0, -300(%rbp)
 1745      FFFF00
 1746 1256 7523     		jne	.L99
 1747              		.loc 1 390 0 is_stmt 0 discriminator 1
 1748 1258 8B9510FF 		movl	-240(%rbp), %edx
 1748      FFFF
 1749 125e 0FB6B594 		movzbl	-364(%rbp), %esi
 1749      FEFFFF
 1750 1265 8B85D4FE 		movl	-300(%rbp), %eax
 1750      FFFF
 1751 126b 89C1     		movl	%eax, %ecx
 1752 126d D3E6     		sall	%cl, %esi
 1753 126f 89F0     		movl	%esi, %eax
 1754 1271 01D0     		addl	%edx, %eax
 1755 1273 898510FF 		movl	%eax, -240(%rbp)
 1755      FFFF
 1756 1279 EB79     		jmp	.L100
 1757              	.L99:
 391:main.c        ****                                             else if (i == 8) befEncSen[0] += ((1 << i) * ((uint32_t
 1758              		.loc 1 391 0 is_stmt 1
 1759 127b 83BDD4FE 		cmpl	$8, -300(%rbp)
 1759      FFFF08
 1760 1282 7523     		jne	.L101
 1761              		.loc 1 391 0 is_stmt 0 discriminator 1
 1762 1284 8B9510FF 		movl	-240(%rbp), %edx
 1762      FFFF
 1763 128a 0FB6B595 		movzbl	-363(%rbp), %esi
 1763      FEFFFF
 1764 1291 8B85D4FE 		movl	-300(%rbp), %eax
 1764      FFFF
 1765 1297 89C1     		movl	%eax, %ecx
 1766 1299 D3E6     		sall	%cl, %esi
 1767 129b 89F0     		movl	%esi, %eax
 1768 129d 01D0     		addl	%edx, %eax
 1769 129f 898510FF 		movl	%eax, -240(%rbp)
 1769      FFFF
 1770 12a5 EB4D     		jmp	.L100
 1771              	.L101:
 392:main.c        ****                                             else if (i == 16) befEncSen[0] += ((1 << i) * ((uint32_
 1772              		.loc 1 392 0 is_stmt 1
 1773 12a7 83BDD4FE 		cmpl	$16, -300(%rbp)
 1773      FFFF10
 1774 12ae 7523     		jne	.L102
 1775              		.loc 1 392 0 is_stmt 0 discriminator 1
 1776 12b0 8B9510FF 		movl	-240(%rbp), %edx
 1776      FFFF
 1777 12b6 0FB6B596 		movzbl	-362(%rbp), %esi
 1777      FEFFFF
 1778 12bd 8B85D4FE 		movl	-300(%rbp), %eax
 1778      FFFF
 1779 12c3 89C1     		movl	%eax, %ecx
 1780 12c5 D3E6     		sall	%cl, %esi
 1781 12c7 89F0     		movl	%esi, %eax
 1782 12c9 01D0     		addl	%edx, %eax
 1783 12cb 898510FF 		movl	%eax, -240(%rbp)
 1783      FFFF
 1784 12d1 EB21     		jmp	.L100
 1785              	.L102:
 393:main.c        ****                                             else befEncSen[0] += ((1 << i) * ((uint32_t) num_2000))
 1786              		.loc 1 393 0 is_stmt 1
 1787 12d3 8B9510FF 		movl	-240(%rbp), %edx
 1787      FFFF
 1788 12d9 0FB6B597 		movzbl	-361(%rbp), %esi
 1788      FEFFFF
 1789 12e0 8B85D4FE 		movl	-300(%rbp), %eax
 1789      FFFF
 1790 12e6 89C1     		movl	%eax, %ecx
 1791 12e8 D3E6     		sall	%cl, %esi
 1792 12ea 89F0     		movl	%esi, %eax
 1793 12ec 01D0     		addl	%edx, %eax
 1794 12ee 898510FF 		movl	%eax, -240(%rbp)
 1794      FFFF
 1795              	.L100:
 389:main.c        ****                                             if (i == 0) befEncSen[0] += ((1 << i) * ((uint32_t) num
 1796              		.loc 1 389 0
 1797 12f4 8385D4FE 		addl	$8, -300(%rbp)
 1797      FFFF08
 1798              	.L98:
 389:main.c        ****                                             if (i == 0) befEncSen[0] += ((1 << i) * ((uint32_t) num
 1799              		.loc 1 389 0 is_stmt 0 discriminator 1
 1800 12fb 83BDD4FE 		cmpl	$31, -300(%rbp)
 1800      FFFF1F
 1801 1302 0F8647FF 		jbe	.L103
 1801      FFFF
 1802              	.LBE19:
 394:main.c        ****                                         }
 395:main.c        **** //                                        printf("bef Enc1 %u\n", befEncSen[1]);
 396:main.c        **** //                                        printf("bef Enc0 %u\n", befEncSen[0]);
 397:main.c        ****                                         encrypt64(befEncSen);
 1803              		.loc 1 397 0 is_stmt 1
 1804 1308 488D8510 		leaq	-240(%rbp), %rax
 1804      FFFFFF
 1805 130f 4889C7   		movq	%rax, %rdi
 1806 1312 E8000000 		call	encrypt64
 1806      00
 1807              	.LBB20:
 398:main.c        **** //                                        printf("af Enc1 %u\n", befEncSen[1]);
 399:main.c        **** //                                        printf("af Enc0 %u\n", befEncSen[0]);
 400:main.c        ****                                         for (uint8_t i = 10; i <= 13; i++) {
 1808              		.loc 1 400 0
 1809 1317 C68599FE 		movb	$10, -359(%rbp)
 1809      FFFF0A
 1810 131e E91C0100 		jmp	.L104
 1810      00
 1811              	.L110:
 1812              	.LBB21:
 401:main.c        ****                                             uint8_t tempSto = 0;
 1813              		.loc 1 401 0
 1814 1323 C68591FE 		movb	$0, -367(%rbp)
 1814      FFFF00
 1815              	.LBB22:
 402:main.c        ****                                             for (uint8_t j = 0; j <= 7; j++) {
 1816              		.loc 1 402 0
 1817 132a C6859AFE 		movb	$0, -358(%rbp)
 1817      FFFF00
 1818 1331 EB71     		jmp	.L105
 1819              	.L107:
 1820              	.LBB23:
 403:main.c        ****                                                 uint8_t temp = j + (i - 10) * 8;
 1821              		.loc 1 403 0
 1822 1333 0FB68599 		movzbl	-359(%rbp), %eax
 1822      FEFFFF
 1823 133a 83E80A   		subl	$10, %eax
 1824 133d 8D14C500 		leal	0(,%rax,8), %edx
 1824      000000
 1825 1344 0FB6859A 		movzbl	-358(%rbp), %eax
 1825      FEFFFF
 1826 134b 01D0     		addl	%edx, %eax
 1827 134d 8885A4FE 		movb	%al, -348(%rbp)
 1827      FFFF
 404:main.c        ****                                                 if ((befEncSen[0] & (1 << temp)) != 0) {
 1828              		.loc 1 404 0
 1829 1353 8B9510FF 		movl	-240(%rbp), %edx
 1829      FFFF
 1830 1359 0FB685A4 		movzbl	-348(%rbp), %eax
 1830      FEFFFF
 1831 1360 BE010000 		movl	$1, %esi
 1831      00
 1832 1365 89C1     		movl	%eax, %ecx
 1833 1367 D3E6     		sall	%cl, %esi
 1834 1369 89F0     		movl	%esi, %eax
 1835 136b 21D0     		andl	%edx, %eax
 1836 136d 85C0     		testl	%eax, %eax
 1837 136f 7423     		je	.L106
 405:main.c        ****                                                     tempSto += (1 << j);
 1838              		.loc 1 405 0
 1839 1371 0FB6859A 		movzbl	-358(%rbp), %eax
 1839      FEFFFF
 1840 1378 BA010000 		movl	$1, %edx
 1840      00
 1841 137d 89C1     		movl	%eax, %ecx
 1842 137f D3E2     		sall	%cl, %edx
 1843 1381 89D0     		movl	%edx, %eax
 1844 1383 89C2     		movl	%eax, %edx
 1845 1385 0FB68591 		movzbl	-367(%rbp), %eax
 1845      FEFFFF
 1846 138c 01D0     		addl	%edx, %eax
 1847 138e 888591FE 		movb	%al, -367(%rbp)
 1847      FFFF
 1848              	.L106:
 1849              	.LBE23:
 402:main.c        ****                                                 uint8_t temp = j + (i - 10) * 8;
 1850              		.loc 1 402 0
 1851 1394 0FB6859A 		movzbl	-358(%rbp), %eax
 1851      FEFFFF
 1852 139b 83C001   		addl	$1, %eax
 1853 139e 88859AFE 		movb	%al, -358(%rbp)
 1853      FFFF
 1854              	.L105:
 402:main.c        ****                                                 uint8_t temp = j + (i - 10) * 8;
 1855              		.loc 1 402 0 is_stmt 0 discriminator 1
 1856 13a4 80BD9AFE 		cmpb	$7, -358(%rbp)
 1856      FFFF07
 1857 13ab 7686     		jbe	.L107
 1858              	.LBE22:
 406:main.c        ****                                                 }
 407:main.c        ****                                             }
 408:main.c        ****                                             flSleep(1000);
 1859              		.loc 1 408 0 is_stmt 1
 1860 13ad BFE80300 		movl	$1000, %edi
 1860      00
 1861 13b2 E8000000 		call	flSleep
 1861      00
 409:main.c        ****                                             fStatus = flWriteChannel(handle, (uint8_t) i, length, &
 1862              		.loc 1 409 0
 1863 13b7 8B95F4FE 		movl	-268(%rbp), %edx
 1863      FFFF
 1864 13bd 0FB6B599 		movzbl	-359(%rbp), %esi
 1864      FEFFFF
 1865 13c4 488B8518 		movq	-232(%rbp), %rax
 1865      FFFFFF
 1866 13cb 488DBD20 		leaq	-224(%rbp), %rdi
 1866      FFFFFF
 1867 13d2 488D8D91 		leaq	-367(%rbp), %rcx
 1867      FEFFFF
 1868 13d9 4989F8   		movq	%rdi, %r8
 1869 13dc 4889C7   		movq	%rax, %rdi
 1870 13df E8000000 		call	flWriteChannel
 1870      00
 1871 13e4 8985C0FE 		movl	%eax, -320(%rbp)
 1871      FFFF
 410:main.c        ****                                             if (LOG) printf("Write to channel %u = %u \n", i, tempS
 1872              		.loc 1 410 0
 1873 13ea 0FB60500 		movzbl	LOG(%rip), %eax
 1873      000000
 1874 13f1 84C0     		testb	%al, %al
 1875 13f3 7422     		je	.L108
 1876              		.loc 1 410 0 is_stmt 0 discriminator 1
 1877 13f5 0FB68591 		movzbl	-367(%rbp), %eax
 1877      FEFFFF
 1878 13fc 0FB6D0   		movzbl	%al, %edx
 1879 13ff 0FB68599 		movzbl	-359(%rbp), %eax
 1879      FEFFFF
 1880 1406 89C6     		movl	%eax, %esi
 1881 1408 BF000000 		movl	$.LC55, %edi
 1881      00
 1882 140d B8000000 		movl	$0, %eax
 1882      00
 1883 1412 E8000000 		call	printf
 1883      00
 1884              	.L108:
 411:main.c        ****                                             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1885              		.loc 1 411 0 is_stmt 1
 1886 1417 83BDC0FE 		cmpl	$0, -320(%rbp)
 1886      FFFF00
 1887 141e 740F     		je	.L109
 1888              		.loc 1 411 0 is_stmt 0 discriminator 1
 1889 1420 C785BCFE 		movl	$1, -324(%rbp)
 1889      FFFF0100 
 1889      0000
 1890              	.LBE21:
 1891              	.LBE20:
 385:main.c        ****                                         flSleep(1000);
 1892              		.loc 1 385 0 is_stmt 1 discriminator 1
 1893 142a E9E70300 		jmp	.L127
 1893      00
 1894              	.L109:
 1895              	.LBB24:
 400:main.c        ****                                             uint8_t tempSto = 0;
 1896              		.loc 1 400 0
 1897 142f 0FB68599 		movzbl	-359(%rbp), %eax
 1897      FEFFFF
 1898 1436 83C001   		addl	$1, %eax
 1899 1439 888599FE 		movb	%al, -359(%rbp)
 1899      FFFF
 1900              	.L104:
 400:main.c        ****                                             uint8_t tempSto = 0;
 1901              		.loc 1 400 0 is_stmt 0 discriminator 1
 1902 143f 80BD99FE 		cmpb	$13, -359(%rbp)
 1902      FFFF0D
 1903 1446 0F86D7FE 		jbe	.L110
 1903      FFFF
 1904              	.LBE24:
 1905              	.LBB25:
 412:main.c        ****                                         }
 413:main.c        **** 
 414:main.c        ****                                         for (uint8_t i = 14; i <= 17; i++) {
 1906              		.loc 1 414 0 is_stmt 1
 1907 144c C6859BFE 		movb	$14, -357(%rbp)
 1907      FFFF0E
 1908 1453 E91C0100 		jmp	.L111
 1908      00
 1909              	.L117:
 1910              	.LBB26:
 415:main.c        ****                                             uint8_t tempSto = 0;
 1911              		.loc 1 415 0
 1912 1458 C68591FE 		movb	$0, -367(%rbp)
 1912      FFFF00
 1913              	.LBB27:
 416:main.c        ****                                             for (uint8_t j = 0; j <= 7; j++) {
 1914              		.loc 1 416 0
 1915 145f C6859CFE 		movb	$0, -356(%rbp)
 1915      FFFF00
 1916 1466 EB71     		jmp	.L112
 1917              	.L114:
 1918              	.LBB28:
 417:main.c        ****                                                 uint8_t temp = j + (i - 14) * 8;
 1919              		.loc 1 417 0
 1920 1468 0FB6859B 		movzbl	-357(%rbp), %eax
 1920      FEFFFF
 1921 146f 83E80E   		subl	$14, %eax
 1922 1472 8D14C500 		leal	0(,%rax,8), %edx
 1922      000000
 1923 1479 0FB6859C 		movzbl	-356(%rbp), %eax
 1923      FEFFFF
 1924 1480 01D0     		addl	%edx, %eax
 1925 1482 8885A5FE 		movb	%al, -347(%rbp)
 1925      FFFF
 418:main.c        ****                                                 if ((befEncSen[1] & (1 << temp)) != 0) {
 1926              		.loc 1 418 0
 1927 1488 8B9514FF 		movl	-236(%rbp), %edx
 1927      FFFF
 1928 148e 0FB685A5 		movzbl	-347(%rbp), %eax
 1928      FEFFFF
 1929 1495 BE010000 		movl	$1, %esi
 1929      00
 1930 149a 89C1     		movl	%eax, %ecx
 1931 149c D3E6     		sall	%cl, %esi
 1932 149e 89F0     		movl	%esi, %eax
 1933 14a0 21D0     		andl	%edx, %eax
 1934 14a2 85C0     		testl	%eax, %eax
 1935 14a4 7423     		je	.L113
 419:main.c        ****                                                     tempSto += (1 << j);
 1936              		.loc 1 419 0
 1937 14a6 0FB6859C 		movzbl	-356(%rbp), %eax
 1937      FEFFFF
 1938 14ad BA010000 		movl	$1, %edx
 1938      00
 1939 14b2 89C1     		movl	%eax, %ecx
 1940 14b4 D3E2     		sall	%cl, %edx
 1941 14b6 89D0     		movl	%edx, %eax
 1942 14b8 89C2     		movl	%eax, %edx
 1943 14ba 0FB68591 		movzbl	-367(%rbp), %eax
 1943      FEFFFF
 1944 14c1 01D0     		addl	%edx, %eax
 1945 14c3 888591FE 		movb	%al, -367(%rbp)
 1945      FFFF
 1946              	.L113:
 1947              	.LBE28:
 416:main.c        ****                                                 uint8_t temp = j + (i - 14) * 8;
 1948              		.loc 1 416 0
 1949 14c9 0FB6859C 		movzbl	-356(%rbp), %eax
 1949      FEFFFF
 1950 14d0 83C001   		addl	$1, %eax
 1951 14d3 88859CFE 		movb	%al, -356(%rbp)
 1951      FFFF
 1952              	.L112:
 416:main.c        ****                                                 uint8_t temp = j + (i - 14) * 8;
 1953              		.loc 1 416 0 is_stmt 0 discriminator 1
 1954 14d9 80BD9CFE 		cmpb	$7, -356(%rbp)
 1954      FFFF07
 1955 14e0 7686     		jbe	.L114
 1956              	.LBE27:
 420:main.c        ****                                                 }
 421:main.c        ****                                             }
 422:main.c        ****                                             flSleep(1000);
 1957              		.loc 1 422 0 is_stmt 1
 1958 14e2 BFE80300 		movl	$1000, %edi
 1958      00
 1959 14e7 E8000000 		call	flSleep
 1959      00
 423:main.c        ****                                             fStatus = flWriteChannel(handle, (uint8_t) i, length, &
 1960              		.loc 1 423 0
 1961 14ec 8B95F4FE 		movl	-268(%rbp), %edx
 1961      FFFF
 1962 14f2 0FB6B59B 		movzbl	-357(%rbp), %esi
 1962      FEFFFF
 1963 14f9 488B8518 		movq	-232(%rbp), %rax
 1963      FFFFFF
 1964 1500 488DBD20 		leaq	-224(%rbp), %rdi
 1964      FFFFFF
 1965 1507 488D8D91 		leaq	-367(%rbp), %rcx
 1965      FEFFFF
 1966 150e 4989F8   		movq	%rdi, %r8
 1967 1511 4889C7   		movq	%rax, %rdi
 1968 1514 E8000000 		call	flWriteChannel
 1968      00
 1969 1519 8985C0FE 		movl	%eax, -320(%rbp)
 1969      FFFF
 424:main.c        ****                                             if (LOG) printf("Write to channel %u = %u \n", i, tempS
 1970              		.loc 1 424 0
 1971 151f 0FB60500 		movzbl	LOG(%rip), %eax
 1971      000000
 1972 1526 84C0     		testb	%al, %al
 1973 1528 7422     		je	.L115
 1974              		.loc 1 424 0 is_stmt 0 discriminator 1
 1975 152a 0FB68591 		movzbl	-367(%rbp), %eax
 1975      FEFFFF
 1976 1531 0FB6D0   		movzbl	%al, %edx
 1977 1534 0FB6859B 		movzbl	-357(%rbp), %eax
 1977      FEFFFF
 1978 153b 89C6     		movl	%eax, %esi
 1979 153d BF000000 		movl	$.LC55, %edi
 1979      00
 1980 1542 B8000000 		movl	$0, %eax
 1980      00
 1981 1547 E8000000 		call	printf
 1981      00
 1982              	.L115:
 425:main.c        ****                                             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1983              		.loc 1 425 0 is_stmt 1
 1984 154c 83BDC0FE 		cmpl	$0, -320(%rbp)
 1984      FFFF00
 1985 1553 740F     		je	.L116
 1986              		.loc 1 425 0 is_stmt 0 discriminator 1
 1987 1555 C785BCFE 		movl	$1, -324(%rbp)
 1987      FFFF0100 
 1987      0000
 1988              	.LBE26:
 1989              	.LBE25:
 385:main.c        ****                                         flSleep(1000);
 1990              		.loc 1 385 0 is_stmt 1 discriminator 1
 1991 155f E9B20200 		jmp	.L127
 1991      00
 1992              	.L116:
 1993              	.LBB29:
 414:main.c        ****                                             uint8_t tempSto = 0;
 1994              		.loc 1 414 0
 1995 1564 0FB6859B 		movzbl	-357(%rbp), %eax
 1995      FEFFFF
 1996 156b 83C001   		addl	$1, %eax
 1997 156e 88859BFE 		movb	%al, -357(%rbp)
 1997      FFFF
 1998              	.L111:
 414:main.c        ****                                             uint8_t tempSto = 0;
 1999              		.loc 1 414 0 is_stmt 0 discriminator 1
 2000 1574 80BD9BFE 		cmpb	$17, -357(%rbp)
 2000      FFFF11
 2001 157b 0F86D7FE 		jbe	.L117
 2001      FFFF
 2002              	.LBE29:
 426:main.c        ****                                         }
 427:main.c        ****                                         /* update the balance in the global variable now and update
 428:main.c        ****                                         if ((*readFromChannelZero) == 1) {
 2003              		.loc 1 428 0 is_stmt 1
 2004 1581 488B4598 		movq	-104(%rbp), %rax
 2005 1585 0FB600   		movzbl	(%rax), %eax
 2006 1588 3C01     		cmpb	$1, %al
 2007 158a 0F853801 		jne	.L118
 2007      0000
 429:main.c        ****                                             dataFromCSV[inLineNum][3] -= reqAmo;
 2008              		.loc 1 429 0
 2009 1590 8B85B4FE 		movl	-332(%rbp), %eax
 2009      FFFF
 2010 1596 8B95B4FE 		movl	-332(%rbp), %edx
 2010      FFFF
 2011 159c 4863D2   		movslq	%edx, %rdx
 2012 159f 48C1E204 		salq	$4, %rdx
 2013 15a3 4881C200 		addq	$dataFromCSV+12, %rdx
 2013      000000
 2014 15aa 8B0A     		movl	(%rdx), %ecx
 2015 15ac 8B95B8FE 		movl	-328(%rbp), %edx
 2015      FFFF
 2016 15b2 29D1     		subl	%edx, %ecx
 2017 15b4 89CA     		movl	%ecx, %edx
 2018 15b6 4898     		cltq
 2019 15b8 48C1E004 		salq	$4, %rax
 2020 15bc 48050000 		addq	$dataFromCSV+12, %rax
 2020      0000
 2021 15c2 8910     		movl	%edx, (%rax)
 430:main.c        **** 
 431:main.c        ****                                             /* Updating csv file in place */
 432:main.c        ****                                             fPtr = fopen("SampleBackEndDatabase.csv", "w+"); // cha
 2022              		.loc 1 432 0
 2023 15c4 BE000000 		movl	$.LC56, %esi
 2023      00
 2024 15c9 BF000000 		movl	$.LC49, %edi
 2024      00
 2025 15ce E8000000 		call	fopen
 2025      00
 2026 15d3 48894590 		movq	%rax, -112(%rbp)
 433:main.c        ****                                             fprintf(fPtr, "%s", "\"User ID (decimal)\",\"PIN Hash (
 2027              		.loc 1 433 0
 2028 15d7 488B4590 		movq	-112(%rbp), %rax
 2029 15db 4889C1   		movq	%rax, %rcx
 2030 15de BA440000 		movl	$68, %edx
 2030      00
 2031 15e3 BE010000 		movl	$1, %esi
 2031      00
 2032 15e8 BF000000 		movl	$.LC57, %edi
 2032      00
 2033 15ed E8000000 		call	fwrite
 2033      00
 434:main.c        ****                                             fprintf(fPtr, "\n");
 2034              		.loc 1 434 0
 2035 15f2 488B4590 		movq	-112(%rbp), %rax
 2036 15f6 4889C6   		movq	%rax, %rsi
 2037 15f9 BF0A0000 		movl	$10, %edi
 2037      00
 2038 15fe E8000000 		call	fputc
 2038      00
 2039              	.LBB30:
 435:main.c        ****                                             for (int i = 1; i <= numLines; i++) {
 2040              		.loc 1 435 0
 2041 1603 C785D8FE 		movl	$1, -296(%rbp)
 2041      FFFF0100 
 2041      0000
 2042 160d E9930000 		jmp	.L119
 2042      00
 2043              	.L125:
 2044              	.LBB31:
 436:main.c        ****                                                 for (int k = 0; k < 4; k++) {
 2045              		.loc 1 436 0
 2046 1612 C785DCFE 		movl	$0, -292(%rbp)
 2046      FFFF0000 
 2046      0000
 2047 161c EB77     		jmp	.L120
 2048              	.L124:
 437:main.c        ****                                                     fprintf(fPtr, "%d", dataFromCSV[i][k]);
 2049              		.loc 1 437 0
 2050 161e 8B85DCFE 		movl	-292(%rbp), %eax
 2050      FFFF
 2051 1624 4898     		cltq
 2052 1626 8B95D8FE 		movl	-296(%rbp), %edx
 2052      FFFF
 2053 162c 4863D2   		movslq	%edx, %rdx
 2054 162f 48C1E202 		salq	$2, %rdx
 2055 1633 4801D0   		addq	%rdx, %rax
 2056 1636 8B148500 		movl	dataFromCSV(,%rax,4), %edx
 2056      000000
 2057 163d 488B4590 		movq	-112(%rbp), %rax
 2058 1641 BE000000 		movl	$.LC1, %esi
 2058      00
 2059 1646 4889C7   		movq	%rax, %rdi
 2060 1649 B8000000 		movl	$0, %eax
 2060      00
 2061 164e E8000000 		call	fprintf
 2061      00
 438:main.c        ****                                                     if (k == 3) {
 2062              		.loc 1 438 0
 2063 1653 83BDDCFE 		cmpl	$3, -292(%rbp)
 2063      FFFF03
 2064 165a 7521     		jne	.L121
 439:main.c        ****                                                         if (i != numLines) fprintf(fPtr, "\n");
 2065              		.loc 1 439 0
 2066 165c 8B050000 		movl	numLines(%rip), %eax
 2066      0000
 2067 1662 3985D8FE 		cmpl	%eax, -296(%rbp)
 2067      FFFF
 2068 1668 7424     		je	.L123
 2069              		.loc 1 439 0 is_stmt 0 discriminator 1
 2070 166a 488B4590 		movq	-112(%rbp), %rax
 2071 166e 4889C6   		movq	%rax, %rsi
 2072 1671 BF0A0000 		movl	$10, %edi
 2072      00
 2073 1676 E8000000 		call	fputc
 2073      00
 2074 167b EB11     		jmp	.L123
 2075              	.L121:
 440:main.c        ****                                                     } else fprintf(fPtr, ",");
 2076              		.loc 1 440 0 is_stmt 1
 2077 167d 488B4590 		movq	-112(%rbp), %rax
 2078 1681 4889C6   		movq	%rax, %rsi
 2079 1684 BF2C0000 		movl	$44, %edi
 2079      00
 2080 1689 E8000000 		call	fputc
 2080      00
 2081              	.L123:
 436:main.c        ****                                                     fprintf(fPtr, "%d", dataFromCSV[i][k]);
 2082              		.loc 1 436 0
 2083 168e 8385DCFE 		addl	$1, -292(%rbp)
 2083      FFFF01
 2084              	.L120:
 436:main.c        ****                                                     fprintf(fPtr, "%d", dataFromCSV[i][k]);
 2085              		.loc 1 436 0 is_stmt 0 discriminator 1
 2086 1695 83BDDCFE 		cmpl	$3, -292(%rbp)
 2086      FFFF03
 2087 169c 7E80     		jle	.L124
 2088              	.LBE31:
 435:main.c        ****                                                 for (int k = 0; k < 4; k++) {
 2089              		.loc 1 435 0 is_stmt 1
 2090 169e 8385D8FE 		addl	$1, -296(%rbp)
 2090      FFFF01
 2091              	.L119:
 435:main.c        ****                                                 for (int k = 0; k < 4; k++) {
 2092              		.loc 1 435 0 is_stmt 0 discriminator 1
 2093 16a5 8B050000 		movl	numLines(%rip), %eax
 2093      0000
 2094 16ab 3985D8FE 		cmpl	%eax, -296(%rbp)
 2094      FFFF
 2095 16b1 0F8E5BFF 		jle	.L125
 2095      FFFF
 2096              	.LBE30:
 441:main.c        ****                                                 }
 442:main.c        ****                                             }
 443:main.c        ****                                             fclose(fPtr);
 2097              		.loc 1 443 0 is_stmt 1
 2098 16b7 488B4590 		movq	-112(%rbp), %rax
 2099 16bb 4889C7   		movq	%rax, %rdi
 2100 16be E8000000 		call	fclose
 2100      00
 2101              	.LBE17:
 2102 16c3 E9490100 		jmp	.L126
 2102      00
 2103              	.L118:
 2104 16c8 E9440100 		jmp	.L126
 2104      00
 2105              	.L91:
 444:main.c        ****                                         }
 445:main.c        ****                                     } else {
 446:main.c        **** //                                        printf("bal %u\n", bal);
 447:main.c        **** //                                        printf("req %u\n", reqAmo);
 448:main.c        ****                                         if (LOG) printf("Insufficient Balance \n");
 2106              		.loc 1 448 0
 2107 16cd 0FB60500 		movzbl	LOG(%rip), %eax
 2107      000000
 2108 16d4 84C0     		testb	%al, %al
 2109 16d6 740A     		je	.L128
 2110              		.loc 1 448 0 is_stmt 0 discriminator 1
 2111 16d8 BF000000 		movl	$.LC58, %edi
 2111      00
 2112 16dd E8000000 		call	puts
 2112      00
 2113              	.L128:
 449:main.c        ****                                         *statusOnChan9 = 2;
 2114              		.loc 1 449 0 is_stmt 1
 2115 16e2 488B45A8 		movq	-88(%rbp), %rax
 2116 16e6 C60002   		movb	$2, (%rax)
 450:main.c        ****                                         flSleep(1000);
 2117              		.loc 1 450 0
 2118 16e9 BFE80300 		movl	$1000, %edi
 2118      00
 2119 16ee E8000000 		call	flSleep
 2119      00
 451:main.c        ****                                         if (LOG) printf("Write to channel %u = %u \n", 9, *statusOn
 2120              		.loc 1 451 0
 2121 16f3 0FB60500 		movzbl	LOG(%rip), %eax
 2121      000000
 2122 16fa 84C0     		testb	%al, %al
 2123 16fc 7420     		je	.L129
 2124              		.loc 1 451 0 is_stmt 0 discriminator 1
 2125 16fe 488B45A8 		movq	-88(%rbp), %rax
 2126 1702 0FB600   		movzbl	(%rax), %eax
 2127 1705 0FB6C0   		movzbl	%al, %eax
 2128 1708 89C2     		movl	%eax, %edx
 2129 170a BE090000 		movl	$9, %esi
 2129      00
 2130 170f BF000000 		movl	$.LC55, %edi
 2130      00
 2131 1714 B8000000 		movl	$0, %eax
 2131      00
 2132 1719 E8000000 		call	printf
 2132      00
 2133              	.L129:
 452:main.c        ****                                         fStatus = flWriteChannel(handle, (uint8_t) 9, length, statu
 2134              		.loc 1 452 0 is_stmt 1
 2135 171e 8B95F4FE 		movl	-268(%rbp), %edx
 2135      FFFF
 2136 1724 488B8518 		movq	-232(%rbp), %rax
 2136      FFFFFF
 2137 172b 488DB520 		leaq	-224(%rbp), %rsi
 2137      FFFFFF
 2138 1732 488B4DA8 		movq	-88(%rbp), %rcx
 2139 1736 4989F0   		movq	%rsi, %r8
 2140 1739 BE090000 		movl	$9, %esi
 2140      00
 2141 173e 4889C7   		movq	%rax, %rdi
 2142 1741 E8000000 		call	flWriteChannel
 2142      00
 2143 1746 8985C0FE 		movl	%eax, -320(%rbp)
 2143      FFFF
 453:main.c        ****                                         CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2144              		.loc 1 453 0
 2145 174c 83BDC0FE 		cmpl	$0, -320(%rbp)
 2145      FFFF00
 2146 1753 740F     		je	.L130
 2147              		.loc 1 453 0 is_stmt 0 discriminator 1
 2148 1755 C785BCFE 		movl	$1, -324(%rbp)
 2148      FFFF0100 
 2148      0000
 2149 175f E9B20000 		jmp	.L127
 2149      00
 2150              	.L130:
 2151              	.LBB32:
 454:main.c        ****                                         for (int i = 10; i <= 17; i++) {
 2152              		.loc 1 454 0 is_stmt 1
 2153 1764 C785E0FE 		movl	$10, -288(%rbp)
 2153      FFFF0A00 
 2153      0000
 2154 176e E9910000 		jmp	.L131
 2154      00
 2155              	.L134:
 2156              	.LBB33:
 455:main.c        ****                                             uint8_t tempSto = 0;
 2157              		.loc 1 455 0
 2158 1773 C68510FF 		movb	$0, -240(%rbp)
 2158      FFFF00
 456:main.c        ****                                             flSleep(1000);
 2159              		.loc 1 456 0
 2160 177a BFE80300 		movl	$1000, %edi
 2160      00
 2161 177f E8000000 		call	flSleep
 2161      00
 457:main.c        ****                                             if (LOG) printf("Write to channel %u = %u \n", i, tempS
 2162              		.loc 1 457 0
 2163 1784 0FB60500 		movzbl	LOG(%rip), %eax
 2163      000000
 2164 178b 84C0     		testb	%al, %al
 2165 178d 7421     		je	.L132
 2166              		.loc 1 457 0 is_stmt 0 discriminator 1
 2167 178f 0FB68510 		movzbl	-240(%rbp), %eax
 2167      FFFFFF
 2168 1796 0FB6D0   		movzbl	%al, %edx
 2169 1799 8B85E0FE 		movl	-288(%rbp), %eax
 2169      FFFF
 2170 179f 89C6     		movl	%eax, %esi
 2171 17a1 BF000000 		movl	$.LC55, %edi
 2171      00
 2172 17a6 B8000000 		movl	$0, %eax
 2172      00
 2173 17ab E8000000 		call	printf
 2173      00
 2174              	.L132:
 458:main.c        ****                                             fStatus = flWriteChannel(handle, (uint8_t) i, length, &
 2175              		.loc 1 458 0 is_stmt 1
 2176 17b0 8B95F4FE 		movl	-268(%rbp), %edx
 2176      FFFF
 2177 17b6 8B85E0FE 		movl	-288(%rbp), %eax
 2177      FFFF
 2178 17bc 0FB6F0   		movzbl	%al, %esi
 2179 17bf 488B8518 		movq	-232(%rbp), %rax
 2179      FFFFFF
 2180 17c6 488DBD20 		leaq	-224(%rbp), %rdi
 2180      FFFFFF
 2181 17cd 488D8D10 		leaq	-240(%rbp), %rcx
 2181      FFFFFF
 2182 17d4 4989F8   		movq	%rdi, %r8
 2183 17d7 4889C7   		movq	%rax, %rdi
 2184 17da E8000000 		call	flWriteChannel
 2184      00
 2185 17df 8985C0FE 		movl	%eax, -320(%rbp)
 2185      FFFF
 459:main.c        ****                                             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2186              		.loc 1 459 0
 2187 17e5 83BDC0FE 		cmpl	$0, -320(%rbp)
 2187      FFFF00
 2188 17ec 740F     		je	.L133
 2189              		.loc 1 459 0 is_stmt 0 discriminator 1
 2190 17ee C785BCFE 		movl	$1, -324(%rbp)
 2190      FFFF0100 
 2190      0000
 2191              	.LBE33:
 2192              	.LBE32:
 2193 17f8 E9570500 		jmp	.L70
 2193      00
 2194              	.L133:
 2195              	.LBB34:
 454:main.c        ****                                             uint8_t tempSto = 0;
 2196              		.loc 1 454 0 is_stmt 1
 2197 17fd 8385E0FE 		addl	$1, -288(%rbp)
 2197      FFFF01
 2198              	.L131:
 454:main.c        ****                                             uint8_t tempSto = 0;
 2199              		.loc 1 454 0 is_stmt 0 discriminator 1
 2200 1804 83BDE0FE 		cmpl	$17, -288(%rbp)
 2200      FFFF11
 2201 180b 0F8E62FF 		jle	.L134
 2201      FFFF
 2202              	.L126:
 2203              	.LBE34:
 2204              	.LBE16:
 2205 1811 E9400500 		jmp	.L59
 2205      00
 2206              	.L127:
 333:main.c        ****                                 if (LOG) printf("Read from channel %u = %u \n", i, *readFromChannel
 2207              		.loc 1 333 0 is_stmt 1
 2208 1816 E94A0500 		jmp	.L56
 2208      00
 2209              	.L90:
 2210              	.LBB35:
 460:main.c        ****                                         }
 461:main.c        ****                                     }
 462:main.c        ****                                 } else {
 463:main.c        ****                                     printf("User has admin privileges \n");
 2211              		.loc 1 463 0
 2212 181b BF000000 		movl	$.LC59, %edi
 2212      00
 2213 1820 E8000000 		call	puts
 2213      00
 464:main.c        ****                                     *statusOnChan9 = 3;
 2214              		.loc 1 464 0
 2215 1825 488B45A8 		movq	-88(%rbp), %rax
 2216 1829 C60003   		movb	$3, (%rax)
 465:main.c        ****                                     flSleep(1000);
 2217              		.loc 1 465 0
 2218 182c BFE80300 		movl	$1000, %edi
 2218      00
 2219 1831 E8000000 		call	flSleep
 2219      00
 466:main.c        ****                                     if (LOG) printf("Write to channel %u = %u \n", 9, *statusOnChan
 2220              		.loc 1 466 0
 2221 1836 0FB60500 		movzbl	LOG(%rip), %eax
 2221      000000
 2222 183d 84C0     		testb	%al, %al
 2223 183f 7420     		je	.L136
 2224              		.loc 1 466 0 is_stmt 0 discriminator 1
 2225 1841 488B45A8 		movq	-88(%rbp), %rax
 2226 1845 0FB600   		movzbl	(%rax), %eax
 2227 1848 0FB6C0   		movzbl	%al, %eax
 2228 184b 89C2     		movl	%eax, %edx
 2229 184d BE090000 		movl	$9, %esi
 2229      00
 2230 1852 BF000000 		movl	$.LC55, %edi
 2230      00
 2231 1857 B8000000 		movl	$0, %eax
 2231      00
 2232 185c E8000000 		call	printf
 2232      00
 2233              	.L136:
 467:main.c        ****                                     fStatus = flWriteChannel(handle, (uint8_t) 9, length, statusOnC
 2234              		.loc 1 467 0 is_stmt 1
 2235 1861 8B95F4FE 		movl	-268(%rbp), %edx
 2235      FFFF
 2236 1867 488B8518 		movq	-232(%rbp), %rax
 2236      FFFFFF
 2237 186e 488DB520 		leaq	-224(%rbp), %rsi
 2237      FFFFFF
 2238 1875 488B4DA8 		movq	-88(%rbp), %rcx
 2239 1879 4989F0   		movq	%rsi, %r8
 2240 187c BE090000 		movl	$9, %esi
 2240      00
 2241 1881 4889C7   		movq	%rax, %rdi
 2242 1884 E8000000 		call	flWriteChannel
 2242      00
 2243 1889 8985C0FE 		movl	%eax, -320(%rbp)
 2243      FFFF
 468:main.c        ****                                     CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2244              		.loc 1 468 0
 2245 188f 83BDC0FE 		cmpl	$0, -320(%rbp)
 2245      FFFF00
 2246 1896 740F     		je	.L137
 2247              		.loc 1 468 0 is_stmt 0 discriminator 1
 2248 1898 C785BCFE 		movl	$1, -324(%rbp)
 2248      FFFF0100 
 2248      0000
 2249 18a2 E9AD0400 		jmp	.L70
 2249      00
 2250              	.L137:
 2251              	.LBB36:
 469:main.c        ****                                     uint32_t befEncSen[2];
 470:main.c        ****                                     for (int i = 0; i < 2; i++) befEncSen[i] = 0;
 2252              		.loc 1 470 0 is_stmt 1
 2253 18a7 C785E4FE 		movl	$0, -284(%rbp)
 2253      FFFF0000 
 2253      0000
 2254 18b1 EB1A     		jmp	.L139
 2255              	.L140:
 2256              		.loc 1 470 0 is_stmt 0 discriminator 2
 2257 18b3 8B85E4FE 		movl	-284(%rbp), %eax
 2257      FFFF
 2258 18b9 4898     		cltq
 2259 18bb C7848510 		movl	$0, -240(%rbp,%rax,4)
 2259      FFFFFF00 
 2259      000000
 2260 18c6 8385E4FE 		addl	$1, -284(%rbp)
 2260      FFFF01
 2261              	.L139:
 2262              		.loc 1 470 0 discriminator 1
 2263 18cd 83BDE4FE 		cmpl	$1, -284(%rbp)
 2263      FFFF01
 2264 18d4 7EDD     		jle	.L140
 2265              	.LBE36:
 2266              	.LBB37:
 471:main.c        ****                                     for (uint32_t i = 0; i <= 31; i += 8) {
 2267              		.loc 1 471 0 is_stmt 1
 2268 18d6 C785E8FE 		movl	$0, -280(%rbp)
 2268      FFFF0000 
 2268      0000
 2269 18e0 E9AC0000 		jmp	.L141
 2269      00
 2270              	.L146:
 472:main.c        ****                                         if (i == 0) befEncSen[0] += ((1 << i) * ((uint32_t) num_100
 2271              		.loc 1 472 0
 2272 18e5 83BDE8FE 		cmpl	$0, -280(%rbp)
 2272      FFFF00
 2273 18ec 7523     		jne	.L142
 2274              		.loc 1 472 0 is_stmt 0 discriminator 1
 2275 18ee 8B9510FF 		movl	-240(%rbp), %edx
 2275      FFFF
 2276 18f4 0FB6B594 		movzbl	-364(%rbp), %esi
 2276      FEFFFF
 2277 18fb 8B85E8FE 		movl	-280(%rbp), %eax
 2277      FFFF
 2278 1901 89C1     		movl	%eax, %ecx
 2279 1903 D3E6     		sall	%cl, %esi
 2280 1905 89F0     		movl	%esi, %eax
 2281 1907 01D0     		addl	%edx, %eax
 2282 1909 898510FF 		movl	%eax, -240(%rbp)
 2282      FFFF
 2283 190f EB79     		jmp	.L143
 2284              	.L142:
 473:main.c        ****                                         else if (i == 8) befEncSen[0] += ((1 << i) * ((uint32_t) nu
 2285              		.loc 1 473 0 is_stmt 1
 2286 1911 83BDE8FE 		cmpl	$8, -280(%rbp)
 2286      FFFF08
 2287 1918 7523     		jne	.L144
 2288              		.loc 1 473 0 is_stmt 0 discriminator 1
 2289 191a 8B9510FF 		movl	-240(%rbp), %edx
 2289      FFFF
 2290 1920 0FB6B595 		movzbl	-363(%rbp), %esi
 2290      FEFFFF
 2291 1927 8B85E8FE 		movl	-280(%rbp), %eax
 2291      FFFF
 2292 192d 89C1     		movl	%eax, %ecx
 2293 192f D3E6     		sall	%cl, %esi
 2294 1931 89F0     		movl	%esi, %eax
 2295 1933 01D0     		addl	%edx, %eax
 2296 1935 898510FF 		movl	%eax, -240(%rbp)
 2296      FFFF
 2297 193b EB4D     		jmp	.L143
 2298              	.L144:
 474:main.c        ****                                         else if (i == 16) befEncSen[0] += ((1 << i) * ((uint32_t) n
 2299              		.loc 1 474 0 is_stmt 1
 2300 193d 83BDE8FE 		cmpl	$16, -280(%rbp)
 2300      FFFF10
 2301 1944 7523     		jne	.L145
 2302              		.loc 1 474 0 is_stmt 0 discriminator 1
 2303 1946 8B9510FF 		movl	-240(%rbp), %edx
 2303      FFFF
 2304 194c 0FB6B596 		movzbl	-362(%rbp), %esi
 2304      FEFFFF
 2305 1953 8B85E8FE 		movl	-280(%rbp), %eax
 2305      FFFF
 2306 1959 89C1     		movl	%eax, %ecx
 2307 195b D3E6     		sall	%cl, %esi
 2308 195d 89F0     		movl	%esi, %eax
 2309 195f 01D0     		addl	%edx, %eax
 2310 1961 898510FF 		movl	%eax, -240(%rbp)
 2310      FFFF
 2311 1967 EB21     		jmp	.L143
 2312              	.L145:
 475:main.c        ****                                         else befEncSen[0] += ((1 << i) * ((uint32_t) num_2000));
 2313              		.loc 1 475 0 is_stmt 1
 2314 1969 8B9510FF 		movl	-240(%rbp), %edx
 2314      FFFF
 2315 196f 0FB6B597 		movzbl	-361(%rbp), %esi
 2315      FEFFFF
 2316 1976 8B85E8FE 		movl	-280(%rbp), %eax
 2316      FFFF
 2317 197c 89C1     		movl	%eax, %ecx
 2318 197e D3E6     		sall	%cl, %esi
 2319 1980 89F0     		movl	%esi, %eax
 2320 1982 01D0     		addl	%edx, %eax
 2321 1984 898510FF 		movl	%eax, -240(%rbp)
 2321      FFFF
 2322              	.L143:
 471:main.c        ****                                         if (i == 0) befEncSen[0] += ((1 << i) * ((uint32_t) num_100
 2323              		.loc 1 471 0
 2324 198a 8385E8FE 		addl	$8, -280(%rbp)
 2324      FFFF08
 2325              	.L141:
 471:main.c        ****                                         if (i == 0) befEncSen[0] += ((1 << i) * ((uint32_t) num_100
 2326              		.loc 1 471 0 is_stmt 0 discriminator 1
 2327 1991 83BDE8FE 		cmpl	$31, -280(%rbp)
 2327      FFFF1F
 2328 1998 0F8647FF 		jbe	.L146
 2328      FFFF
 2329              	.LBE37:
 476:main.c        ****                                     }
 477:main.c        ****                                     encrypt64(befEncSen);
 2330              		.loc 1 477 0 is_stmt 1
 2331 199e 488D8510 		leaq	-240(%rbp), %rax
 2331      FFFFFF
 2332 19a5 4889C7   		movq	%rax, %rdi
 2333 19a8 E8000000 		call	encrypt64
 2333      00
 2334              	.LBB38:
 478:main.c        ****                                     for (uint8_t i = 10; i <= 13; i++) {
 2335              		.loc 1 478 0
 2336 19ad C6859DFE 		movb	$10, -355(%rbp)
 2336      FFFF0A
 2337 19b4 E91C0100 		jmp	.L147
 2337      00
 2338              	.L153:
 2339              	.LBB39:
 479:main.c        ****                                         uint8_t tempSto = 0;
 2340              		.loc 1 479 0
 2341 19b9 C685B8FE 		movb	$0, -328(%rbp)
 2341      FFFF00
 2342              	.LBB40:
 480:main.c        ****                                         for (uint8_t j = 0; j <= 7; j++) {
 2343              		.loc 1 480 0
 2344 19c0 C6859EFE 		movb	$0, -354(%rbp)
 2344      FFFF00
 2345 19c7 EB71     		jmp	.L148
 2346              	.L150:
 2347              	.LBB41:
 481:main.c        ****                                             uint8_t temp = j + (i - 10) * 8;
 2348              		.loc 1 481 0
 2349 19c9 0FB6859D 		movzbl	-355(%rbp), %eax
 2349      FEFFFF
 2350 19d0 83E80A   		subl	$10, %eax
 2351 19d3 8D14C500 		leal	0(,%rax,8), %edx
 2351      000000
 2352 19da 0FB6859E 		movzbl	-354(%rbp), %eax
 2352      FEFFFF
 2353 19e1 01D0     		addl	%edx, %eax
 2354 19e3 8885A6FE 		movb	%al, -346(%rbp)
 2354      FFFF
 482:main.c        ****                                             if ((befEncSen[0] & (1 << temp)) != 0) {
 2355              		.loc 1 482 0
 2356 19e9 8B9510FF 		movl	-240(%rbp), %edx
 2356      FFFF
 2357 19ef 0FB685A6 		movzbl	-346(%rbp), %eax
 2357      FEFFFF
 2358 19f6 BE010000 		movl	$1, %esi
 2358      00
 2359 19fb 89C1     		movl	%eax, %ecx
 2360 19fd D3E6     		sall	%cl, %esi
 2361 19ff 89F0     		movl	%esi, %eax
 2362 1a01 21D0     		andl	%edx, %eax
 2363 1a03 85C0     		testl	%eax, %eax
 2364 1a05 7423     		je	.L149
 483:main.c        ****                                                 tempSto += (1 << j);
 2365              		.loc 1 483 0
 2366 1a07 0FB6859E 		movzbl	-354(%rbp), %eax
 2366      FEFFFF
 2367 1a0e BA010000 		movl	$1, %edx
 2367      00
 2368 1a13 89C1     		movl	%eax, %ecx
 2369 1a15 D3E2     		sall	%cl, %edx
 2370 1a17 89D0     		movl	%edx, %eax
 2371 1a19 89C2     		movl	%eax, %edx
 2372 1a1b 0FB685B8 		movzbl	-328(%rbp), %eax
 2372      FEFFFF
 2373 1a22 01D0     		addl	%edx, %eax
 2374 1a24 8885B8FE 		movb	%al, -328(%rbp)
 2374      FFFF
 2375              	.L149:
 2376              	.LBE41:
 480:main.c        ****                                             uint8_t temp = j + (i - 10) * 8;
 2377              		.loc 1 480 0
 2378 1a2a 0FB6859E 		movzbl	-354(%rbp), %eax
 2378      FEFFFF
 2379 1a31 83C001   		addl	$1, %eax
 2380 1a34 88859EFE 		movb	%al, -354(%rbp)
 2380      FFFF
 2381              	.L148:
 480:main.c        ****                                             uint8_t temp = j + (i - 10) * 8;
 2382              		.loc 1 480 0 is_stmt 0 discriminator 1
 2383 1a3a 80BD9EFE 		cmpb	$7, -354(%rbp)
 2383      FFFF07
 2384 1a41 7686     		jbe	.L150
 2385              	.LBE40:
 484:main.c        ****                                             }
 485:main.c        ****                                         }
 486:main.c        ****                                         flSleep(1000);
 2386              		.loc 1 486 0 is_stmt 1
 2387 1a43 BFE80300 		movl	$1000, %edi
 2387      00
 2388 1a48 E8000000 		call	flSleep
 2388      00
 487:main.c        ****                                         if (LOG) printf("Write to channel %u = %u \n", i, tempSto);
 2389              		.loc 1 487 0
 2390 1a4d 0FB60500 		movzbl	LOG(%rip), %eax
 2390      000000
 2391 1a54 84C0     		testb	%al, %al
 2392 1a56 7422     		je	.L151
 2393              		.loc 1 487 0 is_stmt 0 discriminator 1
 2394 1a58 0FB685B8 		movzbl	-328(%rbp), %eax
 2394      FEFFFF
 2395 1a5f 0FB6D0   		movzbl	%al, %edx
 2396 1a62 0FB6859D 		movzbl	-355(%rbp), %eax
 2396      FEFFFF
 2397 1a69 89C6     		movl	%eax, %esi
 2398 1a6b BF000000 		movl	$.LC55, %edi
 2398      00
 2399 1a70 B8000000 		movl	$0, %eax
 2399      00
 2400 1a75 E8000000 		call	printf
 2400      00
 2401              	.L151:
 488:main.c        ****                                         fStatus = flWriteChannel(handle, (uint8_t) i, length, &temp
 2402              		.loc 1 488 0 is_stmt 1
 2403 1a7a 8B95F4FE 		movl	-268(%rbp), %edx
 2403      FFFF
 2404 1a80 0FB6B59D 		movzbl	-355(%rbp), %esi
 2404      FEFFFF
 2405 1a87 488B8518 		movq	-232(%rbp), %rax
 2405      FFFFFF
 2406 1a8e 488DBD20 		leaq	-224(%rbp), %rdi
 2406      FFFFFF
 2407 1a95 488D8DB8 		leaq	-328(%rbp), %rcx
 2407      FEFFFF
 2408 1a9c 4989F8   		movq	%rdi, %r8
 2409 1a9f 4889C7   		movq	%rax, %rdi
 2410 1aa2 E8000000 		call	flWriteChannel
 2410      00
 2411 1aa7 8985C0FE 		movl	%eax, -320(%rbp)
 2411      FFFF
 489:main.c        ****                                         CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2412              		.loc 1 489 0
 2413 1aad 83BDC0FE 		cmpl	$0, -320(%rbp)
 2413      FFFF00
 2414 1ab4 740F     		je	.L152
 2415              		.loc 1 489 0 is_stmt 0 discriminator 1
 2416 1ab6 C785BCFE 		movl	$1, -324(%rbp)
 2416      FFFF0100 
 2416      0000
 2417              	.LBE39:
 2418              	.LBE38:
 468:main.c        ****                                     uint32_t befEncSen[2];
 2419              		.loc 1 468 0 is_stmt 1 discriminator 1
 2420 1ac0 E98F0200 		jmp	.L70
 2420      00
 2421              	.L152:
 2422              	.LBB42:
 478:main.c        ****                                         uint8_t tempSto = 0;
 2423              		.loc 1 478 0
 2424 1ac5 0FB6859D 		movzbl	-355(%rbp), %eax
 2424      FEFFFF
 2425 1acc 83C001   		addl	$1, %eax
 2426 1acf 88859DFE 		movb	%al, -355(%rbp)
 2426      FFFF
 2427              	.L147:
 478:main.c        ****                                         uint8_t tempSto = 0;
 2428              		.loc 1 478 0 is_stmt 0 discriminator 1
 2429 1ad5 80BD9DFE 		cmpb	$13, -355(%rbp)
 2429      FFFF0D
 2430 1adc 0F86D7FE 		jbe	.L153
 2430      FFFF
 2431              	.LBE42:
 2432              	.LBB43:
 490:main.c        ****                                     }
 491:main.c        **** 
 492:main.c        ****                                     for (uint8_t i = 14; i <= 17; i++) {
 2433              		.loc 1 492 0 is_stmt 1
 2434 1ae2 C6859FFE 		movb	$14, -353(%rbp)
 2434      FFFF0E
 2435 1ae9 E91C0100 		jmp	.L154
 2435      00
 2436              	.L160:
 2437              	.LBB44:
 493:main.c        ****                                         uint8_t tempSto = 0;
 2438              		.loc 1 493 0
 2439 1aee C685B8FE 		movb	$0, -328(%rbp)
 2439      FFFF00
 2440              	.LBB45:
 494:main.c        ****                                         for (uint8_t j = 0; j <= 7; j++) {
 2441              		.loc 1 494 0
 2442 1af5 C685A0FE 		movb	$0, -352(%rbp)
 2442      FFFF00
 2443 1afc EB71     		jmp	.L155
 2444              	.L157:
 2445              	.LBB46:
 495:main.c        ****                                             uint8_t temp = j + (i - 14) * 8;
 2446              		.loc 1 495 0
 2447 1afe 0FB6859F 		movzbl	-353(%rbp), %eax
 2447      FEFFFF
 2448 1b05 83E80E   		subl	$14, %eax
 2449 1b08 8D14C500 		leal	0(,%rax,8), %edx
 2449      000000
 2450 1b0f 0FB685A0 		movzbl	-352(%rbp), %eax
 2450      FEFFFF
 2451 1b16 01D0     		addl	%edx, %eax
 2452 1b18 8885A7FE 		movb	%al, -345(%rbp)
 2452      FFFF
 496:main.c        ****                                             if ((befEncSen[1] & (1 << temp)) != 0) {
 2453              		.loc 1 496 0
 2454 1b1e 8B9514FF 		movl	-236(%rbp), %edx
 2454      FFFF
 2455 1b24 0FB685A7 		movzbl	-345(%rbp), %eax
 2455      FEFFFF
 2456 1b2b BE010000 		movl	$1, %esi
 2456      00
 2457 1b30 89C1     		movl	%eax, %ecx
 2458 1b32 D3E6     		sall	%cl, %esi
 2459 1b34 89F0     		movl	%esi, %eax
 2460 1b36 21D0     		andl	%edx, %eax
 2461 1b38 85C0     		testl	%eax, %eax
 2462 1b3a 7423     		je	.L156
 497:main.c        ****                                                 tempSto += (1 << j);
 2463              		.loc 1 497 0
 2464 1b3c 0FB685A0 		movzbl	-352(%rbp), %eax
 2464      FEFFFF
 2465 1b43 BA010000 		movl	$1, %edx
 2465      00
 2466 1b48 89C1     		movl	%eax, %ecx
 2467 1b4a D3E2     		sall	%cl, %edx
 2468 1b4c 89D0     		movl	%edx, %eax
 2469 1b4e 89C2     		movl	%eax, %edx
 2470 1b50 0FB685B8 		movzbl	-328(%rbp), %eax
 2470      FEFFFF
 2471 1b57 01D0     		addl	%edx, %eax
 2472 1b59 8885B8FE 		movb	%al, -328(%rbp)
 2472      FFFF
 2473              	.L156:
 2474              	.LBE46:
 494:main.c        ****                                             uint8_t temp = j + (i - 14) * 8;
 2475              		.loc 1 494 0
 2476 1b5f 0FB685A0 		movzbl	-352(%rbp), %eax
 2476      FEFFFF
 2477 1b66 83C001   		addl	$1, %eax
 2478 1b69 8885A0FE 		movb	%al, -352(%rbp)
 2478      FFFF
 2479              	.L155:
 494:main.c        ****                                             uint8_t temp = j + (i - 14) * 8;
 2480              		.loc 1 494 0 is_stmt 0 discriminator 1
 2481 1b6f 80BDA0FE 		cmpb	$7, -352(%rbp)
 2481      FFFF07
 2482 1b76 7686     		jbe	.L157
 2483              	.LBE45:
 498:main.c        ****                                             }
 499:main.c        ****                                         }
 500:main.c        ****                                         flSleep(1000);
 2484              		.loc 1 500 0 is_stmt 1
 2485 1b78 BFE80300 		movl	$1000, %edi
 2485      00
 2486 1b7d E8000000 		call	flSleep
 2486      00
 501:main.c        ****                                         if (LOG) printf("Write to channel %u = %u \n", i, tempSto);
 2487              		.loc 1 501 0
 2488 1b82 0FB60500 		movzbl	LOG(%rip), %eax
 2488      000000
 2489 1b89 84C0     		testb	%al, %al
 2490 1b8b 7422     		je	.L158
 2491              		.loc 1 501 0 is_stmt 0 discriminator 1
 2492 1b8d 0FB685B8 		movzbl	-328(%rbp), %eax
 2492      FEFFFF
 2493 1b94 0FB6D0   		movzbl	%al, %edx
 2494 1b97 0FB6859F 		movzbl	-353(%rbp), %eax
 2494      FEFFFF
 2495 1b9e 89C6     		movl	%eax, %esi
 2496 1ba0 BF000000 		movl	$.LC55, %edi
 2496      00
 2497 1ba5 B8000000 		movl	$0, %eax
 2497      00
 2498 1baa E8000000 		call	printf
 2498      00
 2499              	.L158:
 502:main.c        ****                                         fStatus = flWriteChannel(handle, (uint8_t) i, length, &temp
 2500              		.loc 1 502 0 is_stmt 1
 2501 1baf 8B95F4FE 		movl	-268(%rbp), %edx
 2501      FFFF
 2502 1bb5 0FB6B59F 		movzbl	-353(%rbp), %esi
 2502      FEFFFF
 2503 1bbc 488B8518 		movq	-232(%rbp), %rax
 2503      FFFFFF
 2504 1bc3 488DBD20 		leaq	-224(%rbp), %rdi
 2504      FFFFFF
 2505 1bca 488D8DB8 		leaq	-328(%rbp), %rcx
 2505      FEFFFF
 2506 1bd1 4989F8   		movq	%rdi, %r8
 2507 1bd4 4889C7   		movq	%rax, %rdi
 2508 1bd7 E8000000 		call	flWriteChannel
 2508      00
 2509 1bdc 8985C0FE 		movl	%eax, -320(%rbp)
 2509      FFFF
 503:main.c        ****                                         CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2510              		.loc 1 503 0
 2511 1be2 83BDC0FE 		cmpl	$0, -320(%rbp)
 2511      FFFF00
 2512 1be9 740F     		je	.L159
 2513              		.loc 1 503 0 is_stmt 0 discriminator 1
 2514 1beb C785BCFE 		movl	$1, -324(%rbp)
 2514      FFFF0100 
 2514      0000
 2515              	.LBE44:
 2516              	.LBE43:
 468:main.c        ****                                     uint32_t befEncSen[2];
 2517              		.loc 1 468 0 is_stmt 1 discriminator 1
 2518 1bf5 E95A0100 		jmp	.L70
 2518      00
 2519              	.L159:
 2520              	.LBB47:
 492:main.c        ****                                         uint8_t tempSto = 0;
 2521              		.loc 1 492 0
 2522 1bfa 0FB6859F 		movzbl	-353(%rbp), %eax
 2522      FEFFFF
 2523 1c01 83C001   		addl	$1, %eax
 2524 1c04 88859FFE 		movb	%al, -353(%rbp)
 2524      FFFF
 2525              	.L154:
 492:main.c        ****                                         uint8_t tempSto = 0;
 2526              		.loc 1 492 0 is_stmt 0 discriminator 1
 2527 1c0a 80BD9FFE 		cmpb	$17, -353(%rbp)
 2527      FFFF11
 2528 1c11 0F86D7FE 		jbe	.L160
 2528      FFFF
 2529              	.LBE47:
 2530 1c17 E9360100 		jmp	.L161
 2530      00
 2531              	.L89:
 2532              	.LBE35:
 504:main.c        ****                                     }
 505:main.c        ****                                 }
 506:main.c        ****                             } else {
 507:main.c        ****                                 printf("Invalid user \n");
 2533              		.loc 1 507 0 is_stmt 1
 2534 1c1c BF000000 		movl	$.LC60, %edi
 2534      00
 2535 1c21 E8000000 		call	puts
 2535      00
 508:main.c        ****                                 *statusOnChan9 = 4;
 2536              		.loc 1 508 0
 2537 1c26 488B45A8 		movq	-88(%rbp), %rax
 2538 1c2a C60004   		movb	$4, (%rax)
 509:main.c        ****                                 flSleep(1000);
 2539              		.loc 1 509 0
 2540 1c2d BFE80300 		movl	$1000, %edi
 2540      00
 2541 1c32 E8000000 		call	flSleep
 2541      00
 510:main.c        ****                                 if (LOG) printf("Write to channel %u = %u \n", 9, *statusOnChan9);
 2542              		.loc 1 510 0
 2543 1c37 0FB60500 		movzbl	LOG(%rip), %eax
 2543      000000
 2544 1c3e 84C0     		testb	%al, %al
 2545 1c40 7420     		je	.L162
 2546              		.loc 1 510 0 is_stmt 0 discriminator 1
 2547 1c42 488B45A8 		movq	-88(%rbp), %rax
 2548 1c46 0FB600   		movzbl	(%rax), %eax
 2549 1c49 0FB6C0   		movzbl	%al, %eax
 2550 1c4c 89C2     		movl	%eax, %edx
 2551 1c4e BE090000 		movl	$9, %esi
 2551      00
 2552 1c53 BF000000 		movl	$.LC55, %edi
 2552      00
 2553 1c58 B8000000 		movl	$0, %eax
 2553      00
 2554 1c5d E8000000 		call	printf
 2554      00
 2555              	.L162:
 511:main.c        ****                                 fStatus = flWriteChannel(handle, (uint8_t) 9, length, statusOnChan9
 2556              		.loc 1 511 0 is_stmt 1
 2557 1c62 8B95F4FE 		movl	-268(%rbp), %edx
 2557      FFFF
 2558 1c68 488B8518 		movq	-232(%rbp), %rax
 2558      FFFFFF
 2559 1c6f 488DB520 		leaq	-224(%rbp), %rsi
 2559      FFFFFF
 2560 1c76 488B4DA8 		movq	-88(%rbp), %rcx
 2561 1c7a 4989F0   		movq	%rsi, %r8
 2562 1c7d BE090000 		movl	$9, %esi
 2562      00
 2563 1c82 4889C7   		movq	%rax, %rdi
 2564 1c85 E8000000 		call	flWriteChannel
 2564      00
 2565 1c8a 8985C0FE 		movl	%eax, -320(%rbp)
 2565      FFFF
 512:main.c        ****                                 CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2566              		.loc 1 512 0
 2567 1c90 83BDC0FE 		cmpl	$0, -320(%rbp)
 2567      FFFF00
 2568 1c97 740F     		je	.L163
 2569              		.loc 1 512 0 is_stmt 0 discriminator 1
 2570 1c99 C785BCFE 		movl	$1, -324(%rbp)
 2570      FFFF0100 
 2570      0000
 2571 1ca3 E9AC0000 		jmp	.L70
 2571      00
 2572              	.L163:
 2573              	.LBB48:
 513:main.c        ****                                 for (int i = 10; i <= 17; i++) {
 2574              		.loc 1 513 0 is_stmt 1
 2575 1ca8 C785ECFE 		movl	$10, -276(%rbp)
 2575      FFFF0A00 
 2575      0000
 2576 1cb2 E98E0000 		jmp	.L164
 2576      00
 2577              	.L167:
 2578              	.LBB49:
 514:main.c        ****                                     uint8_t tempSto = 0;
 2579              		.loc 1 514 0
 2580 1cb7 C68510FF 		movb	$0, -240(%rbp)
 2580      FFFF00
 515:main.c        ****                                     flSleep(1000);
 2581              		.loc 1 515 0
 2582 1cbe BFE80300 		movl	$1000, %edi
 2582      00
 2583 1cc3 E8000000 		call	flSleep
 2583      00
 516:main.c        ****                                     if (LOG) printf("Write to channel %u = %u \n", i, tempSto);
 2584              		.loc 1 516 0
 2585 1cc8 0FB60500 		movzbl	LOG(%rip), %eax
 2585      000000
 2586 1ccf 84C0     		testb	%al, %al
 2587 1cd1 7421     		je	.L165
 2588              		.loc 1 516 0 is_stmt 0 discriminator 1
 2589 1cd3 0FB68510 		movzbl	-240(%rbp), %eax
 2589      FFFFFF
 2590 1cda 0FB6D0   		movzbl	%al, %edx
 2591 1cdd 8B85ECFE 		movl	-276(%rbp), %eax
 2591      FFFF
 2592 1ce3 89C6     		movl	%eax, %esi
 2593 1ce5 BF000000 		movl	$.LC55, %edi
 2593      00
 2594 1cea B8000000 		movl	$0, %eax
 2594      00
 2595 1cef E8000000 		call	printf
 2595      00
 2596              	.L165:
 517:main.c        ****                                     fStatus = flWriteChannel(handle, (uint8_t) i, length, &tempSto,
 2597              		.loc 1 517 0 is_stmt 1
 2598 1cf4 8B95F4FE 		movl	-268(%rbp), %edx
 2598      FFFF
 2599 1cfa 8B85ECFE 		movl	-276(%rbp), %eax
 2599      FFFF
 2600 1d00 0FB6F0   		movzbl	%al, %esi
 2601 1d03 488B8518 		movq	-232(%rbp), %rax
 2601      FFFFFF
 2602 1d0a 488DBD20 		leaq	-224(%rbp), %rdi
 2602      FFFFFF
 2603 1d11 488D8D10 		leaq	-240(%rbp), %rcx
 2603      FFFFFF
 2604 1d18 4989F8   		movq	%rdi, %r8
 2605 1d1b 4889C7   		movq	%rax, %rdi
 2606 1d1e E8000000 		call	flWriteChannel
 2606      00
 2607 1d23 8985C0FE 		movl	%eax, -320(%rbp)
 2607      FFFF
 518:main.c        ****                                     CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2608              		.loc 1 518 0
 2609 1d29 83BDC0FE 		cmpl	$0, -320(%rbp)
 2609      FFFF00
 2610 1d30 740C     		je	.L166
 2611              		.loc 1 518 0 is_stmt 0 discriminator 1
 2612 1d32 C785BCFE 		movl	$1, -324(%rbp)
 2612      FFFF0100 
 2612      0000
 2613              	.LBE49:
 2614              	.LBE48:
 333:main.c        ****                                 if (LOG) printf("Read from channel %u = %u \n", i, *readFromChannel
 2615              		.loc 1 333 0 is_stmt 1 discriminator 1
 2616 1d3c EB27     		jmp	.L56
 2617              	.L166:
 2618              	.LBB50:
 513:main.c        ****                                     uint8_t tempSto = 0;
 2619              		.loc 1 513 0
 2620 1d3e 8385ECFE 		addl	$1, -276(%rbp)
 2620      FFFF01
 2621              	.L164:
 513:main.c        ****                                     uint8_t tempSto = 0;
 2622              		.loc 1 513 0 is_stmt 0 discriminator 1
 2623 1d45 83BDECFE 		cmpl	$17, -276(%rbp)
 2623      FFFF11
 2624 1d4c 0F8E65FF 		jle	.L167
 2624      FFFF
 2625              	.L161:
 2626              	.LBE50:
 2627 1d52 EB02     		jmp	.L59
 2628              	.L70:
 2629              	.LBE10:
 2630              	.LBE9:
 2631              	.LBE8:
 306:main.c        ****                     if (LOG) printf("Read from channel 0 = %u \n", *readFromChannelZero);
 2632              		.loc 1 306 0 is_stmt 1 discriminator 1
 2633 1d54 EB63     		jmp	.L29
 2634              	.L59:
 2635              	.LBB51:
 519:main.c        ****                                 }
 520:main.c        ****                             }
 521:main.c        ****                         }
 522:main.c        ****                     }
 523:main.c        ****                     flSleep(1000);
 2636              		.loc 1 523 0
 2637 1d56 BFE80300 		movl	$1000, %edi
 2637      00
 2638 1d5b E8000000 		call	flSleep
 2638      00
 2639              	.LBE51:
 524:main.c        ****                 }
 2640              		.loc 1 524 0
 2641 1d60 E928EEFF 		jmp	.L168
 2641      FF
 2642              	.L56:
 2643              	.LBE7:
 279:main.c        ****             fStatus = flIsFPGARunning(handle, &isRunning, &error);
 2644              		.loc 1 279 0 discriminator 1
 2645 1d65 EB52     		jmp	.L29
 2646              	.L49:
 525:main.c        **** 
 526:main.c        ****             } else {
 527:main.c        ****                 fprintf(stderr, "The FPGALink device at %s is not ready to talk - did you forget --
 2647              		.loc 1 527 0
 2648 1d67 488B0500 		movq	stderr(%rip), %rax
 2648      000000
 2649 1d6e 488B5580 		movq	-128(%rbp), %rdx
 2650 1d72 BE000000 		movl	$.LC61, %esi
 2650      00
 2651 1d77 4889C7   		movq	%rax, %rdi
 2652 1d7a B8000000 		movl	$0, %eax
 2652      00
 2653 1d7f E8000000 		call	fprintf
 2653      00
 528:main.c        ****                 FAIL(FLP_ARGS, cleanup);
 2654              		.loc 1 528 0
 2655 1d84 C785BCFE 		movl	$12, -324(%rbp)
 2655      FFFF0C00 
 2655      0000
 2656 1d8e 90       		nop
 2657 1d8f EB28     		jmp	.L29
 2658              	.L45:
 2659              	.LBE6:
 529:main.c        ****             }
 530:main.c        ****         } else {
 531:main.c        ****             fprintf(stderr, "Action requested but device at %s does not support CommFPGA\n", vp);
 2660              		.loc 1 531 0
 2661 1d91 488B0500 		movq	stderr(%rip), %rax
 2661      000000
 2662 1d98 488B5580 		movq	-128(%rbp), %rdx
 2663 1d9c BE000000 		movl	$.LC62, %esi
 2663      00
 2664 1da1 4889C7   		movq	%rax, %rdi
 2665 1da4 B8000000 		movl	$0, %eax
 2665      00
 2666 1da9 E8000000 		call	fprintf
 2666      00
 532:main.c        ****             FAIL(FLP_ARGS, cleanup);
 2667              		.loc 1 532 0
 2668 1dae C785BCFE 		movl	$12, -324(%rbp)
 2668      FFFF0C00 
 2668      0000
 2669 1db8 90       		nop
 2670              	.L29:
 533:main.c        ****         }
 534:main.c        ****     }
 535:main.c        **** 
 536:main.c        ****     cleanup:
 537:main.c        ****     free((void *) line);
 2671              		.loc 1 537 0
 2672 1db9 488B4588 		movq	-120(%rbp), %rax
 2673 1dbd 4889C7   		movq	%rax, %rdi
 2674 1dc0 E8000000 		call	free
 2674      00
 538:main.c        ****     flClose(handle);
 2675              		.loc 1 538 0
 2676 1dc5 488B8518 		movq	-232(%rbp), %rax
 2676      FFFFFF
 2677 1dcc 4889C7   		movq	%rax, %rdi
 2678 1dcf E8000000 		call	flClose
 2678      00
 539:main.c        ****     if (error) {
 2679              		.loc 1 539 0
 2680 1dd4 488B8520 		movq	-224(%rbp), %rax
 2680      FFFFFF
 2681 1ddb 4885C0   		testq	%rax, %rax
 2682 1dde 742F     		je	.L169
 540:main.c        ****         fprintf(stderr, "%s\n", error);
 2683              		.loc 1 540 0
 2684 1de0 488B9520 		movq	-224(%rbp), %rdx
 2684      FFFFFF
 2685 1de7 488B0500 		movq	stderr(%rip), %rax
 2685      000000
 2686 1dee BE000000 		movl	$.LC63, %esi
 2686      00
 2687 1df3 4889C7   		movq	%rax, %rdi
 2688 1df6 B8000000 		movl	$0, %eax
 2688      00
 2689 1dfb E8000000 		call	fprintf
 2689      00
 541:main.c        ****         flFreeError(error);
 2690              		.loc 1 541 0
 2691 1e00 488B8520 		movq	-224(%rbp), %rax
 2691      FFFFFF
 2692 1e07 4889C7   		movq	%rax, %rdi
 2693 1e0a E8000000 		call	flFreeError
 2693      00
 2694              	.L169:
 542:main.c        ****     }
 543:main.c        ****     return retVal;
 2695              		.loc 1 543 0
 2696 1e0f 8B85BCFE 		movl	-324(%rbp), %eax
 2696      FFFF
 2697              	.L170:
 544:main.c        **** }...
 2698              		.loc 1 544 0
 2699 1e15 4881C488 		addq	$392, %rsp
 2699      010000
 2700 1e1c 5B       		popq	%rbx
 2701 1e1d 5D       		popq	%rbp
 2702              		.cfi_def_cfa 7, 8
 2703 1e1e C3       		ret
 2704              		.cfi_endproc
 2705              	.LFE14:
 2707              	.Letext0:
 2708              		.file 2 "/usr/include/stdint.h"
 2709              		.file 3 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
 2710              		.file 4 "/usr/include/x86_64-linux-gnu/bits/types.h"
 2711              		.file 5 "/usr/include/stdio.h"
 2712              		.file 6 "/usr/include/libio.h"
 2713              		.file 7 "/home/pandu/Desktop/DigitalLogicDesign/Lab/03-finishingup/backend/libs/libargtable2/argta
 2714              		.file 8 "/home/pandu/Desktop/DigitalLogicDesign/Lab/03-finishingup/backend/common/makestuff.h"
 2715              		.file 9 "/home/pandu/Desktop/DigitalLogicDesign/Lab/03-finishingup/backend/libs/libfpgalink/libfpg
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
                            *COM*:0000000000186a50 dataFromCSV
     /tmp/cc3V5fTg.s:10     .bss:0000000000000000 numLines
     /tmp/cc3V5fTg.s:15     .bss:0000000000000004 LOG
     /tmp/cc3V5fTg.s:20     .text:0000000000000000 decrypt
     /tmp/cc3V5fTg.s:122    .text:00000000000000dd encrypt
     /tmp/cc3V5fTg.s:223    .text:00000000000001ba decrypt64
     /tmp/cc3V5fTg.s:257    .text:00000000000001f7 encrypt64
     /tmp/cc3V5fTg.s:291    .text:0000000000000234 myHash
     /tmp/cc3V5fTg.s:365    .text:00000000000002a8 format
     /tmp/cc3V5fTg.s:421    .text:0000000000000328 find
     /tmp/cc3V5fTg.s:508    .text:00000000000003d5 suffBal
     /tmp/cc3V5fTg.s:603    .rodata:00000000000000e0 errMessages
     /tmp/cc3V5fTg.s:739    .text:000000000000046b main

UNDEFINED SYMBOLS
strtok
sscanf
arg_str0
arg_str1
arg_lit0
arg_end
arg_nullcheck
stderr
fprintf
arg_parse
printf
stdout
arg_print_syntax
puts
arg_print_glossary
arg_print_errors
flInitialise
flOpen
flLoadCustomFirmware
flLoadStandardFirmware
flSleep
putchar
fflush
flIsDeviceAvailable
flGetFirmwareVersion
flGetFirmwareID
flIsCommCapable
flSelectConduit
flIsFPGARunning
fopen
malloc
getline
free
fclose
flReadChannel
flWriteChannel
fwrite
fputc
flClose
flFreeError
