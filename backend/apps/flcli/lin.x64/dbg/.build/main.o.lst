   1              		.file	"main.c"
   2              		.text
   3              	.Ltext0:
   4              		.comm	dataFromCSV,1600080,32
   5              		.globl	numLines
   6              		.bss
   7              		.align 4
  10              	numLines:
  11 0000 00000000 		.zero	4
  12              		.globl	LOG
  15              	LOG:
  16 0004 00       		.zero	1
  17              		.text
  18              		.globl	decrypt
  20              	decrypt:
  21              	.LFB6:
  22              		.file 1 "main.c"
   1:main.c        **** /*
   2:main.c        ****    Original 64 bit -> | User 16-bit | Password 16-bit | 2k 8-bit | 1k 8-bit | 500 8-bit | 100 8-bit
   3:main.c        ****    (in VHDL before encryption)  8 7 6 5 4 3 2 1	
   4:main.c        **** */
   5:main.c        **** #define _GNU_SOURCE
   6:main.c        **** 
   7:main.c        **** #include <stdint.h>
   8:main.c        **** #include <stdbool.h>
   9:main.c        **** #include <stdio.h>
  10:main.c        **** #include <stdlib.h>
  11:main.c        **** #include <argtable2.h>
  12:main.c        **** #include <string.h>
  13:main.c        **** #include <libfpgalink.h>
  14:main.c        **** 
  15:main.c        **** #include <errno.h>
  16:main.c        **** #include <makestuff.h>
  17:main.c        **** #include <libbuffer.h>
  18:main.c        **** #include <liberror.h>
  19:main.c        **** #include <libdump.h>
  20:main.c        **** #include <readline/readline.h>
  21:main.c        **** #include <readline/history.h>
  22:main.c        **** 
  23:main.c        **** #ifdef WIN32
  24:main.c        **** #include <Windows.h>
  25:main.c        **** #else
  26:main.c        **** 
  27:main.c        **** #include <sys/time.h>
  28:main.c        **** 
  29:main.c        **** #endif
  30:main.c        **** #define N 100005
  31:main.c        **** 
  32:main.c        **** int dataFromCSV[N][4];
  33:main.c        **** int numLines = 0;
  34:main.c        **** bool LOG = false;
  35:main.c        **** 
  36:main.c        **** /* Adapted from tiny encryption algorithm wikipedia */
  37:main.c        **** void decrypt(uint32_t *v, uint32_t *k) {
  23              		.loc 1 37 0
  24              		.cfi_startproc
  25 0000 55       		pushq	%rbp
  26              		.cfi_def_cfa_offset 16
  27              		.cfi_offset 6, -16
  28 0001 4889E5   		movq	%rsp, %rbp
  29              		.cfi_def_cfa_register 6
  30 0004 48897DC8 		movq	%rdi, -56(%rbp)
  31 0008 488975C0 		movq	%rsi, -64(%rbp)
  38:main.c        ****     uint32_t v0 = v[0], v1 = v[1], sum = 0xC6EF3720, i;  /* set up */
  32              		.loc 1 38 0
  33 000c 488B45C8 		movq	-56(%rbp), %rax
  34 0010 8B00     		movl	(%rax), %eax
  35 0012 8945DC   		movl	%eax, -36(%rbp)
  36 0015 488B45C8 		movq	-56(%rbp), %rax
  37 0019 8B4004   		movl	4(%rax), %eax
  38 001c 8945E0   		movl	%eax, -32(%rbp)
  39 001f C745E420 		movl	$-957401312, -28(%rbp)
  39      37EFC6
  39:main.c        ****     uint32_t delta = 0x9e3779b9;                     /* a key schedule constant */
  40              		.loc 1 39 0
  41 0026 C745ECB9 		movl	$-1640531527, -20(%rbp)
  41      79379E
  40:main.c        ****     uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3];   /* cache key */
  42              		.loc 1 40 0
  43 002d 488B45C0 		movq	-64(%rbp), %rax
  44 0031 8B00     		movl	(%rax), %eax
  45 0033 8945F0   		movl	%eax, -16(%rbp)
  46 0036 488B45C0 		movq	-64(%rbp), %rax
  47 003a 8B4004   		movl	4(%rax), %eax
  48 003d 8945F4   		movl	%eax, -12(%rbp)
  49 0040 488B45C0 		movq	-64(%rbp), %rax
  50 0044 8B4008   		movl	8(%rax), %eax
  51 0047 8945F8   		movl	%eax, -8(%rbp)
  52 004a 488B45C0 		movq	-64(%rbp), %rax
  53 004e 8B400C   		movl	12(%rax), %eax
  54 0051 8945FC   		movl	%eax, -4(%rbp)
  41:main.c        ****     /* basic cycle start */
  42:main.c        ****     for (i = 0; i < 32; i++) {
  55              		.loc 1 42 0
  56 0054 C745E800 		movl	$0, -24(%rbp)
  56      000000
  57 005b EB62     		jmp	.L2
  58              	.L3:
  43:main.c        ****         v1 -= ((v0 << 4) + k2) ^ (v0 + sum) ^ ((v0 >> 5) + k3);
  59              		.loc 1 43 0 discriminator 2
  60 005d 8B45DC   		movl	-36(%rbp), %eax
  61 0060 C1E004   		sall	$4, %eax
  62 0063 89C2     		movl	%eax, %edx
  63 0065 8B45F8   		movl	-8(%rbp), %eax
  64 0068 8D0C02   		leal	(%rdx,%rax), %ecx
  65 006b 8B45E4   		movl	-28(%rbp), %eax
  66 006e 8B55DC   		movl	-36(%rbp), %edx
  67 0071 01D0     		addl	%edx, %eax
  68 0073 31C1     		xorl	%eax, %ecx
  69 0075 89CA     		movl	%ecx, %edx
  70 0077 8B45DC   		movl	-36(%rbp), %eax
  71 007a C1E805   		shrl	$5, %eax
  72 007d 89C1     		movl	%eax, %ecx
  73 007f 8B45FC   		movl	-4(%rbp), %eax
  74 0082 01C8     		addl	%ecx, %eax
  75 0084 31D0     		xorl	%edx, %eax
  76 0086 2945E0   		subl	%eax, -32(%rbp)
  44:main.c        ****         v0 -= ((v1 << 4) + k0) ^ (v1 + sum) ^ ((v1 >> 5) + k1);
  77              		.loc 1 44 0 discriminator 2
  78 0089 8B45E0   		movl	-32(%rbp), %eax
  79 008c C1E004   		sall	$4, %eax
  80 008f 89C2     		movl	%eax, %edx
  81 0091 8B45F0   		movl	-16(%rbp), %eax
  82 0094 8D0C02   		leal	(%rdx,%rax), %ecx
  83 0097 8B45E4   		movl	-28(%rbp), %eax
  84 009a 8B55E0   		movl	-32(%rbp), %edx
  85 009d 01D0     		addl	%edx, %eax
  86 009f 31C1     		xorl	%eax, %ecx
  87 00a1 89CA     		movl	%ecx, %edx
  88 00a3 8B45E0   		movl	-32(%rbp), %eax
  89 00a6 C1E805   		shrl	$5, %eax
  90 00a9 89C1     		movl	%eax, %ecx
  91 00ab 8B45F4   		movl	-12(%rbp), %eax
  92 00ae 01C8     		addl	%ecx, %eax
  93 00b0 31D0     		xorl	%edx, %eax
  94 00b2 2945DC   		subl	%eax, -36(%rbp)
  45:main.c        ****         sum -= delta;
  95              		.loc 1 45 0 discriminator 2
  96 00b5 8B45EC   		movl	-20(%rbp), %eax
  97 00b8 2945E4   		subl	%eax, -28(%rbp)
  42:main.c        ****         v1 -= ((v0 << 4) + k2) ^ (v0 + sum) ^ ((v0 >> 5) + k3);
  98              		.loc 1 42 0 discriminator 2
  99 00bb 8345E801 		addl	$1, -24(%rbp)
 100              	.L2:
  42:main.c        ****         v1 -= ((v0 << 4) + k2) ^ (v0 + sum) ^ ((v0 >> 5) + k3);
 101              		.loc 1 42 0 is_stmt 0 discriminator 1
 102 00bf 837DE81F 		cmpl	$31, -24(%rbp)
 103 00c3 7698     		jbe	.L3
  46:main.c        ****     }
  47:main.c        ****     /* end cycle */
  48:main.c        ****     v[0] = v0;
 104              		.loc 1 48 0 is_stmt 1
 105 00c5 488B45C8 		movq	-56(%rbp), %rax
 106 00c9 8B55DC   		movl	-36(%rbp), %edx
 107 00cc 8910     		movl	%edx, (%rax)
  49:main.c        ****     v[1] = v1;
 108              		.loc 1 49 0
 109 00ce 488B45C8 		movq	-56(%rbp), %rax
 110 00d2 488D5004 		leaq	4(%rax), %rdx
 111 00d6 8B45E0   		movl	-32(%rbp), %eax
 112 00d9 8902     		movl	%eax, (%rdx)
  50:main.c        **** }
 113              		.loc 1 50 0
 114 00db 5D       		popq	%rbp
 115              		.cfi_def_cfa 7, 8
 116 00dc C3       		ret
 117              		.cfi_endproc
 118              	.LFE6:
 120              		.globl	encrypt
 122              	encrypt:
 123              	.LFB7:
  51:main.c        **** 
  52:main.c        **** /* Adapted from tiny encryption algorithm wikipedia */
  53:main.c        **** void encrypt(uint32_t *v, uint32_t *k) {
 124              		.loc 1 53 0
 125              		.cfi_startproc
 126 00dd 55       		pushq	%rbp
 127              		.cfi_def_cfa_offset 16
 128              		.cfi_offset 6, -16
 129 00de 4889E5   		movq	%rsp, %rbp
 130              		.cfi_def_cfa_register 6
 131 00e1 48897DC8 		movq	%rdi, -56(%rbp)
 132 00e5 488975C0 		movq	%rsi, -64(%rbp)
  54:main.c        ****     uint32_t v0 = v[0], v1 = v[1], sum = 0, i;           /* set up */
 133              		.loc 1 54 0
 134 00e9 488B45C8 		movq	-56(%rbp), %rax
 135 00ed 8B00     		movl	(%rax), %eax
 136 00ef 8945DC   		movl	%eax, -36(%rbp)
 137 00f2 488B45C8 		movq	-56(%rbp), %rax
 138 00f6 8B4004   		movl	4(%rax), %eax
 139 00f9 8945E0   		movl	%eax, -32(%rbp)
 140 00fc C745E400 		movl	$0, -28(%rbp)
 140      000000
  55:main.c        ****     uint32_t delta = 0x9e3779b9;                     /* a key schedule constant */
 141              		.loc 1 55 0
 142 0103 C745ECB9 		movl	$-1640531527, -20(%rbp)
 142      79379E
  56:main.c        ****     uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3];   /* cache key */
 143              		.loc 1 56 0
 144 010a 488B45C0 		movq	-64(%rbp), %rax
 145 010e 8B00     		movl	(%rax), %eax
 146 0110 8945F0   		movl	%eax, -16(%rbp)
 147 0113 488B45C0 		movq	-64(%rbp), %rax
 148 0117 8B4004   		movl	4(%rax), %eax
 149 011a 8945F4   		movl	%eax, -12(%rbp)
 150 011d 488B45C0 		movq	-64(%rbp), %rax
 151 0121 8B4008   		movl	8(%rax), %eax
 152 0124 8945F8   		movl	%eax, -8(%rbp)
 153 0127 488B45C0 		movq	-64(%rbp), %rax
 154 012b 8B400C   		movl	12(%rax), %eax
 155 012e 8945FC   		movl	%eax, -4(%rbp)
  57:main.c        ****     /* basic cycle start */
  58:main.c        ****     for (i = 0; i < 32; i++) {
 156              		.loc 1 58 0
 157 0131 C745E800 		movl	$0, -24(%rbp)
 157      000000
 158 0138 EB62     		jmp	.L5
 159              	.L6:
  59:main.c        ****         sum += delta;
 160              		.loc 1 59 0 discriminator 2
 161 013a 8B45EC   		movl	-20(%rbp), %eax
 162 013d 0145E4   		addl	%eax, -28(%rbp)
  60:main.c        ****         v0 += ((v1 << 4) + k0) ^ (v1 + sum) ^ ((v1 >> 5) + k1);
 163              		.loc 1 60 0 discriminator 2
 164 0140 8B45E0   		movl	-32(%rbp), %eax
 165 0143 C1E004   		sall	$4, %eax
 166 0146 89C2     		movl	%eax, %edx
 167 0148 8B45F0   		movl	-16(%rbp), %eax
 168 014b 8D0C02   		leal	(%rdx,%rax), %ecx
 169 014e 8B45E4   		movl	-28(%rbp), %eax
 170 0151 8B55E0   		movl	-32(%rbp), %edx
 171 0154 01D0     		addl	%edx, %eax
 172 0156 31C1     		xorl	%eax, %ecx
 173 0158 89CA     		movl	%ecx, %edx
 174 015a 8B45E0   		movl	-32(%rbp), %eax
 175 015d C1E805   		shrl	$5, %eax
 176 0160 89C1     		movl	%eax, %ecx
 177 0162 8B45F4   		movl	-12(%rbp), %eax
 178 0165 01C8     		addl	%ecx, %eax
 179 0167 31D0     		xorl	%edx, %eax
 180 0169 0145DC   		addl	%eax, -36(%rbp)
  61:main.c        ****         v1 += ((v0 << 4) + k2) ^ (v0 + sum) ^ ((v0 >> 5) + k3);
 181              		.loc 1 61 0 discriminator 2
 182 016c 8B45DC   		movl	-36(%rbp), %eax
 183 016f C1E004   		sall	$4, %eax
 184 0172 89C2     		movl	%eax, %edx
 185 0174 8B45F8   		movl	-8(%rbp), %eax
 186 0177 8D0C02   		leal	(%rdx,%rax), %ecx
 187 017a 8B45E4   		movl	-28(%rbp), %eax
 188 017d 8B55DC   		movl	-36(%rbp), %edx
 189 0180 01D0     		addl	%edx, %eax
 190 0182 31C1     		xorl	%eax, %ecx
 191 0184 89CA     		movl	%ecx, %edx
 192 0186 8B45DC   		movl	-36(%rbp), %eax
 193 0189 C1E805   		shrl	$5, %eax
 194 018c 89C1     		movl	%eax, %ecx
 195 018e 8B45FC   		movl	-4(%rbp), %eax
 196 0191 01C8     		addl	%ecx, %eax
 197 0193 31D0     		xorl	%edx, %eax
 198 0195 0145E0   		addl	%eax, -32(%rbp)
  58:main.c        ****         sum += delta;
 199              		.loc 1 58 0 discriminator 2
 200 0198 8345E801 		addl	$1, -24(%rbp)
 201              	.L5:
  58:main.c        ****         sum += delta;
 202              		.loc 1 58 0 is_stmt 0 discriminator 1
 203 019c 837DE81F 		cmpl	$31, -24(%rbp)
 204 01a0 7698     		jbe	.L6
  62:main.c        ****     }
  63:main.c        ****     /* end cycle */
  64:main.c        ****     v[0] = v0;
 205              		.loc 1 64 0 is_stmt 1
 206 01a2 488B45C8 		movq	-56(%rbp), %rax
 207 01a6 8B55DC   		movl	-36(%rbp), %edx
 208 01a9 8910     		movl	%edx, (%rax)
  65:main.c        ****     v[1] = v1;
 209              		.loc 1 65 0
 210 01ab 488B45C8 		movq	-56(%rbp), %rax
 211 01af 488D5004 		leaq	4(%rax), %rdx
 212 01b3 8B45E0   		movl	-32(%rbp), %eax
 213 01b6 8902     		movl	%eax, (%rdx)
  66:main.c        **** }
 214              		.loc 1 66 0
 215 01b8 5D       		popq	%rbp
 216              		.cfi_def_cfa 7, 8
 217 01b9 C3       		ret
 218              		.cfi_endproc
 219              	.LFE7:
 221              		.globl	decrypt64
 223              	decrypt64:
 224              	.LFB8:
  67:main.c        **** 
  68:main.c        **** void decrypt64(uint32_t *inpData) {
 225              		.loc 1 68 0
 226              		.cfi_startproc
 227 01ba 55       		pushq	%rbp
 228              		.cfi_def_cfa_offset 16
 229              		.cfi_offset 6, -16
 230 01bb 4889E5   		movq	%rsp, %rbp
 231              		.cfi_def_cfa_register 6
 232 01be 4883EC18 		subq	$24, %rsp
 233 01c2 48897DE8 		movq	%rdi, -24(%rbp)
  69:main.c        ****     uint32_t key[4];
  70:main.c        ****     key[0] = 0x2927c18c;
 234              		.loc 1 70 0
 235 01c6 C745F08C 		movl	$690471308, -16(%rbp)
 235      C12729
  71:main.c        ****     key[1] = 0x75f8c48f;
 236              		.loc 1 71 0
 237 01cd C745F48F 		movl	$1979237519, -12(%rbp)
 237      C4F875
  72:main.c        ****     key[2] = 0x43fd99f7;
 238              		.loc 1 72 0
 239 01d4 C745F8F7 		movl	$1140693495, -8(%rbp)
 239      99FD43
  73:main.c        ****     key[3] = 0xff0f7457;
 240              		.loc 1 73 0
 241 01db C745FC57 		movl	$-15764393, -4(%rbp)
 241      740FFF
  74:main.c        ****     decrypt(inpData, key);
 242              		.loc 1 74 0
 243 01e2 488D55F0 		leaq	-16(%rbp), %rdx
 244 01e6 488B45E8 		movq	-24(%rbp), %rax
 245 01ea 4889D6   		movq	%rdx, %rsi
 246 01ed 4889C7   		movq	%rax, %rdi
 247 01f0 E8000000 		call	decrypt
 247      00
  75:main.c        **** }
 248              		.loc 1 75 0
 249 01f5 C9       		leave
 250              		.cfi_def_cfa 7, 8
 251 01f6 C3       		ret
 252              		.cfi_endproc
 253              	.LFE8:
 255              		.globl	encrypt64
 257              	encrypt64:
 258              	.LFB9:
  76:main.c        **** 
  77:main.c        **** void encrypt64(uint32_t *inpData) {
 259              		.loc 1 77 0
 260              		.cfi_startproc
 261 01f7 55       		pushq	%rbp
 262              		.cfi_def_cfa_offset 16
 263              		.cfi_offset 6, -16
 264 01f8 4889E5   		movq	%rsp, %rbp
 265              		.cfi_def_cfa_register 6
 266 01fb 4883EC18 		subq	$24, %rsp
 267 01ff 48897DE8 		movq	%rdi, -24(%rbp)
  78:main.c        ****     uint32_t key[4];
  79:main.c        ****     key[0] = 0x2927c18c;
 268              		.loc 1 79 0
 269 0203 C745F08C 		movl	$690471308, -16(%rbp)
 269      C12729
  80:main.c        ****     key[1] = 0x75f8c48f;
 270              		.loc 1 80 0
 271 020a C745F48F 		movl	$1979237519, -12(%rbp)
 271      C4F875
  81:main.c        ****     key[2] = 0x43fd99f7;
 272              		.loc 1 81 0
 273 0211 C745F8F7 		movl	$1140693495, -8(%rbp)
 273      99FD43
  82:main.c        ****     key[3] = 0xff0f7457;
 274              		.loc 1 82 0
 275 0218 C745FC57 		movl	$-15764393, -4(%rbp)
 275      740FFF
  83:main.c        ****     encrypt(inpData, key);
 276              		.loc 1 83 0
 277 021f 488D55F0 		leaq	-16(%rbp), %rdx
 278 0223 488B45E8 		movq	-24(%rbp), %rax
 279 0227 4889D6   		movq	%rdx, %rsi
 280 022a 4889C7   		movq	%rax, %rdi
 281 022d E8000000 		call	encrypt
 281      00
  84:main.c        **** }
 282              		.loc 1 84 0
 283 0232 C9       		leave
 284              		.cfi_def_cfa 7, 8
 285 0233 C3       		ret
 286              		.cfi_endproc
 287              	.LFE9:
 289              		.globl	myHash
 291              	myHash:
 292              	.LFB10:
  85:main.c        **** 
  86:main.c        **** uint16_t myHash(uint16_t befHash) {
 293              		.loc 1 86 0
 294              		.cfi_startproc
 295 0234 55       		pushq	%rbp
 296              		.cfi_def_cfa_offset 16
 297              		.cfi_offset 6, -16
 298 0235 4889E5   		movq	%rsp, %rbp
 299              		.cfi_def_cfa_register 6
 300 0238 89F8     		movl	%edi, %eax
 301 023a 668945EC 		movw	%ax, -20(%rbp)
  87:main.c        ****     uint16_t ret = 0;
 302              		.loc 1 87 0
 303 023e 66C745FA 		movw	$0, -6(%rbp)
 303      0000
 304              	.LBB2:
  88:main.c        ****     for (uint16_t i = 0; i <= 15; i++) {
 305              		.loc 1 88 0
 306 0244 66C745FC 		movw	$0, -4(%rbp)
 306      0000
 307 024a EB4F     		jmp	.L10
 308              	.L12:
  89:main.c        ****         if ((befHash & (1 << i)) != 0) {
 309              		.loc 1 89 0
 310 024c 0FB755EC 		movzwl	-20(%rbp), %edx
 311 0250 0FB745FC 		movzwl	-4(%rbp), %eax
 312 0254 89C1     		movl	%eax, %ecx
 313 0256 D3FA     		sarl	%cl, %edx
 314 0258 89D0     		movl	%edx, %eax
 315 025a 83E001   		andl	$1, %eax
 316 025d 85C0     		testl	%eax, %eax
 317 025f 742F     		je	.L11
 318              	.LBB3:
  90:main.c        ****             uint16_t j = ((i + 11) % 16);
 319              		.loc 1 90 0
 320 0261 0FB745FC 		movzwl	-4(%rbp), %eax
 321 0265 8D500B   		leal	11(%rax), %edx
 322 0268 89D0     		movl	%edx, %eax
 323 026a C1F81F   		sarl	$31, %eax
 324 026d C1E81C   		shrl	$28, %eax
 325 0270 01C2     		addl	%eax, %edx
 326 0272 83E20F   		andl	$15, %edx
 327 0275 29C2     		subl	%eax, %edx
 328 0277 89D0     		movl	%edx, %eax
 329 0279 668945FE 		movw	%ax, -2(%rbp)
  91:main.c        ****             ret += (1 << j);
 330              		.loc 1 91 0
 331 027d 0FB745FE 		movzwl	-2(%rbp), %eax
 332 0281 BA010000 		movl	$1, %edx
 332      00
 333 0286 89C1     		movl	%eax, %ecx
 334 0288 D3E2     		sall	%cl, %edx
 335 028a 89D0     		movl	%edx, %eax
 336 028c 660145FA 		addw	%ax, -6(%rbp)
 337              	.L11:
 338              	.LBE3:
  88:main.c        ****         if ((befHash & (1 << i)) != 0) {
 339              		.loc 1 88 0
 340 0290 0FB745FC 		movzwl	-4(%rbp), %eax
 341 0294 83C001   		addl	$1, %eax
 342 0297 668945FC 		movw	%ax, -4(%rbp)
 343              	.L10:
  88:main.c        ****         if ((befHash & (1 << i)) != 0) {
 344              		.loc 1 88 0 is_stmt 0 discriminator 1
 345 029b 66837DFC 		cmpw	$15, -4(%rbp)
 345      0F
 346 02a0 76AA     		jbe	.L12
 347              	.LBE2:
  92:main.c        ****         }
  93:main.c        ****     }
  94:main.c        ****     return ret;
 348              		.loc 1 94 0 is_stmt 1
 349 02a2 0FB745FA 		movzwl	-6(%rbp), %eax
  95:main.c        **** }
 350              		.loc 1 95 0
 351 02a6 5D       		popq	%rbp
 352              		.cfi_def_cfa 7, 8
 353 02a7 C3       		ret
 354              		.cfi_endproc
 355              	.LFE10:
 357              		.section	.rodata
 358              	.LC0:
 359 0000 2C00     		.string	","
 360              	.LC1:
 361 0002 256400   		.string	"%d"
 362              		.text
 363              		.globl	format
 365              	format:
 366              	.LFB11:
  96:main.c        **** 
  97:main.c        **** void format(char *line) {
 367              		.loc 1 97 0
 368              		.cfi_startproc
 369 02a8 55       		pushq	%rbp
 370              		.cfi_def_cfa_offset 16
 371              		.cfi_offset 6, -16
 372 02a9 4889E5   		movq	%rsp, %rbp
 373              		.cfi_def_cfa_register 6
 374 02ac 4883EC20 		subq	$32, %rsp
 375 02b0 48897DE8 		movq	%rdi, -24(%rbp)
  98:main.c        ****     char *wordPtr;
  99:main.c        ****     wordPtr = strtok(line, ",");
 376              		.loc 1 99 0
 377 02b4 488B45E8 		movq	-24(%rbp), %rax
 378 02b8 BE000000 		movl	$.LC0, %esi
 378      00
 379 02bd 4889C7   		movq	%rax, %rdi
 380 02c0 E8000000 		call	strtok
 380      00
 381 02c5 488945F8 		movq	%rax, -8(%rbp)
 100:main.c        ****     int cnt = 0;
 382              		.loc 1 100 0
 383 02c9 C745F400 		movl	$0, -12(%rbp)
 383      000000
 101:main.c        ****     while (wordPtr != NULL) {
 384              		.loc 1 101 0
 385 02d0 EB4D     		jmp	.L15
 386              	.L16:
 102:main.c        ****         sscanf(wordPtr, "%d", &dataFromCSV[numLines][cnt]);
 387              		.loc 1 102 0
 388 02d2 8B150000 		movl	numLines(%rip), %edx
 388      0000
 389 02d8 8B45F4   		movl	-12(%rbp), %eax
 390 02db 4898     		cltq
 391 02dd 4863D2   		movslq	%edx, %rdx
 392 02e0 48C1E202 		salq	$2, %rdx
 393 02e4 4801D0   		addq	%rdx, %rax
 394 02e7 48C1E002 		salq	$2, %rax
 395 02eb 488D9000 		leaq	dataFromCSV(%rax), %rdx
 395      000000
 396 02f2 488B45F8 		movq	-8(%rbp), %rax
 397 02f6 BE000000 		movl	$.LC1, %esi
 397      00
 398 02fb 4889C7   		movq	%rax, %rdi
 399 02fe B8000000 		movl	$0, %eax
 399      00
 400 0303 E8000000 		call	sscanf
 400      00
 103:main.c        ****         wordPtr = strtok(NULL, ",");
 401              		.loc 1 103 0
 402 0308 BE000000 		movl	$.LC0, %esi
 402      00
 403 030d BF000000 		movl	$0, %edi
 403      00
 404 0312 E8000000 		call	strtok
 404      00
 405 0317 488945F8 		movq	%rax, -8(%rbp)
 104:main.c        ****         cnt++;
 406              		.loc 1 104 0
 407 031b 8345F401 		addl	$1, -12(%rbp)
 408              	.L15:
 101:main.c        ****         sscanf(wordPtr, "%d", &dataFromCSV[numLines][cnt]);
 409              		.loc 1 101 0 discriminator 1
 410 031f 48837DF8 		cmpq	$0, -8(%rbp)
 410      00
 411 0324 75AC     		jne	.L16
 105:main.c        ****     }
 106:main.c        **** }
 412              		.loc 1 106 0
 413 0326 C9       		leave
 414              		.cfi_def_cfa 7, 8
 415 0327 C3       		ret
 416              		.cfi_endproc
 417              	.LFE11:
 419              		.globl	find
 421              	find:
 422              	.LFB12:
 107:main.c        **** 
 108:main.c        **** bool find(uint16_t userID, uint16_t hashedPin, bool *isAdmin, int *bal, int *inLineNum) {
 423              		.loc 1 108 0
 424              		.cfi_startproc
 425 0328 55       		pushq	%rbp
 426              		.cfi_def_cfa_offset 16
 427              		.cfi_offset 6, -16
 428 0329 4889E5   		movq	%rsp, %rbp
 429              		.cfi_def_cfa_register 6
 430 032c 89F0     		movl	%esi, %eax
 431 032e 488955E0 		movq	%rdx, -32(%rbp)
 432 0332 48894DD8 		movq	%rcx, -40(%rbp)
 433 0336 4C8945D0 		movq	%r8, -48(%rbp)
 434 033a 66897DEC 		movw	%di, -20(%rbp)
 435 033e 668945E8 		movw	%ax, -24(%rbp)
 109:main.c        ****     bool pos = false;
 436              		.loc 1 109 0
 437 0342 C645FB00 		movb	$0, -5(%rbp)
 438              	.LBB4:
 110:main.c        ****     for (int i = 1; i <= numLines; i++) {
 439              		.loc 1 110 0
 440 0346 C745FC01 		movl	$1, -4(%rbp)
 440      000000
 441 034d EB75     		jmp	.L18
 442              	.L22:
 111:main.c        ****         if (userID == (uint16_t) dataFromCSV[i][0] && hashedPin == (uint16_t) dataFromCSV[i][1]) {
 443              		.loc 1 111 0
 444 034f 8B45FC   		movl	-4(%rbp), %eax
 445 0352 4898     		cltq
 446 0354 48C1E004 		salq	$4, %rax
 447 0358 48050000 		addq	$dataFromCSV, %rax
 447      0000
 448 035e 8B00     		movl	(%rax), %eax
 449 0360 663B45EC 		cmpw	-20(%rbp), %ax
 450 0364 755A     		jne	.L19
 451              		.loc 1 111 0 is_stmt 0 discriminator 1
 452 0366 8B45FC   		movl	-4(%rbp), %eax
 453 0369 4898     		cltq
 454 036b 48C1E004 		salq	$4, %rax
 455 036f 48050000 		addq	$dataFromCSV+4, %rax
 455      0000
 456 0375 8B00     		movl	(%rax), %eax
 457 0377 663B45E8 		cmpw	-24(%rbp), %ax
 458 037b 7543     		jne	.L19
 112:main.c        ****             pos = true;
 459              		.loc 1 112 0 is_stmt 1
 460 037d C645FB01 		movb	$1, -5(%rbp)
 113:main.c        ****             if (dataFromCSV[i][2] == 1) *isAdmin = true;
 461              		.loc 1 113 0
 462 0381 8B45FC   		movl	-4(%rbp), %eax
 463 0384 4898     		cltq
 464 0386 48C1E004 		salq	$4, %rax
 465 038a 48050000 		addq	$dataFromCSV+8, %rax
 465      0000
 466 0390 8B00     		movl	(%rax), %eax
 467 0392 83F801   		cmpl	$1, %eax
 468 0395 7507     		jne	.L20
 469              		.loc 1 113 0 is_stmt 0 discriminator 1
 470 0397 488B45E0 		movq	-32(%rbp), %rax
 471 039b C60001   		movb	$1, (%rax)
 472              	.L20:
 114:main.c        ****             *bal = dataFromCSV[i][3];
 473              		.loc 1 114 0 is_stmt 1
 474 039e 8B45FC   		movl	-4(%rbp), %eax
 475 03a1 4898     		cltq
 476 03a3 48C1E004 		salq	$4, %rax
 477 03a7 48050000 		addq	$dataFromCSV+12, %rax
 477      0000
 478 03ad 8B10     		movl	(%rax), %edx
 479 03af 488B45D8 		movq	-40(%rbp), %rax
 480 03b3 8910     		movl	%edx, (%rax)
 115:main.c        ****             *inLineNum = i;
 481              		.loc 1 115 0
 482 03b5 488B45D0 		movq	-48(%rbp), %rax
 483 03b9 8B55FC   		movl	-4(%rbp), %edx
 484 03bc 8910     		movl	%edx, (%rax)
 116:main.c        ****             break;
 485              		.loc 1 116 0
 486 03be EB0F     		jmp	.L21
 487              	.L19:
 110:main.c        ****         if (userID == (uint16_t) dataFromCSV[i][0] && hashedPin == (uint16_t) dataFromCSV[i][1]) {
 488              		.loc 1 110 0
 489 03c0 8345FC01 		addl	$1, -4(%rbp)
 490              	.L18:
 110:main.c        ****         if (userID == (uint16_t) dataFromCSV[i][0] && hashedPin == (uint16_t) dataFromCSV[i][1]) {
 491              		.loc 1 110 0 is_stmt 0 discriminator 1
 492 03c4 8B050000 		movl	numLines(%rip), %eax
 492      0000
 493 03ca 3945FC   		cmpl	%eax, -4(%rbp)
 494 03cd 7E80     		jle	.L22
 495              	.L21:
 496              	.LBE4:
 117:main.c        ****         }
 118:main.c        ****     }
 119:main.c        ****     return pos;
 497              		.loc 1 119 0 is_stmt 1
 498 03cf 0FB645FB 		movzbl	-5(%rbp), %eax
 120:main.c        **** }
 499              		.loc 1 120 0
 500 03d3 5D       		popq	%rbp
 501              		.cfi_def_cfa 7, 8
 502 03d4 C3       		ret
 503              		.cfi_endproc
 504              	.LFE12:
 506              		.globl	suffBal
 508              	suffBal:
 509              	.LFB13:
 121:main.c        **** 
 122:main.c        **** bool suffBal(int bal, int *reqAmo, uint8_t num_100, uint8_t num_500, uint8_t num_1000, uint8_t num_
 510              		.loc 1 122 0
 511              		.cfi_startproc
 512 03d5 55       		pushq	%rbp
 513              		.cfi_def_cfa_offset 16
 514              		.cfi_offset 6, -16
 515 03d6 4889E5   		movq	%rsp, %rbp
 516              		.cfi_def_cfa_register 6
 517 03d9 897DEC   		movl	%edi, -20(%rbp)
 518 03dc 488975E0 		movq	%rsi, -32(%rbp)
 519 03e0 89C8     		movl	%ecx, %eax
 520 03e2 4489C6   		movl	%r8d, %esi
 521 03e5 4489C9   		movl	%r9d, %ecx
 522 03e8 8855E8   		movb	%dl, -24(%rbp)
 523 03eb 8845DC   		movb	%al, -36(%rbp)
 524 03ee 408875D8 		movb	%sil, -40(%rbp)
 525 03f2 884DD4   		movb	%cl, -44(%rbp)
 123:main.c        ****     bool hasSuffBal = true;
 526              		.loc 1 123 0
 527 03f5 C645FF01 		movb	$1, -1(%rbp)
 124:main.c        ****     *reqAmo += 100 * ((int) num_100);
 528              		.loc 1 124 0
 529 03f9 488B45E0 		movq	-32(%rbp), %rax
 530 03fd 8B10     		movl	(%rax), %edx
 531 03ff 0FB645E8 		movzbl	-24(%rbp), %eax
 532 0403 6BC064   		imull	$100, %eax, %eax
 533 0406 01C2     		addl	%eax, %edx
 534 0408 488B45E0 		movq	-32(%rbp), %rax
 535 040c 8910     		movl	%edx, (%rax)
 125:main.c        ****     *reqAmo += 500 * ((int) num_500);
 536              		.loc 1 125 0
 537 040e 488B45E0 		movq	-32(%rbp), %rax
 538 0412 8B10     		movl	(%rax), %edx
 539 0414 0FB645DC 		movzbl	-36(%rbp), %eax
 540 0418 69C0F401 		imull	$500, %eax, %eax
 540      0000
 541 041e 01C2     		addl	%eax, %edx
 542 0420 488B45E0 		movq	-32(%rbp), %rax
 543 0424 8910     		movl	%edx, (%rax)
 126:main.c        ****     *reqAmo += 1000 * ((int) num_1000);
 544              		.loc 1 126 0
 545 0426 488B45E0 		movq	-32(%rbp), %rax
 546 042a 8B10     		movl	(%rax), %edx
 547 042c 0FB645D8 		movzbl	-40(%rbp), %eax
 548 0430 69C0E803 		imull	$1000, %eax, %eax
 548      0000
 549 0436 01C2     		addl	%eax, %edx
 550 0438 488B45E0 		movq	-32(%rbp), %rax
 551 043c 8910     		movl	%edx, (%rax)
 127:main.c        ****     *reqAmo += 2000 * ((int) num_2000);
 552              		.loc 1 127 0
 553 043e 488B45E0 		movq	-32(%rbp), %rax
 554 0442 8B10     		movl	(%rax), %edx
 555 0444 0FB645D4 		movzbl	-44(%rbp), %eax
 556 0448 69C0D007 		imull	$2000, %eax, %eax
 556      0000
 557 044e 01C2     		addl	%eax, %edx
 558 0450 488B45E0 		movq	-32(%rbp), %rax
 559 0454 8910     		movl	%edx, (%rax)
 128:main.c        ****     if (*reqAmo > bal) hasSuffBal = false;
 560              		.loc 1 128 0
 561 0456 488B45E0 		movq	-32(%rbp), %rax
 562 045a 8B00     		movl	(%rax), %eax
 563 045c 3B45EC   		cmpl	-20(%rbp), %eax
 564 045f 7E04     		jle	.L25
 565              		.loc 1 128 0 is_stmt 0 discriminator 1
 566 0461 C645FF00 		movb	$0, -1(%rbp)
 567              	.L25:
 129:main.c        ****     return hasSuffBal;
 568              		.loc 1 129 0 is_stmt 1
 569 0465 0FB645FF 		movzbl	-1(%rbp), %eax
 130:main.c        **** }
 570              		.loc 1 130 0
 571 0469 5D       		popq	%rbp
 572              		.cfi_def_cfa 7, 8
 573 046a C3       		ret
 574              		.cfi_endproc
 575              	.LFE13:
 577              		.section	.rodata
 578              	.LC2:
 579 0005 556E7061 		.string	"Unparseable hex number"
 579      72736561 
 579      626C6520 
 579      68657820 
 579      6E756D62 
 580              	.LC3:
 581 001c 4368616E 		.string	"Channel out of range"
 581      6E656C20 
 581      6F757420 
 581      6F662072 
 581      616E6765 
 582              	.LC4:
 583 0031 436F6E64 		.string	"Conduit out of range"
 583      75697420 
 583      6F757420 
 583      6F662072 
 583      616E6765 
 584              	.LC5:
 585 0046 496C6C65 		.string	"Illegal character"
 585      67616C20 
 585      63686172 
 585      61637465 
 585      7200
 586              	.LC6:
 587 0058 556E7465 		.string	"Unterminated string"
 587      726D696E 
 587      61746564 
 587      20737472 
 587      696E6700 
 588              	.LC7:
 589 006c 4E6F206D 		.string	"No memory"
 589      656D6F72 
 589      7900
 590              	.LC8:
 591 0076 456D7074 		.string	"Empty string"
 591      79207374 
 591      72696E67 
 591      00
 592              	.LC9:
 593 0083 4F646420 		.string	"Odd number of digits"
 593      6E756D62 
 593      6572206F 
 593      66206469 
 593      67697473 
 594              	.LC10:
 595 0098 43616E6E 		.string	"Cannot load file"
 595      6F74206C 
 595      6F616420 
 595      66696C65 
 595      00
 596              	.LC11:
 597 00a9 43616E6E 		.string	"Cannot save file"
 597      6F742073 
 597      61766520 
 597      66696C65 
 597      00
 598              	.LC12:
 599 00ba 42616420 		.string	"Bad arguments"
 599      61726775 
 599      6D656E74 
 599      7300
 600 00c8 00000000 		.align 32
 600      00000000 
 600      00000000 
 600      00000000 
 600      00000000 
 603              	errMessages:
 604 00e0 00000000 		.quad	0
 604      00000000 
 605 00e8 00000000 		.quad	0
 605      00000000 
 606 00f0 00000000 		.quad	.LC2
 606      00000000 
 607 00f8 00000000 		.quad	.LC3
 607      00000000 
 608 0100 00000000 		.quad	.LC4
 608      00000000 
 609 0108 00000000 		.quad	.LC5
 609      00000000 
 610 0110 00000000 		.quad	.LC6
 610      00000000 
 611 0118 00000000 		.quad	.LC7
 611      00000000 
 612 0120 00000000 		.quad	.LC8
 612      00000000 
 613 0128 00000000 		.quad	.LC9
 613      00000000 
 614 0130 00000000 		.quad	.LC10
 614      00000000 
 615 0138 00000000 		.quad	.LC11
 615      00000000 
 616 0140 00000000 		.quad	.LC12
 616      00000000 
 617              		.align 8
 618              	.LC13:
 619 0148 20202020 		.string	"            vendor ID and product ID (e.g 04B4:8613)"
 619      20202020 
 619      20202020 
 619      76656E64 
 619      6F722049 
 620              	.LC14:
 621 017d 3C564944 		.string	"<VID:PID>"
 621      3A504944 
 621      3E00
 622              	.LC15:
 623 0187 69767000 		.string	"ivp"
 624              	.LC16:
 625 018b 6900     		.string	"i"
 626 018d 000000   		.align 8
 627              	.LC17:
 628 0190 20202020 		.string	"       VID, PID and opt. dev ID (e.g 1D50:602B:0001)"
 628      20202056 
 628      49442C20 
 628      50494420 
 628      616E6420 
 629              	.LC18:
 630 01c5 3C564944 		.string	"<VID:PID[:DID]>"
 630      3A504944 
 630      5B3A4449 
 630      445D3E00 
 631              	.LC19:
 632 01d5 767000   		.string	"vp"
 633              	.LC20:
 634 01d8 7600     		.string	"v"
 635 01da 00000000 		.align 8
 635      0000
 636              	.LC21:
 637 01e0 20202020 		.string	"                    communicates with the atm module"
 637      20202020 
 637      20202020 
 637      20202020 
 637      20202020 
 638              	.LC22:
 639 0215 61746D00 		.string	"atm"
 640              	.LC23:
 641 0219 7900     		.string	"y"
 642 021b 00000000 		.align 8
 642      00
 643              	.LC24:
 644 0220 20202020 		.string	"        gives log on more events"
 644      20202020 
 644      67697665 
 644      73206C6F 
 644      67206F6E 
 645              	.LC25:
 646 0241 6C6F6700 		.string	"log"
 647              	.LC26:
 648 0245 6C00     		.string	"l"
 649 0247 00       		.align 8
 650              	.LC27:
 651 0248 20202020 		.string	"                     print this help and exit"
 651      20202020 
 651      20202020 
 651      20202020 
 651      20202020 
 652              	.LC28:
 653 0276 68656C70 		.string	"help"
 653      00
 654              	.LC29:
 655 027b 6800     		.string	"h"
 656              	.LC30:
 657 027d 666C636C 		.string	"flcli"
 657      6900
 658              	.LC31:
 659 0283 25733A20 		.string	"%s: insufficient memory\n"
 659      696E7375 
 659      66666963 
 659      69656E74 
 659      206D656D 
 660 029c 00000000 		.align 8
 661              	.LC32:
 662 02a0 46504741 		.string	"FPGALink Command-Line Interface Copyright (C) 2017 Jarvis \n\n Usage: %s"
 662      4C696E6B 
 662      20436F6D 
 662      6D616E64 
 662      2D4C696E 
 663              	.LC33:
 664 02e7 0A00     		.string	"\n"
 665 02e9 00000000 		.align 8
 665      000000
 666              	.LC34:
 667 02f0 0A496E74 		.string	"\nInteract with an FPGALink device.\n"
 667      65726163 
 667      74207769 
 667      74682061 
 667      6E204650 
 668              	.LC35:
 669 0314 2020252D 		.string	"  %-10s %s\n"
 669      31307320 
 669      25730A00 
 670              		.align 8
 671              	.LC36:
 672 0320 54727920 		.string	"Try '%s --help' for more information.\n"
 672      27257320 
 672      2D2D6865 
 672      6C702720 
 672      666F7220 
 673 0347 00       		.align 8
 674              	.LC37:
 675 0348 41747465 		.string	"Attempting to open connection to FPGALink device %s...\n"
 675      6D707469 
 675      6E672074 
 675      6F206F70 
 675      656E2063 
 676              	.LC38:
 677 0380 4C6F6164 		.string	"Loading firmware into %s...\n"
 677      696E6720 
 677      6669726D 
 677      77617265 
 677      20696E74 
 678              	.LC39:
 679 039d 41776169 		.string	"Awaiting renumeration"
 679      74696E67 
 679      2072656E 
 679      756D6572 
 679      6174696F 
 680 03b3 00000000 		.align 8
 680      00
 681              	.LC40:
 682 03b8 46504741 		.string	"FPGALink device did not renumerate properly as %s\n"
 682      4C696E6B 
 682      20646576 
 682      69636520 
 682      64696420 
 683 03eb 00000000 		.align 8
 683      00
 684              	.LC41:
 685 03f0 41747465 		.string	"Attempting to open connection to FPGLink device %s again...\n"
 685      6D707469 
 685      6E672074 
 685      6F206F70 
 685      656E2063 
 686 042d 000000   		.align 8
 687              	.LC42:
 688 0430 436F756C 		.string	"Could not open FPGALink device at %s and no initial VID:PID was supplied\n"
 688      64206E6F 
 688      74206F70 
 688      656E2046 
 688      5047414C 
 689 047a 00000000 		.align 8
 689      0000
 690              	.LC43:
 691 0480 436F6E6E 		.string	"Connected to FPGALink device %s (firmwareID: 0x%04X, firmwareVersion: 0x%08X)\n"
 691      65637465 
 691      6420746F 
 691      20465047 
 691      414C696E 
 692              	.LC44:
 693 04cf 722B00   		.string	"r+"
 694              	.LC45:
 695 04d2 53616D70 		.string	"SampleBackEndDatabase.csv"
 695      6C654261 
 695      636B456E 
 695      64446174 
 695      61626173 
 696              	.LC46:
 697 04ec 43737620 		.string	"Csv doesn't exist "
 697      646F6573 
 697      6E277420 
 697      65786973 
 697      742000
 698              	.LC47:
 699 04ff 52656164 		.string	"Read from channel 0 = %u \n"
 699      2066726F 
 699      6D206368 
 699      616E6E65 
 699      6C203020 
 700              	.LC48:
 701 051a 52656164 		.string	"Read from channel %u = %u \n"
 701      2066726F 
 701      6D206368 
 701      616E6E65 
 701      6C202575 
 702              	.LC49:
 703 0536 56616C69 		.string	"Valid user found "
 703      64207573 
 703      65722066 
 703      6F756E64 
 703      2000
 704              	.LC50:
 705 0548 53756666 		.string	"Sufficient Balance in account"
 705      69636965 
 705      6E742042 
 705      616C616E 
 705      63652069 
 706              	.LC51:
 707 0566 57726974 		.string	"Write to channel %u = %u \n"
 707      6520746F 
 707      20636861 
 707      6E6E656C 
 707      20257520 
 708              	.LC52:
 709 0581 772B00   		.string	"w+"
 710 0584 00000000 		.align 8
 711              	.LC53:
 712 0588 22557365 		.string	"\"User ID (decimal)\",\"PIN Hash (decimal)\",\"Admin\",\"Balance (decimal)\""
 712      72204944 
 712      20286465 
 712      63696D61 
 712      6C29222C 
 713              	.LC54:
 714 05cd 496E7375 		.string	"Insufficient Balance "
 714      66666963 
 714      69656E74 
 714      2042616C 
 714      616E6365 
 715              	.LC55:
 716 05e3 55736572 		.string	"User has admin privileges "
 716      20686173 
 716      2061646D 
 716      696E2070 
 716      72697669 
 717              	.LC56:
 718 05fe 496E7661 		.string	"Invalid user "
 718      6C696420 
 718      75736572 
 718      2000
 719 060c 00000000 		.align 8
 720              	.LC57:
 721 0610 54686520 		.string	"The FPGALink device at %s is not ready to talk - did you forget --program?\n"
 721      46504741 
 721      4C696E6B 
 721      20646576 
 721      69636520 
 722 065c 00000000 		.align 8
 723              	.LC58:
 724 0660 41637469 		.string	"Action requested but device at %s does not support CommFPGA\n"
 724      6F6E2072 
 724      65717565 
 724      73746564 
 724      20627574 
 725              	.LC59:
 726 069d 25730A00 		.string	"%s\n"
 727              		.text
 728              		.globl	main
 730              	main:
 731              	.LFB14:
 131:main.c        **** 
 132:main.c        **** static const char *const errMessages[] = {
 133:main.c        ****         NULL,
 134:main.c        ****         NULL,
 135:main.c        ****         "Unparseable hex number",
 136:main.c        ****         "Channel out of range",
 137:main.c        ****         "Conduit out of range",
 138:main.c        ****         "Illegal character",
 139:main.c        ****         "Unterminated string",
 140:main.c        ****         "No memory",
 141:main.c        ****         "Empty string",
 142:main.c        ****         "Odd number of digits",
 143:main.c        ****         "Cannot load file",
 144:main.c        ****         "Cannot save file",
 145:main.c        ****         "Bad arguments"
 146:main.c        **** };
 147:main.c        **** 
 148:main.c        **** typedef enum {
 149:main.c        ****     FLP_SUCCESS,
 150:main.c        ****     FLP_LIBERR,
 151:main.c        ****     FLP_BAD_HEX,
 152:main.c        ****     FLP_CHAN_RANGE,
 153:main.c        ****     FLP_CONDUIT_RANGE,
 154:main.c        ****     FLP_ILL_CHAR,
 155:main.c        ****     FLP_UNTERM_STRING,
 156:main.c        ****     FLP_NO_MEMORY,
 157:main.c        ****     FLP_EMPTY_STRING,
 158:main.c        ****     FLP_ODD_DIGITS,
 159:main.c        ****     FLP_CANNOT_LOAD,
 160:main.c        ****     FLP_CANNOT_SAVE,
 161:main.c        ****     FLP_ARGS
 162:main.c        **** } ReturnCode;
 163:main.c        **** 
 164:main.c        **** int main(int argc, char *argv[]) {
 732              		.loc 1 164 0
 733              		.cfi_startproc
 734 046b 55       		pushq	%rbp
 735              		.cfi_def_cfa_offset 16
 736              		.cfi_offset 6, -16
 737 046c 4889E5   		movq	%rsp, %rbp
 738              		.cfi_def_cfa_register 6
 739 046f 53       		pushq	%rbx
 740 0470 4881EC78 		subq	$376, %rsp
 740      010000
 741              		.cfi_offset 3, -24
 742 0477 89BD8CFE 		movl	%edi, -372(%rbp)
 742      FFFF
 743 047d 4889B580 		movq	%rsi, -384(%rbp)
 743      FEFFFF
 165:main.c        ****     ReturnCode retVal = FLP_SUCCESS;
 744              		.loc 1 165 0
 745 0484 C785CCFE 		movl	$0, -308(%rbp)
 745      FFFF0000 
 745      0000
 166:main.c        **** 
 167:main.c        ****     struct arg_str *ivpOpt = arg_str0("i", "ivp", "<VID:PID>", "            vendor ID and product I
 746              		.loc 1 167 0
 747 048e B9000000 		movl	$.LC13, %ecx
 747      00
 748 0493 BA000000 		movl	$.LC14, %edx
 748      00
 749 0498 BE000000 		movl	$.LC15, %esi
 749      00
 750 049d BF000000 		movl	$.LC16, %edi
 750      00
 751 04a2 E8000000 		call	arg_str0
 751      00
 752 04a7 48898550 		movq	%rax, -176(%rbp)
 752      FFFFFF
 168:main.c        ****     struct arg_str *vpOpt = arg_str1("v", "vp", "<VID:PID[:DID]>", "       VID, PID and opt. dev ID
 753              		.loc 1 168 0
 754 04ae B9000000 		movl	$.LC17, %ecx
 754      00
 755 04b3 BA000000 		movl	$.LC18, %edx
 755      00
 756 04b8 BE000000 		movl	$.LC19, %esi
 756      00
 757 04bd BF000000 		movl	$.LC20, %edi
 757      00
 758 04c2 E8000000 		call	arg_str1
 758      00
 759 04c7 48898558 		movq	%rax, -168(%rbp)
 759      FFFFFF
 169:main.c        ****     struct arg_lit *loopOpt = arg_lit0("y", "atm", "                    communicates with the atm m
 760              		.loc 1 169 0
 761 04ce BA000000 		movl	$.LC21, %edx
 761      00
 762 04d3 BE000000 		movl	$.LC22, %esi
 762      00
 763 04d8 BF000000 		movl	$.LC23, %edi
 763      00
 764 04dd E8000000 		call	arg_lit0
 764      00
 765 04e2 48898560 		movq	%rax, -160(%rbp)
 765      FFFFFF
 170:main.c        ****     struct arg_lit *verboseOpt = arg_lit0("l", "log", "        gives log on more events");
 766              		.loc 1 170 0
 767 04e9 BA000000 		movl	$.LC24, %edx
 767      00
 768 04ee BE000000 		movl	$.LC25, %esi
 768      00
 769 04f3 BF000000 		movl	$.LC26, %edi
 769      00
 770 04f8 E8000000 		call	arg_lit0
 770      00
 771 04fd 48898568 		movq	%rax, -152(%rbp)
 771      FFFFFF
 171:main.c        ****     struct arg_lit *helpOpt = arg_lit0("h", "help", "                     print this help and exit"
 772              		.loc 1 171 0
 773 0504 BA000000 		movl	$.LC27, %edx
 773      00
 774 0509 BE000000 		movl	$.LC28, %esi
 774      00
 775 050e BF000000 		movl	$.LC29, %edi
 775      00
 776 0513 E8000000 		call	arg_lit0
 776      00
 777 0518 48898570 		movq	%rax, -144(%rbp)
 777      FFFFFF
 172:main.c        ****     struct arg_end *endOpt = arg_end(20);
 778              		.loc 1 172 0
 779 051f BF140000 		movl	$20, %edi
 779      00
 780 0524 E8000000 		call	arg_end
 780      00
 781 0529 48898578 		movq	%rax, -136(%rbp)
 781      FFFFFF
 173:main.c        **** 
 174:main.c        ****     void *argTable[] = {
 782              		.loc 1 174 0
 783 0530 488B8550 		movq	-176(%rbp), %rax
 783      FFFFFF
 784 0537 488945C0 		movq	%rax, -64(%rbp)
 785 053b 488B8558 		movq	-168(%rbp), %rax
 785      FFFFFF
 786 0542 488945C8 		movq	%rax, -56(%rbp)
 787 0546 488B8560 		movq	-160(%rbp), %rax
 787      FFFFFF
 788 054d 488945D0 		movq	%rax, -48(%rbp)
 789 0551 488B8568 		movq	-152(%rbp), %rax
 789      FFFFFF
 790 0558 488945D8 		movq	%rax, -40(%rbp)
 791 055c 488B8570 		movq	-144(%rbp), %rax
 791      FFFFFF
 792 0563 488945E0 		movq	%rax, -32(%rbp)
 793 0567 488B8578 		movq	-136(%rbp), %rax
 793      FFFFFF
 794 056e 488945E8 		movq	%rax, -24(%rbp)
 175:main.c        ****             ivpOpt,
 176:main.c        ****             vpOpt,
 177:main.c        ****             loopOpt,
 178:main.c        ****             verboseOpt,
 179:main.c        ****             helpOpt,
 180:main.c        ****             endOpt
 181:main.c        ****     };
 182:main.c        **** 
 183:main.c        ****     const char *progName = "flcli";
 795              		.loc 1 183 0
 796 0572 48C74580 		movq	$.LC30, -128(%rbp)
 796      00000000 
 184:main.c        ****     int numErrors;
 185:main.c        ****     struct FLContext *handle = NULL;
 797              		.loc 1 185 0
 798 057a 48C78530 		movq	$0, -208(%rbp)
 798      FFFFFF00 
 798      000000
 186:main.c        ****     FLStatus fStatus;
 187:main.c        ****     const char *error = NULL;
 799              		.loc 1 187 0
 800 0585 48C78538 		movq	$0, -200(%rbp)
 800      FFFFFF00 
 800      000000
 188:main.c        ****     const char *ivp = NULL;
 801              		.loc 1 188 0
 802 0590 48C74588 		movq	$0, -120(%rbp)
 802      00000000 
 189:main.c        ****     const char *vp = NULL;
 803              		.loc 1 189 0
 804 0598 48C74590 		movq	$0, -112(%rbp)
 804      00000000 
 190:main.c        ****     bool isCommCapable;
 191:main.c        ****     const char *line = NULL;
 805              		.loc 1 191 0
 806 05a0 48C74598 		movq	$0, -104(%rbp)
 806      00000000 
 192:main.c        ****     uint8 conduit = 0x01;
 807              		.loc 1 192 0
 808 05a8 C685B1FE 		movb	$1, -335(%rbp)
 808      FFFF01
 193:main.c        **** 
 194:main.c        ****     if (arg_nullcheck(argTable) != 0) {
 809              		.loc 1 194 0
 810 05af 488D45C0 		leaq	-64(%rbp), %rax
 811 05b3 4889C7   		movq	%rax, %rdi
 812 05b6 E8000000 		call	arg_nullcheck
 812      00
 813 05bb 85C0     		testl	%eax, %eax
 814 05bd 742C     		je	.L28
 195:main.c        ****         fprintf(stderr, "%s: insufficient memory\n", progName);
 815              		.loc 1 195 0
 816 05bf 488B0500 		movq	stderr(%rip), %rax
 816      000000
 817 05c6 488B5580 		movq	-128(%rbp), %rdx
 818 05ca BE000000 		movl	$.LC31, %esi
 818      00
 819 05cf 4889C7   		movq	%rax, %rdi
 820 05d2 B8000000 		movl	$0, %eax
 820      00
 821 05d7 E8000000 		call	fprintf
 821      00
 196:main.c        ****         FAIL(1, cleanup);
 822              		.loc 1 196 0
 823 05dc C785CCFE 		movl	$1, -308(%rbp)
 823      FFFF0100 
 823      0000
 824 05e6 E9581700 		jmp	.L29
 824      00
 825              	.L28:
 197:main.c        ****     }
 198:main.c        **** 
 199:main.c        ****     numErrors = arg_parse(argc, argv, argTable);
 826              		.loc 1 199 0
 827 05eb 488D55C0 		leaq	-64(%rbp), %rdx
 828 05ef 488B8D80 		movq	-384(%rbp), %rcx
 828      FEFFFF
 829 05f6 8B858CFE 		movl	-372(%rbp), %eax
 829      FFFF
 830 05fc 4889CE   		movq	%rcx, %rsi
 831 05ff 89C7     		movl	%eax, %edi
 832 0601 E8000000 		call	arg_parse
 832      00
 833 0606 8985FCFE 		movl	%eax, -260(%rbp)
 833      FFFF
 200:main.c        **** 
 201:main.c        ****     if (verboseOpt->count > 0) {
 834              		.loc 1 201 0
 835 060c 488B8568 		movq	-152(%rbp), %rax
 835      FFFFFF
 836 0613 8B4060   		movl	96(%rax), %eax
 837 0616 85C0     		testl	%eax, %eax
 838 0618 7E07     		jle	.L30
 202:main.c        ****         LOG = true;
 839              		.loc 1 202 0
 840 061a C6050000 		movb	$1, LOG(%rip)
 840      000001
 841              	.L30:
 203:main.c        ****     }
 204:main.c        **** 
 205:main.c        ****     if (helpOpt->count > 0) {
 842              		.loc 1 205 0
 843 0621 488B8570 		movq	-144(%rbp), %rax
 843      FFFFFF
 844 0628 8B4060   		movl	96(%rax), %eax
 845 062b 85C0     		testl	%eax, %eax
 846 062d 7E65     		jle	.L31
 206:main.c        ****         printf("FPGALink Command-Line Interface Copyright (C) 2017 Jarvis \n\n Usage: %s", progName
 847              		.loc 1 206 0
 848 062f 488B4580 		movq	-128(%rbp), %rax
 849 0633 4889C6   		movq	%rax, %rsi
 850 0636 BF000000 		movl	$.LC32, %edi
 850      00
 851 063b B8000000 		movl	$0, %eax
 851      00
 852 0640 E8000000 		call	printf
 852      00
 207:main.c        ****         arg_print_syntax(stdout, argTable, "\n");
 853              		.loc 1 207 0
 854 0645 488B0500 		movq	stdout(%rip), %rax
 854      000000
 855 064c 488D4DC0 		leaq	-64(%rbp), %rcx
 856 0650 BA000000 		movl	$.LC33, %edx
 856      00
 857 0655 4889CE   		movq	%rcx, %rsi
 858 0658 4889C7   		movq	%rax, %rdi
 859 065b E8000000 		call	arg_print_syntax
 859      00
 208:main.c        ****         printf("\nInteract with an FPGALink device.\n\n");
 860              		.loc 1 208 0
 861 0660 BF000000 		movl	$.LC34, %edi
 861      00
 862 0665 E8000000 		call	puts
 862      00
 209:main.c        ****         arg_print_glossary(stdout, argTable, "  %-10s %s\n");
 863              		.loc 1 209 0
 864 066a 488B0500 		movq	stdout(%rip), %rax
 864      000000
 865 0671 488D4DC0 		leaq	-64(%rbp), %rcx
 866 0675 BA000000 		movl	$.LC35, %edx
 866      00
 867 067a 4889CE   		movq	%rcx, %rsi
 868 067d 4889C7   		movq	%rax, %rdi
 869 0680 E8000000 		call	arg_print_glossary
 869      00
 210:main.c        ****         FAIL(FLP_SUCCESS, cleanup);
 870              		.loc 1 210 0
 871 0685 C785CCFE 		movl	$0, -308(%rbp)
 871      FFFF0000 
 871      0000
 872 068f E9AF1600 		jmp	.L29
 872      00
 873              	.L31:
 211:main.c        ****     }
 212:main.c        **** 
 213:main.c        ****     if (numErrors > 0) {
 874              		.loc 1 213 0
 875 0694 83BDFCFE 		cmpl	$0, -260(%rbp)
 875      FFFF00
 876 069b 7E49     		jle	.L32
 214:main.c        ****         arg_print_errors(stdout, endOpt, progName);
 877              		.loc 1 214 0
 878 069d 488B0500 		movq	stdout(%rip), %rax
 878      000000
 879 06a4 488B5580 		movq	-128(%rbp), %rdx
 880 06a8 488B8D78 		movq	-136(%rbp), %rcx
 880      FFFFFF
 881 06af 4889CE   		movq	%rcx, %rsi
 882 06b2 4889C7   		movq	%rax, %rdi
 883 06b5 E8000000 		call	arg_print_errors
 883      00
 215:main.c        ****         fprintf(stderr, "Try '%s --help' for more information.\n", progName);
 884              		.loc 1 215 0
 885 06ba 488B0500 		movq	stderr(%rip), %rax
 885      000000
 886 06c1 488B5580 		movq	-128(%rbp), %rdx
 887 06c5 BE000000 		movl	$.LC36, %esi
 887      00
 888 06ca 4889C7   		movq	%rax, %rdi
 889 06cd B8000000 		movl	$0, %eax
 889      00
 890 06d2 E8000000 		call	fprintf
 890      00
 216:main.c        ****         FAIL(FLP_ARGS, cleanup);
 891              		.loc 1 216 0
 892 06d7 C785CCFE 		movl	$12, -308(%rbp)
 892      FFFF0C00 
 892      0000
 893 06e1 E95D1600 		jmp	.L29
 893      00
 894              	.L32:
 217:main.c        ****     }
 218:main.c        **** 
 219:main.c        ****     fStatus = flInitialise(0, &error);
 895              		.loc 1 219 0
 896 06e6 488D8538 		leaq	-200(%rbp), %rax
 896      FFFFFF
 897 06ed 4889C6   		movq	%rax, %rsi
 898 06f0 BF000000 		movl	$0, %edi
 898      00
 899 06f5 E8000000 		call	flInitialise
 899      00
 900 06fa 898500FF 		movl	%eax, -256(%rbp)
 900      FFFF
 220:main.c        ****     CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 901              		.loc 1 220 0
 902 0700 83BD00FF 		cmpl	$0, -256(%rbp)
 902      FFFF00
 903 0707 740F     		je	.L33
 904              		.loc 1 220 0 is_stmt 0 discriminator 1
 905 0709 C785CCFE 		movl	$1, -308(%rbp)
 905      FFFF0100 
 905      0000
 906 0713 E92B1600 		jmp	.L29
 906      00
 907              	.L33:
 221:main.c        **** 
 222:main.c        ****     vp = vpOpt->sval[0];
 908              		.loc 1 222 0 is_stmt 1
 909 0718 488B8558 		movq	-168(%rbp), %rax
 909      FFFFFF
 910 071f 488B4068 		movq	104(%rax), %rax
 911 0723 488B00   		movq	(%rax), %rax
 912 0726 48894590 		movq	%rax, -112(%rbp)
 223:main.c        **** 
 224:main.c        ****     printf("Attempting to open connection to FPGALink device %s...\n", vp);
 913              		.loc 1 224 0
 914 072a 488B4590 		movq	-112(%rbp), %rax
 915 072e 4889C6   		movq	%rax, %rsi
 916 0731 BF000000 		movl	$.LC37, %edi
 916      00
 917 0736 B8000000 		movl	$0, %eax
 917      00
 918 073b E8000000 		call	printf
 918      00
 225:main.c        ****     fStatus = flOpen(vp, &handle, NULL);
 919              		.loc 1 225 0
 920 0740 488D8D30 		leaq	-208(%rbp), %rcx
 920      FFFFFF
 921 0747 488B4590 		movq	-112(%rbp), %rax
 922 074b BA000000 		movl	$0, %edx
 922      00
 923 0750 4889CE   		movq	%rcx, %rsi
 924 0753 4889C7   		movq	%rax, %rdi
 925 0756 E8000000 		call	flOpen
 925      00
 926 075b 898500FF 		movl	%eax, -256(%rbp)
 926      FFFF
 226:main.c        ****     if (fStatus) {
 927              		.loc 1 226 0
 928 0761 83BD00FF 		cmpl	$0, -256(%rbp)
 928      FFFF00
 929 0768 0F84CF01 		je	.L34
 929      0000
 227:main.c        ****         if (ivpOpt->count) {
 930              		.loc 1 227 0
 931 076e 488B8550 		movq	-176(%rbp), %rax
 931      FFFFFF
 932 0775 8B4060   		movl	96(%rax), %eax
 933 0778 85C0     		testl	%eax, %eax
 934 077a 0F849101 		je	.L35
 934      0000
 935              	.LBB5:
 228:main.c        ****             int count = 60;
 936              		.loc 1 228 0
 937 0780 C785D0FE 		movl	$60, -304(%rbp)
 937      FFFF3C00 
 937      0000
 229:main.c        ****             uint8 flag;
 230:main.c        ****             ivp = ivpOpt->sval[0];
 938              		.loc 1 230 0
 939 078a 488B8550 		movq	-176(%rbp), %rax
 939      FFFFFF
 940 0791 488B4068 		movq	104(%rax), %rax
 941 0795 488B00   		movq	(%rax), %rax
 942 0798 48894588 		movq	%rax, -120(%rbp)
 231:main.c        ****             printf("Loading firmware into %s...\n", ivp);
 943              		.loc 1 231 0
 944 079c 488B4588 		movq	-120(%rbp), %rax
 945 07a0 4889C6   		movq	%rax, %rsi
 946 07a3 BF000000 		movl	$.LC38, %edi
 946      00
 947 07a8 B8000000 		movl	$0, %eax
 947      00
 948 07ad E8000000 		call	printf
 948      00
 232:main.c        ****             fStatus = flLoadStandardFirmware(ivp, vp, &error);
 949              		.loc 1 232 0
 950 07b2 488D9538 		leaq	-200(%rbp), %rdx
 950      FFFFFF
 951 07b9 488B4D90 		movq	-112(%rbp), %rcx
 952 07bd 488B4588 		movq	-120(%rbp), %rax
 953 07c1 4889CE   		movq	%rcx, %rsi
 954 07c4 4889C7   		movq	%rax, %rdi
 955 07c7 E8000000 		call	flLoadStandardFirmware
 955      00
 956 07cc 898500FF 		movl	%eax, -256(%rbp)
 956      FFFF
 233:main.c        ****             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 957              		.loc 1 233 0
 958 07d2 83BD00FF 		cmpl	$0, -256(%rbp)
 958      FFFF00
 959 07d9 740F     		je	.L36
 960              		.loc 1 233 0 is_stmt 0 discriminator 1
 961 07db C785CCFE 		movl	$1, -308(%rbp)
 961      FFFF0100 
 961      0000
 962 07e5 E9591500 		jmp	.L29
 962      00
 963              	.L36:
 234:main.c        **** 
 235:main.c        ****             printf("Awaiting renumeration");
 964              		.loc 1 235 0 is_stmt 1
 965 07ea BF000000 		movl	$.LC39, %edi
 965      00
 966 07ef B8000000 		movl	$0, %eax
 966      00
 967 07f4 E8000000 		call	printf
 967      00
 236:main.c        ****             flSleep(1000);
 968              		.loc 1 236 0
 969 07f9 BFE80300 		movl	$1000, %edi
 969      00
 970 07fe E8000000 		call	flSleep
 970      00
 971              	.L40:
 237:main.c        ****             do {
 238:main.c        ****                 printf(".");
 972              		.loc 1 238 0
 973 0803 BF2E0000 		movl	$46, %edi
 973      00
 974 0808 E8000000 		call	putchar
 974      00
 239:main.c        ****                 fflush(stdout);
 975              		.loc 1 239 0
 976 080d 488B0500 		movq	stdout(%rip), %rax
 976      000000
 977 0814 4889C7   		movq	%rax, %rdi
 978 0817 E8000000 		call	fflush
 978      00
 240:main.c        ****                 fStatus = flIsDeviceAvailable(vp, &flag, &error);
 979              		.loc 1 240 0
 980 081c 488D9538 		leaq	-200(%rbp), %rdx
 980      FFFFFF
 981 0823 488D8D48 		leaq	-184(%rbp), %rcx
 981      FFFFFF
 982 082a 488B4590 		movq	-112(%rbp), %rax
 983 082e 4889CE   		movq	%rcx, %rsi
 984 0831 4889C7   		movq	%rax, %rdi
 985 0834 E8000000 		call	flIsDeviceAvailable
 985      00
 986 0839 898500FF 		movl	%eax, -256(%rbp)
 986      FFFF
 241:main.c        ****                 CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 987              		.loc 1 241 0
 988 083f 83BD00FF 		cmpl	$0, -256(%rbp)
 988      FFFF00
 989 0846 740F     		je	.L38
 990              		.loc 1 241 0 is_stmt 0 discriminator 1
 991 0848 C785CCFE 		movl	$1, -308(%rbp)
 991      FFFF0100 
 991      0000
 992 0852 E9EC1400 		jmp	.L29
 992      00
 993              	.L38:
 242:main.c        ****                 flSleep(250);
 994              		.loc 1 242 0 is_stmt 1
 995 0857 BFFA0000 		movl	$250, %edi
 995      00
 996 085c E8000000 		call	flSleep
 996      00
 243:main.c        ****                 count--;
 997              		.loc 1 243 0
 998 0861 83ADD0FE 		subl	$1, -304(%rbp)
 998      FFFF01
 244:main.c        ****             } while (!flag && count);
 999              		.loc 1 244 0
 1000 0868 0FB68548 		movzbl	-184(%rbp), %eax
 1000      FFFFFF
 1001 086f 84C0     		testb	%al, %al
 1002 0871 7509     		jne	.L39
 1003              		.loc 1 244 0 is_stmt 0 discriminator 1
 1004 0873 83BDD0FE 		cmpl	$0, -304(%rbp)
 1004      FFFF00
 1005 087a 7587     		jne	.L40
 1006              	.L39:
 245:main.c        ****             printf("\n");
 1007              		.loc 1 245 0 is_stmt 1
 1008 087c BF0A0000 		movl	$10, %edi
 1008      00
 1009 0881 E8000000 		call	putchar
 1009      00
 246:main.c        ****             if (!flag) {
 1010              		.loc 1 246 0
 1011 0886 0FB68548 		movzbl	-184(%rbp), %eax
 1011      FFFFFF
 1012 088d 84C0     		testb	%al, %al
 1013 088f 752C     		jne	.L41
 247:main.c        ****                 fprintf(stderr, "FPGALink device did not renumerate properly as %s\n", vp);
 1014              		.loc 1 247 0
 1015 0891 488B0500 		movq	stderr(%rip), %rax
 1015      000000
 1016 0898 488B5590 		movq	-112(%rbp), %rdx
 1017 089c BE000000 		movl	$.LC40, %esi
 1017      00
 1018 08a1 4889C7   		movq	%rax, %rdi
 1019 08a4 B8000000 		movl	$0, %eax
 1019      00
 1020 08a9 E8000000 		call	fprintf
 1020      00
 248:main.c        ****                 FAIL(FLP_LIBERR, cleanup);
 1021              		.loc 1 248 0
 1022 08ae C785CCFE 		movl	$1, -308(%rbp)
 1022      FFFF0100 
 1022      0000
 1023 08b8 E9861400 		jmp	.L29
 1023      00
 1024              	.L41:
 249:main.c        ****             }
 250:main.c        **** 
 251:main.c        ****             printf("Attempting to open connection to FPGLink device %s again...\n", vp);
 1025              		.loc 1 251 0
 1026 08bd 488B4590 		movq	-112(%rbp), %rax
 1027 08c1 4889C6   		movq	%rax, %rsi
 1028 08c4 BF000000 		movl	$.LC41, %edi
 1028      00
 1029 08c9 B8000000 		movl	$0, %eax
 1029      00
 1030 08ce E8000000 		call	printf
 1030      00
 252:main.c        ****             fStatus = flOpen(vp, &handle, &error);
 1031              		.loc 1 252 0
 1032 08d3 488D9538 		leaq	-200(%rbp), %rdx
 1032      FFFFFF
 1033 08da 488D8D30 		leaq	-208(%rbp), %rcx
 1033      FFFFFF
 1034 08e1 488B4590 		movq	-112(%rbp), %rax
 1035 08e5 4889CE   		movq	%rcx, %rsi
 1036 08e8 4889C7   		movq	%rax, %rdi
 1037 08eb E8000000 		call	flOpen
 1037      00
 1038 08f0 898500FF 		movl	%eax, -256(%rbp)
 1038      FFFF
 253:main.c        ****             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1039              		.loc 1 253 0
 1040 08f6 83BD00FF 		cmpl	$0, -256(%rbp)
 1040      FFFF00
 1041 08fd 7410     		je	.L42
 1042              		.loc 1 253 0 is_stmt 0 discriminator 1
 1043 08ff C785CCFE 		movl	$1, -308(%rbp)
 1043      FFFF0100 
 1043      0000
 1044 0909 90       		nop
 1045 090a E9341400 		jmp	.L29
 1045      00
 1046              	.L42:
 1047              	.LBE5:
 1048 090f EB2C     		jmp	.L34
 1049              	.L35:
 254:main.c        ****         } else {
 255:main.c        ****             fprintf(stderr, "Could not open FPGALink device at %s and no initial VID:PID was suppli
 1050              		.loc 1 255 0 is_stmt 1
 1051 0911 488B0500 		movq	stderr(%rip), %rax
 1051      000000
 1052 0918 488B5590 		movq	-112(%rbp), %rdx
 1053 091c BE000000 		movl	$.LC42, %esi
 1053      00
 1054 0921 4889C7   		movq	%rax, %rdi
 1055 0924 B8000000 		movl	$0, %eax
 1055      00
 1056 0929 E8000000 		call	fprintf
 1056      00
 256:main.c        ****             FAIL(FLP_ARGS, cleanup);
 1057              		.loc 1 256 0
 1058 092e C785CCFE 		movl	$12, -308(%rbp)
 1058      FFFF0C00 
 1058      0000
 1059 0938 E9061400 		jmp	.L29
 1059      00
 1060              	.L34:
 257:main.c        ****         }
 258:main.c        ****     }
 259:main.c        **** 
 260:main.c        ****     printf(
 1061              		.loc 1 260 0
 1062 093d 488B8530 		movq	-208(%rbp), %rax
 1062      FFFFFF
 1063 0944 4889C7   		movq	%rax, %rdi
 1064 0947 E8000000 		call	flGetFirmwareVersion
 1064      00
 1065 094c 89C3     		movl	%eax, %ebx
 261:main.c        ****             "Connected to FPGALink device %s (firmwareID: 0x%04X, firmwareVersion: 0x%08X)\n",
 262:main.c        ****             vp, flGetFirmwareID(handle), flGetFirmwareVersion(handle)
 1066              		.loc 1 262 0
 1067 094e 488B8530 		movq	-208(%rbp), %rax
 1067      FFFFFF
 1068 0955 4889C7   		movq	%rax, %rdi
 1069 0958 E8000000 		call	flGetFirmwareID
 1069      00
 260:main.c        ****             "Connected to FPGALink device %s (firmwareID: 0x%04X, firmwareVersion: 0x%08X)\n",
 1070              		.loc 1 260 0
 1071 095d 0FB7D0   		movzwl	%ax, %edx
 1072 0960 488B4590 		movq	-112(%rbp), %rax
 1073 0964 89D9     		movl	%ebx, %ecx
 1074 0966 4889C6   		movq	%rax, %rsi
 1075 0969 BF000000 		movl	$.LC43, %edi
 1075      00
 1076 096e B8000000 		movl	$0, %eax
 1076      00
 1077 0973 E8000000 		call	printf
 1077      00
 263:main.c        ****     );
 264:main.c        **** 
 265:main.c        ****     isCommCapable = flIsCommCapable(handle, conduit);
 1078              		.loc 1 265 0
 1079 0978 0FB695B1 		movzbl	-335(%rbp), %edx
 1079      FEFFFF
 1080 097f 488B8530 		movq	-208(%rbp), %rax
 1080      FFFFFF
 1081 0986 89D6     		movl	%edx, %esi
 1082 0988 4889C7   		movq	%rax, %rdi
 1083 098b E8000000 		call	flIsCommCapable
 1083      00
 1084 0990 84C0     		testb	%al, %al
 1085 0992 0F95C0   		setne	%al
 1086 0995 8885B2FE 		movb	%al, -334(%rbp)
 1086      FFFF
 266:main.c        **** 
 267:main.c        ****     // -y reads in from csv and initiates the while loop
 268:main.c        ****     if (loopOpt->count > 0) {
 1087              		.loc 1 268 0
 1088 099b 488B8560 		movq	-160(%rbp), %rax
 1088      FFFFFF
 1089 09a2 8B4060   		movl	96(%rax), %eax
 1090 09a5 85C0     		testl	%eax, %eax
 1091 09a7 0F8E9613 		jle	.L29
 1091      0000
 269:main.c        ****         if (isCommCapable) {
 1092              		.loc 1 269 0
 1093 09ad 80BDB2FE 		cmpb	$0, -334(%rbp)
 1093      FFFF00
 1094 09b4 0F846113 		je	.L43
 1094      0000
 1095              	.LBB6:
 270:main.c        ****             uint8 isRunning;
 271:main.c        ****             fStatus = flSelectConduit(handle, conduit, &error);
 1096              		.loc 1 271 0
 1097 09ba 0FB68DB1 		movzbl	-335(%rbp), %ecx
 1097      FEFFFF
 1098 09c1 488B8530 		movq	-208(%rbp), %rax
 1098      FFFFFF
 1099 09c8 488D9538 		leaq	-200(%rbp), %rdx
 1099      FFFFFF
 1100 09cf 89CE     		movl	%ecx, %esi
 1101 09d1 4889C7   		movq	%rax, %rdi
 1102 09d4 E8000000 		call	flSelectConduit
 1102      00
 1103 09d9 898500FF 		movl	%eax, -256(%rbp)
 1103      FFFF
 272:main.c        ****             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1104              		.loc 1 272 0
 1105 09df 83BD00FF 		cmpl	$0, -256(%rbp)
 1105      FFFF00
 1106 09e6 740F     		je	.L44
 1107              		.loc 1 272 0 is_stmt 0 discriminator 1
 1108 09e8 C785CCFE 		movl	$1, -308(%rbp)
 1108      FFFF0100 
 1108      0000
 1109 09f2 E94C1300 		jmp	.L29
 1109      00
 1110              	.L44:
 273:main.c        ****             fStatus = flIsFPGARunning(handle, &isRunning, &error);
 1111              		.loc 1 273 0 is_stmt 1
 1112 09f7 488B8530 		movq	-208(%rbp), %rax
 1112      FFFFFF
 1113 09fe 488D9538 		leaq	-200(%rbp), %rdx
 1113      FFFFFF
 1114 0a05 488D8D9F 		leaq	-353(%rbp), %rcx
 1114      FEFFFF
 1115 0a0c 4889CE   		movq	%rcx, %rsi
 1116 0a0f 4889C7   		movq	%rax, %rdi
 1117 0a12 E8000000 		call	flIsFPGARunning
 1117      00
 1118 0a17 898500FF 		movl	%eax, -256(%rbp)
 1118      FFFF
 274:main.c        ****             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1119              		.loc 1 274 0
 1120 0a1d 83BD00FF 		cmpl	$0, -256(%rbp)
 1120      FFFF00
 1121 0a24 740F     		je	.L46
 1122              		.loc 1 274 0 is_stmt 0 discriminator 1
 1123 0a26 C785CCFE 		movl	$1, -308(%rbp)
 1123      FFFF0100 
 1123      0000
 1124 0a30 E90E1300 		jmp	.L29
 1124      00
 1125              	.L46:
 275:main.c        ****             if (isRunning) {
 1126              		.loc 1 275 0 is_stmt 1
 1127 0a35 0FB6859F 		movzbl	-353(%rbp), %eax
 1127      FEFFFF
 1128 0a3c 84C0     		testb	%al, %al
 1129 0a3e 0F84AD12 		je	.L47
 1129      0000
 1130              	.LBB7:
 276:main.c        **** 
 277:main.c        ****                 FILE *fPtr;
 278:main.c        ****                 fPtr = fopen("SampleBackEndDatabase.csv", "r+"); // change flag according to need
 1131              		.loc 1 278 0
 1132 0a44 BE000000 		movl	$.LC44, %esi
 1132      00
 1133 0a49 BF000000 		movl	$.LC45, %edi
 1133      00
 1134 0a4e E8000000 		call	fopen
 1134      00
 1135 0a53 488945A0 		movq	%rax, -96(%rbp)
 279:main.c        ****                 if (fPtr == NULL) {
 1136              		.loc 1 279 0
 1137 0a57 48837DA0 		cmpq	$0, -96(%rbp)
 1137      00
 1138 0a5c 7514     		jne	.L48
 280:main.c        ****                     printf("Csv doesn't exist \n");
 1139              		.loc 1 280 0
 1140 0a5e BF000000 		movl	$.LC46, %edi
 1140      00
 1141 0a63 E8000000 		call	puts
 1141      00
 281:main.c        ****                     return 0;
 1142              		.loc 1 281 0
 1143 0a68 B8000000 		movl	$0, %eax
 1143      00
 1144 0a6d E92D1300 		jmp	.L168
 1144      00
 1145              	.L48:
 282:main.c        ****                 }
 283:main.c        ****                 size_t lineSize = 100;
 1146              		.loc 1 283 0
 1147 0a72 48C78540 		movq	$100, -192(%rbp)
 1147      FFFFFF64 
 1147      000000
 284:main.c        ****                 char *lineFromFile = malloc(lineSize * sizeof(char));
 1148              		.loc 1 284 0
 1149 0a7d 488B8540 		movq	-192(%rbp), %rax
 1149      FFFFFF
 1150 0a84 4889C7   		movq	%rax, %rdi
 1151 0a87 E8000000 		call	malloc
 1151      00
 1152 0a8c 48898548 		movq	%rax, -184(%rbp)
 1152      FFFFFF
 285:main.c        **** 
 286:main.c        ****                 while ((getline(&lineFromFile, &lineSize, fPtr)) != -1) {
 1153              		.loc 1 286 0
 1154 0a93 EB28     		jmp	.L50
 1155              	.L52:
 287:main.c        ****                     if (numLines != 0) format(lineFromFile);
 1156              		.loc 1 287 0
 1157 0a95 8B050000 		movl	numLines(%rip), %eax
 1157      0000
 1158 0a9b 85C0     		testl	%eax, %eax
 1159 0a9d 740F     		je	.L51
 1160              		.loc 1 287 0 is_stmt 0 discriminator 1
 1161 0a9f 488B8548 		movq	-184(%rbp), %rax
 1161      FFFFFF
 1162 0aa6 4889C7   		movq	%rax, %rdi
 1163 0aa9 E8000000 		call	format
 1163      00
 1164              	.L51:
 288:main.c        ****                     numLines++;
 1165              		.loc 1 288 0 is_stmt 1
 1166 0aae 8B050000 		movl	numLines(%rip), %eax
 1166      0000
 1167 0ab4 83C001   		addl	$1, %eax
 1168 0ab7 89050000 		movl	%eax, numLines(%rip)
 1168      0000
 1169              	.L50:
 286:main.c        ****                     if (numLines != 0) format(lineFromFile);
 1170              		.loc 1 286 0 discriminator 1
 1171 0abd 488B55A0 		movq	-96(%rbp), %rdx
 1172 0ac1 488D8D40 		leaq	-192(%rbp), %rcx
 1172      FFFFFF
 1173 0ac8 488D8548 		leaq	-184(%rbp), %rax
 1173      FFFFFF
 1174 0acf 4889CE   		movq	%rcx, %rsi
 1175 0ad2 4889C7   		movq	%rax, %rdi
 1176 0ad5 E8000000 		call	getline
 1176      00
 1177 0ada 4883F8FF 		cmpq	$-1, %rax
 1178 0ade 75B5     		jne	.L52
 289:main.c        ****                 }
 290:main.c        ****                 numLines--;
 1179              		.loc 1 290 0
 1180 0ae0 8B050000 		movl	numLines(%rip), %eax
 1180      0000
 1181 0ae6 83E801   		subl	$1, %eax
 1182 0ae9 89050000 		movl	%eax, numLines(%rip)
 1182      0000
 291:main.c        ****                 free(lineFromFile);
 1183              		.loc 1 291 0
 1184 0aef 488B8548 		movq	-184(%rbp), %rax
 1184      FFFFFF
 1185 0af6 4889C7   		movq	%rax, %rdi
 1186 0af9 E8000000 		call	free
 1186      00
 292:main.c        ****                 fclose(fPtr);
 1187              		.loc 1 292 0
 1188 0afe 488B45A0 		movq	-96(%rbp), %rax
 1189 0b02 4889C7   		movq	%rax, %rdi
 1190 0b05 E8000000 		call	fclose
 1190      00
 1191              	.L166:
 1192              	.LBB8:
 293:main.c        **** 
 294:main.c        ****                 while (true) {
 295:main.c        ****                     uint32_t length = 1;
 1193              		.loc 1 295 0
 1194 0b0a C78504FF 		movl	$1, -252(%rbp)
 1194      FFFF0100 
 1194      0000
 296:main.c        ****                     uint8_t *readFromChannelZero = malloc(sizeof(uint8_t));
 1195              		.loc 1 296 0
 1196 0b14 BF010000 		movl	$1, %edi
 1196      00
 1197 0b19 E8000000 		call	malloc
 1197      00
 1198 0b1e 488945A8 		movq	%rax, -88(%rbp)
 297:main.c        **** 
 298:main.c        ****                     fStatus = flReadChannel(handle, (uint8_t) 0, length, readFromChannelZero, &erro
 1199              		.loc 1 298 0
 1200 0b22 8B9504FF 		movl	-252(%rbp), %edx
 1200      FFFF
 1201 0b28 488B8530 		movq	-208(%rbp), %rax
 1201      FFFFFF
 1202 0b2f 488DB538 		leaq	-200(%rbp), %rsi
 1202      FFFFFF
 1203 0b36 488B4DA8 		movq	-88(%rbp), %rcx
 1204 0b3a 4989F0   		movq	%rsi, %r8
 1205 0b3d BE000000 		movl	$0, %esi
 1205      00
 1206 0b42 4889C7   		movq	%rax, %rdi
 1207 0b45 E8000000 		call	flReadChannel
 1207      00
 1208 0b4a 898500FF 		movl	%eax, -256(%rbp)
 1208      FFFF
 299:main.c        ****                     CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1209              		.loc 1 299 0
 1210 0b50 83BD00FF 		cmpl	$0, -256(%rbp)
 1210      FFFF00
 1211 0b57 740F     		je	.L53
 1212              		.loc 1 299 0 is_stmt 0 discriminator 1
 1213 0b59 C785CCFE 		movl	$1, -308(%rbp)
 1213      FFFF0100 
 1213      0000
 1214 0b63 E9871100 		jmp	.L54
 1214      00
 1215              	.L53:
 300:main.c        ****                     if (LOG) printf("Read from channel 0 = %u \n", *readFromChannelZero);
 1216              		.loc 1 300 0 is_stmt 1
 1217 0b68 0FB60500 		movzbl	LOG(%rip), %eax
 1217      000000
 1218 0b6f 84C0     		testb	%al, %al
 1219 0b71 741B     		je	.L55
 1220              		.loc 1 300 0 is_stmt 0 discriminator 1
 1221 0b73 488B45A8 		movq	-88(%rbp), %rax
 1222 0b77 0FB600   		movzbl	(%rax), %eax
 1223 0b7a 0FB6C0   		movzbl	%al, %eax
 1224 0b7d 89C6     		movl	%eax, %esi
 1225 0b7f BF000000 		movl	$.LC47, %edi
 1225      00
 1226 0b84 B8000000 		movl	$0, %eax
 1226      00
 1227 0b89 E8000000 		call	printf
 1227      00
 1228              	.L55:
 301:main.c        **** 
 302:main.c        ****                     if (((*readFromChannelZero) == 1) || ((*readFromChannelZero) == 2)) {
 1229              		.loc 1 302 0 is_stmt 1
 1230 0b8e 488B45A8 		movq	-88(%rbp), %rax
 1231 0b92 0FB600   		movzbl	(%rax), %eax
 1232 0b95 3C01     		cmpb	$1, %al
 1233 0b97 740F     		je	.L56
 1234              		.loc 1 302 0 is_stmt 0 discriminator 1
 1235 0b99 488B45A8 		movq	-88(%rbp), %rax
 1236 0b9d 0FB600   		movzbl	(%rax), %eax
 1237 0ba0 3C02     		cmpb	$2, %al
 1238 0ba2 0F853811 		jne	.L57
 1238      0000
 1239              	.L56:
 1240              	.LBB9:
 303:main.c        ****                         uint8_t cnt = 1, valRead = *readFromChannelZero;
 1241              		.loc 1 303 0 is_stmt 1
 1242 0ba8 C685A2FE 		movb	$1, -350(%rbp)
 1242      FFFF01
 1243 0baf 488B45A8 		movq	-88(%rbp), %rax
 1244 0bb3 0FB600   		movzbl	(%rax), %eax
 1245 0bb6 8885B3FE 		movb	%al, -333(%rbp)
 1245      FFFF
 304:main.c        ****                         bool cont = true;
 1246              		.loc 1 304 0
 1247 0bbc C685A3FE 		movb	$1, -349(%rbp)
 1247      FFFF01
 305:main.c        ****                         while (cnt < 3) {
 1248              		.loc 1 305 0
 1249 0bc3 E9A00000 		jmp	.L58
 1249      00
 1250              	.L63:
 306:main.c        **** 
 307:main.c        ****                             flSleep(1000);
 1251              		.loc 1 307 0
 1252 0bc8 BFE80300 		movl	$1000, %edi
 1252      00
 1253 0bcd E8000000 		call	flSleep
 1253      00
 308:main.c        ****                             fStatus = flReadChannel(handle, 0, length, readFromChannelZero, &error)
 1254              		.loc 1 308 0
 1255 0bd2 8B9504FF 		movl	-252(%rbp), %edx
 1255      FFFF
 1256 0bd8 488B8530 		movq	-208(%rbp), %rax
 1256      FFFFFF
 1257 0bdf 488DB538 		leaq	-200(%rbp), %rsi
 1257      FFFFFF
 1258 0be6 488B4DA8 		movq	-88(%rbp), %rcx
 1259 0bea 4989F0   		movq	%rsi, %r8
 1260 0bed BE000000 		movl	$0, %esi
 1260      00
 1261 0bf2 4889C7   		movq	%rax, %rdi
 1262 0bf5 E8000000 		call	flReadChannel
 1262      00
 1263 0bfa 898500FF 		movl	%eax, -256(%rbp)
 1263      FFFF
 309:main.c        ****                             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1264              		.loc 1 309 0
 1265 0c00 83BD00FF 		cmpl	$0, -256(%rbp)
 1265      FFFF00
 1266 0c07 740F     		je	.L59
 1267              		.loc 1 309 0 is_stmt 0 discriminator 1
 1268 0c09 C785CCFE 		movl	$1, -308(%rbp)
 1268      FFFF0100 
 1268      0000
 1269 0c13 E9D71000 		jmp	.L54
 1269      00
 1270              	.L59:
 310:main.c        ****                             if (LOG) printf("Read from channel 0 = %u \n", *readFromChannelZero);
 1271              		.loc 1 310 0 is_stmt 1
 1272 0c18 0FB60500 		movzbl	LOG(%rip), %eax
 1272      000000
 1273 0c1f 84C0     		testb	%al, %al
 1274 0c21 741B     		je	.L60
 1275              		.loc 1 310 0 is_stmt 0 discriminator 1
 1276 0c23 488B45A8 		movq	-88(%rbp), %rax
 1277 0c27 0FB600   		movzbl	(%rax), %eax
 1278 0c2a 0FB6C0   		movzbl	%al, %eax
 1279 0c2d 89C6     		movl	%eax, %esi
 1280 0c2f BF000000 		movl	$.LC47, %edi
 1280      00
 1281 0c34 B8000000 		movl	$0, %eax
 1281      00
 1282 0c39 E8000000 		call	printf
 1282      00
 1283              	.L60:
 311:main.c        **** 
 312:main.c        ****                             if (*readFromChannelZero == valRead) cnt++;
 1284              		.loc 1 312 0 is_stmt 1
 1285 0c3e 488B45A8 		movq	-88(%rbp), %rax
 1286 0c42 0FB600   		movzbl	(%rax), %eax
 1287 0c45 3A85B3FE 		cmpb	-333(%rbp), %al
 1287      FFFF
 1288 0c4b 7512     		jne	.L61
 1289              		.loc 1 312 0 is_stmt 0 discriminator 1
 1290 0c4d 0FB685A2 		movzbl	-350(%rbp), %eax
 1290      FEFFFF
 1291 0c54 83C001   		addl	$1, %eax
 1292 0c57 8885A2FE 		movb	%al, -350(%rbp)
 1292      FFFF
 1293 0c5d EB09     		jmp	.L58
 1294              	.L61:
 313:main.c        ****                             else {
 314:main.c        ****                                 cont = false;
 1295              		.loc 1 314 0 is_stmt 1
 1296 0c5f C685A3FE 		movb	$0, -349(%rbp)
 1296      FFFF00
 315:main.c        ****                                 break;
 1297              		.loc 1 315 0
 1298 0c66 EB0D     		jmp	.L62
 1299              	.L58:
 305:main.c        **** 
 1300              		.loc 1 305 0 discriminator 1
 1301 0c68 80BDA2FE 		cmpb	$2, -350(%rbp)
 1301      FFFF02
 1302 0c6f 0F8653FF 		jbe	.L63
 1302      FFFF
 1303              	.L62:
 316:main.c        ****                             }
 317:main.c        ****                         }
 318:main.c        ****                         if (cont) {
 1304              		.loc 1 318 0
 1305 0c75 80BDA3FE 		cmpb	$0, -349(%rbp)
 1305      FFFF00
 1306 0c7c 0F845E10 		je	.L57
 1306      0000
 1307              	.LBB10:
 1308              	.LBB11:
 319:main.c        ****                             uint32_t inpFromFrontEnd[2];
 320:main.c        ****                             for (int i = 0; i < 2; i++) inpFromFrontEnd[i] = 0;
 1309              		.loc 1 320 0
 1310 0c82 C785D4FE 		movl	$0, -300(%rbp)
 1310      FFFF0000 
 1310      0000
 1311 0c8c EB1A     		jmp	.L64
 1312              	.L65:
 1313              		.loc 1 320 0 is_stmt 0 discriminator 2
 1314 0c8e 8B85D4FE 		movl	-300(%rbp), %eax
 1314      FFFF
 1315 0c94 4898     		cltq
 1316 0c96 C7848510 		movl	$0, -240(%rbp,%rax,4)
 1316      FFFFFF00 
 1316      000000
 1317 0ca1 8385D4FE 		addl	$1, -300(%rbp)
 1317      FFFF01
 1318              	.L64:
 1319              		.loc 1 320 0 discriminator 1
 1320 0ca8 83BDD4FE 		cmpl	$1, -300(%rbp)
 1320      FFFF01
 1321 0caf 7EDD     		jle	.L65
 1322              	.LBE11:
 1323              	.LBB12:
 321:main.c        ****                             for (uint32_t i = 1; i <= 8; i++) {
 1324              		.loc 1 321 0 is_stmt 1
 1325 0cb1 C785D8FE 		movl	$1, -296(%rbp)
 1325      FFFF0100 
 1325      0000
 1326 0cbb E9100100 		jmp	.L66
 1326      00
 1327              	.L72:
 1328              	.LBB13:
 322:main.c        ****                                 uint8_t *readFromChannel_i = malloc(sizeof(uint8_t));
 1329              		.loc 1 322 0
 1330 0cc0 BF010000 		movl	$1, %edi
 1330      00
 1331 0cc5 E8000000 		call	malloc
 1331      00
 1332 0cca 488945B0 		movq	%rax, -80(%rbp)
 323:main.c        **** 
 324:main.c        ****                                 flSleep(1000);
 1333              		.loc 1 324 0
 1334 0cce BFE80300 		movl	$1000, %edi
 1334      00
 1335 0cd3 E8000000 		call	flSleep
 1335      00
 325:main.c        ****                                 fStatus = flReadChannel(handle, (uint8_t) i, length, readFromChanne
 1336              		.loc 1 325 0
 1337 0cd8 8B9504FF 		movl	-252(%rbp), %edx
 1337      FFFF
 1338 0cde 8B85D8FE 		movl	-296(%rbp), %eax
 1338      FFFF
 1339 0ce4 0FB6F0   		movzbl	%al, %esi
 1340 0ce7 488B8530 		movq	-208(%rbp), %rax
 1340      FFFFFF
 1341 0cee 488DBD38 		leaq	-200(%rbp), %rdi
 1341      FFFFFF
 1342 0cf5 488B4DB0 		movq	-80(%rbp), %rcx
 1343 0cf9 4989F8   		movq	%rdi, %r8
 1344 0cfc 4889C7   		movq	%rax, %rdi
 1345 0cff E8000000 		call	flReadChannel
 1345      00
 1346 0d04 898500FF 		movl	%eax, -256(%rbp)
 1346      FFFF
 326:main.c        ****                                 CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1347              		.loc 1 326 0
 1348 0d0a 83BD00FF 		cmpl	$0, -256(%rbp)
 1348      FFFF00
 1349 0d11 740F     		je	.L67
 1350              		.loc 1 326 0 is_stmt 0 discriminator 1
 1351 0d13 C785CCFE 		movl	$1, -308(%rbp)
 1351      FFFF0100 
 1351      0000
 1352 0d1d E9BC0F00 		jmp	.L68
 1352      00
 1353              	.L67:
 327:main.c        ****                                 if (LOG) printf("Read from channel %u = %u \n", i, *readFromChannel
 1354              		.loc 1 327 0 is_stmt 1
 1355 0d22 0FB60500 		movzbl	LOG(%rip), %eax
 1355      000000
 1356 0d29 84C0     		testb	%al, %al
 1357 0d2b 7421     		je	.L69
 1358              		.loc 1 327 0 is_stmt 0 discriminator 1
 1359 0d2d 488B45B0 		movq	-80(%rbp), %rax
 1360 0d31 0FB600   		movzbl	(%rax), %eax
 1361 0d34 0FB6D0   		movzbl	%al, %edx
 1362 0d37 8B85D8FE 		movl	-296(%rbp), %eax
 1362      FFFF
 1363 0d3d 89C6     		movl	%eax, %esi
 1364 0d3f BF000000 		movl	$.LC48, %edi
 1364      00
 1365 0d44 B8000000 		movl	$0, %eax
 1365      00
 1366 0d49 E8000000 		call	printf
 1366      00
 1367              	.L69:
 328:main.c        ****                                 uint32_t temp1 = 8 * (i - 1), temp2 = 8 * (i - 5);
 1368              		.loc 1 328 0 is_stmt 1
 1369 0d4e 8B85D8FE 		movl	-296(%rbp), %eax
 1369      FFFF
 1370 0d54 05FFFFFF 		addl	$536870911, %eax
 1370      1F
 1371 0d59 C1E003   		sall	$3, %eax
 1372 0d5c 898508FF 		movl	%eax, -248(%rbp)
 1372      FFFF
 1373 0d62 8B85D8FE 		movl	-296(%rbp), %eax
 1373      FFFF
 1374 0d68 05FBFFFF 		addl	$536870907, %eax
 1374      1F
 1375 0d6d C1E003   		sall	$3, %eax
 1376 0d70 89850CFF 		movl	%eax, -244(%rbp)
 1376      FFFF
 329:main.c        ****                                 if (i <= 4) inpFromFrontEnd[0] += (*readFromChannel_i) * (1 << temp
 1377              		.loc 1 329 0
 1378 0d76 83BDD8FE 		cmpl	$4, -296(%rbp)
 1378      FFFF04
 1379 0d7d 7726     		ja	.L70
 1380              		.loc 1 329 0 is_stmt 0 discriminator 1
 1381 0d7f 8B9510FF 		movl	-240(%rbp), %edx
 1381      FFFF
 1382 0d85 488B45B0 		movq	-80(%rbp), %rax
 1383 0d89 0FB600   		movzbl	(%rax), %eax
 1384 0d8c 0FB6F0   		movzbl	%al, %esi
 1385 0d8f 8B8508FF 		movl	-248(%rbp), %eax
 1385      FFFF
 1386 0d95 89C1     		movl	%eax, %ecx
 1387 0d97 D3E6     		sall	%cl, %esi
 1388 0d99 89F0     		movl	%esi, %eax
 1389 0d9b 01D0     		addl	%edx, %eax
 1390 0d9d 898510FF 		movl	%eax, -240(%rbp)
 1390      FFFF
 1391 0da3 EB24     		jmp	.L71
 1392              	.L70:
 330:main.c        ****                                 else inpFromFrontEnd[1] += (*readFromChannel_i) * (1 << temp2);
 1393              		.loc 1 330 0 is_stmt 1
 1394 0da5 8B9514FF 		movl	-236(%rbp), %edx
 1394      FFFF
 1395 0dab 488B45B0 		movq	-80(%rbp), %rax
 1396 0daf 0FB600   		movzbl	(%rax), %eax
 1397 0db2 0FB6F0   		movzbl	%al, %esi
 1398 0db5 8B850CFF 		movl	-244(%rbp), %eax
 1398      FFFF
 1399 0dbb 89C1     		movl	%eax, %ecx
 1400 0dbd D3E6     		sall	%cl, %esi
 1401 0dbf 89F0     		movl	%esi, %eax
 1402 0dc1 01D0     		addl	%edx, %eax
 1403 0dc3 898514FF 		movl	%eax, -236(%rbp)
 1403      FFFF
 1404              	.L71:
 1405              	.LBE13:
 321:main.c        ****                                 uint8_t *readFromChannel_i = malloc(sizeof(uint8_t));
 1406              		.loc 1 321 0
 1407 0dc9 8385D8FE 		addl	$1, -296(%rbp)
 1407      FFFF01
 1408              	.L66:
 321:main.c        ****                                 uint8_t *readFromChannel_i = malloc(sizeof(uint8_t));
 1409              		.loc 1 321 0 is_stmt 0 discriminator 1
 1410 0dd0 83BDD8FE 		cmpl	$8, -296(%rbp)
 1410      FFFF08
 1411 0dd7 0F86E3FE 		jbe	.L72
 1411      FFFF
 1412              	.LBE12:
 331:main.c        ****                             }
 332:main.c        ****                             decrypt64(inpFromFrontEnd);
 1413              		.loc 1 332 0 is_stmt 1
 1414 0ddd 488D8510 		leaq	-240(%rbp), %rax
 1414      FFFFFF
 1415 0de4 4889C7   		movq	%rax, %rdi
 1416 0de7 E8000000 		call	decrypt64
 1416      00
 333:main.c        ****                             uint8_t num_100 = 0, num_500 = 0, num_1000 = 0, num_2000 = 0;
 1417              		.loc 1 333 0
 1418 0dec C685A4FE 		movb	$0, -348(%rbp)
 1418      FFFF00
 1419 0df3 C685A5FE 		movb	$0, -347(%rbp)
 1419      FFFF00
 1420 0dfa C685A6FE 		movb	$0, -346(%rbp)
 1420      FFFF00
 1421 0e01 C685A7FE 		movb	$0, -345(%rbp)
 1421      FFFF00
 334:main.c        ****                             uint16_t userID = 0, unhashedPin = 0;
 1422              		.loc 1 334 0
 1423 0e08 66C785B8 		movw	$0, -328(%rbp)
 1423      FEFFFF00 
 1423      00
 1424 0e11 66C785BA 		movw	$0, -326(%rbp)
 1424      FEFFFF00 
 1424      00
 1425              	.LBB14:
 335:main.c        ****                             for (uint8_t i = 1; i <= 32; i++) {
 1426              		.loc 1 335 0
 1427 0e1a C685A8FE 		movb	$1, -344(%rbp)
 1427      FFFF01
 1428 0e21 E92F0100 		jmp	.L73
 1428      00
 1429              	.L81:
 336:main.c        ****                                 if (i <= 8) {
 1430              		.loc 1 336 0
 1431 0e26 80BDA8FE 		cmpb	$8, -344(%rbp)
 1431      FFFF08
 1432 0e2d 7745     		ja	.L74
 337:main.c        ****                                     if ((inpFromFrontEnd[0] & (1 << (i - 1))) != 0) num_100 += ((1 
 1433              		.loc 1 337 0
 1434 0e2f 8B9510FF 		movl	-240(%rbp), %edx
 1434      FFFF
 1435 0e35 0FB685A8 		movzbl	-344(%rbp), %eax
 1435      FEFFFF
 1436 0e3c 83E801   		subl	$1, %eax
 1437 0e3f BE010000 		movl	$1, %esi
 1437      00
 1438 0e44 89C1     		movl	%eax, %ecx
 1439 0e46 D3E6     		sall	%cl, %esi
 1440 0e48 89F0     		movl	%esi, %eax
 1441 0e4a 21D0     		andl	%edx, %eax
 1442 0e4c 85C0     		testl	%eax, %eax
 1443 0e4e 0F84F100 		je	.L76
 1443      0000
 1444              		.loc 1 337 0 is_stmt 0 discriminator 1
 1445 0e54 0FB685A8 		movzbl	-344(%rbp), %eax
 1445      FEFFFF
 1446 0e5b 83E801   		subl	$1, %eax
 1447 0e5e BA010000 		movl	$1, %edx
 1447      00
 1448 0e63 89C1     		movl	%eax, %ecx
 1449 0e65 D3E2     		sall	%cl, %edx
 1450 0e67 89D0     		movl	%edx, %eax
 1451 0e69 0085A4FE 		addb	%al, -348(%rbp)
 1451      FFFF
 1452 0e6f E9D10000 		jmp	.L76
 1452      00
 1453              	.L74:
 338:main.c        ****                                 } else if (i <= 16) {
 1454              		.loc 1 338 0 is_stmt 1
 1455 0e74 80BDA8FE 		cmpb	$16, -344(%rbp)
 1455      FFFF10
 1456 0e7b 7745     		ja	.L77
 339:main.c        ****                                     if ((inpFromFrontEnd[0] & (1 << (i - 1))) != 0) num_500 += ((1 
 1457              		.loc 1 339 0
 1458 0e7d 8B9510FF 		movl	-240(%rbp), %edx
 1458      FFFF
 1459 0e83 0FB685A8 		movzbl	-344(%rbp), %eax
 1459      FEFFFF
 1460 0e8a 83E801   		subl	$1, %eax
 1461 0e8d BE010000 		movl	$1, %esi
 1461      00
 1462 0e92 89C1     		movl	%eax, %ecx
 1463 0e94 D3E6     		sall	%cl, %esi
 1464 0e96 89F0     		movl	%esi, %eax
 1465 0e98 21D0     		andl	%edx, %eax
 1466 0e9a 85C0     		testl	%eax, %eax
 1467 0e9c 0F84A300 		je	.L76
 1467      0000
 1468              		.loc 1 339 0 is_stmt 0 discriminator 1
 1469 0ea2 0FB685A8 		movzbl	-344(%rbp), %eax
 1469      FEFFFF
 1470 0ea9 83E809   		subl	$9, %eax
 1471 0eac BA010000 		movl	$1, %edx
 1471      00
 1472 0eb1 89C1     		movl	%eax, %ecx
 1473 0eb3 D3E2     		sall	%cl, %edx
 1474 0eb5 89D0     		movl	%edx, %eax
 1475 0eb7 0085A5FE 		addb	%al, -347(%rbp)
 1475      FFFF
 1476 0ebd E9830000 		jmp	.L76
 1476      00
 1477              	.L77:
 340:main.c        ****                                 } else if (i <= 24) {
 1478              		.loc 1 340 0 is_stmt 1
 1479 0ec2 80BDA8FE 		cmpb	$24, -344(%rbp)
 1479      FFFF18
 1480 0ec9 773E     		ja	.L79
 341:main.c        ****                                     if ((inpFromFrontEnd[0] & (1 << (i - 1))) != 0) num_1000 += ((1
 1481              		.loc 1 341 0
 1482 0ecb 8B9510FF 		movl	-240(%rbp), %edx
 1482      FFFF
 1483 0ed1 0FB685A8 		movzbl	-344(%rbp), %eax
 1483      FEFFFF
 1484 0ed8 83E801   		subl	$1, %eax
 1485 0edb BE010000 		movl	$1, %esi
 1485      00
 1486 0ee0 89C1     		movl	%eax, %ecx
 1487 0ee2 D3E6     		sall	%cl, %esi
 1488 0ee4 89F0     		movl	%esi, %eax
 1489 0ee6 21D0     		andl	%edx, %eax
 1490 0ee8 85C0     		testl	%eax, %eax
 1491 0eea 7459     		je	.L76
 1492              		.loc 1 341 0 is_stmt 0 discriminator 1
 1493 0eec 0FB685A8 		movzbl	-344(%rbp), %eax
 1493      FEFFFF
 1494 0ef3 83E811   		subl	$17, %eax
 1495 0ef6 BA010000 		movl	$1, %edx
 1495      00
 1496 0efb 89C1     		movl	%eax, %ecx
 1497 0efd D3E2     		sall	%cl, %edx
 1498 0eff 89D0     		movl	%edx, %eax
 1499 0f01 0085A6FE 		addb	%al, -346(%rbp)
 1499      FFFF
 1500 0f07 EB3C     		jmp	.L76
 1501              	.L79:
 342:main.c        ****                                 } else {
 343:main.c        ****                                     if ((inpFromFrontEnd[0] & (1 << (i - 1))) != 0) num_2000 += ((1
 1502              		.loc 1 343 0 is_stmt 1
 1503 0f09 8B9510FF 		movl	-240(%rbp), %edx
 1503      FFFF
 1504 0f0f 0FB685A8 		movzbl	-344(%rbp), %eax
 1504      FEFFFF
 1505 0f16 83E801   		subl	$1, %eax
 1506 0f19 BE010000 		movl	$1, %esi
 1506      00
 1507 0f1e 89C1     		movl	%eax, %ecx
 1508 0f20 D3E6     		sall	%cl, %esi
 1509 0f22 89F0     		movl	%esi, %eax
 1510 0f24 21D0     		andl	%edx, %eax
 1511 0f26 85C0     		testl	%eax, %eax
 1512 0f28 741B     		je	.L76
 1513              		.loc 1 343 0 is_stmt 0 discriminator 1
 1514 0f2a 0FB685A8 		movzbl	-344(%rbp), %eax
 1514      FEFFFF
 1515 0f31 83E819   		subl	$25, %eax
 1516 0f34 BA010000 		movl	$1, %edx
 1516      00
 1517 0f39 89C1     		movl	%eax, %ecx
 1518 0f3b D3E2     		sall	%cl, %edx
 1519 0f3d 89D0     		movl	%edx, %eax
 1520 0f3f 0085A7FE 		addb	%al, -345(%rbp)
 1520      FFFF
 1521              	.L76:
 335:main.c        ****                                 if (i <= 8) {
 1522              		.loc 1 335 0 is_stmt 1
 1523 0f45 0FB685A8 		movzbl	-344(%rbp), %eax
 1523      FEFFFF
 1524 0f4c 83C001   		addl	$1, %eax
 1525 0f4f 8885A8FE 		movb	%al, -344(%rbp)
 1525      FFFF
 1526              	.L73:
 335:main.c        ****                                 if (i <= 8) {
 1527              		.loc 1 335 0 is_stmt 0 discriminator 1
 1528 0f55 80BDA8FE 		cmpb	$32, -344(%rbp)
 1528      FFFF20
 1529 0f5c 0F86C4FE 		jbe	.L81
 1529      FFFF
 1530              	.LBE14:
 1531              	.LBB15:
 344:main.c        ****                                 }
 345:main.c        ****                             }
 346:main.c        ****                             for (uint16_t i = 1; i <= 32; i++) {
 1532              		.loc 1 346 0 is_stmt 1
 1533 0f62 66C785BC 		movw	$1, -324(%rbp)
 1533      FEFFFF01 
 1533      00
 1534 0f6b E9970000 		jmp	.L82
 1534      00
 1535              	.L86:
 347:main.c        ****                                 if (i <= 16) {
 1536              		.loc 1 347 0
 1537 0f70 6683BDBC 		cmpw	$16, -324(%rbp)
 1537      FEFFFF10 
 1538 0f78 773F     		ja	.L83
 348:main.c        ****                                     if ((inpFromFrontEnd[1] & (1 << (i - 1))) != 0) unhashedPin += 
 1539              		.loc 1 348 0
 1540 0f7a 8B9514FF 		movl	-236(%rbp), %edx
 1540      FFFF
 1541 0f80 0FB785BC 		movzwl	-324(%rbp), %eax
 1541      FEFFFF
 1542 0f87 83E801   		subl	$1, %eax
 1543 0f8a BE010000 		movl	$1, %esi
 1543      00
 1544 0f8f 89C1     		movl	%eax, %ecx
 1545 0f91 D3E6     		sall	%cl, %esi
 1546 0f93 89F0     		movl	%esi, %eax
 1547 0f95 21D0     		andl	%edx, %eax
 1548 0f97 85C0     		testl	%eax, %eax
 1549 0f99 745B     		je	.L85
 1550              		.loc 1 348 0 is_stmt 0 discriminator 1
 1551 0f9b 0FB785BC 		movzwl	-324(%rbp), %eax
 1551      FEFFFF
 1552 0fa2 83E801   		subl	$1, %eax
 1553 0fa5 BA010000 		movl	$1, %edx
 1553      00
 1554 0faa 89C1     		movl	%eax, %ecx
 1555 0fac D3E2     		sall	%cl, %edx
 1556 0fae 89D0     		movl	%edx, %eax
 1557 0fb0 660185BA 		addw	%ax, -326(%rbp)
 1557      FEFFFF
 1558 0fb7 EB3D     		jmp	.L85
 1559              	.L83:
 349:main.c        ****                                 } else {
 350:main.c        ****                                     if ((inpFromFrontEnd[1] & (1 << (i - 1))) != 0) userID += ((1 <
 1560              		.loc 1 350 0 is_stmt 1
 1561 0fb9 8B9514FF 		movl	-236(%rbp), %edx
 1561      FFFF
 1562 0fbf 0FB785BC 		movzwl	-324(%rbp), %eax
 1562      FEFFFF
 1563 0fc6 83E801   		subl	$1, %eax
 1564 0fc9 BE010000 		movl	$1, %esi
 1564      00
 1565 0fce 89C1     		movl	%eax, %ecx
 1566 0fd0 D3E6     		sall	%cl, %esi
 1567 0fd2 89F0     		movl	%esi, %eax
 1568 0fd4 21D0     		andl	%edx, %eax
 1569 0fd6 85C0     		testl	%eax, %eax
 1570 0fd8 741C     		je	.L85
 1571              		.loc 1 350 0 is_stmt 0 discriminator 1
 1572 0fda 0FB785BC 		movzwl	-324(%rbp), %eax
 1572      FEFFFF
 1573 0fe1 83E811   		subl	$17, %eax
 1574 0fe4 BA010000 		movl	$1, %edx
 1574      00
 1575 0fe9 89C1     		movl	%eax, %ecx
 1576 0feb D3E2     		sall	%cl, %edx
 1577 0fed 89D0     		movl	%edx, %eax
 1578 0fef 660185B8 		addw	%ax, -328(%rbp)
 1578      FEFFFF
 1579              	.L85:
 346:main.c        ****                                 if (i <= 16) {
 1580              		.loc 1 346 0 is_stmt 1
 1581 0ff6 0FB785BC 		movzwl	-324(%rbp), %eax
 1581      FEFFFF
 1582 0ffd 83C001   		addl	$1, %eax
 1583 1000 668985BC 		movw	%ax, -324(%rbp)
 1583      FEFFFF
 1584              	.L82:
 346:main.c        ****                                 if (i <= 16) {
 1585              		.loc 1 346 0 is_stmt 0 discriminator 1
 1586 1007 6683BDBC 		cmpw	$32, -324(%rbp)
 1586      FEFFFF20 
 1587 100f 0F865BFF 		jbe	.L86
 1587      FFFF
 1588              	.LBE15:
 351:main.c        ****                                 }
 352:main.c        ****                             }
 353:main.c        **** //                            printf("unhashedPin %u\n", unhashedPin);
 354:main.c        **** //                            printf("userID %u\n", userID);
 355:main.c        ****                             uint16_t hashedPin = myHash(unhashedPin);
 1589              		.loc 1 355 0 is_stmt 1
 1590 1015 0FB785BA 		movzwl	-326(%rbp), %eax
 1590      FEFFFF
 1591 101c 89C7     		movl	%eax, %edi
 1592 101e E8000000 		call	myHash
 1592      00
 1593 1023 668985BE 		movw	%ax, -322(%rbp)
 1593      FEFFFF
 356:main.c        **** //                            printf("hashedPin %u\n", hashedPin);
 357:main.c        **** //                            printf("num_2000 %u\n", num_2000);
 358:main.c        **** //                            printf("num_1000 %u\n", num_1000);
 359:main.c        **** //                            printf("num_500 %u\n", num_500);
 360:main.c        **** //                            printf("num_100 %u\n", num_100);
 361:main.c        **** 
 362:main.c        ****                             int bal = -1;
 1594              		.loc 1 362 0
 1595 102a C785C0FE 		movl	$-1, -320(%rbp)
 1595      FFFFFFFF 
 1595      FFFF
 363:main.c        ****                             bool isAdmin = false;
 1596              		.loc 1 363 0
 1597 1034 C685A0FE 		movb	$0, -352(%rbp)
 1597      FFFF00
 364:main.c        ****                             int inLineNum = -1;
 1598              		.loc 1 364 0
 1599 103b C785C4FE 		movl	$-1, -316(%rbp)
 1599      FFFFFFFF 
 1599      FFFF
 365:main.c        ****                             uint8_t *statusOnChan9 = malloc(sizeof(uint8_t));
 1600              		.loc 1 365 0
 1601 1045 BF010000 		movl	$1, %edi
 1601      00
 1602 104a E8000000 		call	malloc
 1602      00
 1603 104f 488945B8 		movq	%rax, -72(%rbp)
 366:main.c        ****                             if (find(userID, hashedPin, &isAdmin, &bal, &inLineNum)) {
 1604              		.loc 1 366 0
 1605 1053 0FB7B5BE 		movzwl	-322(%rbp), %esi
 1605      FEFFFF
 1606 105a 0FB785B8 		movzwl	-328(%rbp), %eax
 1606      FEFFFF
 1607 1061 488DBDC4 		leaq	-316(%rbp), %rdi
 1607      FEFFFF
 1608 1068 488D8DC0 		leaq	-320(%rbp), %rcx
 1608      FEFFFF
 1609 106f 488D95A0 		leaq	-352(%rbp), %rdx
 1609      FEFFFF
 1610 1076 4989F8   		movq	%rdi, %r8
 1611 1079 89C7     		movl	%eax, %edi
 1612 107b E8000000 		call	find
 1612      00
 1613 1080 84C0     		testb	%al, %al
 1614 1082 0F841E0B 		je	.L87
 1614      0000
 367:main.c        ****                                 printf("Valid user found \n");
 1615              		.loc 1 367 0
 1616 1088 BF000000 		movl	$.LC49, %edi
 1616      00
 1617 108d E8000000 		call	puts
 1617      00
 368:main.c        ****                                 if (!isAdmin) {
 1618              		.loc 1 368 0
 1619 1092 0FB685A0 		movzbl	-352(%rbp), %eax
 1619      FEFFFF
 1620 1099 83F001   		xorl	$1, %eax
 1621 109c 84C0     		testb	%al, %al
 1622 109e 0F840107 		je	.L88
 1622      0000
 1623              	.LBB16:
 369:main.c        ****                                     int reqAmo = 0;
 1624              		.loc 1 369 0
 1625 10a4 C785C8FE 		movl	$0, -312(%rbp)
 1625      FFFF0000 
 1625      0000
 370:main.c        ****                                     if (suffBal(bal, &reqAmo, num_100, num_500, num_1000, num_2000)
 1626              		.loc 1 370 0
 1627 10ae 440FB685 		movzbl	-345(%rbp), %r8d
 1627      A7FEFFFF 
 1628 10b6 0FB6BDA6 		movzbl	-346(%rbp), %edi
 1628      FEFFFF
 1629 10bd 0FB68DA5 		movzbl	-347(%rbp), %ecx
 1629      FEFFFF
 1630 10c4 0FB695A4 		movzbl	-348(%rbp), %edx
 1630      FEFFFF
 1631 10cb 8B85C0FE 		movl	-320(%rbp), %eax
 1631      FFFF
 1632 10d1 488DB5C8 		leaq	-312(%rbp), %rsi
 1632      FEFFFF
 1633 10d8 4589C1   		movl	%r8d, %r9d
 1634 10db 4189F8   		movl	%edi, %r8d
 1635 10de 89C7     		movl	%eax, %edi
 1636 10e0 E8000000 		call	suffBal
 1636      00
 1637 10e5 84C0     		testb	%al, %al
 1638 10e7 0F846A05 		je	.L89
 1638      0000
 1639              		.loc 1 370 0 is_stmt 0 discriminator 1
 1640 10ed 80BDA6FE 		cmpb	$0, -346(%rbp)
 1640      FFFF00
 1641 10f4 0F855D05 		jne	.L89
 1641      0000
 1642              	.LBB17:
 371:main.c        **** //                                        printf("bal %u\n", bal);
 372:main.c        **** //                                        printf("req %u\n", reqAmo);
 373:main.c        ****                                         if (LOG) printf("Sufficient Balance in account\n");
 1643              		.loc 1 373 0 is_stmt 1
 1644 10fa 0FB60500 		movzbl	LOG(%rip), %eax
 1644      000000
 1645 1101 84C0     		testb	%al, %al
 1646 1103 740A     		je	.L90
 1647              		.loc 1 373 0 is_stmt 0 discriminator 1
 1648 1105 BF000000 		movl	$.LC50, %edi
 1648      00
 1649 110a E8000000 		call	puts
 1649      00
 1650              	.L90:
 374:main.c        ****                                         *statusOnChan9 = 1;
 1651              		.loc 1 374 0 is_stmt 1
 1652 110f 488B45B8 		movq	-72(%rbp), %rax
 1653 1113 C60001   		movb	$1, (%rax)
 375:main.c        ****                                         flSleep(1000);
 1654              		.loc 1 375 0
 1655 1116 BFE80300 		movl	$1000, %edi
 1655      00
 1656 111b E8000000 		call	flSleep
 1656      00
 376:main.c        ****                                         if (LOG) printf("Write to channel %u = %u \n", 9, *statusOn
 1657              		.loc 1 376 0
 1658 1120 0FB60500 		movzbl	LOG(%rip), %eax
 1658      000000
 1659 1127 84C0     		testb	%al, %al
 1660 1129 7420     		je	.L91
 1661              		.loc 1 376 0 is_stmt 0 discriminator 1
 1662 112b 488B45B8 		movq	-72(%rbp), %rax
 1663 112f 0FB600   		movzbl	(%rax), %eax
 1664 1132 0FB6C0   		movzbl	%al, %eax
 1665 1135 89C2     		movl	%eax, %edx
 1666 1137 BE090000 		movl	$9, %esi
 1666      00
 1667 113c BF000000 		movl	$.LC51, %edi
 1667      00
 1668 1141 B8000000 		movl	$0, %eax
 1668      00
 1669 1146 E8000000 		call	printf
 1669      00
 1670              	.L91:
 377:main.c        ****                                         fStatus = flWriteChannel(handle, (uint8_t) 9, length, statu
 1671              		.loc 1 377 0 is_stmt 1
 1672 114b 8B9504FF 		movl	-252(%rbp), %edx
 1672      FFFF
 1673 1151 488B8530 		movq	-208(%rbp), %rax
 1673      FFFFFF
 1674 1158 488DB538 		leaq	-200(%rbp), %rsi
 1674      FFFFFF
 1675 115f 488B4DB8 		movq	-72(%rbp), %rcx
 1676 1163 4989F0   		movq	%rsi, %r8
 1677 1166 BE090000 		movl	$9, %esi
 1677      00
 1678 116b 4889C7   		movq	%rax, %rdi
 1679 116e E8000000 		call	flWriteChannel
 1679      00
 1680 1173 898500FF 		movl	%eax, -256(%rbp)
 1680      FFFF
 378:main.c        ****                                         CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1681              		.loc 1 378 0
 1682 1179 83BD00FF 		cmpl	$0, -256(%rbp)
 1682      FFFF00
 1683 1180 740F     		je	.L92
 1684              		.loc 1 378 0 is_stmt 0 discriminator 1
 1685 1182 C785CCFE 		movl	$1, -308(%rbp)
 1685      FFFF0100 
 1685      0000
 1686 118c E90F0600 		jmp	.L125
 1686      00
 1687              	.L92:
 379:main.c        ****                                         flSleep(1000);
 1688              		.loc 1 379 0 is_stmt 1
 1689 1191 BFE80300 		movl	$1000, %edi
 1689      00
 1690 1196 E8000000 		call	flSleep
 1690      00
 1691              	.LBB18:
 380:main.c        ****                                         uint32_t befEncSen[2];
 381:main.c        ****                                         for (int i = 0; i < 2; i++) befEncSen[i] = 0;
 1692              		.loc 1 381 0
 1693 119b C785DCFE 		movl	$0, -292(%rbp)
 1693      FFFF0000 
 1693      0000
 1694 11a5 EB1A     		jmp	.L94
 1695              	.L95:
 1696              		.loc 1 381 0 is_stmt 0 discriminator 2
 1697 11a7 8B85DCFE 		movl	-292(%rbp), %eax
 1697      FFFF
 1698 11ad 4898     		cltq
 1699 11af C7848520 		movl	$0, -224(%rbp,%rax,4)
 1699      FFFFFF00 
 1699      000000
 1700 11ba 8385DCFE 		addl	$1, -292(%rbp)
 1700      FFFF01
 1701              	.L94:
 1702              		.loc 1 381 0 discriminator 1
 1703 11c1 83BDDCFE 		cmpl	$1, -292(%rbp)
 1703      FFFF01
 1704 11c8 7EDD     		jle	.L95
 1705              	.LBE18:
 1706              	.LBB19:
 382:main.c        ****                                         for (uint32_t i = 0; i <= 31; i += 8) {
 1707              		.loc 1 382 0 is_stmt 1
 1708 11ca C785E0FE 		movl	$0, -288(%rbp)
 1708      FFFF0000 
 1708      0000
 1709 11d4 E9AC0000 		jmp	.L96
 1709      00
 1710              	.L101:
 383:main.c        ****                                             if (i == 0) befEncSen[0] += ((1 << i) * ((uint32_t) num
 1711              		.loc 1 383 0
 1712 11d9 83BDE0FE 		cmpl	$0, -288(%rbp)
 1712      FFFF00
 1713 11e0 7523     		jne	.L97
 1714              		.loc 1 383 0 is_stmt 0 discriminator 1
 1715 11e2 8B9520FF 		movl	-224(%rbp), %edx
 1715      FFFF
 1716 11e8 0FB6B5A4 		movzbl	-348(%rbp), %esi
 1716      FEFFFF
 1717 11ef 8B85E0FE 		movl	-288(%rbp), %eax
 1717      FFFF
 1718 11f5 89C1     		movl	%eax, %ecx
 1719 11f7 D3E6     		sall	%cl, %esi
 1720 11f9 89F0     		movl	%esi, %eax
 1721 11fb 01D0     		addl	%edx, %eax
 1722 11fd 898520FF 		movl	%eax, -224(%rbp)
 1722      FFFF
 1723 1203 EB79     		jmp	.L98
 1724              	.L97:
 384:main.c        ****                                             else if (i == 8) befEncSen[0] += ((1 << i) * ((uint32_t
 1725              		.loc 1 384 0 is_stmt 1
 1726 1205 83BDE0FE 		cmpl	$8, -288(%rbp)
 1726      FFFF08
 1727 120c 7523     		jne	.L99
 1728              		.loc 1 384 0 is_stmt 0 discriminator 1
 1729 120e 8B9520FF 		movl	-224(%rbp), %edx
 1729      FFFF
 1730 1214 0FB6B5A5 		movzbl	-347(%rbp), %esi
 1730      FEFFFF
 1731 121b 8B85E0FE 		movl	-288(%rbp), %eax
 1731      FFFF
 1732 1221 89C1     		movl	%eax, %ecx
 1733 1223 D3E6     		sall	%cl, %esi
 1734 1225 89F0     		movl	%esi, %eax
 1735 1227 01D0     		addl	%edx, %eax
 1736 1229 898520FF 		movl	%eax, -224(%rbp)
 1736      FFFF
 1737 122f EB4D     		jmp	.L98
 1738              	.L99:
 385:main.c        ****                                             else if (i == 16) befEncSen[0] += ((1 << i) * ((uint32_
 1739              		.loc 1 385 0 is_stmt 1
 1740 1231 83BDE0FE 		cmpl	$16, -288(%rbp)
 1740      FFFF10
 1741 1238 7523     		jne	.L100
 1742              		.loc 1 385 0 is_stmt 0 discriminator 1
 1743 123a 8B9520FF 		movl	-224(%rbp), %edx
 1743      FFFF
 1744 1240 0FB6B5A6 		movzbl	-346(%rbp), %esi
 1744      FEFFFF
 1745 1247 8B85E0FE 		movl	-288(%rbp), %eax
 1745      FFFF
 1746 124d 89C1     		movl	%eax, %ecx
 1747 124f D3E6     		sall	%cl, %esi
 1748 1251 89F0     		movl	%esi, %eax
 1749 1253 01D0     		addl	%edx, %eax
 1750 1255 898520FF 		movl	%eax, -224(%rbp)
 1750      FFFF
 1751 125b EB21     		jmp	.L98
 1752              	.L100:
 386:main.c        ****                                             else befEncSen[0] += ((1 << i) * ((uint32_t) num_2000))
 1753              		.loc 1 386 0 is_stmt 1
 1754 125d 8B9520FF 		movl	-224(%rbp), %edx
 1754      FFFF
 1755 1263 0FB6B5A7 		movzbl	-345(%rbp), %esi
 1755      FEFFFF
 1756 126a 8B85E0FE 		movl	-288(%rbp), %eax
 1756      FFFF
 1757 1270 89C1     		movl	%eax, %ecx
 1758 1272 D3E6     		sall	%cl, %esi
 1759 1274 89F0     		movl	%esi, %eax
 1760 1276 01D0     		addl	%edx, %eax
 1761 1278 898520FF 		movl	%eax, -224(%rbp)
 1761      FFFF
 1762              	.L98:
 382:main.c        ****                                             if (i == 0) befEncSen[0] += ((1 << i) * ((uint32_t) num
 1763              		.loc 1 382 0
 1764 127e 8385E0FE 		addl	$8, -288(%rbp)
 1764      FFFF08
 1765              	.L96:
 382:main.c        ****                                             if (i == 0) befEncSen[0] += ((1 << i) * ((uint32_t) num
 1766              		.loc 1 382 0 is_stmt 0 discriminator 1
 1767 1285 83BDE0FE 		cmpl	$31, -288(%rbp)
 1767      FFFF1F
 1768 128c 0F8647FF 		jbe	.L101
 1768      FFFF
 1769              	.LBE19:
 387:main.c        ****                                         }
 388:main.c        ****                                         encrypt64(befEncSen);
 1770              		.loc 1 388 0 is_stmt 1
 1771 1292 488D8520 		leaq	-224(%rbp), %rax
 1771      FFFFFF
 1772 1299 4889C7   		movq	%rax, %rdi
 1773 129c E8000000 		call	encrypt64
 1773      00
 1774              	.LBB20:
 389:main.c        ****                                         for (uint8_t i = 10; i <= 13; i++) {
 1775              		.loc 1 389 0
 1776 12a1 C685A9FE 		movb	$10, -343(%rbp)
 1776      FFFF0A
 1777 12a8 E91C0100 		jmp	.L102
 1777      00
 1778              	.L108:
 1779              	.LBB21:
 390:main.c        ****                                             uint8_t tempSto = 0;
 1780              		.loc 1 390 0
 1781 12ad C685A1FE 		movb	$0, -351(%rbp)
 1781      FFFF00
 1782              	.LBB22:
 391:main.c        ****                                             for (uint8_t j = 0; j <= 7; j++) {
 1783              		.loc 1 391 0
 1784 12b4 C685AAFE 		movb	$0, -342(%rbp)
 1784      FFFF00
 1785 12bb EB71     		jmp	.L103
 1786              	.L105:
 1787              	.LBB23:
 392:main.c        ****                                                 uint8_t temp = j + (i - 10) * 8;
 1788              		.loc 1 392 0
 1789 12bd 0FB685A9 		movzbl	-343(%rbp), %eax
 1789      FEFFFF
 1790 12c4 83E80A   		subl	$10, %eax
 1791 12c7 8D14C500 		leal	0(,%rax,8), %edx
 1791      000000
 1792 12ce 0FB685AA 		movzbl	-342(%rbp), %eax
 1792      FEFFFF
 1793 12d5 01D0     		addl	%edx, %eax
 1794 12d7 8885B4FE 		movb	%al, -332(%rbp)
 1794      FFFF
 393:main.c        ****                                                 if ((befEncSen[0] & (1 << temp)) != 0) {
 1795              		.loc 1 393 0
 1796 12dd 8B9520FF 		movl	-224(%rbp), %edx
 1796      FFFF
 1797 12e3 0FB685B4 		movzbl	-332(%rbp), %eax
 1797      FEFFFF
 1798 12ea BE010000 		movl	$1, %esi
 1798      00
 1799 12ef 89C1     		movl	%eax, %ecx
 1800 12f1 D3E6     		sall	%cl, %esi
 1801 12f3 89F0     		movl	%esi, %eax
 1802 12f5 21D0     		andl	%edx, %eax
 1803 12f7 85C0     		testl	%eax, %eax
 1804 12f9 7423     		je	.L104
 394:main.c        ****                                                     tempSto += (1 << j);
 1805              		.loc 1 394 0
 1806 12fb 0FB685AA 		movzbl	-342(%rbp), %eax
 1806      FEFFFF
 1807 1302 BA010000 		movl	$1, %edx
 1807      00
 1808 1307 89C1     		movl	%eax, %ecx
 1809 1309 D3E2     		sall	%cl, %edx
 1810 130b 89D0     		movl	%edx, %eax
 1811 130d 89C2     		movl	%eax, %edx
 1812 130f 0FB685A1 		movzbl	-351(%rbp), %eax
 1812      FEFFFF
 1813 1316 01D0     		addl	%edx, %eax
 1814 1318 8885A1FE 		movb	%al, -351(%rbp)
 1814      FFFF
 1815              	.L104:
 1816              	.LBE23:
 391:main.c        ****                                                 uint8_t temp = j + (i - 10) * 8;
 1817              		.loc 1 391 0
 1818 131e 0FB685AA 		movzbl	-342(%rbp), %eax
 1818      FEFFFF
 1819 1325 83C001   		addl	$1, %eax
 1820 1328 8885AAFE 		movb	%al, -342(%rbp)
 1820      FFFF
 1821              	.L103:
 391:main.c        ****                                                 uint8_t temp = j + (i - 10) * 8;
 1822              		.loc 1 391 0 is_stmt 0 discriminator 1
 1823 132e 80BDAAFE 		cmpb	$7, -342(%rbp)
 1823      FFFF07
 1824 1335 7686     		jbe	.L105
 1825              	.LBE22:
 395:main.c        ****                                                 }
 396:main.c        ****                                             }
 397:main.c        ****                                             flSleep(1000);
 1826              		.loc 1 397 0 is_stmt 1
 1827 1337 BFE80300 		movl	$1000, %edi
 1827      00
 1828 133c E8000000 		call	flSleep
 1828      00
 398:main.c        ****                                             fStatus = flWriteChannel(handle, (uint8_t) i, length, &
 1829              		.loc 1 398 0
 1830 1341 8B9504FF 		movl	-252(%rbp), %edx
 1830      FFFF
 1831 1347 0FB6B5A9 		movzbl	-343(%rbp), %esi
 1831      FEFFFF
 1832 134e 488B8530 		movq	-208(%rbp), %rax
 1832      FFFFFF
 1833 1355 488DBD38 		leaq	-200(%rbp), %rdi
 1833      FFFFFF
 1834 135c 488D8DA1 		leaq	-351(%rbp), %rcx
 1834      FEFFFF
 1835 1363 4989F8   		movq	%rdi, %r8
 1836 1366 4889C7   		movq	%rax, %rdi
 1837 1369 E8000000 		call	flWriteChannel
 1837      00
 1838 136e 898500FF 		movl	%eax, -256(%rbp)
 1838      FFFF
 399:main.c        ****                                             if (LOG) printf("Write to channel %u = %u \n", i, tempS
 1839              		.loc 1 399 0
 1840 1374 0FB60500 		movzbl	LOG(%rip), %eax
 1840      000000
 1841 137b 84C0     		testb	%al, %al
 1842 137d 7422     		je	.L106
 1843              		.loc 1 399 0 is_stmt 0 discriminator 1
 1844 137f 0FB685A1 		movzbl	-351(%rbp), %eax
 1844      FEFFFF
 1845 1386 0FB6D0   		movzbl	%al, %edx
 1846 1389 0FB685A9 		movzbl	-343(%rbp), %eax
 1846      FEFFFF
 1847 1390 89C6     		movl	%eax, %esi
 1848 1392 BF000000 		movl	$.LC51, %edi
 1848      00
 1849 1397 B8000000 		movl	$0, %eax
 1849      00
 1850 139c E8000000 		call	printf
 1850      00
 1851              	.L106:
 400:main.c        ****                                             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1852              		.loc 1 400 0 is_stmt 1
 1853 13a1 83BD00FF 		cmpl	$0, -256(%rbp)
 1853      FFFF00
 1854 13a8 740F     		je	.L107
 1855              		.loc 1 400 0 is_stmt 0 discriminator 1
 1856 13aa C785CCFE 		movl	$1, -308(%rbp)
 1856      FFFF0100 
 1856      0000
 1857              	.LBE21:
 1858              	.LBE20:
 378:main.c        ****                                         flSleep(1000);
 1859              		.loc 1 378 0 is_stmt 1 discriminator 1
 1860 13b4 E9E70300 		jmp	.L125
 1860      00
 1861              	.L107:
 1862              	.LBB24:
 389:main.c        ****                                             uint8_t tempSto = 0;
 1863              		.loc 1 389 0
 1864 13b9 0FB685A9 		movzbl	-343(%rbp), %eax
 1864      FEFFFF
 1865 13c0 83C001   		addl	$1, %eax
 1866 13c3 8885A9FE 		movb	%al, -343(%rbp)
 1866      FFFF
 1867              	.L102:
 389:main.c        ****                                             uint8_t tempSto = 0;
 1868              		.loc 1 389 0 is_stmt 0 discriminator 1
 1869 13c9 80BDA9FE 		cmpb	$13, -343(%rbp)
 1869      FFFF0D
 1870 13d0 0F86D7FE 		jbe	.L108
 1870      FFFF
 1871              	.LBE24:
 1872              	.LBB25:
 401:main.c        ****                                         }
 402:main.c        **** 
 403:main.c        ****                                         for (uint8_t i = 14; i <= 17; i++) {
 1873              		.loc 1 403 0 is_stmt 1
 1874 13d6 C685ABFE 		movb	$14, -341(%rbp)
 1874      FFFF0E
 1875 13dd E91C0100 		jmp	.L109
 1875      00
 1876              	.L115:
 1877              	.LBB26:
 404:main.c        ****                                             uint8_t tempSto = 0;
 1878              		.loc 1 404 0
 1879 13e2 C685A1FE 		movb	$0, -351(%rbp)
 1879      FFFF00
 1880              	.LBB27:
 405:main.c        ****                                             for (uint8_t j = 0; j <= 7; j++) {
 1881              		.loc 1 405 0
 1882 13e9 C685ACFE 		movb	$0, -340(%rbp)
 1882      FFFF00
 1883 13f0 EB71     		jmp	.L110
 1884              	.L112:
 1885              	.LBB28:
 406:main.c        ****                                                 uint8_t temp = j + (i - 14) * 8;
 1886              		.loc 1 406 0
 1887 13f2 0FB685AB 		movzbl	-341(%rbp), %eax
 1887      FEFFFF
 1888 13f9 83E80E   		subl	$14, %eax
 1889 13fc 8D14C500 		leal	0(,%rax,8), %edx
 1889      000000
 1890 1403 0FB685AC 		movzbl	-340(%rbp), %eax
 1890      FEFFFF
 1891 140a 01D0     		addl	%edx, %eax
 1892 140c 8885B5FE 		movb	%al, -331(%rbp)
 1892      FFFF
 407:main.c        ****                                                 if ((befEncSen[1] & (1 << temp)) != 0) {
 1893              		.loc 1 407 0
 1894 1412 8B9524FF 		movl	-220(%rbp), %edx
 1894      FFFF
 1895 1418 0FB685B5 		movzbl	-331(%rbp), %eax
 1895      FEFFFF
 1896 141f BE010000 		movl	$1, %esi
 1896      00
 1897 1424 89C1     		movl	%eax, %ecx
 1898 1426 D3E6     		sall	%cl, %esi
 1899 1428 89F0     		movl	%esi, %eax
 1900 142a 21D0     		andl	%edx, %eax
 1901 142c 85C0     		testl	%eax, %eax
 1902 142e 7423     		je	.L111
 408:main.c        ****                                                     tempSto += (1 << j);
 1903              		.loc 1 408 0
 1904 1430 0FB685AC 		movzbl	-340(%rbp), %eax
 1904      FEFFFF
 1905 1437 BA010000 		movl	$1, %edx
 1905      00
 1906 143c 89C1     		movl	%eax, %ecx
 1907 143e D3E2     		sall	%cl, %edx
 1908 1440 89D0     		movl	%edx, %eax
 1909 1442 89C2     		movl	%eax, %edx
 1910 1444 0FB685A1 		movzbl	-351(%rbp), %eax
 1910      FEFFFF
 1911 144b 01D0     		addl	%edx, %eax
 1912 144d 8885A1FE 		movb	%al, -351(%rbp)
 1912      FFFF
 1913              	.L111:
 1914              	.LBE28:
 405:main.c        ****                                                 uint8_t temp = j + (i - 14) * 8;
 1915              		.loc 1 405 0
 1916 1453 0FB685AC 		movzbl	-340(%rbp), %eax
 1916      FEFFFF
 1917 145a 83C001   		addl	$1, %eax
 1918 145d 8885ACFE 		movb	%al, -340(%rbp)
 1918      FFFF
 1919              	.L110:
 405:main.c        ****                                                 uint8_t temp = j + (i - 14) * 8;
 1920              		.loc 1 405 0 is_stmt 0 discriminator 1
 1921 1463 80BDACFE 		cmpb	$7, -340(%rbp)
 1921      FFFF07
 1922 146a 7686     		jbe	.L112
 1923              	.LBE27:
 409:main.c        ****                                                 }
 410:main.c        ****                                             }
 411:main.c        ****                                             flSleep(1000);
 1924              		.loc 1 411 0 is_stmt 1
 1925 146c BFE80300 		movl	$1000, %edi
 1925      00
 1926 1471 E8000000 		call	flSleep
 1926      00
 412:main.c        ****                                             fStatus = flWriteChannel(handle, (uint8_t) i, length, &
 1927              		.loc 1 412 0
 1928 1476 8B9504FF 		movl	-252(%rbp), %edx
 1928      FFFF
 1929 147c 0FB6B5AB 		movzbl	-341(%rbp), %esi
 1929      FEFFFF
 1930 1483 488B8530 		movq	-208(%rbp), %rax
 1930      FFFFFF
 1931 148a 488DBD38 		leaq	-200(%rbp), %rdi
 1931      FFFFFF
 1932 1491 488D8DA1 		leaq	-351(%rbp), %rcx
 1932      FEFFFF
 1933 1498 4989F8   		movq	%rdi, %r8
 1934 149b 4889C7   		movq	%rax, %rdi
 1935 149e E8000000 		call	flWriteChannel
 1935      00
 1936 14a3 898500FF 		movl	%eax, -256(%rbp)
 1936      FFFF
 413:main.c        ****                                             if (LOG) printf("Write to channel %u = %u \n", i, tempS
 1937              		.loc 1 413 0
 1938 14a9 0FB60500 		movzbl	LOG(%rip), %eax
 1938      000000
 1939 14b0 84C0     		testb	%al, %al
 1940 14b2 7422     		je	.L113
 1941              		.loc 1 413 0 is_stmt 0 discriminator 1
 1942 14b4 0FB685A1 		movzbl	-351(%rbp), %eax
 1942      FEFFFF
 1943 14bb 0FB6D0   		movzbl	%al, %edx
 1944 14be 0FB685AB 		movzbl	-341(%rbp), %eax
 1944      FEFFFF
 1945 14c5 89C6     		movl	%eax, %esi
 1946 14c7 BF000000 		movl	$.LC51, %edi
 1946      00
 1947 14cc B8000000 		movl	$0, %eax
 1947      00
 1948 14d1 E8000000 		call	printf
 1948      00
 1949              	.L113:
 414:main.c        ****                                             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1950              		.loc 1 414 0 is_stmt 1
 1951 14d6 83BD00FF 		cmpl	$0, -256(%rbp)
 1951      FFFF00
 1952 14dd 740F     		je	.L114
 1953              		.loc 1 414 0 is_stmt 0 discriminator 1
 1954 14df C785CCFE 		movl	$1, -308(%rbp)
 1954      FFFF0100 
 1954      0000
 1955              	.LBE26:
 1956              	.LBE25:
 378:main.c        ****                                         flSleep(1000);
 1957              		.loc 1 378 0 is_stmt 1 discriminator 1
 1958 14e9 E9B20200 		jmp	.L125
 1958      00
 1959              	.L114:
 1960              	.LBB29:
 403:main.c        ****                                             uint8_t tempSto = 0;
 1961              		.loc 1 403 0
 1962 14ee 0FB685AB 		movzbl	-341(%rbp), %eax
 1962      FEFFFF
 1963 14f5 83C001   		addl	$1, %eax
 1964 14f8 8885ABFE 		movb	%al, -341(%rbp)
 1964      FFFF
 1965              	.L109:
 403:main.c        ****                                             uint8_t tempSto = 0;
 1966              		.loc 1 403 0 is_stmt 0 discriminator 1
 1967 14fe 80BDABFE 		cmpb	$17, -341(%rbp)
 1967      FFFF11
 1968 1505 0F86D7FE 		jbe	.L115
 1968      FFFF
 1969              	.LBE29:
 415:main.c        ****                                         }
 416:main.c        ****                                         /* update the balance in the global variable now and update
 417:main.c        ****                                         if ((*readFromChannelZero) == 1) {
 1970              		.loc 1 417 0 is_stmt 1
 1971 150b 488B45A8 		movq	-88(%rbp), %rax
 1972 150f 0FB600   		movzbl	(%rax), %eax
 1973 1512 3C01     		cmpb	$1, %al
 1974 1514 0F853801 		jne	.L116
 1974      0000
 418:main.c        ****                                             dataFromCSV[inLineNum][3] -= reqAmo;
 1975              		.loc 1 418 0
 1976 151a 8B85C4FE 		movl	-316(%rbp), %eax
 1976      FFFF
 1977 1520 8B95C4FE 		movl	-316(%rbp), %edx
 1977      FFFF
 1978 1526 4863D2   		movslq	%edx, %rdx
 1979 1529 48C1E204 		salq	$4, %rdx
 1980 152d 4881C200 		addq	$dataFromCSV+12, %rdx
 1980      000000
 1981 1534 8B0A     		movl	(%rdx), %ecx
 1982 1536 8B95C8FE 		movl	-312(%rbp), %edx
 1982      FFFF
 1983 153c 29D1     		subl	%edx, %ecx
 1984 153e 89CA     		movl	%ecx, %edx
 1985 1540 4898     		cltq
 1986 1542 48C1E004 		salq	$4, %rax
 1987 1546 48050000 		addq	$dataFromCSV+12, %rax
 1987      0000
 1988 154c 8910     		movl	%edx, (%rax)
 419:main.c        **** 
 420:main.c        ****                                             /* Updating csv file in place */
 421:main.c        ****                                             fPtr = fopen("SampleBackEndDatabase.csv", "w+"); // cha
 1989              		.loc 1 421 0
 1990 154e BE000000 		movl	$.LC52, %esi
 1990      00
 1991 1553 BF000000 		movl	$.LC45, %edi
 1991      00
 1992 1558 E8000000 		call	fopen
 1992      00
 1993 155d 488945A0 		movq	%rax, -96(%rbp)
 422:main.c        ****                                             fprintf(fPtr, "%s", "\"User ID (decimal)\",\"PIN Hash (
 1994              		.loc 1 422 0
 1995 1561 488B45A0 		movq	-96(%rbp), %rax
 1996 1565 4889C1   		movq	%rax, %rcx
 1997 1568 BA440000 		movl	$68, %edx
 1997      00
 1998 156d BE010000 		movl	$1, %esi
 1998      00
 1999 1572 BF000000 		movl	$.LC53, %edi
 1999      00
 2000 1577 E8000000 		call	fwrite
 2000      00
 423:main.c        ****                                             fprintf(fPtr, "\n");
 2001              		.loc 1 423 0
 2002 157c 488B45A0 		movq	-96(%rbp), %rax
 2003 1580 4889C6   		movq	%rax, %rsi
 2004 1583 BF0A0000 		movl	$10, %edi
 2004      00
 2005 1588 E8000000 		call	fputc
 2005      00
 2006              	.LBB30:
 424:main.c        ****                                             for (int i = 1; i <= numLines; i++) {
 2007              		.loc 1 424 0
 2008 158d C785E4FE 		movl	$1, -284(%rbp)
 2008      FFFF0100 
 2008      0000
 2009 1597 E9930000 		jmp	.L117
 2009      00
 2010              	.L123:
 2011              	.LBB31:
 425:main.c        ****                                                 for (int k = 0; k < 4; k++) {
 2012              		.loc 1 425 0
 2013 159c C785E8FE 		movl	$0, -280(%rbp)
 2013      FFFF0000 
 2013      0000
 2014 15a6 EB77     		jmp	.L118
 2015              	.L122:
 426:main.c        ****                                                     fprintf(fPtr, "%d", dataFromCSV[i][k]);
 2016              		.loc 1 426 0
 2017 15a8 8B85E8FE 		movl	-280(%rbp), %eax
 2017      FFFF
 2018 15ae 4898     		cltq
 2019 15b0 8B95E4FE 		movl	-284(%rbp), %edx
 2019      FFFF
 2020 15b6 4863D2   		movslq	%edx, %rdx
 2021 15b9 48C1E202 		salq	$2, %rdx
 2022 15bd 4801D0   		addq	%rdx, %rax
 2023 15c0 8B148500 		movl	dataFromCSV(,%rax,4), %edx
 2023      000000
 2024 15c7 488B45A0 		movq	-96(%rbp), %rax
 2025 15cb BE000000 		movl	$.LC1, %esi
 2025      00
 2026 15d0 4889C7   		movq	%rax, %rdi
 2027 15d3 B8000000 		movl	$0, %eax
 2027      00
 2028 15d8 E8000000 		call	fprintf
 2028      00
 427:main.c        ****                                                     if (k == 3) {
 2029              		.loc 1 427 0
 2030 15dd 83BDE8FE 		cmpl	$3, -280(%rbp)
 2030      FFFF03
 2031 15e4 7521     		jne	.L119
 428:main.c        ****                                                         if (i != numLines) fprintf(fPtr, "\n");
 2032              		.loc 1 428 0
 2033 15e6 8B050000 		movl	numLines(%rip), %eax
 2033      0000
 2034 15ec 3985E4FE 		cmpl	%eax, -284(%rbp)
 2034      FFFF
 2035 15f2 7424     		je	.L121
 2036              		.loc 1 428 0 is_stmt 0 discriminator 1
 2037 15f4 488B45A0 		movq	-96(%rbp), %rax
 2038 15f8 4889C6   		movq	%rax, %rsi
 2039 15fb BF0A0000 		movl	$10, %edi
 2039      00
 2040 1600 E8000000 		call	fputc
 2040      00
 2041 1605 EB11     		jmp	.L121
 2042              	.L119:
 429:main.c        ****                                                     } else fprintf(fPtr, ",");
 2043              		.loc 1 429 0 is_stmt 1
 2044 1607 488B45A0 		movq	-96(%rbp), %rax
 2045 160b 4889C6   		movq	%rax, %rsi
 2046 160e BF2C0000 		movl	$44, %edi
 2046      00
 2047 1613 E8000000 		call	fputc
 2047      00
 2048              	.L121:
 425:main.c        ****                                                     fprintf(fPtr, "%d", dataFromCSV[i][k]);
 2049              		.loc 1 425 0
 2050 1618 8385E8FE 		addl	$1, -280(%rbp)
 2050      FFFF01
 2051              	.L118:
 425:main.c        ****                                                     fprintf(fPtr, "%d", dataFromCSV[i][k]);
 2052              		.loc 1 425 0 is_stmt 0 discriminator 1
 2053 161f 83BDE8FE 		cmpl	$3, -280(%rbp)
 2053      FFFF03
 2054 1626 7E80     		jle	.L122
 2055              	.LBE31:
 424:main.c        ****                                                 for (int k = 0; k < 4; k++) {
 2056              		.loc 1 424 0 is_stmt 1
 2057 1628 8385E4FE 		addl	$1, -284(%rbp)
 2057      FFFF01
 2058              	.L117:
 424:main.c        ****                                                 for (int k = 0; k < 4; k++) {
 2059              		.loc 1 424 0 is_stmt 0 discriminator 1
 2060 162f 8B050000 		movl	numLines(%rip), %eax
 2060      0000
 2061 1635 3985E4FE 		cmpl	%eax, -284(%rbp)
 2061      FFFF
 2062 163b 0F8E5BFF 		jle	.L123
 2062      FFFF
 2063              	.LBE30:
 430:main.c        ****                                                 }
 431:main.c        ****                                             }
 432:main.c        ****                                             fclose(fPtr);
 2064              		.loc 1 432 0 is_stmt 1
 2065 1641 488B45A0 		movq	-96(%rbp), %rax
 2066 1645 4889C7   		movq	%rax, %rdi
 2067 1648 E8000000 		call	fclose
 2067      00
 2068              	.LBE17:
 370:main.c        **** //                                        printf("bal %u\n", bal);
 2069              		.loc 1 370 0
 2070 164d E9490100 		jmp	.L124
 2070      00
 2071              	.L116:
 2072 1652 E9440100 		jmp	.L124
 2072      00
 2073              	.L89:
 433:main.c        ****                                         }
 434:main.c        ****                                     } else {
 435:main.c        **** //                                        printf("bal %u\n", bal);
 436:main.c        **** //                                        printf("req %u\n", reqAmo);
 437:main.c        ****                                         if (LOG) printf("Insufficient Balance \n");
 2074              		.loc 1 437 0
 2075 1657 0FB60500 		movzbl	LOG(%rip), %eax
 2075      000000
 2076 165e 84C0     		testb	%al, %al
 2077 1660 740A     		je	.L126
 2078              		.loc 1 437 0 is_stmt 0 discriminator 1
 2079 1662 BF000000 		movl	$.LC54, %edi
 2079      00
 2080 1667 E8000000 		call	puts
 2080      00
 2081              	.L126:
 438:main.c        ****                                         *statusOnChan9 = 2;
 2082              		.loc 1 438 0 is_stmt 1
 2083 166c 488B45B8 		movq	-72(%rbp), %rax
 2084 1670 C60002   		movb	$2, (%rax)
 439:main.c        ****                                         flSleep(1000);
 2085              		.loc 1 439 0
 2086 1673 BFE80300 		movl	$1000, %edi
 2086      00
 2087 1678 E8000000 		call	flSleep
 2087      00
 440:main.c        ****                                         if (LOG) printf("Write to channel %u = %u \n", 9, *statusOn
 2088              		.loc 1 440 0
 2089 167d 0FB60500 		movzbl	LOG(%rip), %eax
 2089      000000
 2090 1684 84C0     		testb	%al, %al
 2091 1686 7420     		je	.L127
 2092              		.loc 1 440 0 is_stmt 0 discriminator 1
 2093 1688 488B45B8 		movq	-72(%rbp), %rax
 2094 168c 0FB600   		movzbl	(%rax), %eax
 2095 168f 0FB6C0   		movzbl	%al, %eax
 2096 1692 89C2     		movl	%eax, %edx
 2097 1694 BE090000 		movl	$9, %esi
 2097      00
 2098 1699 BF000000 		movl	$.LC51, %edi
 2098      00
 2099 169e B8000000 		movl	$0, %eax
 2099      00
 2100 16a3 E8000000 		call	printf
 2100      00
 2101              	.L127:
 441:main.c        ****                                         fStatus = flWriteChannel(handle, (uint8_t) 9, length, statu
 2102              		.loc 1 441 0 is_stmt 1
 2103 16a8 8B9504FF 		movl	-252(%rbp), %edx
 2103      FFFF
 2104 16ae 488B8530 		movq	-208(%rbp), %rax
 2104      FFFFFF
 2105 16b5 488DB538 		leaq	-200(%rbp), %rsi
 2105      FFFFFF
 2106 16bc 488B4DB8 		movq	-72(%rbp), %rcx
 2107 16c0 4989F0   		movq	%rsi, %r8
 2108 16c3 BE090000 		movl	$9, %esi
 2108      00
 2109 16c8 4889C7   		movq	%rax, %rdi
 2110 16cb E8000000 		call	flWriteChannel
 2110      00
 2111 16d0 898500FF 		movl	%eax, -256(%rbp)
 2111      FFFF
 442:main.c        ****                                         CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2112              		.loc 1 442 0
 2113 16d6 83BD00FF 		cmpl	$0, -256(%rbp)
 2113      FFFF00
 2114 16dd 740F     		je	.L128
 2115              		.loc 1 442 0 is_stmt 0 discriminator 1
 2116 16df C785CCFE 		movl	$1, -308(%rbp)
 2116      FFFF0100 
 2116      0000
 2117 16e9 E9B20000 		jmp	.L125
 2117      00
 2118              	.L128:
 2119              	.LBB32:
 443:main.c        ****                                         for (int i = 10; i <= 17; i++) {
 2120              		.loc 1 443 0 is_stmt 1
 2121 16ee C785ECFE 		movl	$10, -276(%rbp)
 2121      FFFF0A00 
 2121      0000
 2122 16f8 E9910000 		jmp	.L129
 2122      00
 2123              	.L132:
 2124              	.LBB33:
 444:main.c        ****                                             uint8_t tempSto = 0;
 2125              		.loc 1 444 0
 2126 16fd C68520FF 		movb	$0, -224(%rbp)
 2126      FFFF00
 445:main.c        ****                                             flSleep(1000);
 2127              		.loc 1 445 0
 2128 1704 BFE80300 		movl	$1000, %edi
 2128      00
 2129 1709 E8000000 		call	flSleep
 2129      00
 446:main.c        ****                                             if (LOG) printf("Write to channel %u = %u \n", i, tempS
 2130              		.loc 1 446 0
 2131 170e 0FB60500 		movzbl	LOG(%rip), %eax
 2131      000000
 2132 1715 84C0     		testb	%al, %al
 2133 1717 7421     		je	.L130
 2134              		.loc 1 446 0 is_stmt 0 discriminator 1
 2135 1719 0FB68520 		movzbl	-224(%rbp), %eax
 2135      FFFFFF
 2136 1720 0FB6D0   		movzbl	%al, %edx
 2137 1723 8B85ECFE 		movl	-276(%rbp), %eax
 2137      FFFF
 2138 1729 89C6     		movl	%eax, %esi
 2139 172b BF000000 		movl	$.LC51, %edi
 2139      00
 2140 1730 B8000000 		movl	$0, %eax
 2140      00
 2141 1735 E8000000 		call	printf
 2141      00
 2142              	.L130:
 447:main.c        ****                                             fStatus = flWriteChannel(handle, (uint8_t) i, length, &
 2143              		.loc 1 447 0 is_stmt 1
 2144 173a 8B9504FF 		movl	-252(%rbp), %edx
 2144      FFFF
 2145 1740 8B85ECFE 		movl	-276(%rbp), %eax
 2145      FFFF
 2146 1746 0FB6F0   		movzbl	%al, %esi
 2147 1749 488B8530 		movq	-208(%rbp), %rax
 2147      FFFFFF
 2148 1750 488DBD38 		leaq	-200(%rbp), %rdi
 2148      FFFFFF
 2149 1757 488D8D20 		leaq	-224(%rbp), %rcx
 2149      FFFFFF
 2150 175e 4989F8   		movq	%rdi, %r8
 2151 1761 4889C7   		movq	%rax, %rdi
 2152 1764 E8000000 		call	flWriteChannel
 2152      00
 2153 1769 898500FF 		movl	%eax, -256(%rbp)
 2153      FFFF
 448:main.c        ****                                             CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2154              		.loc 1 448 0
 2155 176f 83BD00FF 		cmpl	$0, -256(%rbp)
 2155      FFFF00
 2156 1776 740F     		je	.L131
 2157              		.loc 1 448 0 is_stmt 0 discriminator 1
 2158 1778 C785CCFE 		movl	$1, -308(%rbp)
 2158      FFFF0100 
 2158      0000
 2159              	.LBE33:
 2160              	.LBE32:
 2161 1782 E9570500 		jmp	.L68
 2161      00
 2162              	.L131:
 2163              	.LBB34:
 443:main.c        ****                                             uint8_t tempSto = 0;
 2164              		.loc 1 443 0 is_stmt 1
 2165 1787 8385ECFE 		addl	$1, -276(%rbp)
 2165      FFFF01
 2166              	.L129:
 443:main.c        ****                                             uint8_t tempSto = 0;
 2167              		.loc 1 443 0 is_stmt 0 discriminator 1
 2168 178e 83BDECFE 		cmpl	$17, -276(%rbp)
 2168      FFFF11
 2169 1795 0F8E62FF 		jle	.L132
 2169      FFFF
 2170              	.L124:
 2171              	.LBE34:
 2172              	.LBE16:
 2173 179b E9400500 		jmp	.L57
 2173      00
 2174              	.L125:
 326:main.c        ****                                 if (LOG) printf("Read from channel %u = %u \n", i, *readFromChannel
 2175              		.loc 1 326 0 is_stmt 1
 2176 17a0 E94A0500 		jmp	.L54
 2176      00
 2177              	.L88:
 2178              	.LBB35:
 449:main.c        ****                                         }
 450:main.c        ****                                     }
 451:main.c        ****                                 } else {
 452:main.c        ****                                     printf("User has admin privileges \n");
 2179              		.loc 1 452 0
 2180 17a5 BF000000 		movl	$.LC55, %edi
 2180      00
 2181 17aa E8000000 		call	puts
 2181      00
 453:main.c        ****                                     *statusOnChan9 = 3;
 2182              		.loc 1 453 0
 2183 17af 488B45B8 		movq	-72(%rbp), %rax
 2184 17b3 C60003   		movb	$3, (%rax)
 454:main.c        ****                                     flSleep(1000);
 2185              		.loc 1 454 0
 2186 17b6 BFE80300 		movl	$1000, %edi
 2186      00
 2187 17bb E8000000 		call	flSleep
 2187      00
 455:main.c        ****                                     if (LOG) printf("Write to channel %u = %u \n", 9, *statusOnChan
 2188              		.loc 1 455 0
 2189 17c0 0FB60500 		movzbl	LOG(%rip), %eax
 2189      000000
 2190 17c7 84C0     		testb	%al, %al
 2191 17c9 7420     		je	.L134
 2192              		.loc 1 455 0 is_stmt 0 discriminator 1
 2193 17cb 488B45B8 		movq	-72(%rbp), %rax
 2194 17cf 0FB600   		movzbl	(%rax), %eax
 2195 17d2 0FB6C0   		movzbl	%al, %eax
 2196 17d5 89C2     		movl	%eax, %edx
 2197 17d7 BE090000 		movl	$9, %esi
 2197      00
 2198 17dc BF000000 		movl	$.LC51, %edi
 2198      00
 2199 17e1 B8000000 		movl	$0, %eax
 2199      00
 2200 17e6 E8000000 		call	printf
 2200      00
 2201              	.L134:
 456:main.c        ****                                     fStatus = flWriteChannel(handle, (uint8_t) 9, length, statusOnC
 2202              		.loc 1 456 0 is_stmt 1
 2203 17eb 8B9504FF 		movl	-252(%rbp), %edx
 2203      FFFF
 2204 17f1 488B8530 		movq	-208(%rbp), %rax
 2204      FFFFFF
 2205 17f8 488DB538 		leaq	-200(%rbp), %rsi
 2205      FFFFFF
 2206 17ff 488B4DB8 		movq	-72(%rbp), %rcx
 2207 1803 4989F0   		movq	%rsi, %r8
 2208 1806 BE090000 		movl	$9, %esi
 2208      00
 2209 180b 4889C7   		movq	%rax, %rdi
 2210 180e E8000000 		call	flWriteChannel
 2210      00
 2211 1813 898500FF 		movl	%eax, -256(%rbp)
 2211      FFFF
 457:main.c        ****                                     CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2212              		.loc 1 457 0
 2213 1819 83BD00FF 		cmpl	$0, -256(%rbp)
 2213      FFFF00
 2214 1820 740F     		je	.L135
 2215              		.loc 1 457 0 is_stmt 0 discriminator 1
 2216 1822 C785CCFE 		movl	$1, -308(%rbp)
 2216      FFFF0100 
 2216      0000
 2217 182c E9AD0400 		jmp	.L68
 2217      00
 2218              	.L135:
 2219              	.LBB36:
 458:main.c        ****                                     uint32_t befEncSen[2];
 459:main.c        ****                                     for (int i = 0; i < 2; i++) befEncSen[i] = 0;
 2220              		.loc 1 459 0 is_stmt 1
 2221 1831 C785F0FE 		movl	$0, -272(%rbp)
 2221      FFFF0000 
 2221      0000
 2222 183b EB1A     		jmp	.L137
 2223              	.L138:
 2224              		.loc 1 459 0 is_stmt 0 discriminator 2
 2225 183d 8B85F0FE 		movl	-272(%rbp), %eax
 2225      FFFF
 2226 1843 4898     		cltq
 2227 1845 C7848520 		movl	$0, -224(%rbp,%rax,4)
 2227      FFFFFF00 
 2227      000000
 2228 1850 8385F0FE 		addl	$1, -272(%rbp)
 2228      FFFF01
 2229              	.L137:
 2230              		.loc 1 459 0 discriminator 1
 2231 1857 83BDF0FE 		cmpl	$1, -272(%rbp)
 2231      FFFF01
 2232 185e 7EDD     		jle	.L138
 2233              	.LBE36:
 2234              	.LBB37:
 460:main.c        ****                                     for (uint32_t i = 0; i <= 31; i += 8) {
 2235              		.loc 1 460 0 is_stmt 1
 2236 1860 C785F4FE 		movl	$0, -268(%rbp)
 2236      FFFF0000 
 2236      0000
 2237 186a E9AC0000 		jmp	.L139
 2237      00
 2238              	.L144:
 461:main.c        ****                                         if (i == 0) befEncSen[0] += ((1 << i) * ((uint32_t) num_100
 2239              		.loc 1 461 0
 2240 186f 83BDF4FE 		cmpl	$0, -268(%rbp)
 2240      FFFF00
 2241 1876 7523     		jne	.L140
 2242              		.loc 1 461 0 is_stmt 0 discriminator 1
 2243 1878 8B9520FF 		movl	-224(%rbp), %edx
 2243      FFFF
 2244 187e 0FB6B5A4 		movzbl	-348(%rbp), %esi
 2244      FEFFFF
 2245 1885 8B85F4FE 		movl	-268(%rbp), %eax
 2245      FFFF
 2246 188b 89C1     		movl	%eax, %ecx
 2247 188d D3E6     		sall	%cl, %esi
 2248 188f 89F0     		movl	%esi, %eax
 2249 1891 01D0     		addl	%edx, %eax
 2250 1893 898520FF 		movl	%eax, -224(%rbp)
 2250      FFFF
 2251 1899 EB79     		jmp	.L141
 2252              	.L140:
 462:main.c        ****                                         else if (i == 8) befEncSen[0] += ((1 << i) * ((uint32_t) nu
 2253              		.loc 1 462 0 is_stmt 1
 2254 189b 83BDF4FE 		cmpl	$8, -268(%rbp)
 2254      FFFF08
 2255 18a2 7523     		jne	.L142
 2256              		.loc 1 462 0 is_stmt 0 discriminator 1
 2257 18a4 8B9520FF 		movl	-224(%rbp), %edx
 2257      FFFF
 2258 18aa 0FB6B5A5 		movzbl	-347(%rbp), %esi
 2258      FEFFFF
 2259 18b1 8B85F4FE 		movl	-268(%rbp), %eax
 2259      FFFF
 2260 18b7 89C1     		movl	%eax, %ecx
 2261 18b9 D3E6     		sall	%cl, %esi
 2262 18bb 89F0     		movl	%esi, %eax
 2263 18bd 01D0     		addl	%edx, %eax
 2264 18bf 898520FF 		movl	%eax, -224(%rbp)
 2264      FFFF
 2265 18c5 EB4D     		jmp	.L141
 2266              	.L142:
 463:main.c        ****                                         else if (i == 16) befEncSen[0] += ((1 << i) * ((uint32_t) n
 2267              		.loc 1 463 0 is_stmt 1
 2268 18c7 83BDF4FE 		cmpl	$16, -268(%rbp)
 2268      FFFF10
 2269 18ce 7523     		jne	.L143
 2270              		.loc 1 463 0 is_stmt 0 discriminator 1
 2271 18d0 8B9520FF 		movl	-224(%rbp), %edx
 2271      FFFF
 2272 18d6 0FB6B5A6 		movzbl	-346(%rbp), %esi
 2272      FEFFFF
 2273 18dd 8B85F4FE 		movl	-268(%rbp), %eax
 2273      FFFF
 2274 18e3 89C1     		movl	%eax, %ecx
 2275 18e5 D3E6     		sall	%cl, %esi
 2276 18e7 89F0     		movl	%esi, %eax
 2277 18e9 01D0     		addl	%edx, %eax
 2278 18eb 898520FF 		movl	%eax, -224(%rbp)
 2278      FFFF
 2279 18f1 EB21     		jmp	.L141
 2280              	.L143:
 464:main.c        ****                                         else befEncSen[0] += ((1 << i) * ((uint32_t) num_2000));
 2281              		.loc 1 464 0 is_stmt 1
 2282 18f3 8B9520FF 		movl	-224(%rbp), %edx
 2282      FFFF
 2283 18f9 0FB6B5A7 		movzbl	-345(%rbp), %esi
 2283      FEFFFF
 2284 1900 8B85F4FE 		movl	-268(%rbp), %eax
 2284      FFFF
 2285 1906 89C1     		movl	%eax, %ecx
 2286 1908 D3E6     		sall	%cl, %esi
 2287 190a 89F0     		movl	%esi, %eax
 2288 190c 01D0     		addl	%edx, %eax
 2289 190e 898520FF 		movl	%eax, -224(%rbp)
 2289      FFFF
 2290              	.L141:
 460:main.c        ****                                         if (i == 0) befEncSen[0] += ((1 << i) * ((uint32_t) num_100
 2291              		.loc 1 460 0
 2292 1914 8385F4FE 		addl	$8, -268(%rbp)
 2292      FFFF08
 2293              	.L139:
 460:main.c        ****                                         if (i == 0) befEncSen[0] += ((1 << i) * ((uint32_t) num_100
 2294              		.loc 1 460 0 is_stmt 0 discriminator 1
 2295 191b 83BDF4FE 		cmpl	$31, -268(%rbp)
 2295      FFFF1F
 2296 1922 0F8647FF 		jbe	.L144
 2296      FFFF
 2297              	.LBE37:
 465:main.c        ****                                     }
 466:main.c        ****                                     encrypt64(befEncSen);
 2298              		.loc 1 466 0 is_stmt 1
 2299 1928 488D8520 		leaq	-224(%rbp), %rax
 2299      FFFFFF
 2300 192f 4889C7   		movq	%rax, %rdi
 2301 1932 E8000000 		call	encrypt64
 2301      00
 2302              	.LBB38:
 467:main.c        ****                                     for (uint8_t i = 10; i <= 13; i++) {
 2303              		.loc 1 467 0
 2304 1937 C685ADFE 		movb	$10, -339(%rbp)
 2304      FFFF0A
 2305 193e E91C0100 		jmp	.L145
 2305      00
 2306              	.L151:
 2307              	.LBB39:
 468:main.c        ****                                         uint8_t tempSto = 0;
 2308              		.loc 1 468 0
 2309 1943 C685C8FE 		movb	$0, -312(%rbp)
 2309      FFFF00
 2310              	.LBB40:
 469:main.c        ****                                         for (uint8_t j = 0; j <= 7; j++) {
 2311              		.loc 1 469 0
 2312 194a C685AEFE 		movb	$0, -338(%rbp)
 2312      FFFF00
 2313 1951 EB71     		jmp	.L146
 2314              	.L148:
 2315              	.LBB41:
 470:main.c        ****                                             uint8_t temp = j + (i - 10) * 8;
 2316              		.loc 1 470 0
 2317 1953 0FB685AD 		movzbl	-339(%rbp), %eax
 2317      FEFFFF
 2318 195a 83E80A   		subl	$10, %eax
 2319 195d 8D14C500 		leal	0(,%rax,8), %edx
 2319      000000
 2320 1964 0FB685AE 		movzbl	-338(%rbp), %eax
 2320      FEFFFF
 2321 196b 01D0     		addl	%edx, %eax
 2322 196d 8885B6FE 		movb	%al, -330(%rbp)
 2322      FFFF
 471:main.c        ****                                             if ((befEncSen[0] & (1 << temp)) != 0) {
 2323              		.loc 1 471 0
 2324 1973 8B9520FF 		movl	-224(%rbp), %edx
 2324      FFFF
 2325 1979 0FB685B6 		movzbl	-330(%rbp), %eax
 2325      FEFFFF
 2326 1980 BE010000 		movl	$1, %esi
 2326      00
 2327 1985 89C1     		movl	%eax, %ecx
 2328 1987 D3E6     		sall	%cl, %esi
 2329 1989 89F0     		movl	%esi, %eax
 2330 198b 21D0     		andl	%edx, %eax
 2331 198d 85C0     		testl	%eax, %eax
 2332 198f 7423     		je	.L147
 472:main.c        ****                                                 tempSto += (1 << j);
 2333              		.loc 1 472 0
 2334 1991 0FB685AE 		movzbl	-338(%rbp), %eax
 2334      FEFFFF
 2335 1998 BA010000 		movl	$1, %edx
 2335      00
 2336 199d 89C1     		movl	%eax, %ecx
 2337 199f D3E2     		sall	%cl, %edx
 2338 19a1 89D0     		movl	%edx, %eax
 2339 19a3 89C2     		movl	%eax, %edx
 2340 19a5 0FB685C8 		movzbl	-312(%rbp), %eax
 2340      FEFFFF
 2341 19ac 01D0     		addl	%edx, %eax
 2342 19ae 8885C8FE 		movb	%al, -312(%rbp)
 2342      FFFF
 2343              	.L147:
 2344              	.LBE41:
 469:main.c        ****                                             uint8_t temp = j + (i - 10) * 8;
 2345              		.loc 1 469 0
 2346 19b4 0FB685AE 		movzbl	-338(%rbp), %eax
 2346      FEFFFF
 2347 19bb 83C001   		addl	$1, %eax
 2348 19be 8885AEFE 		movb	%al, -338(%rbp)
 2348      FFFF
 2349              	.L146:
 469:main.c        ****                                             uint8_t temp = j + (i - 10) * 8;
 2350              		.loc 1 469 0 is_stmt 0 discriminator 1
 2351 19c4 80BDAEFE 		cmpb	$7, -338(%rbp)
 2351      FFFF07
 2352 19cb 7686     		jbe	.L148
 2353              	.LBE40:
 473:main.c        ****                                             }
 474:main.c        ****                                         }
 475:main.c        ****                                         flSleep(1000);
 2354              		.loc 1 475 0 is_stmt 1
 2355 19cd BFE80300 		movl	$1000, %edi
 2355      00
 2356 19d2 E8000000 		call	flSleep
 2356      00
 476:main.c        ****                                         if (LOG) printf("Write to channel %u = %u \n", i, tempSto);
 2357              		.loc 1 476 0
 2358 19d7 0FB60500 		movzbl	LOG(%rip), %eax
 2358      000000
 2359 19de 84C0     		testb	%al, %al
 2360 19e0 7422     		je	.L149
 2361              		.loc 1 476 0 is_stmt 0 discriminator 1
 2362 19e2 0FB685C8 		movzbl	-312(%rbp), %eax
 2362      FEFFFF
 2363 19e9 0FB6D0   		movzbl	%al, %edx
 2364 19ec 0FB685AD 		movzbl	-339(%rbp), %eax
 2364      FEFFFF
 2365 19f3 89C6     		movl	%eax, %esi
 2366 19f5 BF000000 		movl	$.LC51, %edi
 2366      00
 2367 19fa B8000000 		movl	$0, %eax
 2367      00
 2368 19ff E8000000 		call	printf
 2368      00
 2369              	.L149:
 477:main.c        ****                                         fStatus = flWriteChannel(handle, (uint8_t) i, length, &temp
 2370              		.loc 1 477 0 is_stmt 1
 2371 1a04 8B9504FF 		movl	-252(%rbp), %edx
 2371      FFFF
 2372 1a0a 0FB6B5AD 		movzbl	-339(%rbp), %esi
 2372      FEFFFF
 2373 1a11 488B8530 		movq	-208(%rbp), %rax
 2373      FFFFFF
 2374 1a18 488DBD38 		leaq	-200(%rbp), %rdi
 2374      FFFFFF
 2375 1a1f 488D8DC8 		leaq	-312(%rbp), %rcx
 2375      FEFFFF
 2376 1a26 4989F8   		movq	%rdi, %r8
 2377 1a29 4889C7   		movq	%rax, %rdi
 2378 1a2c E8000000 		call	flWriteChannel
 2378      00
 2379 1a31 898500FF 		movl	%eax, -256(%rbp)
 2379      FFFF
 478:main.c        ****                                         CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2380              		.loc 1 478 0
 2381 1a37 83BD00FF 		cmpl	$0, -256(%rbp)
 2381      FFFF00
 2382 1a3e 740F     		je	.L150
 2383              		.loc 1 478 0 is_stmt 0 discriminator 1
 2384 1a40 C785CCFE 		movl	$1, -308(%rbp)
 2384      FFFF0100 
 2384      0000
 2385              	.LBE39:
 2386              	.LBE38:
 457:main.c        ****                                     uint32_t befEncSen[2];
 2387              		.loc 1 457 0 is_stmt 1 discriminator 1
 2388 1a4a E98F0200 		jmp	.L68
 2388      00
 2389              	.L150:
 2390              	.LBB42:
 467:main.c        ****                                         uint8_t tempSto = 0;
 2391              		.loc 1 467 0
 2392 1a4f 0FB685AD 		movzbl	-339(%rbp), %eax
 2392      FEFFFF
 2393 1a56 83C001   		addl	$1, %eax
 2394 1a59 8885ADFE 		movb	%al, -339(%rbp)
 2394      FFFF
 2395              	.L145:
 467:main.c        ****                                         uint8_t tempSto = 0;
 2396              		.loc 1 467 0 is_stmt 0 discriminator 1
 2397 1a5f 80BDADFE 		cmpb	$13, -339(%rbp)
 2397      FFFF0D
 2398 1a66 0F86D7FE 		jbe	.L151
 2398      FFFF
 2399              	.LBE42:
 2400              	.LBB43:
 479:main.c        ****                                     }
 480:main.c        **** 
 481:main.c        ****                                     for (uint8_t i = 14; i <= 17; i++) {
 2401              		.loc 1 481 0 is_stmt 1
 2402 1a6c C685AFFE 		movb	$14, -337(%rbp)
 2402      FFFF0E
 2403 1a73 E91C0100 		jmp	.L152
 2403      00
 2404              	.L158:
 2405              	.LBB44:
 482:main.c        ****                                         uint8_t tempSto = 0;
 2406              		.loc 1 482 0
 2407 1a78 C685C8FE 		movb	$0, -312(%rbp)
 2407      FFFF00
 2408              	.LBB45:
 483:main.c        ****                                         for (uint8_t j = 0; j <= 7; j++) {
 2409              		.loc 1 483 0
 2410 1a7f C685B0FE 		movb	$0, -336(%rbp)
 2410      FFFF00
 2411 1a86 EB71     		jmp	.L153
 2412              	.L155:
 2413              	.LBB46:
 484:main.c        ****                                             uint8_t temp = j + (i - 14) * 8;
 2414              		.loc 1 484 0
 2415 1a88 0FB685AF 		movzbl	-337(%rbp), %eax
 2415      FEFFFF
 2416 1a8f 83E80E   		subl	$14, %eax
 2417 1a92 8D14C500 		leal	0(,%rax,8), %edx
 2417      000000
 2418 1a99 0FB685B0 		movzbl	-336(%rbp), %eax
 2418      FEFFFF
 2419 1aa0 01D0     		addl	%edx, %eax
 2420 1aa2 8885B7FE 		movb	%al, -329(%rbp)
 2420      FFFF
 485:main.c        ****                                             if ((befEncSen[1] & (1 << temp)) != 0) {
 2421              		.loc 1 485 0
 2422 1aa8 8B9524FF 		movl	-220(%rbp), %edx
 2422      FFFF
 2423 1aae 0FB685B7 		movzbl	-329(%rbp), %eax
 2423      FEFFFF
 2424 1ab5 BE010000 		movl	$1, %esi
 2424      00
 2425 1aba 89C1     		movl	%eax, %ecx
 2426 1abc D3E6     		sall	%cl, %esi
 2427 1abe 89F0     		movl	%esi, %eax
 2428 1ac0 21D0     		andl	%edx, %eax
 2429 1ac2 85C0     		testl	%eax, %eax
 2430 1ac4 7423     		je	.L154
 486:main.c        ****                                                 tempSto += (1 << j);
 2431              		.loc 1 486 0
 2432 1ac6 0FB685B0 		movzbl	-336(%rbp), %eax
 2432      FEFFFF
 2433 1acd BA010000 		movl	$1, %edx
 2433      00
 2434 1ad2 89C1     		movl	%eax, %ecx
 2435 1ad4 D3E2     		sall	%cl, %edx
 2436 1ad6 89D0     		movl	%edx, %eax
 2437 1ad8 89C2     		movl	%eax, %edx
 2438 1ada 0FB685C8 		movzbl	-312(%rbp), %eax
 2438      FEFFFF
 2439 1ae1 01D0     		addl	%edx, %eax
 2440 1ae3 8885C8FE 		movb	%al, -312(%rbp)
 2440      FFFF
 2441              	.L154:
 2442              	.LBE46:
 483:main.c        ****                                             uint8_t temp = j + (i - 14) * 8;
 2443              		.loc 1 483 0
 2444 1ae9 0FB685B0 		movzbl	-336(%rbp), %eax
 2444      FEFFFF
 2445 1af0 83C001   		addl	$1, %eax
 2446 1af3 8885B0FE 		movb	%al, -336(%rbp)
 2446      FFFF
 2447              	.L153:
 483:main.c        ****                                             uint8_t temp = j + (i - 14) * 8;
 2448              		.loc 1 483 0 is_stmt 0 discriminator 1
 2449 1af9 80BDB0FE 		cmpb	$7, -336(%rbp)
 2449      FFFF07
 2450 1b00 7686     		jbe	.L155
 2451              	.LBE45:
 487:main.c        ****                                             }
 488:main.c        ****                                         }
 489:main.c        ****                                         flSleep(1000);
 2452              		.loc 1 489 0 is_stmt 1
 2453 1b02 BFE80300 		movl	$1000, %edi
 2453      00
 2454 1b07 E8000000 		call	flSleep
 2454      00
 490:main.c        ****                                         if (LOG) printf("Write to channel %u = %u \n", i, tempSto);
 2455              		.loc 1 490 0
 2456 1b0c 0FB60500 		movzbl	LOG(%rip), %eax
 2456      000000
 2457 1b13 84C0     		testb	%al, %al
 2458 1b15 7422     		je	.L156
 2459              		.loc 1 490 0 is_stmt 0 discriminator 1
 2460 1b17 0FB685C8 		movzbl	-312(%rbp), %eax
 2460      FEFFFF
 2461 1b1e 0FB6D0   		movzbl	%al, %edx
 2462 1b21 0FB685AF 		movzbl	-337(%rbp), %eax
 2462      FEFFFF
 2463 1b28 89C6     		movl	%eax, %esi
 2464 1b2a BF000000 		movl	$.LC51, %edi
 2464      00
 2465 1b2f B8000000 		movl	$0, %eax
 2465      00
 2466 1b34 E8000000 		call	printf
 2466      00
 2467              	.L156:
 491:main.c        ****                                         fStatus = flWriteChannel(handle, (uint8_t) i, length, &temp
 2468              		.loc 1 491 0 is_stmt 1
 2469 1b39 8B9504FF 		movl	-252(%rbp), %edx
 2469      FFFF
 2470 1b3f 0FB6B5AF 		movzbl	-337(%rbp), %esi
 2470      FEFFFF
 2471 1b46 488B8530 		movq	-208(%rbp), %rax
 2471      FFFFFF
 2472 1b4d 488DBD38 		leaq	-200(%rbp), %rdi
 2472      FFFFFF
 2473 1b54 488D8DC8 		leaq	-312(%rbp), %rcx
 2473      FEFFFF
 2474 1b5b 4989F8   		movq	%rdi, %r8
 2475 1b5e 4889C7   		movq	%rax, %rdi
 2476 1b61 E8000000 		call	flWriteChannel
 2476      00
 2477 1b66 898500FF 		movl	%eax, -256(%rbp)
 2477      FFFF
 492:main.c        ****                                         CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2478              		.loc 1 492 0
 2479 1b6c 83BD00FF 		cmpl	$0, -256(%rbp)
 2479      FFFF00
 2480 1b73 740F     		je	.L157
 2481              		.loc 1 492 0 is_stmt 0 discriminator 1
 2482 1b75 C785CCFE 		movl	$1, -308(%rbp)
 2482      FFFF0100 
 2482      0000
 2483              	.LBE44:
 2484              	.LBE43:
 457:main.c        ****                                     uint32_t befEncSen[2];
 2485              		.loc 1 457 0 is_stmt 1 discriminator 1
 2486 1b7f E95A0100 		jmp	.L68
 2486      00
 2487              	.L157:
 2488              	.LBB47:
 481:main.c        ****                                         uint8_t tempSto = 0;
 2489              		.loc 1 481 0
 2490 1b84 0FB685AF 		movzbl	-337(%rbp), %eax
 2490      FEFFFF
 2491 1b8b 83C001   		addl	$1, %eax
 2492 1b8e 8885AFFE 		movb	%al, -337(%rbp)
 2492      FFFF
 2493              	.L152:
 481:main.c        ****                                         uint8_t tempSto = 0;
 2494              		.loc 1 481 0 is_stmt 0 discriminator 1
 2495 1b94 80BDAFFE 		cmpb	$17, -337(%rbp)
 2495      FFFF11
 2496 1b9b 0F86D7FE 		jbe	.L158
 2496      FFFF
 2497              	.LBE47:
 2498 1ba1 E9360100 		jmp	.L159
 2498      00
 2499              	.L87:
 2500              	.LBE35:
 493:main.c        ****                                     }
 494:main.c        ****                                 }
 495:main.c        ****                             } else {
 496:main.c        ****                                 printf("Invalid user \n");
 2501              		.loc 1 496 0 is_stmt 1
 2502 1ba6 BF000000 		movl	$.LC56, %edi
 2502      00
 2503 1bab E8000000 		call	puts
 2503      00
 497:main.c        ****                                 *statusOnChan9 = 4;
 2504              		.loc 1 497 0
 2505 1bb0 488B45B8 		movq	-72(%rbp), %rax
 2506 1bb4 C60004   		movb	$4, (%rax)
 498:main.c        ****                                 flSleep(1000);
 2507              		.loc 1 498 0
 2508 1bb7 BFE80300 		movl	$1000, %edi
 2508      00
 2509 1bbc E8000000 		call	flSleep
 2509      00
 499:main.c        ****                                 if (LOG) printf("Write to channel %u = %u \n", 9, *statusOnChan9);
 2510              		.loc 1 499 0
 2511 1bc1 0FB60500 		movzbl	LOG(%rip), %eax
 2511      000000
 2512 1bc8 84C0     		testb	%al, %al
 2513 1bca 7420     		je	.L160
 2514              		.loc 1 499 0 is_stmt 0 discriminator 1
 2515 1bcc 488B45B8 		movq	-72(%rbp), %rax
 2516 1bd0 0FB600   		movzbl	(%rax), %eax
 2517 1bd3 0FB6C0   		movzbl	%al, %eax
 2518 1bd6 89C2     		movl	%eax, %edx
 2519 1bd8 BE090000 		movl	$9, %esi
 2519      00
 2520 1bdd BF000000 		movl	$.LC51, %edi
 2520      00
 2521 1be2 B8000000 		movl	$0, %eax
 2521      00
 2522 1be7 E8000000 		call	printf
 2522      00
 2523              	.L160:
 500:main.c        ****                                 fStatus = flWriteChannel(handle, (uint8_t) 9, length, statusOnChan9
 2524              		.loc 1 500 0 is_stmt 1
 2525 1bec 8B9504FF 		movl	-252(%rbp), %edx
 2525      FFFF
 2526 1bf2 488B8530 		movq	-208(%rbp), %rax
 2526      FFFFFF
 2527 1bf9 488DB538 		leaq	-200(%rbp), %rsi
 2527      FFFFFF
 2528 1c00 488B4DB8 		movq	-72(%rbp), %rcx
 2529 1c04 4989F0   		movq	%rsi, %r8
 2530 1c07 BE090000 		movl	$9, %esi
 2530      00
 2531 1c0c 4889C7   		movq	%rax, %rdi
 2532 1c0f E8000000 		call	flWriteChannel
 2532      00
 2533 1c14 898500FF 		movl	%eax, -256(%rbp)
 2533      FFFF
 501:main.c        ****                                 CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2534              		.loc 1 501 0
 2535 1c1a 83BD00FF 		cmpl	$0, -256(%rbp)
 2535      FFFF00
 2536 1c21 740F     		je	.L161
 2537              		.loc 1 501 0 is_stmt 0 discriminator 1
 2538 1c23 C785CCFE 		movl	$1, -308(%rbp)
 2538      FFFF0100 
 2538      0000
 2539 1c2d E9AC0000 		jmp	.L68
 2539      00
 2540              	.L161:
 2541              	.LBB48:
 502:main.c        ****                                 for (int i = 10; i <= 17; i++) {
 2542              		.loc 1 502 0 is_stmt 1
 2543 1c32 C785F8FE 		movl	$10, -264(%rbp)
 2543      FFFF0A00 
 2543      0000
 2544 1c3c E98E0000 		jmp	.L162
 2544      00
 2545              	.L165:
 2546              	.LBB49:
 503:main.c        ****                                     uint8_t tempSto = 0;
 2547              		.loc 1 503 0
 2548 1c41 C68520FF 		movb	$0, -224(%rbp)
 2548      FFFF00
 504:main.c        ****                                     flSleep(1000);
 2549              		.loc 1 504 0
 2550 1c48 BFE80300 		movl	$1000, %edi
 2550      00
 2551 1c4d E8000000 		call	flSleep
 2551      00
 505:main.c        ****                                     if (LOG) printf("Write to channel %u = %u \n", i, tempSto);
 2552              		.loc 1 505 0
 2553 1c52 0FB60500 		movzbl	LOG(%rip), %eax
 2553      000000
 2554 1c59 84C0     		testb	%al, %al
 2555 1c5b 7421     		je	.L163
 2556              		.loc 1 505 0 is_stmt 0 discriminator 1
 2557 1c5d 0FB68520 		movzbl	-224(%rbp), %eax
 2557      FFFFFF
 2558 1c64 0FB6D0   		movzbl	%al, %edx
 2559 1c67 8B85F8FE 		movl	-264(%rbp), %eax
 2559      FFFF
 2560 1c6d 89C6     		movl	%eax, %esi
 2561 1c6f BF000000 		movl	$.LC51, %edi
 2561      00
 2562 1c74 B8000000 		movl	$0, %eax
 2562      00
 2563 1c79 E8000000 		call	printf
 2563      00
 2564              	.L163:
 506:main.c        ****                                     fStatus = flWriteChannel(handle, (uint8_t) i, length, &tempSto,
 2565              		.loc 1 506 0 is_stmt 1
 2566 1c7e 8B9504FF 		movl	-252(%rbp), %edx
 2566      FFFF
 2567 1c84 8B85F8FE 		movl	-264(%rbp), %eax
 2567      FFFF
 2568 1c8a 0FB6F0   		movzbl	%al, %esi
 2569 1c8d 488B8530 		movq	-208(%rbp), %rax
 2569      FFFFFF
 2570 1c94 488DBD38 		leaq	-200(%rbp), %rdi
 2570      FFFFFF
 2571 1c9b 488D8D20 		leaq	-224(%rbp), %rcx
 2571      FFFFFF
 2572 1ca2 4989F8   		movq	%rdi, %r8
 2573 1ca5 4889C7   		movq	%rax, %rdi
 2574 1ca8 E8000000 		call	flWriteChannel
 2574      00
 2575 1cad 898500FF 		movl	%eax, -256(%rbp)
 2575      FFFF
 507:main.c        ****                                     CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2576              		.loc 1 507 0
 2577 1cb3 83BD00FF 		cmpl	$0, -256(%rbp)
 2577      FFFF00
 2578 1cba 740C     		je	.L164
 2579              		.loc 1 507 0 is_stmt 0 discriminator 1
 2580 1cbc C785CCFE 		movl	$1, -308(%rbp)
 2580      FFFF0100 
 2580      0000
 2581              	.LBE49:
 2582              	.LBE48:
 326:main.c        ****                                 if (LOG) printf("Read from channel %u = %u \n", i, *readFromChannel
 2583              		.loc 1 326 0 is_stmt 1 discriminator 1
 2584 1cc6 EB27     		jmp	.L54
 2585              	.L164:
 2586              	.LBB50:
 502:main.c        ****                                     uint8_t tempSto = 0;
 2587              		.loc 1 502 0
 2588 1cc8 8385F8FE 		addl	$1, -264(%rbp)
 2588      FFFF01
 2589              	.L162:
 502:main.c        ****                                     uint8_t tempSto = 0;
 2590              		.loc 1 502 0 is_stmt 0 discriminator 1
 2591 1ccf 83BDF8FE 		cmpl	$17, -264(%rbp)
 2591      FFFF11
 2592 1cd6 0F8E65FF 		jle	.L165
 2592      FFFF
 2593              	.L159:
 2594              	.LBE50:
 2595 1cdc EB02     		jmp	.L57
 2596              	.L68:
 2597              	.LBE10:
 2598              	.LBE9:
 2599              	.LBE8:
 299:main.c        ****                     if (LOG) printf("Read from channel 0 = %u \n", *readFromChannelZero);
 2600              		.loc 1 299 0 is_stmt 1 discriminator 1
 2601 1cde EB63     		jmp	.L29
 2602              	.L57:
 2603              	.LBB51:
 508:main.c        ****                                 }
 509:main.c        ****                             }
 510:main.c        ****                         }
 511:main.c        ****                     }
 512:main.c        ****                     flSleep(1000);
 2604              		.loc 1 512 0
 2605 1ce0 BFE80300 		movl	$1000, %edi
 2605      00
 2606 1ce5 E8000000 		call	flSleep
 2606      00
 2607              	.LBE51:
 513:main.c        ****                 }
 2608              		.loc 1 513 0
 2609 1cea E91BEEFF 		jmp	.L166
 2609      FF
 2610              	.L54:
 2611              	.LBE7:
 272:main.c        ****             fStatus = flIsFPGARunning(handle, &isRunning, &error);
 2612              		.loc 1 272 0 discriminator 1
 2613 1cef EB52     		jmp	.L29
 2614              	.L47:
 514:main.c        **** 
 515:main.c        ****             } else {
 516:main.c        ****                 fprintf(stderr, "The FPGALink device at %s is not ready to talk - did you forget --
 2615              		.loc 1 516 0
 2616 1cf1 488B0500 		movq	stderr(%rip), %rax
 2616      000000
 2617 1cf8 488B5590 		movq	-112(%rbp), %rdx
 2618 1cfc BE000000 		movl	$.LC57, %esi
 2618      00
 2619 1d01 4889C7   		movq	%rax, %rdi
 2620 1d04 B8000000 		movl	$0, %eax
 2620      00
 2621 1d09 E8000000 		call	fprintf
 2621      00
 517:main.c        ****                 FAIL(FLP_ARGS, cleanup);
 2622              		.loc 1 517 0
 2623 1d0e C785CCFE 		movl	$12, -308(%rbp)
 2623      FFFF0C00 
 2623      0000
 2624 1d18 90       		nop
 2625 1d19 EB28     		jmp	.L29
 2626              	.L43:
 2627              	.LBE6:
 518:main.c        ****             }
 519:main.c        ****         } else {
 520:main.c        ****             fprintf(stderr, "Action requested but device at %s does not support CommFPGA\n", vp);
 2628              		.loc 1 520 0
 2629 1d1b 488B0500 		movq	stderr(%rip), %rax
 2629      000000
 2630 1d22 488B5590 		movq	-112(%rbp), %rdx
 2631 1d26 BE000000 		movl	$.LC58, %esi
 2631      00
 2632 1d2b 4889C7   		movq	%rax, %rdi
 2633 1d2e B8000000 		movl	$0, %eax
 2633      00
 2634 1d33 E8000000 		call	fprintf
 2634      00
 521:main.c        ****             FAIL(FLP_ARGS, cleanup);
 2635              		.loc 1 521 0
 2636 1d38 C785CCFE 		movl	$12, -308(%rbp)
 2636      FFFF0C00 
 2636      0000
 2637 1d42 90       		nop
 2638              	.L29:
 522:main.c        ****         }
 523:main.c        ****     }
 524:main.c        **** 
 525:main.c        ****     cleanup:
 526:main.c        ****     free((void *) line);
 2639              		.loc 1 526 0
 2640 1d43 488B4598 		movq	-104(%rbp), %rax
 2641 1d47 4889C7   		movq	%rax, %rdi
 2642 1d4a E8000000 		call	free
 2642      00
 527:main.c        ****     flClose(handle);
 2643              		.loc 1 527 0
 2644 1d4f 488B8530 		movq	-208(%rbp), %rax
 2644      FFFFFF
 2645 1d56 4889C7   		movq	%rax, %rdi
 2646 1d59 E8000000 		call	flClose
 2646      00
 528:main.c        ****     if (error) {
 2647              		.loc 1 528 0
 2648 1d5e 488B8538 		movq	-200(%rbp), %rax
 2648      FFFFFF
 2649 1d65 4885C0   		testq	%rax, %rax
 2650 1d68 742F     		je	.L167
 529:main.c        ****         fprintf(stderr, "%s\n", error);
 2651              		.loc 1 529 0
 2652 1d6a 488B9538 		movq	-200(%rbp), %rdx
 2652      FFFFFF
 2653 1d71 488B0500 		movq	stderr(%rip), %rax
 2653      000000
 2654 1d78 BE000000 		movl	$.LC59, %esi
 2654      00
 2655 1d7d 4889C7   		movq	%rax, %rdi
 2656 1d80 B8000000 		movl	$0, %eax
 2656      00
 2657 1d85 E8000000 		call	fprintf
 2657      00
 530:main.c        ****         flFreeError(error);
 2658              		.loc 1 530 0
 2659 1d8a 488B8538 		movq	-200(%rbp), %rax
 2659      FFFFFF
 2660 1d91 4889C7   		movq	%rax, %rdi
 2661 1d94 E8000000 		call	flFreeError
 2661      00
 2662              	.L167:
 531:main.c        ****     }
 532:main.c        ****     return retVal;
 2663              		.loc 1 532 0
 2664 1d99 8B85CCFE 		movl	-308(%rbp), %eax
 2664      FFFF
 2665              	.L168:
 533:main.c        **** }...
 2666              		.loc 1 533 0
 2667 1d9f 4881C478 		addq	$376, %rsp
 2667      010000
 2668 1da6 5B       		popq	%rbx
 2669 1da7 5D       		popq	%rbp
 2670              		.cfi_def_cfa 7, 8
 2671 1da8 C3       		ret
 2672              		.cfi_endproc
 2673              	.LFE14:
 2675              	.Letext0:
 2676              		.file 2 "/usr/include/stdint.h"
 2677              		.file 3 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
 2678              		.file 4 "/usr/include/x86_64-linux-gnu/bits/types.h"
 2679              		.file 5 "/usr/include/stdio.h"
 2680              		.file 6 "/usr/include/libio.h"
 2681              		.file 7 "/home/pandu/Desktop/DigitalLogicDesign/Lab/03-finishingup/backend/libs/libargtable2/argta
 2682              		.file 8 "/home/pandu/Desktop/DigitalLogicDesign/Lab/03-finishingup/backend/common/makestuff.h"
 2683              		.file 9 "/home/pandu/Desktop/DigitalLogicDesign/Lab/03-finishingup/backend/libs/libfpgalink/libfpg
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
                            *COM*:0000000000186a50 dataFromCSV
     /tmp/ccTeg7rQ.s:10     .bss:0000000000000000 numLines
     /tmp/ccTeg7rQ.s:15     .bss:0000000000000004 LOG
     /tmp/ccTeg7rQ.s:20     .text:0000000000000000 decrypt
     /tmp/ccTeg7rQ.s:122    .text:00000000000000dd encrypt
     /tmp/ccTeg7rQ.s:223    .text:00000000000001ba decrypt64
     /tmp/ccTeg7rQ.s:257    .text:00000000000001f7 encrypt64
     /tmp/ccTeg7rQ.s:291    .text:0000000000000234 myHash
     /tmp/ccTeg7rQ.s:365    .text:00000000000002a8 format
     /tmp/ccTeg7rQ.s:421    .text:0000000000000328 find
     /tmp/ccTeg7rQ.s:508    .text:00000000000003d5 suffBal
     /tmp/ccTeg7rQ.s:603    .rodata:00000000000000e0 errMessages
     /tmp/ccTeg7rQ.s:730    .text:000000000000046b main

UNDEFINED SYMBOLS
strtok
sscanf
arg_str0
arg_str1
arg_lit0
arg_end
arg_nullcheck
stderr
fprintf
arg_parse
printf
stdout
arg_print_syntax
puts
arg_print_glossary
arg_print_errors
flInitialise
flOpen
flLoadStandardFirmware
flSleep
putchar
fflush
flIsDeviceAvailable
flGetFirmwareVersion
flGetFirmwareID
flIsCommCapable
flSelectConduit
flIsFPGARunning
fopen
malloc
getline
free
fclose
flReadChannel
flWriteChannel
fwrite
fputc
flClose
flFreeError
