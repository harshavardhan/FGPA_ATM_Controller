   1              		.file	"libusbwrap.c"
   2              		.text
   3              	.Ltext0:
   5              	queueSize:
   6              	.LFB6:
   7              		.file 1 "unbounded_queue.h"
   1:unbounded_queue.h **** #ifndef UNBOUNDED_QUEUE_H
   2:unbounded_queue.h **** #define UNBOUNDED_QUEUE_H
   3:unbounded_queue.h **** 
   4:unbounded_queue.h **** #include "libusbwrap.h"
   5:unbounded_queue.h **** 
   6:unbounded_queue.h **** #ifdef __cplusplus
   7:unbounded_queue.h **** extern "C" {
   8:unbounded_queue.h **** #endif
   9:unbounded_queue.h **** 
  10:unbounded_queue.h **** 	typedef const void* Item;
  11:unbounded_queue.h **** 	typedef Item (*CreateFunc)(void);
  12:unbounded_queue.h **** 	typedef void (*DestroyFunc)(Item);
  13:unbounded_queue.h **** 
  14:unbounded_queue.h **** 	struct UnboundedQueue {
  15:unbounded_queue.h **** 		Item *itemArray;
  16:unbounded_queue.h **** 		size_t capacity;
  17:unbounded_queue.h **** 		size_t putIndex;
  18:unbounded_queue.h **** 		size_t takeIndex;
  19:unbounded_queue.h **** 		size_t numItems;
  20:unbounded_queue.h **** 		CreateFunc createFunc;
  21:unbounded_queue.h **** 		DestroyFunc destroyFunc;
  22:unbounded_queue.h **** 	};
  23:unbounded_queue.h **** 
  24:unbounded_queue.h **** 	USBStatus queueInit(
  25:unbounded_queue.h **** 		struct UnboundedQueue *self, size_t capacity, CreateFunc createFunc, DestroyFunc destroyFunc
  26:unbounded_queue.h **** 	);
  27:unbounded_queue.h **** 	USBStatus queuePut(
  28:unbounded_queue.h **** 		struct UnboundedQueue *self, Item *item  // never blocks, can ENOMEM
  29:unbounded_queue.h **** 	);
  30:unbounded_queue.h **** 	void queueCommitPut(
  31:unbounded_queue.h **** 		struct UnboundedQueue *self
  32:unbounded_queue.h **** 	);
  33:unbounded_queue.h **** 	USBStatus queueTake(
  34:unbounded_queue.h **** 		struct UnboundedQueue *self, Item *item  // returns NULL on empty
  35:unbounded_queue.h **** 	);
  36:unbounded_queue.h **** 	void queueCommitTake(
  37:unbounded_queue.h **** 		struct UnboundedQueue *self
  38:unbounded_queue.h **** 	);
  39:unbounded_queue.h **** 	void queueDestroy(
  40:unbounded_queue.h **** 		struct UnboundedQueue *self
  41:unbounded_queue.h **** 	);
  42:unbounded_queue.h **** 	static inline size_t queueSize(const struct UnboundedQueue *self) {
   8              		.loc 1 42 0
   9              		.cfi_startproc
  10 0000 55       		pushq	%rbp
  11              		.cfi_def_cfa_offset 16
  12              		.cfi_offset 6, -16
  13 0001 4889E5   		movq	%rsp, %rbp
  14              		.cfi_def_cfa_register 6
  15 0004 48897DF8 		movq	%rdi, -8(%rbp)
  43:unbounded_queue.h **** 		return self->numItems;
  16              		.loc 1 43 0
  17 0008 488B45F8 		movq	-8(%rbp), %rax
  18 000c 488B4020 		movq	32(%rax), %rax
  44:unbounded_queue.h **** 	}
  19              		.loc 1 44 0
  20 0010 5D       		popq	%rbp
  21              		.cfi_def_cfa 7, 8
  22 0011 C3       		ret
  23              		.cfi_endproc
  24              	.LFE6:
  27              	libusb_fill_bulk_transfer:
  28              	.LFB12:
  29              		.file 2 "/usr/include/libusb-1.0/libusb.h"
   1:/usr/include/libusb-1.0/libusb.h **** /*
   2:/usr/include/libusb-1.0/libusb.h ****  * Public libusbx header file
   3:/usr/include/libusb-1.0/libusb.h ****  * Copyright © 2001 Johannes Erdfelt <johannes@erdfelt.com>
   4:/usr/include/libusb-1.0/libusb.h ****  * Copyright © 2007-2008 Daniel Drake <dsd@gentoo.org>
   5:/usr/include/libusb-1.0/libusb.h ****  * Copyright © 2012 Pete Batard <pete@akeo.ie>
   6:/usr/include/libusb-1.0/libusb.h ****  * Copyright © 2012 Nathan Hjelm <hjelmn@cs.unm.edu>
   7:/usr/include/libusb-1.0/libusb.h ****  * For more information, please visit: http://libusbx.org
   8:/usr/include/libusb-1.0/libusb.h ****  *
   9:/usr/include/libusb-1.0/libusb.h ****  * This library is free software; you can redistribute it and/or
  10:/usr/include/libusb-1.0/libusb.h ****  * modify it under the terms of the GNU Lesser General Public
  11:/usr/include/libusb-1.0/libusb.h ****  * License as published by the Free Software Foundation; either
  12:/usr/include/libusb-1.0/libusb.h ****  * version 2.1 of the License, or (at your option) any later version.
  13:/usr/include/libusb-1.0/libusb.h ****  *
  14:/usr/include/libusb-1.0/libusb.h ****  * This library is distributed in the hope that it will be useful,
  15:/usr/include/libusb-1.0/libusb.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16:/usr/include/libusb-1.0/libusb.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17:/usr/include/libusb-1.0/libusb.h ****  * Lesser General Public License for more details.
  18:/usr/include/libusb-1.0/libusb.h ****  *
  19:/usr/include/libusb-1.0/libusb.h ****  * You should have received a copy of the GNU Lesser General Public
  20:/usr/include/libusb-1.0/libusb.h ****  * License along with this library; if not, write to the Free Software
  21:/usr/include/libusb-1.0/libusb.h ****  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  22:/usr/include/libusb-1.0/libusb.h ****  */
  23:/usr/include/libusb-1.0/libusb.h **** 
  24:/usr/include/libusb-1.0/libusb.h **** #ifndef LIBUSB_H
  25:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_H
  26:/usr/include/libusb-1.0/libusb.h **** 
  27:/usr/include/libusb-1.0/libusb.h **** #ifdef _MSC_VER
  28:/usr/include/libusb-1.0/libusb.h **** /* on MS environments, the inline keyword is available in C++ only */
  29:/usr/include/libusb-1.0/libusb.h **** #if !defined(__cplusplus)
  30:/usr/include/libusb-1.0/libusb.h **** #define inline __inline
  31:/usr/include/libusb-1.0/libusb.h **** #endif
  32:/usr/include/libusb-1.0/libusb.h **** /* ssize_t is also not available (copy/paste from MinGW) */
  33:/usr/include/libusb-1.0/libusb.h **** #ifndef _SSIZE_T_DEFINED
  34:/usr/include/libusb-1.0/libusb.h **** #define _SSIZE_T_DEFINED
  35:/usr/include/libusb-1.0/libusb.h **** #undef ssize_t
  36:/usr/include/libusb-1.0/libusb.h **** #ifdef _WIN64
  37:/usr/include/libusb-1.0/libusb.h ****   typedef __int64 ssize_t;
  38:/usr/include/libusb-1.0/libusb.h **** #else
  39:/usr/include/libusb-1.0/libusb.h ****   typedef int ssize_t;
  40:/usr/include/libusb-1.0/libusb.h **** #endif /* _WIN64 */
  41:/usr/include/libusb-1.0/libusb.h **** #endif /* _SSIZE_T_DEFINED */
  42:/usr/include/libusb-1.0/libusb.h **** #endif /* _MSC_VER */
  43:/usr/include/libusb-1.0/libusb.h **** 
  44:/usr/include/libusb-1.0/libusb.h **** /* stdint.h is not available on older MSVC */
  45:/usr/include/libusb-1.0/libusb.h **** #if defined(_MSC_VER) && (_MSC_VER < 1600) && (!defined(_STDINT)) && (!defined(_STDINT_H))
  46:/usr/include/libusb-1.0/libusb.h **** typedef unsigned __int8   uint8_t;
  47:/usr/include/libusb-1.0/libusb.h **** typedef unsigned __int16  uint16_t;
  48:/usr/include/libusb-1.0/libusb.h **** typedef unsigned __int32  uint32_t;
  49:/usr/include/libusb-1.0/libusb.h **** #else
  50:/usr/include/libusb-1.0/libusb.h **** #include <stdint.h>
  51:/usr/include/libusb-1.0/libusb.h **** #endif
  52:/usr/include/libusb-1.0/libusb.h **** 
  53:/usr/include/libusb-1.0/libusb.h **** #if !defined(_WIN32_WCE)
  54:/usr/include/libusb-1.0/libusb.h **** #include <sys/types.h>
  55:/usr/include/libusb-1.0/libusb.h **** #endif
  56:/usr/include/libusb-1.0/libusb.h **** 
  57:/usr/include/libusb-1.0/libusb.h **** #if defined(__linux) || defined(__APPLE__) || defined(__CYGWIN__)
  58:/usr/include/libusb-1.0/libusb.h **** #include <sys/time.h>
  59:/usr/include/libusb-1.0/libusb.h **** #endif
  60:/usr/include/libusb-1.0/libusb.h **** 
  61:/usr/include/libusb-1.0/libusb.h **** #include <time.h>
  62:/usr/include/libusb-1.0/libusb.h **** #include <limits.h>
  63:/usr/include/libusb-1.0/libusb.h **** 
  64:/usr/include/libusb-1.0/libusb.h **** /* 'interface' might be defined as a macro on Windows, so we need to
  65:/usr/include/libusb-1.0/libusb.h ****  * undefine it so as not to break the current libusbx API, because
  66:/usr/include/libusb-1.0/libusb.h ****  * libusb_config_descriptor has an 'interface' member
  67:/usr/include/libusb-1.0/libusb.h ****  * As this can be problematic if you include windows.h after libusb.h
  68:/usr/include/libusb-1.0/libusb.h ****  * in your sources, we force windows.h to be included first. */
  69:/usr/include/libusb-1.0/libusb.h **** #if defined(_WIN32) || defined(__CYGWIN__) || defined(_WIN32_WCE)
  70:/usr/include/libusb-1.0/libusb.h **** #include <windows.h>
  71:/usr/include/libusb-1.0/libusb.h **** #if defined(interface)
  72:/usr/include/libusb-1.0/libusb.h **** #undef interface
  73:/usr/include/libusb-1.0/libusb.h **** #endif
  74:/usr/include/libusb-1.0/libusb.h **** #if !defined(__CYGWIN__)
  75:/usr/include/libusb-1.0/libusb.h **** #include <winsock.h>
  76:/usr/include/libusb-1.0/libusb.h **** #endif
  77:/usr/include/libusb-1.0/libusb.h **** #endif
  78:/usr/include/libusb-1.0/libusb.h **** 
  79:/usr/include/libusb-1.0/libusb.h **** #if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
  80:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DEPRECATED_FOR(f) \
  81:/usr/include/libusb-1.0/libusb.h ****   __attribute__((deprecated("Use " #f " instead")))
  82:/usr/include/libusb-1.0/libusb.h **** #else
  83:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DEPRECATED_FOR(f)
  84:/usr/include/libusb-1.0/libusb.h **** #endif /* __GNUC__ */
  85:/usr/include/libusb-1.0/libusb.h **** 
  86:/usr/include/libusb-1.0/libusb.h **** /** \def LIBUSB_CALL
  87:/usr/include/libusb-1.0/libusb.h ****  * \ingroup misc
  88:/usr/include/libusb-1.0/libusb.h ****  * libusbx's Windows calling convention.
  89:/usr/include/libusb-1.0/libusb.h ****  *
  90:/usr/include/libusb-1.0/libusb.h ****  * Under Windows, the selection of available compilers and configurations
  91:/usr/include/libusb-1.0/libusb.h ****  * means that, unlike other platforms, there is not <em>one true calling
  92:/usr/include/libusb-1.0/libusb.h ****  * convention</em> (calling convention: the manner in which parameters are
  93:/usr/include/libusb-1.0/libusb.h ****  * passed to funcions in the generated assembly code).
  94:/usr/include/libusb-1.0/libusb.h ****  *
  95:/usr/include/libusb-1.0/libusb.h ****  * Matching the Windows API itself, libusbx uses the WINAPI convention (which
  96:/usr/include/libusb-1.0/libusb.h ****  * translates to the <tt>stdcall</tt> convention) and guarantees that the
  97:/usr/include/libusb-1.0/libusb.h ****  * library is compiled in this way. The public header file also includes
  98:/usr/include/libusb-1.0/libusb.h ****  * appropriate annotations so that your own software will use the right
  99:/usr/include/libusb-1.0/libusb.h ****  * convention, even if another convention is being used by default within
 100:/usr/include/libusb-1.0/libusb.h ****  * your codebase.
 101:/usr/include/libusb-1.0/libusb.h ****  *
 102:/usr/include/libusb-1.0/libusb.h ****  * The one consideration that you must apply in your software is to mark
 103:/usr/include/libusb-1.0/libusb.h ****  * all functions which you use as libusbx callbacks with this LIBUSB_CALL
 104:/usr/include/libusb-1.0/libusb.h ****  * annotation, so that they too get compiled for the correct calling
 105:/usr/include/libusb-1.0/libusb.h ****  * convention.
 106:/usr/include/libusb-1.0/libusb.h ****  *
 107:/usr/include/libusb-1.0/libusb.h ****  * On non-Windows operating systems, this macro is defined as nothing. This
 108:/usr/include/libusb-1.0/libusb.h ****  * means that you can apply it to your code without worrying about
 109:/usr/include/libusb-1.0/libusb.h ****  * cross-platform compatibility.
 110:/usr/include/libusb-1.0/libusb.h ****  */
 111:/usr/include/libusb-1.0/libusb.h **** /* LIBUSB_CALL must be defined on both definition and declaration of libusbx
 112:/usr/include/libusb-1.0/libusb.h ****  * functions. You'd think that declaration would be enough, but cygwin will
 113:/usr/include/libusb-1.0/libusb.h ****  * complain about conflicting types unless both are marked this way.
 114:/usr/include/libusb-1.0/libusb.h ****  * The placement of this macro is important too; it must appear after the
 115:/usr/include/libusb-1.0/libusb.h ****  * return type, before the function name. See internal documentation for
 116:/usr/include/libusb-1.0/libusb.h ****  * API_EXPORTED.
 117:/usr/include/libusb-1.0/libusb.h ****  */
 118:/usr/include/libusb-1.0/libusb.h **** #if defined(_WIN32) || defined(__CYGWIN__) || defined(_WIN32_WCE)
 119:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_CALL WINAPI
 120:/usr/include/libusb-1.0/libusb.h **** #else
 121:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_CALL
 122:/usr/include/libusb-1.0/libusb.h **** #endif
 123:/usr/include/libusb-1.0/libusb.h **** 
 124:/usr/include/libusb-1.0/libusb.h **** /** \def LIBUSBX_API_VERSION
 125:/usr/include/libusb-1.0/libusb.h ****  * \ingroup misc
 126:/usr/include/libusb-1.0/libusb.h ****  * libusbx's API version.
 127:/usr/include/libusb-1.0/libusb.h ****  *
 128:/usr/include/libusb-1.0/libusb.h ****  * Since version 1.0.13, to help with feature detection, libusbx defines
 129:/usr/include/libusb-1.0/libusb.h ****  * a LIBUSBX_API_VERSION macro that gets increased every time there is a
 130:/usr/include/libusb-1.0/libusb.h ****  * significant change to the API, such as the introduction of a new call,
 131:/usr/include/libusb-1.0/libusb.h ****  * the definition of a new macro/enum member, or any other element that
 132:/usr/include/libusb-1.0/libusb.h ****  * libusbx applications may want to detect at compilation time.
 133:/usr/include/libusb-1.0/libusb.h ****  *
 134:/usr/include/libusb-1.0/libusb.h ****  * The macro is typically used in an application as follows:
 135:/usr/include/libusb-1.0/libusb.h ****  * \code
 136:/usr/include/libusb-1.0/libusb.h ****  * #if defined(LIBUSBX_API_VERSION) && (LIBUSBX_API_VERSION >= 0x01001234)
 137:/usr/include/libusb-1.0/libusb.h ****  * // Use one of the newer features from the libusbx API
 138:/usr/include/libusb-1.0/libusb.h ****  * #endif
 139:/usr/include/libusb-1.0/libusb.h ****  * \endcode
 140:/usr/include/libusb-1.0/libusb.h ****  *
 141:/usr/include/libusb-1.0/libusb.h ****  * Another feature of LIBUSBX_API_VERSION is that it can be used to detect
 142:/usr/include/libusb-1.0/libusb.h ****  * whether you are compiling against the libusb or the libusbx library.
 143:/usr/include/libusb-1.0/libusb.h ****  *
 144:/usr/include/libusb-1.0/libusb.h ****  * Internally, LIBUSBX_API_VERSION is defined as follows:
 145:/usr/include/libusb-1.0/libusb.h ****  * (libusbx major << 24) | (libusbx minor << 16) | (16 bit incremental)
 146:/usr/include/libusb-1.0/libusb.h ****  */
 147:/usr/include/libusb-1.0/libusb.h **** #define LIBUSBX_API_VERSION 0x01000102
 148:/usr/include/libusb-1.0/libusb.h **** 
 149:/usr/include/libusb-1.0/libusb.h **** #ifdef __cplusplus
 150:/usr/include/libusb-1.0/libusb.h **** extern "C" {
 151:/usr/include/libusb-1.0/libusb.h **** #endif
 152:/usr/include/libusb-1.0/libusb.h **** 
 153:/usr/include/libusb-1.0/libusb.h **** /** \fn libusb_cpu_to_le16
 154:/usr/include/libusb-1.0/libusb.h ****  * \ingroup misc
 155:/usr/include/libusb-1.0/libusb.h ****  * Convert a 16-bit value from host-endian to little-endian format. On
 156:/usr/include/libusb-1.0/libusb.h ****  * little endian systems, this function does nothing. On big endian systems,
 157:/usr/include/libusb-1.0/libusb.h ****  * the bytes are swapped.
 158:/usr/include/libusb-1.0/libusb.h ****  * \param x the host-endian value to convert
 159:/usr/include/libusb-1.0/libusb.h ****  * \returns the value in little-endian byte order
 160:/usr/include/libusb-1.0/libusb.h ****  */
 161:/usr/include/libusb-1.0/libusb.h **** static inline uint16_t libusb_cpu_to_le16(const uint16_t x)
 162:/usr/include/libusb-1.0/libusb.h **** {
 163:/usr/include/libusb-1.0/libusb.h **** 	union {
 164:/usr/include/libusb-1.0/libusb.h **** 		uint8_t  b8[2];
 165:/usr/include/libusb-1.0/libusb.h **** 		uint16_t b16;
 166:/usr/include/libusb-1.0/libusb.h **** 	} _tmp;
 167:/usr/include/libusb-1.0/libusb.h **** 	_tmp.b8[1] = (uint8_t) (x >> 8);
 168:/usr/include/libusb-1.0/libusb.h **** 	_tmp.b8[0] = (uint8_t) (x & 0xff);
 169:/usr/include/libusb-1.0/libusb.h **** 	return _tmp.b16;
 170:/usr/include/libusb-1.0/libusb.h **** }
 171:/usr/include/libusb-1.0/libusb.h **** 
 172:/usr/include/libusb-1.0/libusb.h **** /** \def libusb_le16_to_cpu
 173:/usr/include/libusb-1.0/libusb.h ****  * \ingroup misc
 174:/usr/include/libusb-1.0/libusb.h ****  * Convert a 16-bit value from little-endian to host-endian format. On
 175:/usr/include/libusb-1.0/libusb.h ****  * little endian systems, this function does nothing. On big endian systems,
 176:/usr/include/libusb-1.0/libusb.h ****  * the bytes are swapped.
 177:/usr/include/libusb-1.0/libusb.h ****  * \param x the little-endian value to convert
 178:/usr/include/libusb-1.0/libusb.h ****  * \returns the value in host-endian byte order
 179:/usr/include/libusb-1.0/libusb.h ****  */
 180:/usr/include/libusb-1.0/libusb.h **** #define libusb_le16_to_cpu libusb_cpu_to_le16
 181:/usr/include/libusb-1.0/libusb.h **** 
 182:/usr/include/libusb-1.0/libusb.h **** /* standard USB stuff */
 183:/usr/include/libusb-1.0/libusb.h **** 
 184:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 185:/usr/include/libusb-1.0/libusb.h ****  * Device and/or Interface Class codes */
 186:/usr/include/libusb-1.0/libusb.h **** enum libusb_class_code {
 187:/usr/include/libusb-1.0/libusb.h **** 	/** In the context of a \ref libusb_device_descriptor "device descriptor",
 188:/usr/include/libusb-1.0/libusb.h **** 	 * this bDeviceClass value indicates that each interface specifies its
 189:/usr/include/libusb-1.0/libusb.h **** 	 * own class information and all interfaces operate independently.
 190:/usr/include/libusb-1.0/libusb.h **** 	 */
 191:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_PER_INTERFACE = 0,
 192:/usr/include/libusb-1.0/libusb.h **** 
 193:/usr/include/libusb-1.0/libusb.h **** 	/** Audio class */
 194:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_AUDIO = 1,
 195:/usr/include/libusb-1.0/libusb.h **** 
 196:/usr/include/libusb-1.0/libusb.h **** 	/** Communications class */
 197:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_COMM = 2,
 198:/usr/include/libusb-1.0/libusb.h **** 
 199:/usr/include/libusb-1.0/libusb.h **** 	/** Human Interface Device class */
 200:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_HID = 3,
 201:/usr/include/libusb-1.0/libusb.h **** 
 202:/usr/include/libusb-1.0/libusb.h **** 	/** Physical */
 203:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_PHYSICAL = 5,
 204:/usr/include/libusb-1.0/libusb.h **** 
 205:/usr/include/libusb-1.0/libusb.h **** 	/** Printer class */
 206:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_PRINTER = 7,
 207:/usr/include/libusb-1.0/libusb.h **** 
 208:/usr/include/libusb-1.0/libusb.h **** 	/** Image class */
 209:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_PTP = 6, /* legacy name from libusb-0.1 usb.h */
 210:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_IMAGE = 6,
 211:/usr/include/libusb-1.0/libusb.h **** 
 212:/usr/include/libusb-1.0/libusb.h **** 	/** Mass storage class */
 213:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_MASS_STORAGE = 8,
 214:/usr/include/libusb-1.0/libusb.h **** 
 215:/usr/include/libusb-1.0/libusb.h **** 	/** Hub class */
 216:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_HUB = 9,
 217:/usr/include/libusb-1.0/libusb.h **** 
 218:/usr/include/libusb-1.0/libusb.h **** 	/** Data class */
 219:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_DATA = 10,
 220:/usr/include/libusb-1.0/libusb.h **** 
 221:/usr/include/libusb-1.0/libusb.h **** 	/** Smart Card */
 222:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_SMART_CARD = 0x0b,
 223:/usr/include/libusb-1.0/libusb.h **** 
 224:/usr/include/libusb-1.0/libusb.h **** 	/** Content Security */
 225:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_CONTENT_SECURITY = 0x0d,
 226:/usr/include/libusb-1.0/libusb.h **** 
 227:/usr/include/libusb-1.0/libusb.h **** 	/** Video */
 228:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_VIDEO = 0x0e,
 229:/usr/include/libusb-1.0/libusb.h **** 
 230:/usr/include/libusb-1.0/libusb.h **** 	/** Personal Healthcare */
 231:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_PERSONAL_HEALTHCARE = 0x0f,
 232:/usr/include/libusb-1.0/libusb.h **** 
 233:/usr/include/libusb-1.0/libusb.h **** 	/** Diagnostic Device */
 234:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_DIAGNOSTIC_DEVICE = 0xdc,
 235:/usr/include/libusb-1.0/libusb.h **** 
 236:/usr/include/libusb-1.0/libusb.h **** 	/** Wireless class */
 237:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_WIRELESS = 0xe0,
 238:/usr/include/libusb-1.0/libusb.h **** 
 239:/usr/include/libusb-1.0/libusb.h **** 	/** Application class */
 240:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_APPLICATION = 0xfe,
 241:/usr/include/libusb-1.0/libusb.h **** 
 242:/usr/include/libusb-1.0/libusb.h **** 	/** Class is vendor-specific */
 243:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_VENDOR_SPEC = 0xff
 244:/usr/include/libusb-1.0/libusb.h **** };
 245:/usr/include/libusb-1.0/libusb.h **** 
 246:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 247:/usr/include/libusb-1.0/libusb.h ****  * Descriptor types as defined by the USB specification. */
 248:/usr/include/libusb-1.0/libusb.h **** enum libusb_descriptor_type {
 249:/usr/include/libusb-1.0/libusb.h **** 	/** Device descriptor. See libusb_device_descriptor. */
 250:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_DEVICE = 0x01,
 251:/usr/include/libusb-1.0/libusb.h **** 
 252:/usr/include/libusb-1.0/libusb.h **** 	/** Configuration descriptor. See libusb_config_descriptor. */
 253:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_CONFIG = 0x02,
 254:/usr/include/libusb-1.0/libusb.h **** 
 255:/usr/include/libusb-1.0/libusb.h **** 	/** String descriptor */
 256:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_STRING = 0x03,
 257:/usr/include/libusb-1.0/libusb.h **** 
 258:/usr/include/libusb-1.0/libusb.h **** 	/** Interface descriptor. See libusb_interface_descriptor. */
 259:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_INTERFACE = 0x04,
 260:/usr/include/libusb-1.0/libusb.h **** 
 261:/usr/include/libusb-1.0/libusb.h **** 	/** Endpoint descriptor. See libusb_endpoint_descriptor. */
 262:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_ENDPOINT = 0x05,
 263:/usr/include/libusb-1.0/libusb.h **** 
 264:/usr/include/libusb-1.0/libusb.h **** 	/** BOS descriptor */
 265:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_BOS = 0x0f,
 266:/usr/include/libusb-1.0/libusb.h **** 
 267:/usr/include/libusb-1.0/libusb.h **** 	/** Device Capability descriptor */
 268:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_DEVICE_CAPABILITY = 0x10,
 269:/usr/include/libusb-1.0/libusb.h **** 
 270:/usr/include/libusb-1.0/libusb.h **** 	/** HID descriptor */
 271:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_HID = 0x21,
 272:/usr/include/libusb-1.0/libusb.h **** 
 273:/usr/include/libusb-1.0/libusb.h **** 	/** HID report descriptor */
 274:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_REPORT = 0x22,
 275:/usr/include/libusb-1.0/libusb.h **** 
 276:/usr/include/libusb-1.0/libusb.h **** 	/** Physical descriptor */
 277:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_PHYSICAL = 0x23,
 278:/usr/include/libusb-1.0/libusb.h **** 
 279:/usr/include/libusb-1.0/libusb.h **** 	/** Hub descriptor */
 280:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_HUB = 0x29,
 281:/usr/include/libusb-1.0/libusb.h **** 
 282:/usr/include/libusb-1.0/libusb.h **** 	/** SuperSpeed Hub descriptor */
 283:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_SUPERSPEED_HUB = 0x2a,
 284:/usr/include/libusb-1.0/libusb.h **** 
 285:/usr/include/libusb-1.0/libusb.h **** 	/** SuperSpeed Endpoint Companion descriptor */
 286:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_SS_ENDPOINT_COMPANION = 0x30
 287:/usr/include/libusb-1.0/libusb.h **** };
 288:/usr/include/libusb-1.0/libusb.h **** 
 289:/usr/include/libusb-1.0/libusb.h **** /* Descriptor sizes per descriptor type */
 290:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_DEVICE_SIZE			18
 291:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_CONFIG_SIZE			9
 292:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_INTERFACE_SIZE		9
 293:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_ENDPOINT_SIZE			7
 294:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_ENDPOINT_AUDIO_SIZE		9	/* Audio extension */
 295:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_HUB_NONVAR_SIZE		7
 296:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_SS_ENDPOINT_COMPANION_SIZE	6
 297:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_BOS_SIZE			5
 298:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_DEVICE_CAPABILITY_SIZE	3
 299:/usr/include/libusb-1.0/libusb.h **** 
 300:/usr/include/libusb-1.0/libusb.h **** /* BOS descriptor sizes */
 301:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_BT_USB_2_0_EXTENSION_SIZE	7
 302:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_BT_SS_USB_DEVICE_CAPABILITY_SIZE	10
 303:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_BT_CONTAINER_ID_SIZE		20
 304:/usr/include/libusb-1.0/libusb.h **** 
 305:/usr/include/libusb-1.0/libusb.h **** /* We unwrap the BOS => define its max size */
 306:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_BOS_MAX_SIZE		((LIBUSB_DT_BOS_SIZE)     +\
 307:/usr/include/libusb-1.0/libusb.h **** 					(LIBUSB_BT_USB_2_0_EXTENSION_SIZE)       +\
 308:/usr/include/libusb-1.0/libusb.h **** 					(LIBUSB_BT_SS_USB_DEVICE_CAPABILITY_SIZE) +\
 309:/usr/include/libusb-1.0/libusb.h **** 					(LIBUSB_BT_CONTAINER_ID_SIZE))
 310:/usr/include/libusb-1.0/libusb.h **** 
 311:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_ENDPOINT_ADDRESS_MASK	0x0f    /* in bEndpointAddress */
 312:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_ENDPOINT_DIR_MASK		0x80
 313:/usr/include/libusb-1.0/libusb.h **** 
 314:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 315:/usr/include/libusb-1.0/libusb.h ****  * Endpoint direction. Values for bit 7 of the
 316:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_endpoint_descriptor::bEndpointAddress "endpoint address" scheme.
 317:/usr/include/libusb-1.0/libusb.h ****  */
 318:/usr/include/libusb-1.0/libusb.h **** enum libusb_endpoint_direction {
 319:/usr/include/libusb-1.0/libusb.h **** 	/** In: device-to-host */
 320:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ENDPOINT_IN = 0x80,
 321:/usr/include/libusb-1.0/libusb.h **** 
 322:/usr/include/libusb-1.0/libusb.h **** 	/** Out: host-to-device */
 323:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ENDPOINT_OUT = 0x00
 324:/usr/include/libusb-1.0/libusb.h **** };
 325:/usr/include/libusb-1.0/libusb.h **** 
 326:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_TRANSFER_TYPE_MASK			0x03    /* in bmAttributes */
 327:/usr/include/libusb-1.0/libusb.h **** 
 328:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 329:/usr/include/libusb-1.0/libusb.h ****  * Endpoint transfer type. Values for bits 0:1 of the
 330:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_endpoint_descriptor::bmAttributes "endpoint attributes" field.
 331:/usr/include/libusb-1.0/libusb.h ****  */
 332:/usr/include/libusb-1.0/libusb.h **** enum libusb_transfer_type {
 333:/usr/include/libusb-1.0/libusb.h **** 	/** Control endpoint */
 334:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_TYPE_CONTROL = 0,
 335:/usr/include/libusb-1.0/libusb.h **** 
 336:/usr/include/libusb-1.0/libusb.h **** 	/** Isochronous endpoint */
 337:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_TYPE_ISOCHRONOUS = 1,
 338:/usr/include/libusb-1.0/libusb.h **** 
 339:/usr/include/libusb-1.0/libusb.h **** 	/** Bulk endpoint */
 340:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_TYPE_BULK = 2,
 341:/usr/include/libusb-1.0/libusb.h **** 
 342:/usr/include/libusb-1.0/libusb.h **** 	/** Interrupt endpoint */
 343:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_TYPE_INTERRUPT = 3
 344:/usr/include/libusb-1.0/libusb.h **** };
 345:/usr/include/libusb-1.0/libusb.h **** 
 346:/usr/include/libusb-1.0/libusb.h **** /** \ingroup misc
 347:/usr/include/libusb-1.0/libusb.h ****  * Standard requests, as defined in table 9-5 of the USB 3.0 specifications */
 348:/usr/include/libusb-1.0/libusb.h **** enum libusb_standard_request {
 349:/usr/include/libusb-1.0/libusb.h **** 	/** Request status of the specific recipient */
 350:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_GET_STATUS = 0x00,
 351:/usr/include/libusb-1.0/libusb.h **** 
 352:/usr/include/libusb-1.0/libusb.h **** 	/** Clear or disable a specific feature */
 353:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_CLEAR_FEATURE = 0x01,
 354:/usr/include/libusb-1.0/libusb.h **** 
 355:/usr/include/libusb-1.0/libusb.h **** 	/* 0x02 is reserved */
 356:/usr/include/libusb-1.0/libusb.h **** 
 357:/usr/include/libusb-1.0/libusb.h **** 	/** Set or enable a specific feature */
 358:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_SET_FEATURE = 0x03,
 359:/usr/include/libusb-1.0/libusb.h **** 
 360:/usr/include/libusb-1.0/libusb.h **** 	/* 0x04 is reserved */
 361:/usr/include/libusb-1.0/libusb.h **** 
 362:/usr/include/libusb-1.0/libusb.h **** 	/** Set device address for all future accesses */
 363:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_SET_ADDRESS = 0x05,
 364:/usr/include/libusb-1.0/libusb.h **** 
 365:/usr/include/libusb-1.0/libusb.h **** 	/** Get the specified descriptor */
 366:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_GET_DESCRIPTOR = 0x06,
 367:/usr/include/libusb-1.0/libusb.h **** 
 368:/usr/include/libusb-1.0/libusb.h **** 	/** Used to update existing descriptors or add new descriptors */
 369:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_SET_DESCRIPTOR = 0x07,
 370:/usr/include/libusb-1.0/libusb.h **** 
 371:/usr/include/libusb-1.0/libusb.h **** 	/** Get the current device configuration value */
 372:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_GET_CONFIGURATION = 0x08,
 373:/usr/include/libusb-1.0/libusb.h **** 
 374:/usr/include/libusb-1.0/libusb.h **** 	/** Set device configuration */
 375:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_SET_CONFIGURATION = 0x09,
 376:/usr/include/libusb-1.0/libusb.h **** 
 377:/usr/include/libusb-1.0/libusb.h **** 	/** Return the selected alternate setting for the specified interface */
 378:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_GET_INTERFACE = 0x0A,
 379:/usr/include/libusb-1.0/libusb.h **** 
 380:/usr/include/libusb-1.0/libusb.h **** 	/** Select an alternate interface for the specified interface */
 381:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_SET_INTERFACE = 0x0B,
 382:/usr/include/libusb-1.0/libusb.h **** 
 383:/usr/include/libusb-1.0/libusb.h **** 	/** Set then report an endpoint's synchronization frame */
 384:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_SYNCH_FRAME = 0x0C,
 385:/usr/include/libusb-1.0/libusb.h **** 
 386:/usr/include/libusb-1.0/libusb.h **** 	/** Sets both the U1 and U2 Exit Latency */
 387:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_SET_SEL = 0x30,
 388:/usr/include/libusb-1.0/libusb.h **** 
 389:/usr/include/libusb-1.0/libusb.h **** 	/** Delay from the time a host transmits a packet to the time it is
 390:/usr/include/libusb-1.0/libusb.h **** 	  * received by the device. */
 391:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SET_ISOCH_DELAY = 0x31,
 392:/usr/include/libusb-1.0/libusb.h **** };
 393:/usr/include/libusb-1.0/libusb.h **** 
 394:/usr/include/libusb-1.0/libusb.h **** /** \ingroup misc
 395:/usr/include/libusb-1.0/libusb.h ****  * Request type bits of the
 396:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup::bmRequestType "bmRequestType" field in control
 397:/usr/include/libusb-1.0/libusb.h ****  * transfers. */
 398:/usr/include/libusb-1.0/libusb.h **** enum libusb_request_type {
 399:/usr/include/libusb-1.0/libusb.h **** 	/** Standard */
 400:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_TYPE_STANDARD = (0x00 << 5),
 401:/usr/include/libusb-1.0/libusb.h **** 
 402:/usr/include/libusb-1.0/libusb.h **** 	/** Class */
 403:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_TYPE_CLASS = (0x01 << 5),
 404:/usr/include/libusb-1.0/libusb.h **** 
 405:/usr/include/libusb-1.0/libusb.h **** 	/** Vendor */
 406:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_TYPE_VENDOR = (0x02 << 5),
 407:/usr/include/libusb-1.0/libusb.h **** 
 408:/usr/include/libusb-1.0/libusb.h **** 	/** Reserved */
 409:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_TYPE_RESERVED = (0x03 << 5)
 410:/usr/include/libusb-1.0/libusb.h **** };
 411:/usr/include/libusb-1.0/libusb.h **** 
 412:/usr/include/libusb-1.0/libusb.h **** /** \ingroup misc
 413:/usr/include/libusb-1.0/libusb.h ****  * Recipient bits of the
 414:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup::bmRequestType "bmRequestType" field in control
 415:/usr/include/libusb-1.0/libusb.h ****  * transfers. Values 4 through 31 are reserved. */
 416:/usr/include/libusb-1.0/libusb.h **** enum libusb_request_recipient {
 417:/usr/include/libusb-1.0/libusb.h **** 	/** Device */
 418:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_RECIPIENT_DEVICE = 0x00,
 419:/usr/include/libusb-1.0/libusb.h **** 
 420:/usr/include/libusb-1.0/libusb.h **** 	/** Interface */
 421:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_RECIPIENT_INTERFACE = 0x01,
 422:/usr/include/libusb-1.0/libusb.h **** 
 423:/usr/include/libusb-1.0/libusb.h **** 	/** Endpoint */
 424:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_RECIPIENT_ENDPOINT = 0x02,
 425:/usr/include/libusb-1.0/libusb.h **** 
 426:/usr/include/libusb-1.0/libusb.h **** 	/** Other */
 427:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_RECIPIENT_OTHER = 0x03,
 428:/usr/include/libusb-1.0/libusb.h **** };
 429:/usr/include/libusb-1.0/libusb.h **** 
 430:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_ISO_SYNC_TYPE_MASK		0x0C
 431:/usr/include/libusb-1.0/libusb.h **** 
 432:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 433:/usr/include/libusb-1.0/libusb.h ****  * Synchronization type for isochronous endpoints. Values for bits 2:3 of the
 434:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_endpoint_descriptor::bmAttributes "bmAttributes" field in
 435:/usr/include/libusb-1.0/libusb.h ****  * libusb_endpoint_descriptor.
 436:/usr/include/libusb-1.0/libusb.h ****  */
 437:/usr/include/libusb-1.0/libusb.h **** enum libusb_iso_sync_type {
 438:/usr/include/libusb-1.0/libusb.h **** 	/** No synchronization */
 439:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ISO_SYNC_TYPE_NONE = 0,
 440:/usr/include/libusb-1.0/libusb.h **** 
 441:/usr/include/libusb-1.0/libusb.h **** 	/** Asynchronous */
 442:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ISO_SYNC_TYPE_ASYNC = 1,
 443:/usr/include/libusb-1.0/libusb.h **** 
 444:/usr/include/libusb-1.0/libusb.h **** 	/** Adaptive */
 445:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ISO_SYNC_TYPE_ADAPTIVE = 2,
 446:/usr/include/libusb-1.0/libusb.h **** 
 447:/usr/include/libusb-1.0/libusb.h **** 	/** Synchronous */
 448:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ISO_SYNC_TYPE_SYNC = 3
 449:/usr/include/libusb-1.0/libusb.h **** };
 450:/usr/include/libusb-1.0/libusb.h **** 
 451:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_ISO_USAGE_TYPE_MASK 0x30
 452:/usr/include/libusb-1.0/libusb.h **** 
 453:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 454:/usr/include/libusb-1.0/libusb.h ****  * Usage type for isochronous endpoints. Values for bits 4:5 of the
 455:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_endpoint_descriptor::bmAttributes "bmAttributes" field in
 456:/usr/include/libusb-1.0/libusb.h ****  * libusb_endpoint_descriptor.
 457:/usr/include/libusb-1.0/libusb.h ****  */
 458:/usr/include/libusb-1.0/libusb.h **** enum libusb_iso_usage_type {
 459:/usr/include/libusb-1.0/libusb.h **** 	/** Data endpoint */
 460:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ISO_USAGE_TYPE_DATA = 0,
 461:/usr/include/libusb-1.0/libusb.h **** 
 462:/usr/include/libusb-1.0/libusb.h **** 	/** Feedback endpoint */
 463:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ISO_USAGE_TYPE_FEEDBACK = 1,
 464:/usr/include/libusb-1.0/libusb.h **** 
 465:/usr/include/libusb-1.0/libusb.h **** 	/** Implicit feedback Data endpoint */
 466:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ISO_USAGE_TYPE_IMPLICIT = 2,
 467:/usr/include/libusb-1.0/libusb.h **** };
 468:/usr/include/libusb-1.0/libusb.h **** 
 469:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 470:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the standard USB device descriptor. This
 471:/usr/include/libusb-1.0/libusb.h ****  * descriptor is documented in section 9.6.1 of the USB 3.0 specification.
 472:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields are represented in host-endian format.
 473:/usr/include/libusb-1.0/libusb.h ****  */
 474:/usr/include/libusb-1.0/libusb.h **** struct libusb_device_descriptor {
 475:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 476:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 477:/usr/include/libusb-1.0/libusb.h **** 
 478:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 479:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_DEVICE LIBUSB_DT_DEVICE in this
 480:/usr/include/libusb-1.0/libusb.h **** 	 * context. */
 481:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 482:/usr/include/libusb-1.0/libusb.h **** 
 483:/usr/include/libusb-1.0/libusb.h **** 	/** USB specification release number in binary-coded decimal. A value of
 484:/usr/include/libusb-1.0/libusb.h **** 	 * 0x0200 indicates USB 2.0, 0x0110 indicates USB 1.1, etc. */
 485:/usr/include/libusb-1.0/libusb.h **** 	uint16_t bcdUSB;
 486:/usr/include/libusb-1.0/libusb.h **** 
 487:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF class code for the device. See \ref libusb_class_code. */
 488:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDeviceClass;
 489:/usr/include/libusb-1.0/libusb.h **** 
 490:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF subclass code for the device, qualified by the bDeviceClass
 491:/usr/include/libusb-1.0/libusb.h **** 	 * value */
 492:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDeviceSubClass;
 493:/usr/include/libusb-1.0/libusb.h **** 
 494:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF protocol code for the device, qualified by the bDeviceClass and
 495:/usr/include/libusb-1.0/libusb.h **** 	 * bDeviceSubClass values */
 496:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDeviceProtocol;
 497:/usr/include/libusb-1.0/libusb.h **** 
 498:/usr/include/libusb-1.0/libusb.h **** 	/** Maximum packet size for endpoint 0 */
 499:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bMaxPacketSize0;
 500:/usr/include/libusb-1.0/libusb.h **** 
 501:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF vendor ID */
 502:/usr/include/libusb-1.0/libusb.h **** 	uint16_t idVendor;
 503:/usr/include/libusb-1.0/libusb.h **** 
 504:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF product ID */
 505:/usr/include/libusb-1.0/libusb.h **** 	uint16_t idProduct;
 506:/usr/include/libusb-1.0/libusb.h **** 
 507:/usr/include/libusb-1.0/libusb.h **** 	/** Device release number in binary-coded decimal */
 508:/usr/include/libusb-1.0/libusb.h **** 	uint16_t bcdDevice;
 509:/usr/include/libusb-1.0/libusb.h **** 
 510:/usr/include/libusb-1.0/libusb.h **** 	/** Index of string descriptor describing manufacturer */
 511:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  iManufacturer;
 512:/usr/include/libusb-1.0/libusb.h **** 
 513:/usr/include/libusb-1.0/libusb.h **** 	/** Index of string descriptor describing product */
 514:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  iProduct;
 515:/usr/include/libusb-1.0/libusb.h **** 
 516:/usr/include/libusb-1.0/libusb.h **** 	/** Index of string descriptor containing device serial number */
 517:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  iSerialNumber;
 518:/usr/include/libusb-1.0/libusb.h **** 
 519:/usr/include/libusb-1.0/libusb.h **** 	/** Number of possible configurations */
 520:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bNumConfigurations;
 521:/usr/include/libusb-1.0/libusb.h **** };
 522:/usr/include/libusb-1.0/libusb.h **** 
 523:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 524:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the standard USB endpoint descriptor. This
 525:/usr/include/libusb-1.0/libusb.h ****  * descriptor is documented in section 9.6.6 of the USB 3.0 specification.
 526:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields are represented in host-endian format.
 527:/usr/include/libusb-1.0/libusb.h ****  */
 528:/usr/include/libusb-1.0/libusb.h **** struct libusb_endpoint_descriptor {
 529:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 530:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 531:/usr/include/libusb-1.0/libusb.h **** 
 532:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 533:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_ENDPOINT LIBUSB_DT_ENDPOINT in
 534:/usr/include/libusb-1.0/libusb.h **** 	 * this context. */
 535:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 536:/usr/include/libusb-1.0/libusb.h **** 
 537:/usr/include/libusb-1.0/libusb.h **** 	/** The address of the endpoint described by this descriptor. Bits 0:3 are
 538:/usr/include/libusb-1.0/libusb.h **** 	 * the endpoint number. Bits 4:6 are reserved. Bit 7 indicates direction,
 539:/usr/include/libusb-1.0/libusb.h **** 	 * see \ref libusb_endpoint_direction.
 540:/usr/include/libusb-1.0/libusb.h **** 	 */
 541:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bEndpointAddress;
 542:/usr/include/libusb-1.0/libusb.h **** 
 543:/usr/include/libusb-1.0/libusb.h **** 	/** Attributes which apply to the endpoint when it is configured using
 544:/usr/include/libusb-1.0/libusb.h **** 	 * the bConfigurationValue. Bits 0:1 determine the transfer type and
 545:/usr/include/libusb-1.0/libusb.h **** 	 * correspond to \ref libusb_transfer_type. Bits 2:3 are only used for
 546:/usr/include/libusb-1.0/libusb.h **** 	 * isochronous endpoints and correspond to \ref libusb_iso_sync_type.
 547:/usr/include/libusb-1.0/libusb.h **** 	 * Bits 4:5 are also only used for isochronous endpoints and correspond to
 548:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_iso_usage_type. Bits 6:7 are reserved.
 549:/usr/include/libusb-1.0/libusb.h **** 	 */
 550:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bmAttributes;
 551:/usr/include/libusb-1.0/libusb.h **** 
 552:/usr/include/libusb-1.0/libusb.h **** 	/** Maximum packet size this endpoint is capable of sending/receiving. */
 553:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wMaxPacketSize;
 554:/usr/include/libusb-1.0/libusb.h **** 
 555:/usr/include/libusb-1.0/libusb.h **** 	/** Interval for polling endpoint for data transfers. */
 556:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bInterval;
 557:/usr/include/libusb-1.0/libusb.h **** 
 558:/usr/include/libusb-1.0/libusb.h **** 	/** For audio devices only: the rate at which synchronization feedback
 559:/usr/include/libusb-1.0/libusb.h **** 	 * is provided. */
 560:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bRefresh;
 561:/usr/include/libusb-1.0/libusb.h **** 
 562:/usr/include/libusb-1.0/libusb.h **** 	/** For audio devices only: the address if the synch endpoint */
 563:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bSynchAddress;
 564:/usr/include/libusb-1.0/libusb.h **** 
 565:/usr/include/libusb-1.0/libusb.h **** 	/** Extra descriptors. If libusbx encounters unknown endpoint descriptors,
 566:/usr/include/libusb-1.0/libusb.h **** 	 * it will store them here, should you wish to parse them. */
 567:/usr/include/libusb-1.0/libusb.h **** 	const unsigned char *extra;
 568:/usr/include/libusb-1.0/libusb.h **** 
 569:/usr/include/libusb-1.0/libusb.h **** 	/** Length of the extra descriptors, in bytes. */
 570:/usr/include/libusb-1.0/libusb.h **** 	int extra_length;
 571:/usr/include/libusb-1.0/libusb.h **** };
 572:/usr/include/libusb-1.0/libusb.h **** 
 573:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 574:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the standard USB interface descriptor. This
 575:/usr/include/libusb-1.0/libusb.h ****  * descriptor is documented in section 9.6.5 of the USB 3.0 specification.
 576:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields are represented in host-endian format.
 577:/usr/include/libusb-1.0/libusb.h ****  */
 578:/usr/include/libusb-1.0/libusb.h **** struct libusb_interface_descriptor {
 579:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 580:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 581:/usr/include/libusb-1.0/libusb.h **** 
 582:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 583:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_INTERFACE LIBUSB_DT_INTERFACE
 584:/usr/include/libusb-1.0/libusb.h **** 	 * in this context. */
 585:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 586:/usr/include/libusb-1.0/libusb.h **** 
 587:/usr/include/libusb-1.0/libusb.h **** 	/** Number of this interface */
 588:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bInterfaceNumber;
 589:/usr/include/libusb-1.0/libusb.h **** 
 590:/usr/include/libusb-1.0/libusb.h **** 	/** Value used to select this alternate setting for this interface */
 591:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bAlternateSetting;
 592:/usr/include/libusb-1.0/libusb.h **** 
 593:/usr/include/libusb-1.0/libusb.h **** 	/** Number of endpoints used by this interface (excluding the control
 594:/usr/include/libusb-1.0/libusb.h **** 	 * endpoint). */
 595:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bNumEndpoints;
 596:/usr/include/libusb-1.0/libusb.h **** 
 597:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF class code for this interface. See \ref libusb_class_code. */
 598:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bInterfaceClass;
 599:/usr/include/libusb-1.0/libusb.h **** 
 600:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF subclass code for this interface, qualified by the
 601:/usr/include/libusb-1.0/libusb.h **** 	 * bInterfaceClass value */
 602:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bInterfaceSubClass;
 603:/usr/include/libusb-1.0/libusb.h **** 
 604:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF protocol code for this interface, qualified by the
 605:/usr/include/libusb-1.0/libusb.h **** 	 * bInterfaceClass and bInterfaceSubClass values */
 606:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bInterfaceProtocol;
 607:/usr/include/libusb-1.0/libusb.h **** 
 608:/usr/include/libusb-1.0/libusb.h **** 	/** Index of string descriptor describing this interface */
 609:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  iInterface;
 610:/usr/include/libusb-1.0/libusb.h **** 
 611:/usr/include/libusb-1.0/libusb.h **** 	/** Array of endpoint descriptors. This length of this array is determined
 612:/usr/include/libusb-1.0/libusb.h **** 	 * by the bNumEndpoints field. */
 613:/usr/include/libusb-1.0/libusb.h **** 	const struct libusb_endpoint_descriptor *endpoint;
 614:/usr/include/libusb-1.0/libusb.h **** 
 615:/usr/include/libusb-1.0/libusb.h **** 	/** Extra descriptors. If libusbx encounters unknown interface descriptors,
 616:/usr/include/libusb-1.0/libusb.h **** 	 * it will store them here, should you wish to parse them. */
 617:/usr/include/libusb-1.0/libusb.h **** 	const unsigned char *extra;
 618:/usr/include/libusb-1.0/libusb.h **** 
 619:/usr/include/libusb-1.0/libusb.h **** 	/** Length of the extra descriptors, in bytes. */
 620:/usr/include/libusb-1.0/libusb.h **** 	int extra_length;
 621:/usr/include/libusb-1.0/libusb.h **** };
 622:/usr/include/libusb-1.0/libusb.h **** 
 623:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 624:/usr/include/libusb-1.0/libusb.h ****  * A collection of alternate settings for a particular USB interface.
 625:/usr/include/libusb-1.0/libusb.h ****  */
 626:/usr/include/libusb-1.0/libusb.h **** struct libusb_interface {
 627:/usr/include/libusb-1.0/libusb.h **** 	/** Array of interface descriptors. The length of this array is determined
 628:/usr/include/libusb-1.0/libusb.h **** 	 * by the num_altsetting field. */
 629:/usr/include/libusb-1.0/libusb.h **** 	const struct libusb_interface_descriptor *altsetting;
 630:/usr/include/libusb-1.0/libusb.h **** 
 631:/usr/include/libusb-1.0/libusb.h **** 	/** The number of alternate settings that belong to this interface */
 632:/usr/include/libusb-1.0/libusb.h **** 	int num_altsetting;
 633:/usr/include/libusb-1.0/libusb.h **** };
 634:/usr/include/libusb-1.0/libusb.h **** 
 635:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 636:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the standard USB configuration descriptor. This
 637:/usr/include/libusb-1.0/libusb.h ****  * descriptor is documented in section 9.6.3 of the USB 3.0 specification.
 638:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields are represented in host-endian format.
 639:/usr/include/libusb-1.0/libusb.h ****  */
 640:/usr/include/libusb-1.0/libusb.h **** struct libusb_config_descriptor {
 641:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 642:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 643:/usr/include/libusb-1.0/libusb.h **** 
 644:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 645:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_CONFIG LIBUSB_DT_CONFIG
 646:/usr/include/libusb-1.0/libusb.h **** 	 * in this context. */
 647:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 648:/usr/include/libusb-1.0/libusb.h **** 
 649:/usr/include/libusb-1.0/libusb.h **** 	/** Total length of data returned for this configuration */
 650:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wTotalLength;
 651:/usr/include/libusb-1.0/libusb.h **** 
 652:/usr/include/libusb-1.0/libusb.h **** 	/** Number of interfaces supported by this configuration */
 653:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bNumInterfaces;
 654:/usr/include/libusb-1.0/libusb.h **** 
 655:/usr/include/libusb-1.0/libusb.h **** 	/** Identifier value for this configuration */
 656:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bConfigurationValue;
 657:/usr/include/libusb-1.0/libusb.h **** 
 658:/usr/include/libusb-1.0/libusb.h **** 	/** Index of string descriptor describing this configuration */
 659:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  iConfiguration;
 660:/usr/include/libusb-1.0/libusb.h **** 
 661:/usr/include/libusb-1.0/libusb.h **** 	/** Configuration characteristics */
 662:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bmAttributes;
 663:/usr/include/libusb-1.0/libusb.h **** 
 664:/usr/include/libusb-1.0/libusb.h **** 	/** Maximum power consumption of the USB device from this bus in this
 665:/usr/include/libusb-1.0/libusb.h **** 	 * configuration when the device is fully opreation. Expressed in units
 666:/usr/include/libusb-1.0/libusb.h **** 	 * of 2 mA. */
 667:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  MaxPower;
 668:/usr/include/libusb-1.0/libusb.h **** 
 669:/usr/include/libusb-1.0/libusb.h **** 	/** Array of interfaces supported by this configuration. The length of
 670:/usr/include/libusb-1.0/libusb.h **** 	 * this array is determined by the bNumInterfaces field. */
 671:/usr/include/libusb-1.0/libusb.h **** 	const struct libusb_interface *interface;
 672:/usr/include/libusb-1.0/libusb.h **** 
 673:/usr/include/libusb-1.0/libusb.h **** 	/** Extra descriptors. If libusbx encounters unknown configuration
 674:/usr/include/libusb-1.0/libusb.h **** 	 * descriptors, it will store them here, should you wish to parse them. */
 675:/usr/include/libusb-1.0/libusb.h **** 	const unsigned char *extra;
 676:/usr/include/libusb-1.0/libusb.h **** 
 677:/usr/include/libusb-1.0/libusb.h **** 	/** Length of the extra descriptors, in bytes. */
 678:/usr/include/libusb-1.0/libusb.h **** 	int extra_length;
 679:/usr/include/libusb-1.0/libusb.h **** };
 680:/usr/include/libusb-1.0/libusb.h **** 
 681:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 682:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the superspeed endpoint companion
 683:/usr/include/libusb-1.0/libusb.h ****  * descriptor. This descriptor is documented in section 9.6.7 of
 684:/usr/include/libusb-1.0/libusb.h ****  * the USB 3.0 specification. All multiple-byte fields are represented in
 685:/usr/include/libusb-1.0/libusb.h ****  * host-endian format.
 686:/usr/include/libusb-1.0/libusb.h ****  */
 687:/usr/include/libusb-1.0/libusb.h **** struct libusb_ss_endpoint_companion_descriptor {
 688:/usr/include/libusb-1.0/libusb.h **** 
 689:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 690:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 691:/usr/include/libusb-1.0/libusb.h **** 
 692:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 693:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_SS_ENDPOINT_COMPANION in
 694:/usr/include/libusb-1.0/libusb.h **** 	 * this context. */
 695:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 696:/usr/include/libusb-1.0/libusb.h **** 
 697:/usr/include/libusb-1.0/libusb.h **** 
 698:/usr/include/libusb-1.0/libusb.h **** 	/** The maximum number of packets the endpoint can send or
 699:/usr/include/libusb-1.0/libusb.h **** 	 *  recieve as part of a burst. */
 700:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bMaxBurst;
 701:/usr/include/libusb-1.0/libusb.h **** 
 702:/usr/include/libusb-1.0/libusb.h **** 	/** In bulk EP:	bits 4:0 represents the	maximum	number of
 703:/usr/include/libusb-1.0/libusb.h **** 	 *  streams the	EP supports. In	isochronous EP:	bits 1:0
 704:/usr/include/libusb-1.0/libusb.h **** 	 *  represents the Mult	- a zero based value that determines
 705:/usr/include/libusb-1.0/libusb.h **** 	 *  the	maximum	number of packets within a service interval  */
 706:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bmAttributes;
 707:/usr/include/libusb-1.0/libusb.h **** 
 708:/usr/include/libusb-1.0/libusb.h **** 	/** The	total number of bytes this EP will transfer every
 709:/usr/include/libusb-1.0/libusb.h **** 	 *  service interval. valid only for periodic EPs. */
 710:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wBytesPerInterval;
 711:/usr/include/libusb-1.0/libusb.h **** };
 712:/usr/include/libusb-1.0/libusb.h **** 
 713:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 714:/usr/include/libusb-1.0/libusb.h ****  * A generic representation of a BOS Device Capability descriptor. It is
 715:/usr/include/libusb-1.0/libusb.h ****  * advised to check bDevCapabilityType and call the matching
 716:/usr/include/libusb-1.0/libusb.h ****  * libusb_get_*_descriptor function to get a structure fully matching the type.
 717:/usr/include/libusb-1.0/libusb.h ****  */
 718:/usr/include/libusb-1.0/libusb.h **** struct libusb_bos_dev_capability_descriptor {
 719:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 720:/usr/include/libusb-1.0/libusb.h **** 	uint8_t bLength;
 721:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 722:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_DEVICE_CAPABILITY
 723:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_DT_DEVICE_CAPABILITY in this context. */
 724:/usr/include/libusb-1.0/libusb.h **** 	uint8_t bDescriptorType;
 725:/usr/include/libusb-1.0/libusb.h **** 	/** Device Capability type */
 726:/usr/include/libusb-1.0/libusb.h **** 	uint8_t bDevCapabilityType;
 727:/usr/include/libusb-1.0/libusb.h **** 	/** Device Capability data (bLength - 3 bytes) */
 728:/usr/include/libusb-1.0/libusb.h **** 	uint8_t dev_capability_data
 729:/usr/include/libusb-1.0/libusb.h **** #if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
 730:/usr/include/libusb-1.0/libusb.h **** 	[] /* valid C99 code */
 731:/usr/include/libusb-1.0/libusb.h **** #else
 732:/usr/include/libusb-1.0/libusb.h **** 	[0] /* non-standard, but usually working code */
 733:/usr/include/libusb-1.0/libusb.h **** #endif
 734:/usr/include/libusb-1.0/libusb.h **** 	;
 735:/usr/include/libusb-1.0/libusb.h **** };
 736:/usr/include/libusb-1.0/libusb.h **** 
 737:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 738:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the Binary Device Object Store (BOS) descriptor.
 739:/usr/include/libusb-1.0/libusb.h ****  * This descriptor is documented in section 9.6.2 of the USB 3.0 specification.
 740:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields are represented in host-endian format.
 741:/usr/include/libusb-1.0/libusb.h ****  */
 742:/usr/include/libusb-1.0/libusb.h **** struct libusb_bos_descriptor {
 743:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 744:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 745:/usr/include/libusb-1.0/libusb.h **** 
 746:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 747:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_BOS LIBUSB_DT_BOS
 748:/usr/include/libusb-1.0/libusb.h **** 	 * in this context. */
 749:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 750:/usr/include/libusb-1.0/libusb.h **** 
 751:/usr/include/libusb-1.0/libusb.h **** 	/** Length of this descriptor and all of its sub descriptors */
 752:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wTotalLength;
 753:/usr/include/libusb-1.0/libusb.h **** 
 754:/usr/include/libusb-1.0/libusb.h **** 	/** The number of separate device capability descriptors in
 755:/usr/include/libusb-1.0/libusb.h **** 	 * the BOS */
 756:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bNumDeviceCaps;
 757:/usr/include/libusb-1.0/libusb.h **** 
 758:/usr/include/libusb-1.0/libusb.h **** 	/** bNumDeviceCap Device Capability Descriptors */
 759:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_bos_dev_capability_descriptor *dev_capability
 760:/usr/include/libusb-1.0/libusb.h **** #if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
 761:/usr/include/libusb-1.0/libusb.h **** 	[] /* valid C99 code */
 762:/usr/include/libusb-1.0/libusb.h **** #else
 763:/usr/include/libusb-1.0/libusb.h **** 	[0] /* non-standard, but usually working code */
 764:/usr/include/libusb-1.0/libusb.h **** #endif
 765:/usr/include/libusb-1.0/libusb.h **** 	;
 766:/usr/include/libusb-1.0/libusb.h **** };
 767:/usr/include/libusb-1.0/libusb.h **** 
 768:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 769:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the USB 2.0 Extension descriptor
 770:/usr/include/libusb-1.0/libusb.h ****  * This descriptor is documented in section 9.6.2.1 of the USB 3.0 specification.
 771:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields are represented in host-endian format.
 772:/usr/include/libusb-1.0/libusb.h ****  */
 773:/usr/include/libusb-1.0/libusb.h **** struct libusb_usb_2_0_extension_descriptor {
 774:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 775:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 776:/usr/include/libusb-1.0/libusb.h **** 
 777:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 778:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_DEVICE_CAPABILITY
 779:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_DT_DEVICE_CAPABILITY in this context. */
 780:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 781:/usr/include/libusb-1.0/libusb.h **** 
 782:/usr/include/libusb-1.0/libusb.h **** 	/** Capability type. Will have value
 783:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_capability_type::LIBUSB_BT_USB_2_0_EXTENSION
 784:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_BT_USB_2_0_EXTENSION in this context. */
 785:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDevCapabilityType;
 786:/usr/include/libusb-1.0/libusb.h **** 
 787:/usr/include/libusb-1.0/libusb.h **** 	/** Bitmap encoding of supported device level features.
 788:/usr/include/libusb-1.0/libusb.h **** 	 * A value of one in a bit location indicates a feature is
 789:/usr/include/libusb-1.0/libusb.h **** 	 * supported; a value of zero indicates it is not supported.
 790:/usr/include/libusb-1.0/libusb.h **** 	 * See \ref libusb_usb_2_0_extension_attributes. */
 791:/usr/include/libusb-1.0/libusb.h **** 	uint32_t  bmAttributes;
 792:/usr/include/libusb-1.0/libusb.h **** };
 793:/usr/include/libusb-1.0/libusb.h **** 
 794:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 795:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the SuperSpeed USB Device Capability descriptor
 796:/usr/include/libusb-1.0/libusb.h ****  * This descriptor is documented in section 9.6.2.2 of the USB 3.0 specification.
 797:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields are represented in host-endian format.
 798:/usr/include/libusb-1.0/libusb.h ****  */
 799:/usr/include/libusb-1.0/libusb.h **** struct libusb_ss_usb_device_capability_descriptor {
 800:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 801:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 802:/usr/include/libusb-1.0/libusb.h **** 
 803:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 804:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_DEVICE_CAPABILITY
 805:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_DT_DEVICE_CAPABILITY in this context. */
 806:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 807:/usr/include/libusb-1.0/libusb.h **** 
 808:/usr/include/libusb-1.0/libusb.h **** 	/** Capability type. Will have value
 809:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_capability_type::LIBUSB_BT_SS_USB_DEVICE_CAPABILITY
 810:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_BT_SS_USB_DEVICE_CAPABILITY in this context. */
 811:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDevCapabilityType;
 812:/usr/include/libusb-1.0/libusb.h **** 
 813:/usr/include/libusb-1.0/libusb.h **** 	/** Bitmap encoding of supported device level features.
 814:/usr/include/libusb-1.0/libusb.h **** 	 * A value of one in a bit location indicates a feature is
 815:/usr/include/libusb-1.0/libusb.h **** 	 * supported; a value of zero indicates it is not supported.
 816:/usr/include/libusb-1.0/libusb.h **** 	 * See \ref libusb_ss_usb_device_capability_attributes. */
 817:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bmAttributes;
 818:/usr/include/libusb-1.0/libusb.h **** 
 819:/usr/include/libusb-1.0/libusb.h **** 	/** Bitmap encoding of the speed supported by this device when
 820:/usr/include/libusb-1.0/libusb.h **** 	 * operating in SuperSpeed mode. See \ref libusb_supported_speed. */
 821:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wSpeedSupported;
 822:/usr/include/libusb-1.0/libusb.h **** 
 823:/usr/include/libusb-1.0/libusb.h **** 	/** The lowest speed at which all the functionality supported
 824:/usr/include/libusb-1.0/libusb.h **** 	 * by the device is available to the user. For example if the
 825:/usr/include/libusb-1.0/libusb.h **** 	 * device supports all its functionality when connected at
 826:/usr/include/libusb-1.0/libusb.h **** 	 * full speed and above then it sets this value to 1. */
 827:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bFunctionalitySupport;
 828:/usr/include/libusb-1.0/libusb.h **** 
 829:/usr/include/libusb-1.0/libusb.h **** 	/** U1 Device Exit Latency. */
 830:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bU1DevExitLat;
 831:/usr/include/libusb-1.0/libusb.h **** 
 832:/usr/include/libusb-1.0/libusb.h **** 	/** U2 Device Exit Latency. */
 833:/usr/include/libusb-1.0/libusb.h **** 	uint16_t bU2DevExitLat;
 834:/usr/include/libusb-1.0/libusb.h **** };
 835:/usr/include/libusb-1.0/libusb.h **** 
 836:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 837:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the Container ID descriptor.
 838:/usr/include/libusb-1.0/libusb.h ****  * This descriptor is documented in section 9.6.2.3 of the USB 3.0 specification.
 839:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields, except UUIDs, are represented in host-endian format.
 840:/usr/include/libusb-1.0/libusb.h ****  */
 841:/usr/include/libusb-1.0/libusb.h **** struct libusb_container_id_descriptor {
 842:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 843:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 844:/usr/include/libusb-1.0/libusb.h **** 
 845:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 846:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_DEVICE_CAPABILITY
 847:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_DT_DEVICE_CAPABILITY in this context. */
 848:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 849:/usr/include/libusb-1.0/libusb.h **** 
 850:/usr/include/libusb-1.0/libusb.h **** 	/** Capability type. Will have value
 851:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_capability_type::LIBUSB_BT_CONTAINER_ID
 852:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_BT_CONTAINER_ID in this context. */
 853:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDevCapabilityType;
 854:/usr/include/libusb-1.0/libusb.h **** 
 855:/usr/include/libusb-1.0/libusb.h **** 	/** Reserved field */
 856:/usr/include/libusb-1.0/libusb.h **** 	uint8_t bReserved;
 857:/usr/include/libusb-1.0/libusb.h **** 
 858:/usr/include/libusb-1.0/libusb.h **** 	/** 128 bit UUID */
 859:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  ContainerID[16];
 860:/usr/include/libusb-1.0/libusb.h **** };
 861:/usr/include/libusb-1.0/libusb.h **** 
 862:/usr/include/libusb-1.0/libusb.h **** /** \ingroup asyncio
 863:/usr/include/libusb-1.0/libusb.h ****  * Setup packet for control transfers. */
 864:/usr/include/libusb-1.0/libusb.h **** struct libusb_control_setup {
 865:/usr/include/libusb-1.0/libusb.h **** 	/** Request type. Bits 0:4 determine recipient, see
 866:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_request_recipient. Bits 5:6 determine type, see
 867:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_request_type. Bit 7 determines data transfer direction, see
 868:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_endpoint_direction.
 869:/usr/include/libusb-1.0/libusb.h **** 	 */
 870:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bmRequestType;
 871:/usr/include/libusb-1.0/libusb.h **** 
 872:/usr/include/libusb-1.0/libusb.h **** 	/** Request. If the type bits of bmRequestType are equal to
 873:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_request_type::LIBUSB_REQUEST_TYPE_STANDARD
 874:/usr/include/libusb-1.0/libusb.h **** 	 * "LIBUSB_REQUEST_TYPE_STANDARD" then this field refers to
 875:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_standard_request. For other cases, use of this field is
 876:/usr/include/libusb-1.0/libusb.h **** 	 * application-specific. */
 877:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bRequest;
 878:/usr/include/libusb-1.0/libusb.h **** 
 879:/usr/include/libusb-1.0/libusb.h **** 	/** Value. Varies according to request */
 880:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wValue;
 881:/usr/include/libusb-1.0/libusb.h **** 
 882:/usr/include/libusb-1.0/libusb.h **** 	/** Index. Varies according to request, typically used to pass an index
 883:/usr/include/libusb-1.0/libusb.h **** 	 * or offset */
 884:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wIndex;
 885:/usr/include/libusb-1.0/libusb.h **** 
 886:/usr/include/libusb-1.0/libusb.h **** 	/** Number of bytes to transfer */
 887:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wLength;
 888:/usr/include/libusb-1.0/libusb.h **** };
 889:/usr/include/libusb-1.0/libusb.h **** 
 890:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_CONTROL_SETUP_SIZE (sizeof(struct libusb_control_setup))
 891:/usr/include/libusb-1.0/libusb.h **** 
 892:/usr/include/libusb-1.0/libusb.h **** /* libusbx */
 893:/usr/include/libusb-1.0/libusb.h **** 
 894:/usr/include/libusb-1.0/libusb.h **** struct libusb_context;
 895:/usr/include/libusb-1.0/libusb.h **** struct libusb_device;
 896:/usr/include/libusb-1.0/libusb.h **** struct libusb_device_handle;
 897:/usr/include/libusb-1.0/libusb.h **** struct libusb_hotplug_callback;
 898:/usr/include/libusb-1.0/libusb.h **** 
 899:/usr/include/libusb-1.0/libusb.h **** /** \ingroup lib
 900:/usr/include/libusb-1.0/libusb.h ****  * Structure providing the version of the libusbx runtime
 901:/usr/include/libusb-1.0/libusb.h ****  */
 902:/usr/include/libusb-1.0/libusb.h **** struct libusb_version {
 903:/usr/include/libusb-1.0/libusb.h **** 	/** Library major version. */
 904:/usr/include/libusb-1.0/libusb.h **** 	const uint16_t major;
 905:/usr/include/libusb-1.0/libusb.h **** 
 906:/usr/include/libusb-1.0/libusb.h **** 	/** Library minor version. */
 907:/usr/include/libusb-1.0/libusb.h **** 	const uint16_t minor;
 908:/usr/include/libusb-1.0/libusb.h **** 
 909:/usr/include/libusb-1.0/libusb.h **** 	/** Library micro version. */
 910:/usr/include/libusb-1.0/libusb.h **** 	const uint16_t micro;
 911:/usr/include/libusb-1.0/libusb.h **** 
 912:/usr/include/libusb-1.0/libusb.h **** 	/** Library nano version. */
 913:/usr/include/libusb-1.0/libusb.h **** 	const uint16_t nano;
 914:/usr/include/libusb-1.0/libusb.h **** 
 915:/usr/include/libusb-1.0/libusb.h **** 	/** Library release candidate suffix string, e.g. "-rc4". */
 916:/usr/include/libusb-1.0/libusb.h **** 	const char *rc;
 917:/usr/include/libusb-1.0/libusb.h **** 
 918:/usr/include/libusb-1.0/libusb.h **** 	/** For ABI compatibility only. */
 919:/usr/include/libusb-1.0/libusb.h **** 	const char* describe;
 920:/usr/include/libusb-1.0/libusb.h **** };
 921:/usr/include/libusb-1.0/libusb.h **** 
 922:/usr/include/libusb-1.0/libusb.h **** /** \ingroup lib
 923:/usr/include/libusb-1.0/libusb.h ****  * Structure representing a libusbx session. The concept of individual libusbx
 924:/usr/include/libusb-1.0/libusb.h ****  * sessions allows for your program to use two libraries (or dynamically
 925:/usr/include/libusb-1.0/libusb.h ****  * load two modules) which both independently use libusb. This will prevent
 926:/usr/include/libusb-1.0/libusb.h ****  * interference between the individual libusbx users - for example
 927:/usr/include/libusb-1.0/libusb.h ****  * libusb_set_debug() will not affect the other user of the library, and
 928:/usr/include/libusb-1.0/libusb.h ****  * libusb_exit() will not destroy resources that the other user is still
 929:/usr/include/libusb-1.0/libusb.h ****  * using.
 930:/usr/include/libusb-1.0/libusb.h ****  *
 931:/usr/include/libusb-1.0/libusb.h ****  * Sessions are created by libusb_init() and destroyed through libusb_exit().
 932:/usr/include/libusb-1.0/libusb.h ****  * If your application is guaranteed to only ever include a single libusbx
 933:/usr/include/libusb-1.0/libusb.h ****  * user (i.e. you), you do not have to worry about contexts: pass NULL in
 934:/usr/include/libusb-1.0/libusb.h ****  * every function call where a context is required. The default context
 935:/usr/include/libusb-1.0/libusb.h ****  * will be used.
 936:/usr/include/libusb-1.0/libusb.h ****  *
 937:/usr/include/libusb-1.0/libusb.h ****  * For more information, see \ref contexts.
 938:/usr/include/libusb-1.0/libusb.h ****  */
 939:/usr/include/libusb-1.0/libusb.h **** typedef struct libusb_context libusb_context;
 940:/usr/include/libusb-1.0/libusb.h **** 
 941:/usr/include/libusb-1.0/libusb.h **** /** \ingroup dev
 942:/usr/include/libusb-1.0/libusb.h ****  * Structure representing a USB device detected on the system. This is an
 943:/usr/include/libusb-1.0/libusb.h ****  * opaque type for which you are only ever provided with a pointer, usually
 944:/usr/include/libusb-1.0/libusb.h ****  * originating from libusb_get_device_list().
 945:/usr/include/libusb-1.0/libusb.h ****  *
 946:/usr/include/libusb-1.0/libusb.h ****  * Certain operations can be performed on a device, but in order to do any
 947:/usr/include/libusb-1.0/libusb.h ****  * I/O you will have to first obtain a device handle using libusb_open().
 948:/usr/include/libusb-1.0/libusb.h ****  *
 949:/usr/include/libusb-1.0/libusb.h ****  * Devices are reference counted with libusb_ref_device() and
 950:/usr/include/libusb-1.0/libusb.h ****  * libusb_unref_device(), and are freed when the reference count reaches 0.
 951:/usr/include/libusb-1.0/libusb.h ****  * New devices presented by libusb_get_device_list() have a reference count of
 952:/usr/include/libusb-1.0/libusb.h ****  * 1, and libusb_free_device_list() can optionally decrease the reference count
 953:/usr/include/libusb-1.0/libusb.h ****  * on all devices in the list. libusb_open() adds another reference which is
 954:/usr/include/libusb-1.0/libusb.h ****  * later destroyed by libusb_close().
 955:/usr/include/libusb-1.0/libusb.h ****  */
 956:/usr/include/libusb-1.0/libusb.h **** typedef struct libusb_device libusb_device;
 957:/usr/include/libusb-1.0/libusb.h **** 
 958:/usr/include/libusb-1.0/libusb.h **** 
 959:/usr/include/libusb-1.0/libusb.h **** /** \ingroup dev
 960:/usr/include/libusb-1.0/libusb.h ****  * Structure representing a handle on a USB device. This is an opaque type for
 961:/usr/include/libusb-1.0/libusb.h ****  * which you are only ever provided with a pointer, usually originating from
 962:/usr/include/libusb-1.0/libusb.h ****  * libusb_open().
 963:/usr/include/libusb-1.0/libusb.h ****  *
 964:/usr/include/libusb-1.0/libusb.h ****  * A device handle is used to perform I/O and other operations. When finished
 965:/usr/include/libusb-1.0/libusb.h ****  * with a device handle, you should call libusb_close().
 966:/usr/include/libusb-1.0/libusb.h ****  */
 967:/usr/include/libusb-1.0/libusb.h **** typedef struct libusb_device_handle libusb_device_handle;
 968:/usr/include/libusb-1.0/libusb.h **** 
 969:/usr/include/libusb-1.0/libusb.h **** /** \ingroup dev
 970:/usr/include/libusb-1.0/libusb.h ****  * Speed codes. Indicates the speed at which the device is operating.
 971:/usr/include/libusb-1.0/libusb.h ****  */
 972:/usr/include/libusb-1.0/libusb.h **** enum libusb_speed {
 973:/usr/include/libusb-1.0/libusb.h **** 	/** The OS doesn't report or know the device speed. */
 974:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SPEED_UNKNOWN = 0,
 975:/usr/include/libusb-1.0/libusb.h **** 
 976:/usr/include/libusb-1.0/libusb.h **** 	/** The device is operating at low speed (1.5MBit/s). */
 977:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SPEED_LOW = 1,
 978:/usr/include/libusb-1.0/libusb.h **** 
 979:/usr/include/libusb-1.0/libusb.h **** 	/** The device is operating at full speed (12MBit/s). */
 980:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SPEED_FULL = 2,
 981:/usr/include/libusb-1.0/libusb.h **** 
 982:/usr/include/libusb-1.0/libusb.h **** 	/** The device is operating at high speed (480MBit/s). */
 983:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SPEED_HIGH = 3,
 984:/usr/include/libusb-1.0/libusb.h **** 
 985:/usr/include/libusb-1.0/libusb.h **** 	/** The device is operating at super speed (5000MBit/s). */
 986:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SPEED_SUPER = 4,
 987:/usr/include/libusb-1.0/libusb.h **** };
 988:/usr/include/libusb-1.0/libusb.h **** 
 989:/usr/include/libusb-1.0/libusb.h **** /** \ingroup dev
 990:/usr/include/libusb-1.0/libusb.h ****  * Supported speeds (wSpeedSupported) bitfield. Indicates what
 991:/usr/include/libusb-1.0/libusb.h ****  * speeds the device supports.
 992:/usr/include/libusb-1.0/libusb.h ****  */
 993:/usr/include/libusb-1.0/libusb.h **** enum libusb_supported_speed {
 994:/usr/include/libusb-1.0/libusb.h **** 	/** Low speed operation supported (1.5MBit/s). */
 995:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_LOW_SPEED_OPERATION   = 1,
 996:/usr/include/libusb-1.0/libusb.h **** 
 997:/usr/include/libusb-1.0/libusb.h **** 	/** Full speed operation supported (12MBit/s). */
 998:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_FULL_SPEED_OPERATION  = 2,
 999:/usr/include/libusb-1.0/libusb.h **** 
1000:/usr/include/libusb-1.0/libusb.h **** 	/** High speed operation supported (480MBit/s). */
1001:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_HIGH_SPEED_OPERATION  = 4,
1002:/usr/include/libusb-1.0/libusb.h **** 
1003:/usr/include/libusb-1.0/libusb.h **** 	/** Superspeed operation supported (5000MBit/s). */
1004:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SUPER_SPEED_OPERATION = 8,
1005:/usr/include/libusb-1.0/libusb.h **** };
1006:/usr/include/libusb-1.0/libusb.h **** 
1007:/usr/include/libusb-1.0/libusb.h **** /** \ingroup dev
1008:/usr/include/libusb-1.0/libusb.h ****  * Masks for the bits of the
1009:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_usb_2_0_extension_descriptor::bmAttributes "bmAttributes" field
1010:/usr/include/libusb-1.0/libusb.h ****  * of the USB 2.0 Extension descriptor.
1011:/usr/include/libusb-1.0/libusb.h ****  */
1012:/usr/include/libusb-1.0/libusb.h **** enum libusb_usb_2_0_extension_attributes {
1013:/usr/include/libusb-1.0/libusb.h **** 	/** Supports Link Power Management (LPM) */
1014:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_BM_LPM_SUPPORT = 2,
1015:/usr/include/libusb-1.0/libusb.h **** };
1016:/usr/include/libusb-1.0/libusb.h **** 
1017:/usr/include/libusb-1.0/libusb.h **** /** \ingroup dev
1018:/usr/include/libusb-1.0/libusb.h ****  * Masks for the bits of the
1019:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_ss_usb_device_capability_descriptor::bmAttributes "bmAttributes" field
1020:/usr/include/libusb-1.0/libusb.h ****  * field of the SuperSpeed USB Device Capability descriptor.
1021:/usr/include/libusb-1.0/libusb.h ****  */
1022:/usr/include/libusb-1.0/libusb.h **** enum libusb_ss_usb_device_capability_attributes {
1023:/usr/include/libusb-1.0/libusb.h **** 	/** Supports Latency Tolerance Messages (LTM) */
1024:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_BM_LTM_SUPPORT = 2,
1025:/usr/include/libusb-1.0/libusb.h **** };
1026:/usr/include/libusb-1.0/libusb.h **** 
1027:/usr/include/libusb-1.0/libusb.h **** /** \ingroup dev
1028:/usr/include/libusb-1.0/libusb.h ****  * USB capability types
1029:/usr/include/libusb-1.0/libusb.h ****  */
1030:/usr/include/libusb-1.0/libusb.h **** enum libusb_bos_type {
1031:/usr/include/libusb-1.0/libusb.h **** 	/** Wireless USB device capability */
1032:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_BT_WIRELESS_USB_DEVICE_CAPABILITY	= 1,
1033:/usr/include/libusb-1.0/libusb.h **** 
1034:/usr/include/libusb-1.0/libusb.h **** 	/** USB 2.0 extensions */
1035:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_BT_USB_2_0_EXTENSION			= 2,
1036:/usr/include/libusb-1.0/libusb.h **** 
1037:/usr/include/libusb-1.0/libusb.h **** 	/** SuperSpeed USB device capability */
1038:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_BT_SS_USB_DEVICE_CAPABILITY		= 3,
1039:/usr/include/libusb-1.0/libusb.h **** 
1040:/usr/include/libusb-1.0/libusb.h **** 	/** Container ID type */
1041:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_BT_CONTAINER_ID				= 4,
1042:/usr/include/libusb-1.0/libusb.h **** };
1043:/usr/include/libusb-1.0/libusb.h **** 
1044:/usr/include/libusb-1.0/libusb.h **** /** \ingroup misc
1045:/usr/include/libusb-1.0/libusb.h ****  * Error codes. Most libusbx functions return 0 on success or one of these
1046:/usr/include/libusb-1.0/libusb.h ****  * codes on failure.
1047:/usr/include/libusb-1.0/libusb.h ****  * You can call libusb_error_name() to retrieve a string representation of an
1048:/usr/include/libusb-1.0/libusb.h ****  * error code or libusb_strerror() to get an end-user suitable description of
1049:/usr/include/libusb-1.0/libusb.h ****  * an error code.
1050:/usr/include/libusb-1.0/libusb.h ****  */
1051:/usr/include/libusb-1.0/libusb.h **** enum libusb_error {
1052:/usr/include/libusb-1.0/libusb.h **** 	/** Success (no error) */
1053:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SUCCESS = 0,
1054:/usr/include/libusb-1.0/libusb.h **** 
1055:/usr/include/libusb-1.0/libusb.h **** 	/** Input/output error */
1056:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_IO = -1,
1057:/usr/include/libusb-1.0/libusb.h **** 
1058:/usr/include/libusb-1.0/libusb.h **** 	/** Invalid parameter */
1059:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_INVALID_PARAM = -2,
1060:/usr/include/libusb-1.0/libusb.h **** 
1061:/usr/include/libusb-1.0/libusb.h **** 	/** Access denied (insufficient permissions) */
1062:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_ACCESS = -3,
1063:/usr/include/libusb-1.0/libusb.h **** 
1064:/usr/include/libusb-1.0/libusb.h **** 	/** No such device (it may have been disconnected) */
1065:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_NO_DEVICE = -4,
1066:/usr/include/libusb-1.0/libusb.h **** 
1067:/usr/include/libusb-1.0/libusb.h **** 	/** Entity not found */
1068:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_NOT_FOUND = -5,
1069:/usr/include/libusb-1.0/libusb.h **** 
1070:/usr/include/libusb-1.0/libusb.h **** 	/** Resource busy */
1071:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_BUSY = -6,
1072:/usr/include/libusb-1.0/libusb.h **** 
1073:/usr/include/libusb-1.0/libusb.h **** 	/** Operation timed out */
1074:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_TIMEOUT = -7,
1075:/usr/include/libusb-1.0/libusb.h **** 
1076:/usr/include/libusb-1.0/libusb.h **** 	/** Overflow */
1077:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_OVERFLOW = -8,
1078:/usr/include/libusb-1.0/libusb.h **** 
1079:/usr/include/libusb-1.0/libusb.h **** 	/** Pipe error */
1080:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_PIPE = -9,
1081:/usr/include/libusb-1.0/libusb.h **** 
1082:/usr/include/libusb-1.0/libusb.h **** 	/** System call interrupted (perhaps due to signal) */
1083:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_INTERRUPTED = -10,
1084:/usr/include/libusb-1.0/libusb.h **** 
1085:/usr/include/libusb-1.0/libusb.h **** 	/** Insufficient memory */
1086:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_NO_MEM = -11,
1087:/usr/include/libusb-1.0/libusb.h **** 
1088:/usr/include/libusb-1.0/libusb.h **** 	/** Operation not supported or unimplemented on this platform */
1089:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_NOT_SUPPORTED = -12,
1090:/usr/include/libusb-1.0/libusb.h **** 
1091:/usr/include/libusb-1.0/libusb.h **** 	/* NB: Remember to update LIBUSB_ERROR_COUNT below as well as the
1092:/usr/include/libusb-1.0/libusb.h **** 	   message strings in strerror.c when adding new error codes here. */
1093:/usr/include/libusb-1.0/libusb.h **** 
1094:/usr/include/libusb-1.0/libusb.h **** 	/** Other error */
1095:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_OTHER = -99,
1096:/usr/include/libusb-1.0/libusb.h **** };
1097:/usr/include/libusb-1.0/libusb.h **** 
1098:/usr/include/libusb-1.0/libusb.h **** /* Total number of error codes in enum libusb_error */
1099:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_ERROR_COUNT 14
1100:/usr/include/libusb-1.0/libusb.h **** 
1101:/usr/include/libusb-1.0/libusb.h **** /** \ingroup asyncio
1102:/usr/include/libusb-1.0/libusb.h ****  * Transfer status codes */
1103:/usr/include/libusb-1.0/libusb.h **** enum libusb_transfer_status {
1104:/usr/include/libusb-1.0/libusb.h **** 	/** Transfer completed without error. Note that this does not indicate
1105:/usr/include/libusb-1.0/libusb.h **** 	 * that the entire amount of requested data was transferred. */
1106:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_COMPLETED,
1107:/usr/include/libusb-1.0/libusb.h **** 
1108:/usr/include/libusb-1.0/libusb.h **** 	/** Transfer failed */
1109:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_ERROR,
1110:/usr/include/libusb-1.0/libusb.h **** 
1111:/usr/include/libusb-1.0/libusb.h **** 	/** Transfer timed out */
1112:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_TIMED_OUT,
1113:/usr/include/libusb-1.0/libusb.h **** 
1114:/usr/include/libusb-1.0/libusb.h **** 	/** Transfer was cancelled */
1115:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_CANCELLED,
1116:/usr/include/libusb-1.0/libusb.h **** 
1117:/usr/include/libusb-1.0/libusb.h **** 	/** For bulk/interrupt endpoints: halt condition detected (endpoint
1118:/usr/include/libusb-1.0/libusb.h **** 	 * stalled). For control endpoints: control request not supported. */
1119:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_STALL,
1120:/usr/include/libusb-1.0/libusb.h **** 
1121:/usr/include/libusb-1.0/libusb.h **** 	/** Device was disconnected */
1122:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_NO_DEVICE,
1123:/usr/include/libusb-1.0/libusb.h **** 
1124:/usr/include/libusb-1.0/libusb.h **** 	/** Device sent more data than requested */
1125:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_OVERFLOW,
1126:/usr/include/libusb-1.0/libusb.h **** 
1127:/usr/include/libusb-1.0/libusb.h **** 	/* NB! Remember to update libusb_error_name()
1128:/usr/include/libusb-1.0/libusb.h **** 	   when adding new status codes here. */
1129:/usr/include/libusb-1.0/libusb.h **** };
1130:/usr/include/libusb-1.0/libusb.h **** 
1131:/usr/include/libusb-1.0/libusb.h **** /** \ingroup asyncio
1132:/usr/include/libusb-1.0/libusb.h ****  * libusb_transfer.flags values */
1133:/usr/include/libusb-1.0/libusb.h **** enum libusb_transfer_flags {
1134:/usr/include/libusb-1.0/libusb.h **** 	/** Report short frames as errors */
1135:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_SHORT_NOT_OK = 1<<0,
1136:/usr/include/libusb-1.0/libusb.h **** 
1137:/usr/include/libusb-1.0/libusb.h **** 	/** Automatically free() transfer buffer during libusb_free_transfer() */
1138:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_FREE_BUFFER = 1<<1,
1139:/usr/include/libusb-1.0/libusb.h **** 
1140:/usr/include/libusb-1.0/libusb.h **** 	/** Automatically call libusb_free_transfer() after callback returns.
1141:/usr/include/libusb-1.0/libusb.h **** 	 * If this flag is set, it is illegal to call libusb_free_transfer()
1142:/usr/include/libusb-1.0/libusb.h **** 	 * from your transfer callback, as this will result in a double-free
1143:/usr/include/libusb-1.0/libusb.h **** 	 * when this flag is acted upon. */
1144:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_FREE_TRANSFER = 1<<2,
1145:/usr/include/libusb-1.0/libusb.h **** 
1146:/usr/include/libusb-1.0/libusb.h **** 	/** Terminate transfers that are a multiple of the endpoint's
1147:/usr/include/libusb-1.0/libusb.h **** 	 * wMaxPacketSize with an extra zero length packet. This is useful
1148:/usr/include/libusb-1.0/libusb.h **** 	 * when a device protocol mandates that each logical request is
1149:/usr/include/libusb-1.0/libusb.h **** 	 * terminated by an incomplete packet (i.e. the logical requests are
1150:/usr/include/libusb-1.0/libusb.h **** 	 * not separated by other means).
1151:/usr/include/libusb-1.0/libusb.h **** 	 *
1152:/usr/include/libusb-1.0/libusb.h **** 	 * This flag only affects host-to-device transfers to bulk and interrupt
1153:/usr/include/libusb-1.0/libusb.h **** 	 * endpoints. In other situations, it is ignored.
1154:/usr/include/libusb-1.0/libusb.h **** 	 *
1155:/usr/include/libusb-1.0/libusb.h **** 	 * This flag only affects transfers with a length that is a multiple of
1156:/usr/include/libusb-1.0/libusb.h **** 	 * the endpoint's wMaxPacketSize. On transfers of other lengths, this
1157:/usr/include/libusb-1.0/libusb.h **** 	 * flag has no effect. Therefore, if you are working with a device that
1158:/usr/include/libusb-1.0/libusb.h **** 	 * needs a ZLP whenever the end of the logical request falls on a packet
1159:/usr/include/libusb-1.0/libusb.h **** 	 * boundary, then it is sensible to set this flag on <em>every</em>
1160:/usr/include/libusb-1.0/libusb.h **** 	 * transfer (you do not have to worry about only setting it on transfers
1161:/usr/include/libusb-1.0/libusb.h **** 	 * that end on the boundary).
1162:/usr/include/libusb-1.0/libusb.h **** 	 *
1163:/usr/include/libusb-1.0/libusb.h **** 	 * This flag is currently only supported on Linux.
1164:/usr/include/libusb-1.0/libusb.h **** 	 * On other systems, libusb_submit_transfer() will return
1165:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_ERROR_NOT_SUPPORTED for every transfer where this flag is set.
1166:/usr/include/libusb-1.0/libusb.h **** 	 *
1167:/usr/include/libusb-1.0/libusb.h **** 	 * Available since libusb-1.0.9.
1168:/usr/include/libusb-1.0/libusb.h **** 	 */
1169:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_ADD_ZERO_PACKET = 1 << 3,
1170:/usr/include/libusb-1.0/libusb.h **** };
1171:/usr/include/libusb-1.0/libusb.h **** 
1172:/usr/include/libusb-1.0/libusb.h **** /** \ingroup asyncio
1173:/usr/include/libusb-1.0/libusb.h ****  * Isochronous packet descriptor. */
1174:/usr/include/libusb-1.0/libusb.h **** struct libusb_iso_packet_descriptor {
1175:/usr/include/libusb-1.0/libusb.h **** 	/** Length of data to request in this packet */
1176:/usr/include/libusb-1.0/libusb.h **** 	unsigned int length;
1177:/usr/include/libusb-1.0/libusb.h **** 
1178:/usr/include/libusb-1.0/libusb.h **** 	/** Amount of data that was actually transferred */
1179:/usr/include/libusb-1.0/libusb.h **** 	unsigned int actual_length;
1180:/usr/include/libusb-1.0/libusb.h **** 
1181:/usr/include/libusb-1.0/libusb.h **** 	/** Status code for this packet */
1182:/usr/include/libusb-1.0/libusb.h **** 	enum libusb_transfer_status status;
1183:/usr/include/libusb-1.0/libusb.h **** };
1184:/usr/include/libusb-1.0/libusb.h **** 
1185:/usr/include/libusb-1.0/libusb.h **** struct libusb_transfer;
1186:/usr/include/libusb-1.0/libusb.h **** 
1187:/usr/include/libusb-1.0/libusb.h **** /** \ingroup asyncio
1188:/usr/include/libusb-1.0/libusb.h ****  * Asynchronous transfer callback function type. When submitting asynchronous
1189:/usr/include/libusb-1.0/libusb.h ****  * transfers, you pass a pointer to a callback function of this type via the
1190:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_transfer::callback "callback" member of the libusb_transfer
1191:/usr/include/libusb-1.0/libusb.h ****  * structure. libusbx will call this function later, when the transfer has
1192:/usr/include/libusb-1.0/libusb.h ****  * completed or failed. See \ref asyncio for more information.
1193:/usr/include/libusb-1.0/libusb.h ****  * \param transfer The libusb_transfer struct the callback function is being
1194:/usr/include/libusb-1.0/libusb.h ****  * notified about.
1195:/usr/include/libusb-1.0/libusb.h ****  */
1196:/usr/include/libusb-1.0/libusb.h **** typedef void (LIBUSB_CALL *libusb_transfer_cb_fn)(struct libusb_transfer *transfer);
1197:/usr/include/libusb-1.0/libusb.h **** 
1198:/usr/include/libusb-1.0/libusb.h **** /** \ingroup asyncio
1199:/usr/include/libusb-1.0/libusb.h ****  * The generic USB transfer structure. The user populates this structure and
1200:/usr/include/libusb-1.0/libusb.h ****  * then submits it in order to request a transfer. After the transfer has
1201:/usr/include/libusb-1.0/libusb.h ****  * completed, the library populates the transfer with the results and passes
1202:/usr/include/libusb-1.0/libusb.h ****  * it back to the user.
1203:/usr/include/libusb-1.0/libusb.h ****  */
1204:/usr/include/libusb-1.0/libusb.h **** struct libusb_transfer {
1205:/usr/include/libusb-1.0/libusb.h **** 	/** Handle of the device that this transfer will be submitted to */
1206:/usr/include/libusb-1.0/libusb.h **** 	libusb_device_handle *dev_handle;
1207:/usr/include/libusb-1.0/libusb.h **** 
1208:/usr/include/libusb-1.0/libusb.h **** 	/** A bitwise OR combination of \ref libusb_transfer_flags. */
1209:/usr/include/libusb-1.0/libusb.h **** 	uint8_t flags;
1210:/usr/include/libusb-1.0/libusb.h **** 
1211:/usr/include/libusb-1.0/libusb.h **** 	/** Address of the endpoint where this transfer will be sent. */
1212:/usr/include/libusb-1.0/libusb.h **** 	unsigned char endpoint;
1213:/usr/include/libusb-1.0/libusb.h **** 
1214:/usr/include/libusb-1.0/libusb.h **** 	/** Type of the endpoint from \ref libusb_transfer_type */
1215:/usr/include/libusb-1.0/libusb.h **** 	unsigned char type;
1216:/usr/include/libusb-1.0/libusb.h **** 
1217:/usr/include/libusb-1.0/libusb.h **** 	/** Timeout for this transfer in millseconds. A value of 0 indicates no
1218:/usr/include/libusb-1.0/libusb.h **** 	 * timeout. */
1219:/usr/include/libusb-1.0/libusb.h **** 	unsigned int timeout;
1220:/usr/include/libusb-1.0/libusb.h **** 
1221:/usr/include/libusb-1.0/libusb.h **** 	/** The status of the transfer. Read-only, and only for use within
1222:/usr/include/libusb-1.0/libusb.h **** 	 * transfer callback function.
1223:/usr/include/libusb-1.0/libusb.h **** 	 *
1224:/usr/include/libusb-1.0/libusb.h **** 	 * If this is an isochronous transfer, this field may read COMPLETED even
1225:/usr/include/libusb-1.0/libusb.h **** 	 * if there were errors in the frames. Use the
1226:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_iso_packet_descriptor::status "status" field in each packet
1227:/usr/include/libusb-1.0/libusb.h **** 	 * to determine if errors occurred. */
1228:/usr/include/libusb-1.0/libusb.h **** 	enum libusb_transfer_status status;
1229:/usr/include/libusb-1.0/libusb.h **** 
1230:/usr/include/libusb-1.0/libusb.h **** 	/** Length of the data buffer */
1231:/usr/include/libusb-1.0/libusb.h **** 	int length;
1232:/usr/include/libusb-1.0/libusb.h **** 
1233:/usr/include/libusb-1.0/libusb.h **** 	/** Actual length of data that was transferred. Read-only, and only for
1234:/usr/include/libusb-1.0/libusb.h **** 	 * use within transfer callback function. Not valid for isochronous
1235:/usr/include/libusb-1.0/libusb.h **** 	 * endpoint transfers. */
1236:/usr/include/libusb-1.0/libusb.h **** 	int actual_length;
1237:/usr/include/libusb-1.0/libusb.h **** 
1238:/usr/include/libusb-1.0/libusb.h **** 	/** Callback function. This will be invoked when the transfer completes,
1239:/usr/include/libusb-1.0/libusb.h **** 	 * fails, or is cancelled. */
1240:/usr/include/libusb-1.0/libusb.h **** 	libusb_transfer_cb_fn callback;
1241:/usr/include/libusb-1.0/libusb.h **** 
1242:/usr/include/libusb-1.0/libusb.h **** 	/** User context data to pass to the callback function. */
1243:/usr/include/libusb-1.0/libusb.h **** 	void *user_data;
1244:/usr/include/libusb-1.0/libusb.h **** 
1245:/usr/include/libusb-1.0/libusb.h **** 	/** Data buffer */
1246:/usr/include/libusb-1.0/libusb.h **** 	unsigned char *buffer;
1247:/usr/include/libusb-1.0/libusb.h **** 
1248:/usr/include/libusb-1.0/libusb.h **** 	/** Number of isochronous packets. Only used for I/O with isochronous
1249:/usr/include/libusb-1.0/libusb.h **** 	 * endpoints. */
1250:/usr/include/libusb-1.0/libusb.h **** 	int num_iso_packets;
1251:/usr/include/libusb-1.0/libusb.h **** 
1252:/usr/include/libusb-1.0/libusb.h **** 	/** Isochronous packet descriptors, for isochronous transfers only. */
1253:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_iso_packet_descriptor iso_packet_desc
1254:/usr/include/libusb-1.0/libusb.h **** #if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
1255:/usr/include/libusb-1.0/libusb.h **** 	[] /* valid C99 code */
1256:/usr/include/libusb-1.0/libusb.h **** #else
1257:/usr/include/libusb-1.0/libusb.h **** 	[0] /* non-standard, but usually working code */
1258:/usr/include/libusb-1.0/libusb.h **** #endif
1259:/usr/include/libusb-1.0/libusb.h **** 	;
1260:/usr/include/libusb-1.0/libusb.h **** };
1261:/usr/include/libusb-1.0/libusb.h **** 
1262:/usr/include/libusb-1.0/libusb.h **** /** \ingroup misc
1263:/usr/include/libusb-1.0/libusb.h ****  * Capabilities supported by an instance of libusb on the current running
1264:/usr/include/libusb-1.0/libusb.h ****  * platform. Test if the loaded library supports a given capability by calling
1265:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_has_capability().
1266:/usr/include/libusb-1.0/libusb.h ****  */
1267:/usr/include/libusb-1.0/libusb.h **** enum libusb_capability {
1268:/usr/include/libusb-1.0/libusb.h **** 	/** The libusb_has_capability() API is available. */
1269:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CAP_HAS_CAPABILITY = 0x0000,
1270:/usr/include/libusb-1.0/libusb.h **** 	/** Hotplug support is available on this platform. */
1271:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CAP_HAS_HOTPLUG = 0x0001,
1272:/usr/include/libusb-1.0/libusb.h **** 	/** The library can access HID devices without requiring user intervention.
1273:/usr/include/libusb-1.0/libusb.h **** 	 * Note that before being able to actually access an HID device, you may
1274:/usr/include/libusb-1.0/libusb.h **** 	 * still have to call additional libusbx functions such as
1275:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_detach_kernel_driver(). */
1276:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CAP_HAS_HID_ACCESS = 0x0100,
1277:/usr/include/libusb-1.0/libusb.h **** 	/** The library supports detaching of the default USB driver, using 
1278:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_detach_kernel_driver(), if one is set by the OS kernel */
1279:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CAP_SUPPORTS_DETACH_KERNEL_DRIVER = 0x0101
1280:/usr/include/libusb-1.0/libusb.h **** };
1281:/usr/include/libusb-1.0/libusb.h **** 
1282:/usr/include/libusb-1.0/libusb.h **** /** \ingroup lib
1283:/usr/include/libusb-1.0/libusb.h ****  *  Log message levels.
1284:/usr/include/libusb-1.0/libusb.h ****  *  - LIBUSB_LOG_LEVEL_NONE (0)    : no messages ever printed by the library (default)
1285:/usr/include/libusb-1.0/libusb.h ****  *  - LIBUSB_LOG_LEVEL_ERROR (1)   : error messages are printed to stderr
1286:/usr/include/libusb-1.0/libusb.h ****  *  - LIBUSB_LOG_LEVEL_WARNING (2) : warning and error messages are printed to stderr
1287:/usr/include/libusb-1.0/libusb.h ****  *  - LIBUSB_LOG_LEVEL_INFO (3)    : informational messages are printed to stdout, warning
1288:/usr/include/libusb-1.0/libusb.h ****  *    and error messages are printed to stderr
1289:/usr/include/libusb-1.0/libusb.h ****  *  - LIBUSB_LOG_LEVEL_DEBUG (4)   : debug and informational messages are printed to stdout,
1290:/usr/include/libusb-1.0/libusb.h ****  *    warnings and errors to stderr
1291:/usr/include/libusb-1.0/libusb.h ****  */
1292:/usr/include/libusb-1.0/libusb.h **** enum libusb_log_level {
1293:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_LOG_LEVEL_NONE = 0,
1294:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_LOG_LEVEL_ERROR,
1295:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_LOG_LEVEL_WARNING,
1296:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_LOG_LEVEL_INFO,
1297:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_LOG_LEVEL_DEBUG,
1298:/usr/include/libusb-1.0/libusb.h **** };
1299:/usr/include/libusb-1.0/libusb.h **** 
1300:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_init(libusb_context **ctx);
1301:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_exit(libusb_context *ctx);
1302:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_set_debug(libusb_context *ctx, int level);
1303:/usr/include/libusb-1.0/libusb.h **** const struct libusb_version * LIBUSB_CALL libusb_get_version(void);
1304:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_has_capability(uint32_t capability);
1305:/usr/include/libusb-1.0/libusb.h **** const char * LIBUSB_CALL libusb_error_name(int errcode);
1306:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_setlocale(const char *locale);
1307:/usr/include/libusb-1.0/libusb.h **** const char * LIBUSB_CALL libusb_strerror(enum libusb_error errcode);
1308:/usr/include/libusb-1.0/libusb.h **** 
1309:/usr/include/libusb-1.0/libusb.h **** ssize_t LIBUSB_CALL libusb_get_device_list(libusb_context *ctx,
1310:/usr/include/libusb-1.0/libusb.h **** 	libusb_device ***list);
1311:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_device_list(libusb_device **list,
1312:/usr/include/libusb-1.0/libusb.h **** 	int unref_devices);
1313:/usr/include/libusb-1.0/libusb.h **** libusb_device * LIBUSB_CALL libusb_ref_device(libusb_device *dev);
1314:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_unref_device(libusb_device *dev);
1315:/usr/include/libusb-1.0/libusb.h **** 
1316:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_configuration(libusb_device_handle *dev,
1317:/usr/include/libusb-1.0/libusb.h **** 	int *config);
1318:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_device_descriptor(libusb_device *dev,
1319:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_device_descriptor *desc);
1320:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_active_config_descriptor(libusb_device *dev,
1321:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_config_descriptor **config);
1322:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_config_descriptor(libusb_device *dev,
1323:/usr/include/libusb-1.0/libusb.h **** 	uint8_t config_index, struct libusb_config_descriptor **config);
1324:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_config_descriptor_by_value(libusb_device *dev,
1325:/usr/include/libusb-1.0/libusb.h **** 	uint8_t bConfigurationValue, struct libusb_config_descriptor **config);
1326:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_config_descriptor(
1327:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_config_descriptor *config);
1328:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_ss_endpoint_companion_descriptor(
1329:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_context *ctx,
1330:/usr/include/libusb-1.0/libusb.h **** 	const struct libusb_endpoint_descriptor *endpoint,
1331:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_ss_endpoint_companion_descriptor **ep_comp);
1332:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_ss_endpoint_companion_descriptor(
1333:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_ss_endpoint_companion_descriptor *ep_comp);
1334:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_bos_descriptor(libusb_device_handle *handle,
1335:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_bos_descriptor **bos);
1336:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_bos_descriptor(struct libusb_bos_descriptor *bos);
1337:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_usb_2_0_extension_descriptor(
1338:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_context *ctx,
1339:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_bos_dev_capability_descriptor *dev_cap,
1340:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_usb_2_0_extension_descriptor **usb_2_0_extension);
1341:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_usb_2_0_extension_descriptor(
1342:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_usb_2_0_extension_descriptor *usb_2_0_extension);
1343:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_ss_usb_device_capability_descriptor(
1344:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_context *ctx,
1345:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_bos_dev_capability_descriptor *dev_cap,
1346:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_ss_usb_device_capability_descriptor **ss_usb_device_cap);
1347:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_ss_usb_device_capability_descriptor(
1348:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_ss_usb_device_capability_descriptor *ss_usb_device_cap);
1349:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_container_id_descriptor(struct libusb_context *ctx,
1350:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_bos_dev_capability_descriptor *dev_cap,
1351:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_container_id_descriptor **container_id);
1352:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_container_id_descriptor(
1353:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_container_id_descriptor *container_id);
1354:/usr/include/libusb-1.0/libusb.h **** uint8_t LIBUSB_CALL libusb_get_bus_number(libusb_device *dev);
1355:/usr/include/libusb-1.0/libusb.h **** uint8_t LIBUSB_CALL libusb_get_port_number(libusb_device *dev);
1356:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_port_numbers(libusb_device *dev, uint8_t* port_numbers, int port_numbers
1357:/usr/include/libusb-1.0/libusb.h **** LIBUSB_DEPRECATED_FOR(libusb_get_port_numbers)
1358:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_port_path(libusb_context *ctx, libusb_device *dev, uint8_t* path, uint8_
1359:/usr/include/libusb-1.0/libusb.h **** libusb_device * LIBUSB_CALL libusb_get_parent(libusb_device *dev);
1360:/usr/include/libusb-1.0/libusb.h **** uint8_t LIBUSB_CALL libusb_get_device_address(libusb_device *dev);
1361:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_device_speed(libusb_device *dev);
1362:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_max_packet_size(libusb_device *dev,
1363:/usr/include/libusb-1.0/libusb.h **** 	unsigned char endpoint);
1364:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_max_iso_packet_size(libusb_device *dev,
1365:/usr/include/libusb-1.0/libusb.h **** 	unsigned char endpoint);
1366:/usr/include/libusb-1.0/libusb.h **** 
1367:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_open(libusb_device *dev, libusb_device_handle **handle);
1368:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_close(libusb_device_handle *dev_handle);
1369:/usr/include/libusb-1.0/libusb.h **** libusb_device * LIBUSB_CALL libusb_get_device(libusb_device_handle *dev_handle);
1370:/usr/include/libusb-1.0/libusb.h **** 
1371:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_set_configuration(libusb_device_handle *dev,
1372:/usr/include/libusb-1.0/libusb.h **** 	int configuration);
1373:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_claim_interface(libusb_device_handle *dev,
1374:/usr/include/libusb-1.0/libusb.h **** 	int interface_number);
1375:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_release_interface(libusb_device_handle *dev,
1376:/usr/include/libusb-1.0/libusb.h **** 	int interface_number);
1377:/usr/include/libusb-1.0/libusb.h **** 
1378:/usr/include/libusb-1.0/libusb.h **** libusb_device_handle * LIBUSB_CALL libusb_open_device_with_vid_pid(
1379:/usr/include/libusb-1.0/libusb.h **** 	libusb_context *ctx, uint16_t vendor_id, uint16_t product_id);
1380:/usr/include/libusb-1.0/libusb.h **** 
1381:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_set_interface_alt_setting(libusb_device_handle *dev,
1382:/usr/include/libusb-1.0/libusb.h **** 	int interface_number, int alternate_setting);
1383:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_clear_halt(libusb_device_handle *dev,
1384:/usr/include/libusb-1.0/libusb.h **** 	unsigned char endpoint);
1385:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_reset_device(libusb_device_handle *dev);
1386:/usr/include/libusb-1.0/libusb.h **** 
1387:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_kernel_driver_active(libusb_device_handle *dev,
1388:/usr/include/libusb-1.0/libusb.h **** 	int interface_number);
1389:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_detach_kernel_driver(libusb_device_handle *dev,
1390:/usr/include/libusb-1.0/libusb.h **** 	int interface_number);
1391:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_attach_kernel_driver(libusb_device_handle *dev,
1392:/usr/include/libusb-1.0/libusb.h **** 	int interface_number);
1393:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_set_auto_detach_kernel_driver(
1394:/usr/include/libusb-1.0/libusb.h **** 	libusb_device_handle *dev, int enable);
1395:/usr/include/libusb-1.0/libusb.h **** 
1396:/usr/include/libusb-1.0/libusb.h **** /* async I/O */
1397:/usr/include/libusb-1.0/libusb.h **** 
1398:/usr/include/libusb-1.0/libusb.h **** /** \ingroup asyncio
1399:/usr/include/libusb-1.0/libusb.h ****  * Get the data section of a control transfer. This convenience function is here
1400:/usr/include/libusb-1.0/libusb.h ****  * to remind you that the data does not start until 8 bytes into the actual
1401:/usr/include/libusb-1.0/libusb.h ****  * buffer, as the setup packet comes first.
1402:/usr/include/libusb-1.0/libusb.h ****  *
1403:/usr/include/libusb-1.0/libusb.h ****  * Calling this function only makes sense from a transfer callback function,
1404:/usr/include/libusb-1.0/libusb.h ****  * or situations where you have already allocated a suitably sized buffer at
1405:/usr/include/libusb-1.0/libusb.h ****  * transfer->buffer.
1406:/usr/include/libusb-1.0/libusb.h ****  *
1407:/usr/include/libusb-1.0/libusb.h ****  * \param transfer a transfer
1408:/usr/include/libusb-1.0/libusb.h ****  * \returns pointer to the first byte of the data section
1409:/usr/include/libusb-1.0/libusb.h ****  */
1410:/usr/include/libusb-1.0/libusb.h **** static inline unsigned char *libusb_control_transfer_get_data(
1411:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_transfer *transfer)
1412:/usr/include/libusb-1.0/libusb.h **** {
1413:/usr/include/libusb-1.0/libusb.h **** 	return transfer->buffer + LIBUSB_CONTROL_SETUP_SIZE;
1414:/usr/include/libusb-1.0/libusb.h **** }
1415:/usr/include/libusb-1.0/libusb.h **** 
1416:/usr/include/libusb-1.0/libusb.h **** /** \ingroup asyncio
1417:/usr/include/libusb-1.0/libusb.h ****  * Get the control setup packet of a control transfer. This convenience
1418:/usr/include/libusb-1.0/libusb.h ****  * function is here to remind you that the control setup occupies the first
1419:/usr/include/libusb-1.0/libusb.h ****  * 8 bytes of the transfer data buffer.
1420:/usr/include/libusb-1.0/libusb.h ****  *
1421:/usr/include/libusb-1.0/libusb.h ****  * Calling this function only makes sense from a transfer callback function,
1422:/usr/include/libusb-1.0/libusb.h ****  * or situations where you have already allocated a suitably sized buffer at
1423:/usr/include/libusb-1.0/libusb.h ****  * transfer->buffer.
1424:/usr/include/libusb-1.0/libusb.h ****  *
1425:/usr/include/libusb-1.0/libusb.h ****  * \param transfer a transfer
1426:/usr/include/libusb-1.0/libusb.h ****  * \returns a casted pointer to the start of the transfer data buffer
1427:/usr/include/libusb-1.0/libusb.h ****  */
1428:/usr/include/libusb-1.0/libusb.h **** static inline struct libusb_control_setup *libusb_control_transfer_get_setup(
1429:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_transfer *transfer)
1430:/usr/include/libusb-1.0/libusb.h **** {
1431:/usr/include/libusb-1.0/libusb.h **** 	return (struct libusb_control_setup *)(void *) transfer->buffer;
1432:/usr/include/libusb-1.0/libusb.h **** }
1433:/usr/include/libusb-1.0/libusb.h **** 
1434:/usr/include/libusb-1.0/libusb.h **** /** \ingroup asyncio
1435:/usr/include/libusb-1.0/libusb.h ****  * Helper function to populate the setup packet (first 8 bytes of the data
1436:/usr/include/libusb-1.0/libusb.h ****  * buffer) for a control transfer. The wIndex, wValue and wLength values should
1437:/usr/include/libusb-1.0/libusb.h ****  * be given in host-endian byte order.
1438:/usr/include/libusb-1.0/libusb.h ****  *
1439:/usr/include/libusb-1.0/libusb.h ****  * \param buffer buffer to output the setup packet into
1440:/usr/include/libusb-1.0/libusb.h ****  * This pointer must be aligned to at least 2 bytes boundary.
1441:/usr/include/libusb-1.0/libusb.h ****  * \param bmRequestType see the
1442:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup::bmRequestType "bmRequestType" field of
1443:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup
1444:/usr/include/libusb-1.0/libusb.h ****  * \param bRequest see the
1445:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup::bRequest "bRequest" field of
1446:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup
1447:/usr/include/libusb-1.0/libusb.h ****  * \param wValue see the
1448:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup::wValue "wValue" field of
1449:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup
1450:/usr/include/libusb-1.0/libusb.h ****  * \param wIndex see the
1451:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup::wIndex "wIndex" field of
1452:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup
1453:/usr/include/libusb-1.0/libusb.h ****  * \param wLength see the
1454:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup::wLength "wLength" field of
1455:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup
1456:/usr/include/libusb-1.0/libusb.h ****  */
1457:/usr/include/libusb-1.0/libusb.h **** static inline void libusb_fill_control_setup(unsigned char *buffer,
1458:/usr/include/libusb-1.0/libusb.h **** 	uint8_t bmRequestType, uint8_t bRequest, uint16_t wValue, uint16_t wIndex,
1459:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wLength)
1460:/usr/include/libusb-1.0/libusb.h **** {
1461:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_control_setup *setup = (struct libusb_control_setup *)(void *) buffer;
1462:/usr/include/libusb-1.0/libusb.h **** 	setup->bmRequestType = bmRequestType;
1463:/usr/include/libusb-1.0/libusb.h **** 	setup->bRequest = bRequest;
1464:/usr/include/libusb-1.0/libusb.h **** 	setup->wValue = libusb_cpu_to_le16(wValue);
1465:/usr/include/libusb-1.0/libusb.h **** 	setup->wIndex = libusb_cpu_to_le16(wIndex);
1466:/usr/include/libusb-1.0/libusb.h **** 	setup->wLength = libusb_cpu_to_le16(wLength);
1467:/usr/include/libusb-1.0/libusb.h **** }
1468:/usr/include/libusb-1.0/libusb.h **** 
1469:/usr/include/libusb-1.0/libusb.h **** struct libusb_transfer * LIBUSB_CALL libusb_alloc_transfer(int iso_packets);
1470:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_submit_transfer(struct libusb_transfer *transfer);
1471:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_cancel_transfer(struct libusb_transfer *transfer);
1472:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_transfer(struct libusb_transfer *transfer);
1473:/usr/include/libusb-1.0/libusb.h **** 
1474:/usr/include/libusb-1.0/libusb.h **** /** \ingroup asyncio
1475:/usr/include/libusb-1.0/libusb.h ****  * Helper function to populate the required \ref libusb_transfer fields
1476:/usr/include/libusb-1.0/libusb.h ****  * for a control transfer.
1477:/usr/include/libusb-1.0/libusb.h ****  *
1478:/usr/include/libusb-1.0/libusb.h ****  * If you pass a transfer buffer to this function, the first 8 bytes will
1479:/usr/include/libusb-1.0/libusb.h ****  * be interpreted as a control setup packet, and the wLength field will be
1480:/usr/include/libusb-1.0/libusb.h ****  * used to automatically populate the \ref libusb_transfer::length "length"
1481:/usr/include/libusb-1.0/libusb.h ****  * field of the transfer. Therefore the recommended approach is:
1482:/usr/include/libusb-1.0/libusb.h ****  * -# Allocate a suitably sized data buffer (including space for control setup)
1483:/usr/include/libusb-1.0/libusb.h ****  * -# Call libusb_fill_control_setup()
1484:/usr/include/libusb-1.0/libusb.h ****  * -# If this is a host-to-device transfer with a data stage, put the data
1485:/usr/include/libusb-1.0/libusb.h ****  *    in place after the setup packet
1486:/usr/include/libusb-1.0/libusb.h ****  * -# Call this function
1487:/usr/include/libusb-1.0/libusb.h ****  * -# Call libusb_submit_transfer()
1488:/usr/include/libusb-1.0/libusb.h ****  *
1489:/usr/include/libusb-1.0/libusb.h ****  * It is also legal to pass a NULL buffer to this function, in which case this
1490:/usr/include/libusb-1.0/libusb.h ****  * function will not attempt to populate the length field. Remember that you
1491:/usr/include/libusb-1.0/libusb.h ****  * must then populate the buffer and length fields later.
1492:/usr/include/libusb-1.0/libusb.h ****  *
1493:/usr/include/libusb-1.0/libusb.h ****  * \param transfer the transfer to populate
1494:/usr/include/libusb-1.0/libusb.h ****  * \param dev_handle handle of the device that will handle the transfer
1495:/usr/include/libusb-1.0/libusb.h ****  * \param buffer data buffer. If provided, this function will interpret the
1496:/usr/include/libusb-1.0/libusb.h ****  * first 8 bytes as a setup packet and infer the transfer length from that.
1497:/usr/include/libusb-1.0/libusb.h ****  * This pointer must be aligned to at least 2 bytes boundary.
1498:/usr/include/libusb-1.0/libusb.h ****  * \param callback callback function to be invoked on transfer completion
1499:/usr/include/libusb-1.0/libusb.h ****  * \param user_data user data to pass to callback function
1500:/usr/include/libusb-1.0/libusb.h ****  * \param timeout timeout for the transfer in milliseconds
1501:/usr/include/libusb-1.0/libusb.h ****  */
1502:/usr/include/libusb-1.0/libusb.h **** static inline void libusb_fill_control_transfer(
1503:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_transfer *transfer, libusb_device_handle *dev_handle,
1504:/usr/include/libusb-1.0/libusb.h **** 	unsigned char *buffer, libusb_transfer_cb_fn callback, void *user_data,
1505:/usr/include/libusb-1.0/libusb.h **** 	unsigned int timeout)
1506:/usr/include/libusb-1.0/libusb.h **** {
1507:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_control_setup *setup = (struct libusb_control_setup *)(void *) buffer;
1508:/usr/include/libusb-1.0/libusb.h **** 	transfer->dev_handle = dev_handle;
1509:/usr/include/libusb-1.0/libusb.h **** 	transfer->endpoint = 0;
1510:/usr/include/libusb-1.0/libusb.h **** 	transfer->type = LIBUSB_TRANSFER_TYPE_CONTROL;
1511:/usr/include/libusb-1.0/libusb.h **** 	transfer->timeout = timeout;
1512:/usr/include/libusb-1.0/libusb.h **** 	transfer->buffer = buffer;
1513:/usr/include/libusb-1.0/libusb.h **** 	if (setup)
1514:/usr/include/libusb-1.0/libusb.h **** 		transfer->length = (int) (LIBUSB_CONTROL_SETUP_SIZE
1515:/usr/include/libusb-1.0/libusb.h **** 			+ libusb_le16_to_cpu(setup->wLength));
1516:/usr/include/libusb-1.0/libusb.h **** 	transfer->user_data = user_data;
1517:/usr/include/libusb-1.0/libusb.h **** 	transfer->callback = callback;
1518:/usr/include/libusb-1.0/libusb.h **** }
1519:/usr/include/libusb-1.0/libusb.h **** 
1520:/usr/include/libusb-1.0/libusb.h **** /** \ingroup asyncio
1521:/usr/include/libusb-1.0/libusb.h ****  * Helper function to populate the required \ref libusb_transfer fields
1522:/usr/include/libusb-1.0/libusb.h ****  * for a bulk transfer.
1523:/usr/include/libusb-1.0/libusb.h ****  *
1524:/usr/include/libusb-1.0/libusb.h ****  * \param transfer the transfer to populate
1525:/usr/include/libusb-1.0/libusb.h ****  * \param dev_handle handle of the device that will handle the transfer
1526:/usr/include/libusb-1.0/libusb.h ****  * \param endpoint address of the endpoint where this transfer will be sent
1527:/usr/include/libusb-1.0/libusb.h ****  * \param buffer data buffer
1528:/usr/include/libusb-1.0/libusb.h ****  * \param length length of data buffer
1529:/usr/include/libusb-1.0/libusb.h ****  * \param callback callback function to be invoked on transfer completion
1530:/usr/include/libusb-1.0/libusb.h ****  * \param user_data user data to pass to callback function
1531:/usr/include/libusb-1.0/libusb.h ****  * \param timeout timeout for the transfer in milliseconds
1532:/usr/include/libusb-1.0/libusb.h ****  */
1533:/usr/include/libusb-1.0/libusb.h **** static inline void libusb_fill_bulk_transfer(struct libusb_transfer *transfer,
1534:/usr/include/libusb-1.0/libusb.h **** 	libusb_device_handle *dev_handle, unsigned char endpoint,
1535:/usr/include/libusb-1.0/libusb.h **** 	unsigned char *buffer, int length, libusb_transfer_cb_fn callback,
1536:/usr/include/libusb-1.0/libusb.h **** 	void *user_data, unsigned int timeout)
1537:/usr/include/libusb-1.0/libusb.h **** {
  30              		.loc 2 1537 0
  31              		.cfi_startproc
  32 0012 55       		pushq	%rbp
  33              		.cfi_def_cfa_offset 16
  34              		.cfi_offset 6, -16
  35 0013 4889E5   		movq	%rsp, %rbp
  36              		.cfi_def_cfa_register 6
  37 0016 48897DF8 		movq	%rdi, -8(%rbp)
  38 001a 488975F0 		movq	%rsi, -16(%rbp)
  39 001e 89D0     		movl	%edx, %eax
  40 0020 48894DE0 		movq	%rcx, -32(%rbp)
  41 0024 448945E8 		movl	%r8d, -24(%rbp)
  42 0028 4C894DD8 		movq	%r9, -40(%rbp)
  43 002c 8845EC   		movb	%al, -20(%rbp)
1538:/usr/include/libusb-1.0/libusb.h **** 	transfer->dev_handle = dev_handle;
  44              		.loc 2 1538 0
  45 002f 488B45F8 		movq	-8(%rbp), %rax
  46 0033 488B55F0 		movq	-16(%rbp), %rdx
  47 0037 488910   		movq	%rdx, (%rax)
1539:/usr/include/libusb-1.0/libusb.h **** 	transfer->endpoint = endpoint;
  48              		.loc 2 1539 0
  49 003a 488B45F8 		movq	-8(%rbp), %rax
  50 003e 0FB655EC 		movzbl	-20(%rbp), %edx
  51 0042 885009   		movb	%dl, 9(%rax)
1540:/usr/include/libusb-1.0/libusb.h **** 	transfer->type = LIBUSB_TRANSFER_TYPE_BULK;
  52              		.loc 2 1540 0
  53 0045 488B45F8 		movq	-8(%rbp), %rax
  54 0049 C6400A02 		movb	$2, 10(%rax)
1541:/usr/include/libusb-1.0/libusb.h **** 	transfer->timeout = timeout;
  55              		.loc 2 1541 0
  56 004d 488B45F8 		movq	-8(%rbp), %rax
  57 0051 8B5518   		movl	24(%rbp), %edx
  58 0054 89500C   		movl	%edx, 12(%rax)
1542:/usr/include/libusb-1.0/libusb.h **** 	transfer->buffer = buffer;
  59              		.loc 2 1542 0
  60 0057 488B45F8 		movq	-8(%rbp), %rax
  61 005b 488B55E0 		movq	-32(%rbp), %rdx
  62 005f 48895030 		movq	%rdx, 48(%rax)
1543:/usr/include/libusb-1.0/libusb.h **** 	transfer->length = length;
  63              		.loc 2 1543 0
  64 0063 488B45F8 		movq	-8(%rbp), %rax
  65 0067 8B55E8   		movl	-24(%rbp), %edx
  66 006a 895014   		movl	%edx, 20(%rax)
1544:/usr/include/libusb-1.0/libusb.h **** 	transfer->user_data = user_data;
  67              		.loc 2 1544 0
  68 006d 488B45F8 		movq	-8(%rbp), %rax
  69 0071 488B5510 		movq	16(%rbp), %rdx
  70 0075 48895028 		movq	%rdx, 40(%rax)
1545:/usr/include/libusb-1.0/libusb.h **** 	transfer->callback = callback;
  71              		.loc 2 1545 0
  72 0079 488B45F8 		movq	-8(%rbp), %rax
  73 007d 488B55D8 		movq	-40(%rbp), %rdx
  74 0081 48895020 		movq	%rdx, 32(%rax)
1546:/usr/include/libusb-1.0/libusb.h **** }
  75              		.loc 2 1546 0
  76 0085 5D       		popq	%rbp
  77              		.cfi_def_cfa 7, 8
  78 0086 C3       		ret
  79              		.cfi_endproc
  80              	.LFE12:
  82              		.local	m_ctx
  83              		.comm	m_ctx,8,8
  84              		.section	.rodata
  85              	.LC0:
  86 0000 64657669 		.string	"device not found"
  86      6365206E 
  86      6F742066 
  86      6F756E64 
  86      00
  87              		.text
  89              	libusbOpenWithVidPid:
  90              	.LFB20:
  91              		.file 3 "libusbwrap.c"
   1:libusbwrap.c  **** /*
   2:libusbwrap.c  ****  * Copyright (C) 2009-2012 Chris McClelland
   3:libusbwrap.c  ****  *
   4:libusbwrap.c  ****  * This program is free software: you can redistribute it and/or modify
   5:libusbwrap.c  ****  * it under the terms of the GNU Lesser General Public License as published by
   6:libusbwrap.c  ****  * the Free Software Foundation, either version 3 of the License, or
   7:libusbwrap.c  ****  * (at your option) any later version.
   8:libusbwrap.c  ****  *
   9:libusbwrap.c  ****  * This program is distributed in the hope that it will be useful,
  10:libusbwrap.c  ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:libusbwrap.c  ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:libusbwrap.c  ****  * GNU Lesser General Public License for more details.
  13:libusbwrap.c  ****  *
  14:libusbwrap.c  ****  * You should have received a copy of the GNU Lesser General Public License
  15:libusbwrap.c  ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:libusbwrap.c  ****  */
  17:libusbwrap.c  **** #ifdef WIN32
  18:libusbwrap.c  **** #include <Windows.h>
  19:libusbwrap.c  **** #else
  20:libusbwrap.c  **** #define _BSD_SOURCE
  21:libusbwrap.c  **** #include <unistd.h>
  22:libusbwrap.c  **** #endif
  23:libusbwrap.c  **** #include <stdio.h>
  24:libusbwrap.c  **** #include <stdlib.h>
  25:libusbwrap.c  **** #include <string.h>
  26:libusbwrap.c  **** #include <makestuff.h>
  27:libusbwrap.c  **** #include <liberror.h>
  28:libusbwrap.c  **** #include "private.h"
  29:libusbwrap.c  **** 
  30:libusbwrap.c  **** static struct libusb_context *m_ctx = NULL;
  31:libusbwrap.c  **** 
  32:libusbwrap.c  **** // Modified from libusb_open_device_with_vid_pid in core.c of libusbx
  33:libusbwrap.c  **** //
  34:libusbwrap.c  **** static libusb_device_handle *libusbOpenWithVidPid(
  35:libusbwrap.c  **** 	libusb_context *ctx, uint16 vid, uint16 pid, uint16 did, const char **error)
  36:libusbwrap.c  **** {
  92              		.loc 3 36 0
  93              		.cfi_startproc
  94 0087 55       		pushq	%rbp
  95              		.cfi_def_cfa_offset 16
  96              		.cfi_offset 6, -16
  97 0088 4889E5   		movq	%rsp, %rbp
  98              		.cfi_def_cfa_register 6
  99 008b 4883EC70 		subq	$112, %rsp
 100 008f 48897DA8 		movq	%rdi, -88(%rbp)
 101 0093 89C8     		movl	%ecx, %eax
 102 0095 4C894590 		movq	%r8, -112(%rbp)
 103 0099 668975A4 		movw	%si, -92(%rbp)
 104 009d 668955A0 		movw	%dx, -96(%rbp)
 105 00a1 6689459C 		movw	%ax, -100(%rbp)
  37:libusbwrap.c  **** 	libusb_device_handle *retVal = NULL;
 106              		.loc 3 37 0
 107 00a5 48C745B8 		movq	$0, -72(%rbp)
 107      00000000 
  38:libusbwrap.c  **** 	struct libusb_device **devs;
  39:libusbwrap.c  **** 	struct libusb_device *found = NULL;
 108              		.loc 3 39 0
 109 00ad 48C745C8 		movq	$0, -56(%rbp)
 109      00000000 
  40:libusbwrap.c  **** 	struct libusb_device *dev;
  41:libusbwrap.c  **** 	size_t i = 0;
 110              		.loc 3 41 0
 111 00b5 48C745D8 		movq	$0, -40(%rbp)
 111      00000000 
  42:libusbwrap.c  **** 	int status = (int)libusb_get_device_list(ctx, &devs);
 112              		.loc 3 42 0
 113 00bd 488D55C0 		leaq	-64(%rbp), %rdx
 114 00c1 488B45A8 		movq	-88(%rbp), %rax
 115 00c5 4889D6   		movq	%rdx, %rsi
 116 00c8 4889C7   		movq	%rax, %rdi
 117 00cb E8000000 		call	libusb_get_device_list@PLT
 117      00
 118 00d0 8945B4   		movl	%eax, -76(%rbp)
  43:libusbwrap.c  **** 	CHECK_STATUS(status < 0, NULL, cleanup, libusb_error_name(status));
 119              		.loc 3 43 0
 120 00d3 837DB400 		cmpl	$0, -76(%rbp)
 121 00d7 7929     		jns	.L5
 122              		.loc 3 43 0 is_stmt 0 discriminator 1
 123 00d9 8B45B4   		movl	-76(%rbp), %eax
 124 00dc 89C7     		movl	%eax, %edi
 125 00de E8000000 		call	libusb_error_name@PLT
 125      00
 126 00e3 4889C2   		movq	%rax, %rdx
 127 00e6 488B4590 		movq	-112(%rbp), %rax
 128 00ea 4889D6   		movq	%rdx, %rsi
 129 00ed 4889C7   		movq	%rax, %rdi
 130 00f0 E8000000 		call	errPrefix@PLT
 130      00
 131 00f5 48C745B8 		movq	$0, -72(%rbp)
 131      00000000 
 132 00fd E9210100 		jmp	.L6
 132      00
 133              	.L5:
  44:libusbwrap.c  **** 	dev = devs[i++];
 134              		.loc 3 44 0 is_stmt 1
 135 0102 488B4DC0 		movq	-64(%rbp), %rcx
 136 0106 488B45D8 		movq	-40(%rbp), %rax
 137 010a 488D5001 		leaq	1(%rax), %rdx
 138 010e 488955D8 		movq	%rdx, -40(%rbp)
 139 0112 48C1E003 		salq	$3, %rax
 140 0116 4801C8   		addq	%rcx, %rax
 141 0119 488B00   		movq	(%rax), %rax
 142 011c 488945D0 		movq	%rax, -48(%rbp)
  45:libusbwrap.c  **** 	while ( dev ) {
 143              		.loc 3 45 0
 144 0120 E9920000 		jmp	.L7
 144      00
 145              	.L12:
 146              	.LBB2:
  46:libusbwrap.c  **** 		struct libusb_device_descriptor desc;
  47:libusbwrap.c  **** 		status = libusb_get_device_descriptor(dev, &desc);
 147              		.loc 3 47 0
 148 0125 488D55E0 		leaq	-32(%rbp), %rdx
 149 0129 488B45D0 		movq	-48(%rbp), %rax
 150 012d 4889D6   		movq	%rdx, %rsi
 151 0130 4889C7   		movq	%rax, %rdi
 152 0133 E8000000 		call	libusb_get_device_descriptor@PLT
 152      00
 153 0138 8945B4   		movl	%eax, -76(%rbp)
  48:libusbwrap.c  **** 		CHECK_STATUS(status < 0, NULL, cleanup, libusb_error_name(status));
 154              		.loc 3 48 0
 155 013b 837DB400 		cmpl	$0, -76(%rbp)
 156 013f 7929     		jns	.L8
 157              		.loc 3 48 0 is_stmt 0 discriminator 1
 158 0141 8B45B4   		movl	-76(%rbp), %eax
 159 0144 89C7     		movl	%eax, %edi
 160 0146 E8000000 		call	libusb_error_name@PLT
 160      00
 161 014b 4889C2   		movq	%rax, %rdx
 162 014e 488B4590 		movq	-112(%rbp), %rax
 163 0152 4889D6   		movq	%rdx, %rsi
 164 0155 4889C7   		movq	%rax, %rdi
 165 0158 E8000000 		call	errPrefix@PLT
 165      00
 166 015d 48C745B8 		movq	$0, -72(%rbp)
 166      00000000 
 167 0165 E9B90000 		jmp	.L6
 167      00
 168              	.L8:
  49:libusbwrap.c  **** 		if (
  50:libusbwrap.c  **** 			desc.idVendor == vid &&
 169              		.loc 3 50 0 is_stmt 1
 170 016a 0FB745E8 		movzwl	-24(%rbp), %eax
  49:libusbwrap.c  **** 		if (
 171              		.loc 3 49 0
 172 016e 663B45A4 		cmpw	-92(%rbp), %ax
 173 0172 7525     		jne	.L9
  51:libusbwrap.c  **** 			desc.idProduct == pid &&
 174              		.loc 3 51 0
 175 0174 0FB745EA 		movzwl	-22(%rbp), %eax
  50:libusbwrap.c  **** 			desc.idProduct == pid &&
 176              		.loc 3 50 0
 177 0178 663B45A0 		cmpw	-96(%rbp), %ax
 178 017c 751B     		jne	.L9
 179              		.loc 3 51 0
 180 017e 66837D9C 		cmpw	$0, -100(%rbp)
 180      00
 181 0183 740A     		je	.L10
  52:libusbwrap.c  **** 			(did == 0x0000 || desc.bcdDevice == did)
 182              		.loc 3 52 0
 183 0185 0FB745EC 		movzwl	-20(%rbp), %eax
 184 0189 663B459C 		cmpw	-100(%rbp), %ax
 185 018d 750A     		jne	.L9
 186              	.L10:
  53:libusbwrap.c  **** 		) {
  54:libusbwrap.c  **** 			found = dev;
 187              		.loc 3 54 0
 188 018f 488B45D0 		movq	-48(%rbp), %rax
 189 0193 488945C8 		movq	%rax, -56(%rbp)
 190 0197 EB29     		jmp	.L11
 191              	.L9:
  55:libusbwrap.c  **** 			break;
  56:libusbwrap.c  **** 		}
  57:libusbwrap.c  **** 		dev = devs[i++];
 192              		.loc 3 57 0
 193 0199 488B4DC0 		movq	-64(%rbp), %rcx
 194 019d 488B45D8 		movq	-40(%rbp), %rax
 195 01a1 488D5001 		leaq	1(%rax), %rdx
 196 01a5 488955D8 		movq	%rdx, -40(%rbp)
 197 01a9 48C1E003 		salq	$3, %rax
 198 01ad 4801C8   		addq	%rcx, %rax
 199 01b0 488B00   		movq	(%rax), %rax
 200 01b3 488945D0 		movq	%rax, -48(%rbp)
 201              	.L7:
 202              	.LBE2:
  45:libusbwrap.c  **** 		struct libusb_device_descriptor desc;
 203              		.loc 3 45 0 discriminator 1
 204 01b7 48837DD0 		cmpq	$0, -48(%rbp)
 204      00
 205 01bc 0F8563FF 		jne	.L12
 205      FFFF
 206              	.L11:
  58:libusbwrap.c  **** 	}
  59:libusbwrap.c  **** 
  60:libusbwrap.c  **** 	if ( found ) {
 207              		.loc 3 60 0
 208 01c2 48837DC8 		cmpq	$0, -56(%rbp)
 208      00
 209 01c7 7442     		je	.L13
  61:libusbwrap.c  **** 		status = libusb_open(found, &retVal);
 210              		.loc 3 61 0
 211 01c9 488D55B8 		leaq	-72(%rbp), %rdx
 212 01cd 488B45C8 		movq	-56(%rbp), %rax
 213 01d1 4889D6   		movq	%rdx, %rsi
 214 01d4 4889C7   		movq	%rax, %rdi
 215 01d7 E8000000 		call	libusb_open@PLT
 215      00
 216 01dc 8945B4   		movl	%eax, -76(%rbp)
  62:libusbwrap.c  **** 		CHECK_STATUS(status < 0, NULL, cleanup, libusb_error_name(status));
 217              		.loc 3 62 0
 218 01df 837DB400 		cmpl	$0, -76(%rbp)
 219 01e3 793E     		jns	.L6
 220              		.loc 3 62 0 is_stmt 0 discriminator 1
 221 01e5 8B45B4   		movl	-76(%rbp), %eax
 222 01e8 89C7     		movl	%eax, %edi
 223 01ea E8000000 		call	libusb_error_name@PLT
 223      00
 224 01ef 4889C2   		movq	%rax, %rdx
 225 01f2 488B4590 		movq	-112(%rbp), %rax
 226 01f6 4889D6   		movq	%rdx, %rsi
 227 01f9 4889C7   		movq	%rax, %rdi
 228 01fc E8000000 		call	errPrefix@PLT
 228      00
 229 0201 48C745B8 		movq	$0, -72(%rbp)
 229      00000000 
 230 0209 EB18     		jmp	.L6
 231              	.L13:
  63:libusbwrap.c  **** 	} else {
  64:libusbwrap.c  **** 		errRender(error, "device not found");
 232              		.loc 3 64 0 is_stmt 1
 233 020b 488B4590 		movq	-112(%rbp), %rax
 234 020f 488D3500 		leaq	.LC0(%rip), %rsi
 234      000000
 235 0216 4889C7   		movq	%rax, %rdi
 236 0219 B8000000 		movl	$0, %eax
 236      00
 237 021e E8000000 		call	errRender@PLT
 237      00
 238              	.L6:
  65:libusbwrap.c  **** 	}
  66:libusbwrap.c  **** 
  67:libusbwrap.c  **** cleanup:
  68:libusbwrap.c  **** 	libusb_free_device_list(devs, 1);
 239              		.loc 3 68 0
 240 0223 488B45C0 		movq	-64(%rbp), %rax
 241 0227 BE010000 		movl	$1, %esi
 241      00
 242 022c 4889C7   		movq	%rax, %rdi
 243 022f E8000000 		call	libusb_free_device_list@PLT
 243      00
  69:libusbwrap.c  **** 	return retVal;
 244              		.loc 3 69 0
 245 0234 488B45B8 		movq	-72(%rbp), %rax
  70:libusbwrap.c  **** }
 246              		.loc 3 70 0
 247 0238 C9       		leave
 248              		.cfi_def_cfa 7, 8
 249 0239 C3       		ret
 250              		.cfi_endproc
 251              	.LFE20:
 253              		.globl	usbValidateVidPid
 255              	usbValidateVidPid:
 256              	.LFB21:
  71:libusbwrap.c  **** 
  72:libusbwrap.c  **** // Return true if vp is VVVV:PPPP where V and P are hex digits:
  73:libusbwrap.c  **** //
  74:libusbwrap.c  **** DLLEXPORT(bool) usbValidateVidPid(const char *vp) {
 257              		.loc 3 74 0
 258              		.cfi_startproc
 259 023a 55       		pushq	%rbp
 260              		.cfi_def_cfa_offset 16
 261              		.cfi_offset 6, -16
 262 023b 4889E5   		movq	%rsp, %rbp
 263              		.cfi_def_cfa_register 6
 264 023e 4883EC20 		subq	$32, %rsp
 265 0242 48897DE8 		movq	%rdi, -24(%rbp)
  75:libusbwrap.c  **** 	int i;
  76:libusbwrap.c  **** 	char ch;
  77:libusbwrap.c  **** 	const size_t len = strlen(vp);
 266              		.loc 3 77 0
 267 0246 488B45E8 		movq	-24(%rbp), %rax
 268 024a 4889C7   		movq	%rax, %rdi
 269 024d E8000000 		call	strlen@PLT
 269      00
 270 0252 488945F8 		movq	%rax, -8(%rbp)
  78:libusbwrap.c  **** 	bool hasDID;
  79:libusbwrap.c  **** 	if ( !vp ) {
 271              		.loc 3 79 0
 272 0256 48837DE8 		cmpq	$0, -24(%rbp)
 272      00
 273 025b 750A     		jne	.L16
  80:libusbwrap.c  **** 		return false;
 274              		.loc 3 80 0
 275 025d B8000000 		movl	$0, %eax
 275      00
 276 0262 E9530100 		jmp	.L17
 276      00
 277              	.L16:
  81:libusbwrap.c  **** 	}
  82:libusbwrap.c  **** 	if ( len == 9 ) {
 278              		.loc 3 82 0
 279 0267 48837DF8 		cmpq	$9, -8(%rbp)
 279      09
 280 026c 7506     		jne	.L18
  83:libusbwrap.c  **** 		hasDID = false;
 281              		.loc 3 83 0
 282 026e C645F200 		movb	$0, -14(%rbp)
 283 0272 EB17     		jmp	.L19
 284              	.L18:
  84:libusbwrap.c  **** 	} else if ( len == 14 ) {
 285              		.loc 3 84 0
 286 0274 48837DF8 		cmpq	$14, -8(%rbp)
 286      0E
 287 0279 7506     		jne	.L20
  85:libusbwrap.c  **** 		hasDID = true;
 288              		.loc 3 85 0
 289 027b C645F201 		movb	$1, -14(%rbp)
 290 027f EB0A     		jmp	.L19
 291              	.L20:
  86:libusbwrap.c  **** 	} else {
  87:libusbwrap.c  **** 		return false;
 292              		.loc 3 87 0
 293 0281 B8000000 		movl	$0, %eax
 293      00
 294 0286 E92F0100 		jmp	.L17
 294      00
 295              	.L19:
  88:libusbwrap.c  **** 	}
  89:libusbwrap.c  **** 	if ( vp[4] != ':' || (hasDID && vp[9] != ':') ) {
 296              		.loc 3 89 0
 297 028b 488B45E8 		movq	-24(%rbp), %rax
 298 028f 4883C004 		addq	$4, %rax
 299 0293 0FB600   		movzbl	(%rax), %eax
 300 0296 3C3A     		cmpb	$58, %al
 301 0298 7515     		jne	.L21
 302              		.loc 3 89 0 is_stmt 0 discriminator 1
 303 029a 807DF200 		cmpb	$0, -14(%rbp)
 304 029e 7419     		je	.L22
 305 02a0 488B45E8 		movq	-24(%rbp), %rax
 306 02a4 4883C009 		addq	$9, %rax
 307 02a8 0FB600   		movzbl	(%rax), %eax
 308 02ab 3C3A     		cmpb	$58, %al
 309 02ad 740A     		je	.L22
 310              	.L21:
  90:libusbwrap.c  **** 		return false;
 311              		.loc 3 90 0 is_stmt 1
 312 02af B8000000 		movl	$0, %eax
 312      00
 313 02b4 E9010100 		jmp	.L17
 313      00
 314              	.L22:
  91:libusbwrap.c  **** 	}
  92:libusbwrap.c  **** 	for ( i = 0; i < 4; i++ ) {
 315              		.loc 3 92 0
 316 02b9 C745F400 		movl	$0, -12(%rbp)
 316      000000
 317 02c0 EB45     		jmp	.L23
 318              	.L28:
  93:libusbwrap.c  **** 		ch = vp[i];
 319              		.loc 3 93 0
 320 02c2 8B45F4   		movl	-12(%rbp), %eax
 321 02c5 4863D0   		movslq	%eax, %rdx
 322 02c8 488B45E8 		movq	-24(%rbp), %rax
 323 02cc 4801D0   		addq	%rdx, %rax
 324 02cf 0FB600   		movzbl	(%rax), %eax
 325 02d2 8845F3   		movb	%al, -13(%rbp)
  94:libusbwrap.c  **** 		if (
 326              		.loc 3 94 0
 327 02d5 807DF32F 		cmpb	$47, -13(%rbp)
 328 02d9 7E1E     		jle	.L24
  95:libusbwrap.c  **** 			ch < '0' ||
 329              		.loc 3 95 0
 330 02db 807DF339 		cmpb	$57, -13(%rbp)
 331 02df 7E06     		jle	.L25
  96:libusbwrap.c  **** 			(ch > '9' && ch < 'A') ||
 332              		.loc 3 96 0
 333 02e1 807DF340 		cmpb	$64, -13(%rbp)
 334 02e5 7E12     		jle	.L24
 335              	.L25:
 336              		.loc 3 96 0 is_stmt 0 discriminator 1
 337 02e7 807DF346 		cmpb	$70, -13(%rbp)
 338 02eb 7E06     		jle	.L26
  97:libusbwrap.c  **** 			(ch > 'F' && ch < 'a') ||
 339              		.loc 3 97 0 is_stmt 1
 340 02ed 807DF360 		cmpb	$96, -13(%rbp)
 341 02f1 7E06     		jle	.L24
 342              	.L26:
 343              		.loc 3 97 0 is_stmt 0 discriminator 1
 344 02f3 807DF366 		cmpb	$102, -13(%rbp)
 345 02f7 7E0A     		jle	.L27
 346              	.L24:
  98:libusbwrap.c  **** 			ch > 'f')
  99:libusbwrap.c  **** 		{
 100:libusbwrap.c  **** 			return false;
 347              		.loc 3 100 0 is_stmt 1
 348 02f9 B8000000 		movl	$0, %eax
 348      00
 349 02fe E9B70000 		jmp	.L17
 349      00
 350              	.L27:
  92:libusbwrap.c  **** 		ch = vp[i];
 351              		.loc 3 92 0
 352 0303 8345F401 		addl	$1, -12(%rbp)
 353              	.L23:
  92:libusbwrap.c  **** 		ch = vp[i];
 354              		.loc 3 92 0 is_stmt 0 discriminator 1
 355 0307 837DF403 		cmpl	$3, -12(%rbp)
 356 030b 7EB5     		jle	.L28
 101:libusbwrap.c  **** 		}
 102:libusbwrap.c  **** 	}
 103:libusbwrap.c  **** 	for ( i = 5; i < 9; i++ ) {
 357              		.loc 3 103 0 is_stmt 1
 358 030d C745F405 		movl	$5, -12(%rbp)
 358      000000
 359 0314 EB42     		jmp	.L29
 360              	.L34:
 104:libusbwrap.c  **** 		ch = vp[i];
 361              		.loc 3 104 0
 362 0316 8B45F4   		movl	-12(%rbp), %eax
 363 0319 4863D0   		movslq	%eax, %rdx
 364 031c 488B45E8 		movq	-24(%rbp), %rax
 365 0320 4801D0   		addq	%rdx, %rax
 366 0323 0FB600   		movzbl	(%rax), %eax
 367 0326 8845F3   		movb	%al, -13(%rbp)
 105:libusbwrap.c  **** 		if (
 368              		.loc 3 105 0
 369 0329 807DF32F 		cmpb	$47, -13(%rbp)
 370 032d 7E1E     		jle	.L30
 106:libusbwrap.c  **** 			ch < '0' ||
 371              		.loc 3 106 0
 372 032f 807DF339 		cmpb	$57, -13(%rbp)
 373 0333 7E06     		jle	.L31
 107:libusbwrap.c  **** 			(ch > '9' && ch < 'A') ||
 374              		.loc 3 107 0
 375 0335 807DF340 		cmpb	$64, -13(%rbp)
 376 0339 7E12     		jle	.L30
 377              	.L31:
 378              		.loc 3 107 0 is_stmt 0 discriminator 1
 379 033b 807DF346 		cmpb	$70, -13(%rbp)
 380 033f 7E06     		jle	.L32
 108:libusbwrap.c  **** 			(ch > 'F' && ch < 'a') ||
 381              		.loc 3 108 0 is_stmt 1
 382 0341 807DF360 		cmpb	$96, -13(%rbp)
 383 0345 7E06     		jle	.L30
 384              	.L32:
 385              		.loc 3 108 0 is_stmt 0 discriminator 1
 386 0347 807DF366 		cmpb	$102, -13(%rbp)
 387 034b 7E07     		jle	.L33
 388              	.L30:
 109:libusbwrap.c  **** 			ch > 'f')
 110:libusbwrap.c  **** 		{
 111:libusbwrap.c  **** 			return false;
 389              		.loc 3 111 0 is_stmt 1
 390 034d B8000000 		movl	$0, %eax
 390      00
 391 0352 EB66     		jmp	.L17
 392              	.L33:
 103:libusbwrap.c  **** 		ch = vp[i];
 393              		.loc 3 103 0
 394 0354 8345F401 		addl	$1, -12(%rbp)
 395              	.L29:
 103:libusbwrap.c  **** 		ch = vp[i];
 396              		.loc 3 103 0 is_stmt 0 discriminator 1
 397 0358 837DF408 		cmpl	$8, -12(%rbp)
 398 035c 7EB8     		jle	.L34
 112:libusbwrap.c  **** 		}
 113:libusbwrap.c  **** 	}
 114:libusbwrap.c  **** 	if ( hasDID ) {
 399              		.loc 3 114 0 is_stmt 1
 400 035e 807DF200 		cmpb	$0, -14(%rbp)
 401 0362 7451     		je	.L35
 115:libusbwrap.c  **** 		for ( i = 10; i < 14; i++ ) {
 402              		.loc 3 115 0
 403 0364 C745F40A 		movl	$10, -12(%rbp)
 403      000000
 404 036b EB42     		jmp	.L36
 405              	.L41:
 116:libusbwrap.c  **** 			ch = vp[i];
 406              		.loc 3 116 0
 407 036d 8B45F4   		movl	-12(%rbp), %eax
 408 0370 4863D0   		movslq	%eax, %rdx
 409 0373 488B45E8 		movq	-24(%rbp), %rax
 410 0377 4801D0   		addq	%rdx, %rax
 411 037a 0FB600   		movzbl	(%rax), %eax
 412 037d 8845F3   		movb	%al, -13(%rbp)
 117:libusbwrap.c  **** 			if (
 413              		.loc 3 117 0
 414 0380 807DF32F 		cmpb	$47, -13(%rbp)
 415 0384 7E1E     		jle	.L37
 118:libusbwrap.c  **** 				ch < '0' ||
 416              		.loc 3 118 0
 417 0386 807DF339 		cmpb	$57, -13(%rbp)
 418 038a 7E06     		jle	.L38
 119:libusbwrap.c  **** 				(ch > '9' && ch < 'A') ||
 419              		.loc 3 119 0
 420 038c 807DF340 		cmpb	$64, -13(%rbp)
 421 0390 7E12     		jle	.L37
 422              	.L38:
 423              		.loc 3 119 0 is_stmt 0 discriminator 1
 424 0392 807DF346 		cmpb	$70, -13(%rbp)
 425 0396 7E06     		jle	.L39
 120:libusbwrap.c  **** 				(ch > 'F' && ch < 'a') ||
 426              		.loc 3 120 0 is_stmt 1
 427 0398 807DF360 		cmpb	$96, -13(%rbp)
 428 039c 7E06     		jle	.L37
 429              	.L39:
 430              		.loc 3 120 0 is_stmt 0 discriminator 1
 431 039e 807DF366 		cmpb	$102, -13(%rbp)
 432 03a2 7E07     		jle	.L40
 433              	.L37:
 121:libusbwrap.c  **** 				ch > 'f')
 122:libusbwrap.c  **** 			{
 123:libusbwrap.c  **** 				return false;
 434              		.loc 3 123 0 is_stmt 1
 435 03a4 B8000000 		movl	$0, %eax
 435      00
 436 03a9 EB0F     		jmp	.L17
 437              	.L40:
 115:libusbwrap.c  **** 			ch = vp[i];
 438              		.loc 3 115 0
 439 03ab 8345F401 		addl	$1, -12(%rbp)
 440              	.L36:
 115:libusbwrap.c  **** 			ch = vp[i];
 441              		.loc 3 115 0 is_stmt 0 discriminator 1
 442 03af 837DF40D 		cmpl	$13, -12(%rbp)
 443 03b3 7EB8     		jle	.L41
 444              	.L35:
 124:libusbwrap.c  **** 			}
 125:libusbwrap.c  **** 		}
 126:libusbwrap.c  **** 	}
 127:libusbwrap.c  **** 	return true;
 445              		.loc 3 127 0 is_stmt 1
 446 03b5 B8010000 		movl	$1, %eax
 446      00
 447              	.L17:
 128:libusbwrap.c  **** }
 448              		.loc 3 128 0
 449 03ba C9       		leave
 450              		.cfi_def_cfa 7, 8
 451 03bb C3       		ret
 452              		.cfi_endproc
 453              	.LFE21:
 455              		.section	.rodata
 456              	.LC1:
 457 0011 75736249 		.string	"usbInitialise(): %s"
 457      6E697469 
 457      616C6973 
 457      6528293A 
 457      20257300 
 458              		.text
 459              		.globl	usbInitialise
 461              	usbInitialise:
 462              	.LFB22:
 129:libusbwrap.c  **** 
 130:libusbwrap.c  **** // Initialise LibUSB with the given log level.
 131:libusbwrap.c  **** //
 132:libusbwrap.c  **** DLLEXPORT(USBStatus) usbInitialise(int debugLevel, const char **error) {
 463              		.loc 3 132 0
 464              		.cfi_startproc
 465 03bc 55       		pushq	%rbp
 466              		.cfi_def_cfa_offset 16
 467              		.cfi_offset 6, -16
 468 03bd 4889E5   		movq	%rsp, %rbp
 469              		.cfi_def_cfa_register 6
 470 03c0 4883EC20 		subq	$32, %rsp
 471 03c4 897DEC   		movl	%edi, -20(%rbp)
 472 03c7 488975E0 		movq	%rsi, -32(%rbp)
 133:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 473              		.loc 3 133 0
 474 03cb C745F800 		movl	$0, -8(%rbp)
 474      000000
 134:libusbwrap.c  **** 	int status = libusb_init(&m_ctx);
 475              		.loc 3 134 0
 476 03d2 488D3D00 		leaq	m_ctx(%rip), %rdi
 476      000000
 477 03d9 E8000000 		call	libusb_init@PLT
 477      00
 478 03de 8945FC   		movl	%eax, -4(%rbp)
 135:libusbwrap.c  **** 	CHECK_STATUS(status, USB_INIT, cleanup, "usbInitialise(): %s", libusb_error_name(status));
 479              		.loc 3 135 0
 480 03e1 837DFC00 		cmpl	$0, -4(%rbp)
 481 03e5 742E     		je	.L43
 482              		.loc 3 135 0 is_stmt 0 discriminator 1
 483 03e7 8B45FC   		movl	-4(%rbp), %eax
 484 03ea 89C7     		movl	%eax, %edi
 485 03ec E8000000 		call	libusb_error_name@PLT
 485      00
 486 03f1 4889C2   		movq	%rax, %rdx
 487 03f4 488B45E0 		movq	-32(%rbp), %rax
 488 03f8 488D3500 		leaq	.LC1(%rip), %rsi
 488      000000
 489 03ff 4889C7   		movq	%rax, %rdi
 490 0402 B8000000 		movl	$0, %eax
 490      00
 491 0407 E8000000 		call	errRender@PLT
 491      00
 492 040c C745F802 		movl	$2, -8(%rbp)
 492      000000
 493 0413 EB14     		jmp	.L44
 494              	.L43:
 136:libusbwrap.c  **** 	libusb_set_debug(m_ctx, debugLevel);
 495              		.loc 3 136 0 is_stmt 1
 496 0415 488B0500 		movq	m_ctx(%rip), %rax
 496      000000
 497 041c 8B55EC   		movl	-20(%rbp), %edx
 498 041f 89D6     		movl	%edx, %esi
 499 0421 4889C7   		movq	%rax, %rdi
 500 0424 E8000000 		call	libusb_set_debug@PLT
 500      00
 501              	.L44:
 137:libusbwrap.c  **** cleanup:
 138:libusbwrap.c  **** 	return retVal;
 502              		.loc 3 138 0
 503 0429 8B45F8   		movl	-8(%rbp), %eax
 139:libusbwrap.c  **** }
 504              		.loc 3 139 0
 505 042c C9       		leave
 506              		.cfi_def_cfa 7, 8
 507 042d C3       		ret
 508              		.cfi_endproc
 509              	.LFE22:
 511              		.section	.rodata
 512 0025 000000   		.align 8
 513              	.LC2:
 514 0028 75736249 		.string	"usbIsDeviceAvailable(): you forgot to call usbInitialise()!"
 514      73446576 
 514      69636541 
 514      7661696C 
 514      61626C65 
 515              	.LC3:
 516 0064 75736249 		.string	"usbIsDeviceAvailable(): %s"
 516      73446576 
 516      69636541 
 516      7661696C 
 516      61626C65 
 517 007f 00       		.align 8
 518              	.LC4:
 519 0080 75736249 		.string	"usbIsDeviceAvailable(): The supplied VID:PID:DID \"%s\" is invalid; it should look like 1
 519      73446576 
 519      69636541 
 519      7661696C 
 519      61626C65 
 520              		.text
 521              		.globl	usbIsDeviceAvailable
 523              	usbIsDeviceAvailable:
 524              	.LFB23:
 140:libusbwrap.c  **** 
 141:libusbwrap.c  **** #define isMatching (thisDevice->descriptor.idVendor == vid && thisDevice->descriptor.idProduct == p
 142:libusbwrap.c  **** 
 143:libusbwrap.c  **** #define FORMAT_ERR "The supplied VID:PID:DID \"%s\" is invalid; it should look like 1D50:602B or 1D
 144:libusbwrap.c  **** 
 145:libusbwrap.c  **** // Find the descriptor of the first occurance of the specified device
 146:libusbwrap.c  **** //
 147:libusbwrap.c  **** DLLEXPORT(USBStatus) usbIsDeviceAvailable(const char *vp, bool *isAvailable, const char **error) {
 525              		.loc 3 147 0
 526              		.cfi_startproc
 527 042e 55       		pushq	%rbp
 528              		.cfi_def_cfa_offset 16
 529              		.cfi_offset 6, -16
 530 042f 4889E5   		movq	%rsp, %rbp
 531              		.cfi_def_cfa_register 6
 532 0432 4883EC70 		subq	$112, %rsp
 533 0436 48897DA8 		movq	%rdi, -88(%rbp)
 534 043a 488975A0 		movq	%rsi, -96(%rbp)
 535 043e 48895598 		movq	%rdx, -104(%rbp)
 148:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 536              		.loc 3 148 0
 537 0442 C745C400 		movl	$0, -60(%rbp)
 537      000000
 149:libusbwrap.c  **** 	struct libusb_device **devList = NULL;
 538              		.loc 3 149 0
 539 0449 48C745D0 		movq	$0, -48(%rbp)
 539      00000000 
 150:libusbwrap.c  **** 	struct libusb_device *thisDev;
 151:libusbwrap.c  **** 	struct libusb_device_descriptor desc;
 152:libusbwrap.c  **** 	uint16 vid, pid, did;
 153:libusbwrap.c  **** 	int status, count;
 154:libusbwrap.c  **** 	CHECK_STATUS(
 540              		.loc 3 154 0
 541 0451 488B0500 		movq	m_ctx(%rip), %rax
 541      000000
 542 0458 4885C0   		testq	%rax, %rax
 543 045b 751F     		jne	.L47
 544              		.loc 3 154 0 is_stmt 0 discriminator 1
 545 045d 488B4598 		movq	-104(%rbp), %rax
 546 0461 488D3500 		leaq	.LC2(%rip), %rsi
 546      000000
 547 0468 4889C7   		movq	%rax, %rdi
 548 046b E8000000 		call	errPrefix@PLT
 548      00
 549 0470 C745C402 		movl	$2, -60(%rbp)
 549      000000
 550 0477 E9A70100 		jmp	.L48
 550      00
 551              	.L47:
 155:libusbwrap.c  **** 		!m_ctx, USB_INIT, cleanup,
 156:libusbwrap.c  **** 		"usbIsDeviceAvailable(): you forgot to call usbInitialise()!");
 157:libusbwrap.c  **** 	count = (int)libusb_get_device_list(m_ctx, &devList);
 552              		.loc 3 157 0 is_stmt 1
 553 047c 488B0500 		movq	m_ctx(%rip), %rax
 553      000000
 554 0483 488D55D0 		leaq	-48(%rbp), %rdx
 555 0487 4889D6   		movq	%rdx, %rsi
 556 048a 4889C7   		movq	%rax, %rdi
 557 048d E8000000 		call	libusb_get_device_list@PLT
 557      00
 558 0492 8945C8   		movl	%eax, -56(%rbp)
 158:libusbwrap.c  **** 	CHECK_STATUS(
 559              		.loc 3 158 0
 560 0495 837DC800 		cmpl	$0, -56(%rbp)
 561 0499 7931     		jns	.L49
 562              		.loc 3 158 0 is_stmt 0 discriminator 1
 563 049b 8B45C8   		movl	-56(%rbp), %eax
 564 049e 89C7     		movl	%eax, %edi
 565 04a0 E8000000 		call	libusb_error_name@PLT
 565      00
 566 04a5 4889C2   		movq	%rax, %rdx
 567 04a8 488B4598 		movq	-104(%rbp), %rax
 568 04ac 488D3500 		leaq	.LC3(%rip), %rsi
 568      000000
 569 04b3 4889C7   		movq	%rax, %rdi
 570 04b6 B8000000 		movl	$0, %eax
 570      00
 571 04bb E8000000 		call	errRender@PLT
 571      00
 572 04c0 C745C405 		movl	$5, -60(%rbp)
 572      000000
 573 04c7 E9570100 		jmp	.L48
 573      00
 574              	.L49:
 159:libusbwrap.c  **** 		count < 0, USB_CANNOT_OPEN_DEVICE, cleanup,
 160:libusbwrap.c  **** 		"usbIsDeviceAvailable(): %s", libusb_error_name(count));
 161:libusbwrap.c  **** 	CHECK_STATUS(
 575              		.loc 3 161 0 is_stmt 1
 576 04cc 488B45A8 		movq	-88(%rbp), %rax
 577 04d0 4889C7   		movq	%rax, %rdi
 578 04d3 E8000000 		call	usbValidateVidPid@PLT
 578      00
 579 04d8 83F001   		xorl	$1, %eax
 580 04db 84C0     		testb	%al, %al
 581 04dd 7428     		je	.L50
 582              		.loc 3 161 0 is_stmt 0 discriminator 1
 583 04df 488B55A8 		movq	-88(%rbp), %rdx
 584 04e3 488B4598 		movq	-104(%rbp), %rax
 585 04e7 488D3500 		leaq	.LC4(%rip), %rsi
 585      000000
 586 04ee 4889C7   		movq	%rax, %rdi
 587 04f1 B8000000 		movl	$0, %eax
 587      00
 588 04f6 E8000000 		call	errRender@PLT
 588      00
 589 04fb C745C401 		movl	$1, -60(%rbp)
 589      000000
 590 0502 E91C0100 		jmp	.L48
 590      00
 591              	.L50:
 162:libusbwrap.c  **** 		!usbValidateVidPid(vp), USB_INVALID_VIDPID, cleanup,
 163:libusbwrap.c  **** 		"usbIsDeviceAvailable(): "FORMAT_ERR, vp);
 164:libusbwrap.c  **** 	vid = (uint16)strtoul(vp, NULL, 16);
 592              		.loc 3 164 0 is_stmt 1
 593 0507 488B45A8 		movq	-88(%rbp), %rax
 594 050b BA100000 		movl	$16, %edx
 594      00
 595 0510 BE000000 		movl	$0, %esi
 595      00
 596 0515 4889C7   		movq	%rax, %rdi
 597 0518 E8000000 		call	strtoul@PLT
 597      00
 598 051d 668945BE 		movw	%ax, -66(%rbp)
 165:libusbwrap.c  **** 	pid = (uint16)strtoul(vp+5, NULL, 16);
 599              		.loc 3 165 0
 600 0521 488B45A8 		movq	-88(%rbp), %rax
 601 0525 4883C005 		addq	$5, %rax
 602 0529 BA100000 		movl	$16, %edx
 602      00
 603 052e BE000000 		movl	$0, %esi
 603      00
 604 0533 4889C7   		movq	%rax, %rdi
 605 0536 E8000000 		call	strtoul@PLT
 605      00
 606 053b 668945C0 		movw	%ax, -64(%rbp)
 166:libusbwrap.c  **** 	did = (uint16)((strlen(vp) == 14) ? strtoul(vp+10, NULL, 16) : 0x0000);
 607              		.loc 3 166 0
 608 053f 488B45A8 		movq	-88(%rbp), %rax
 609 0543 4889C7   		movq	%rax, %rdi
 610 0546 E8000000 		call	strlen@PLT
 610      00
 611 054b 4883F80E 		cmpq	$14, %rax
 612 054f 751C     		jne	.L51
 613              		.loc 3 166 0 is_stmt 0 discriminator 1
 614 0551 488B45A8 		movq	-88(%rbp), %rax
 615 0555 4883C00A 		addq	$10, %rax
 616 0559 BA100000 		movl	$16, %edx
 616      00
 617 055e BE000000 		movl	$0, %esi
 617      00
 618 0563 4889C7   		movq	%rax, %rdi
 619 0566 E8000000 		call	strtoul@PLT
 619      00
 620 056b EB05     		jmp	.L52
 621              	.L51:
 622              		.loc 3 166 0 discriminator 2
 623 056d B8000000 		movl	$0, %eax
 623      00
 624              	.L52:
 625              		.loc 3 166 0 discriminator 3
 626 0572 668945C2 		movw	%ax, -62(%rbp)
 167:libusbwrap.c  **** 	*isAvailable = false;
 627              		.loc 3 167 0 is_stmt 1 discriminator 3
 628 0576 488B45A0 		movq	-96(%rbp), %rax
 629 057a C60000   		movb	$0, (%rax)
 168:libusbwrap.c  **** 	while ( count-- ) {
 630              		.loc 3 168 0 discriminator 3
 631 057d E9900000 		jmp	.L53
 631      00
 632              	.L56:
 169:libusbwrap.c  **** 		thisDev = devList[count];
 633              		.loc 3 169 0
 634 0582 488B45D0 		movq	-48(%rbp), %rax
 635 0586 8B55C8   		movl	-56(%rbp), %edx
 636 0589 4863D2   		movslq	%edx, %rdx
 637 058c 48C1E203 		salq	$3, %rdx
 638 0590 4801D0   		addq	%rdx, %rax
 639 0593 488B00   		movq	(%rax), %rax
 640 0596 488945D8 		movq	%rax, -40(%rbp)
 170:libusbwrap.c  **** 		status = libusb_get_device_descriptor(thisDev, &desc);
 641              		.loc 3 170 0
 642 059a 488D55E0 		leaq	-32(%rbp), %rdx
 643 059e 488B45D8 		movq	-40(%rbp), %rax
 644 05a2 4889D6   		movq	%rdx, %rsi
 645 05a5 4889C7   		movq	%rax, %rdi
 646 05a8 E8000000 		call	libusb_get_device_descriptor@PLT
 646      00
 647 05ad 8945CC   		movl	%eax, -52(%rbp)
 171:libusbwrap.c  **** 		CHECK_STATUS(
 648              		.loc 3 171 0
 649 05b0 837DCC00 		cmpl	$0, -52(%rbp)
 650 05b4 742E     		je	.L54
 651              		.loc 3 171 0 is_stmt 0 discriminator 1
 652 05b6 8B45CC   		movl	-52(%rbp), %eax
 653 05b9 89C7     		movl	%eax, %edi
 654 05bb E8000000 		call	libusb_error_name@PLT
 654      00
 655 05c0 4889C2   		movq	%rax, %rdx
 656 05c3 488B4598 		movq	-104(%rbp), %rax
 657 05c7 488D3500 		leaq	.LC3(%rip), %rsi
 657      000000
 658 05ce 4889C7   		movq	%rax, %rdi
 659 05d1 B8000000 		movl	$0, %eax
 659      00
 660 05d6 E8000000 		call	errRender@PLT
 660      00
 661 05db C745C409 		movl	$9, -60(%rbp)
 661      000000
 662 05e2 EB3F     		jmp	.L48
 663              	.L54:
 172:libusbwrap.c  **** 			status, USB_CANNOT_GET_DESCRIPTOR, cleanup,
 173:libusbwrap.c  **** 			"usbIsDeviceAvailable(): %s", libusb_error_name(status));
 174:libusbwrap.c  **** 		if (
 175:libusbwrap.c  **** 			desc.idVendor == vid &&
 664              		.loc 3 175 0 is_stmt 1
 665 05e4 0FB745E8 		movzwl	-24(%rbp), %eax
 174:libusbwrap.c  **** 			desc.idVendor == vid &&
 666              		.loc 3 174 0
 667 05e8 663B45BE 		cmpw	-66(%rbp), %ax
 668 05ec 7524     		jne	.L53
 176:libusbwrap.c  **** 			desc.idProduct == pid &&
 669              		.loc 3 176 0
 670 05ee 0FB745EA 		movzwl	-22(%rbp), %eax
 175:libusbwrap.c  **** 			desc.idProduct == pid &&
 671              		.loc 3 175 0
 672 05f2 663B45C0 		cmpw	-64(%rbp), %ax
 673 05f6 751A     		jne	.L53
 674              		.loc 3 176 0
 675 05f8 66837DC2 		cmpw	$0, -62(%rbp)
 675      00
 676 05fd 740A     		je	.L55
 177:libusbwrap.c  **** 			(did == 0x0000 || desc.bcdDevice == did)
 677              		.loc 3 177 0
 678 05ff 0FB745EC 		movzwl	-20(%rbp), %eax
 679 0603 663B45C2 		cmpw	-62(%rbp), %ax
 680 0607 7509     		jne	.L53
 681              	.L55:
 178:libusbwrap.c  **** 		) {
 179:libusbwrap.c  **** 			*isAvailable = true;
 682              		.loc 3 179 0
 683 0609 488B45A0 		movq	-96(%rbp), %rax
 684 060d C60001   		movb	$1, (%rax)
 180:libusbwrap.c  **** 			break;
 685              		.loc 3 180 0
 686 0610 EB11     		jmp	.L48
 687              	.L53:
 168:libusbwrap.c  **** 		thisDev = devList[count];
 688              		.loc 3 168 0 discriminator 1
 689 0612 8B45C8   		movl	-56(%rbp), %eax
 690 0615 8D50FF   		leal	-1(%rax), %edx
 691 0618 8955C8   		movl	%edx, -56(%rbp)
 692 061b 85C0     		testl	%eax, %eax
 693 061d 0F855FFF 		jne	.L56
 693      FFFF
 694              	.L48:
 181:libusbwrap.c  **** 		}
 182:libusbwrap.c  **** 	}
 183:libusbwrap.c  **** cleanup:
 184:libusbwrap.c  **** 	libusb_free_device_list(devList, 1);
 695              		.loc 3 184 0
 696 0623 488B45D0 		movq	-48(%rbp), %rax
 697 0627 BE010000 		movl	$1, %esi
 697      00
 698 062c 4889C7   		movq	%rax, %rdi
 699 062f E8000000 		call	libusb_free_device_list@PLT
 699      00
 185:libusbwrap.c  **** 	return retVal;
 700              		.loc 3 185 0
 701 0634 8B45C4   		movl	-60(%rbp), %eax
 186:libusbwrap.c  **** }
 702              		.loc 3 186 0
 703 0637 C9       		leave
 704              		.cfi_def_cfa 7, 8
 705 0638 C3       		ret
 706              		.cfi_endproc
 707              	.LFE23:
 709              		.globl	createTransfer
 711              	createTransfer:
 712              	.LFB24:
 187:libusbwrap.c  **** 
 188:libusbwrap.c  **** struct TransferWrapper {
 189:libusbwrap.c  **** 	struct libusb_transfer *transfer;
 190:libusbwrap.c  **** 	int completed;
 191:libusbwrap.c  **** 	struct AsyncTransferFlags flags;
 192:libusbwrap.c  **** 	uint8 buffer[0x10000];  // can use this...
 193:libusbwrap.c  **** 	uint8 *bufPtr;          // ...or this.
 194:libusbwrap.c  **** };
 195:libusbwrap.c  **** struct TransferWrapper *createTransfer(void) {
 713              		.loc 3 195 0
 714              		.cfi_startproc
 715 0639 55       		pushq	%rbp
 716              		.cfi_def_cfa_offset 16
 717              		.cfi_offset 6, -16
 718 063a 4889E5   		movq	%rsp, %rbp
 719              		.cfi_def_cfa_register 6
 720 063d 4883EC10 		subq	$16, %rsp
 196:libusbwrap.c  **** 	struct TransferWrapper *retVal = (struct TransferWrapper *)calloc(1, sizeof(struct TransferWrapper
 721              		.loc 3 196 0
 722 0641 BE180001 		movl	$65560, %esi
 722      00
 723 0646 BF010000 		movl	$1, %edi
 723      00
 724 064b E8000000 		call	calloc@PLT
 724      00
 725 0650 488945F8 		movq	%rax, -8(%rbp)
 197:libusbwrap.c  **** 	CHECK_STATUS(retVal == NULL, NULL, exit);
 726              		.loc 3 197 0
 727 0654 48837DF8 		cmpq	$0, -8(%rbp)
 727      00
 728 0659 750A     		jne	.L59
 729              		.loc 3 197 0 is_stmt 0 discriminator 1
 730 065b 48C745F8 		movq	$0, -8(%rbp)
 730      00000000 
 731 0663 EB3A     		jmp	.L60
 732              	.L59:
 198:libusbwrap.c  **** 	retVal->transfer = libusb_alloc_transfer(0);
 733              		.loc 3 198 0 is_stmt 1
 734 0665 BF000000 		movl	$0, %edi
 734      00
 735 066a E8000000 		call	libusb_alloc_transfer@PLT
 735      00
 736 066f 488B55F8 		movq	-8(%rbp), %rdx
 737 0673 488902   		movq	%rax, (%rdx)
 199:libusbwrap.c  **** 	CHECK_STATUS(retVal->transfer == NULL, NULL, freeWrap);
 738              		.loc 3 199 0
 739 0676 488B45F8 		movq	-8(%rbp), %rax
 740 067a 488B00   		movq	(%rax), %rax
 741 067d 4885C0   		testq	%rax, %rax
 742 0680 7517     		jne	.L61
 743              		.loc 3 199 0 is_stmt 0 discriminator 1
 744 0682 48C745F8 		movq	$0, -8(%rbp)
 744      00000000 
 745 068a 90       		nop
 746              	.L62:
 200:libusbwrap.c  **** 	return retVal;
 201:libusbwrap.c  **** freeWrap:
 202:libusbwrap.c  **** 	free((void*)retVal);
 747              		.loc 3 202 0 is_stmt 1 discriminator 1
 748 068b 488B45F8 		movq	-8(%rbp), %rax
 749 068f 4889C7   		movq	%rax, %rdi
 750 0692 E8000000 		call	free@PLT
 750      00
 751 0697 EB06     		jmp	.L60
 752              	.L61:
 200:libusbwrap.c  **** 	return retVal;
 753              		.loc 3 200 0
 754 0699 488B45F8 		movq	-8(%rbp), %rax
 755 069d EB05     		jmp	.L63
 756              	.L60:
 203:libusbwrap.c  **** exit:
 204:libusbwrap.c  **** 	return NULL;
 757              		.loc 3 204 0
 758 069f B8000000 		movl	$0, %eax
 758      00
 759              	.L63:
 205:libusbwrap.c  **** }
 760              		.loc 3 205 0
 761 06a4 C9       		leave
 762              		.cfi_def_cfa 7, 8
 763 06a5 C3       		ret
 764              		.cfi_endproc
 765              	.LFE24:
 768              	destroyTransfer:
 769              	.LFB25:
 206:libusbwrap.c  **** 
 207:libusbwrap.c  **** static void destroyTransfer(struct TransferWrapper *tx) {
 770              		.loc 3 207 0
 771              		.cfi_startproc
 772 06a6 55       		pushq	%rbp
 773              		.cfi_def_cfa_offset 16
 774              		.cfi_offset 6, -16
 775 06a7 4889E5   		movq	%rsp, %rbp
 776              		.cfi_def_cfa_register 6
 777 06aa 4883EC10 		subq	$16, %rsp
 778 06ae 48897DF8 		movq	%rdi, -8(%rbp)
 208:libusbwrap.c  **** 	if ( tx ) {
 779              		.loc 3 208 0
 780 06b2 48837DF8 		cmpq	$0, -8(%rbp)
 780      00
 781 06b7 741B     		je	.L64
 209:libusbwrap.c  **** 		libusb_free_transfer(tx->transfer);
 782              		.loc 3 209 0
 783 06b9 488B45F8 		movq	-8(%rbp), %rax
 784 06bd 488B00   		movq	(%rax), %rax
 785 06c0 4889C7   		movq	%rax, %rdi
 786 06c3 E8000000 		call	libusb_free_transfer@PLT
 786      00
 210:libusbwrap.c  **** 		free((void*)tx);
 787              		.loc 3 210 0
 788 06c8 488B45F8 		movq	-8(%rbp), %rax
 789 06cc 4889C7   		movq	%rax, %rdi
 790 06cf E8000000 		call	free@PLT
 790      00
 791              	.L64:
 211:libusbwrap.c  **** 	}
 212:libusbwrap.c  **** }
 792              		.loc 3 212 0
 793 06d4 C9       		leave
 794              		.cfi_def_cfa 7, 8
 795 06d5 C3       		ret
 796              		.cfi_endproc
 797              	.LFE25:
 799              		.section	.rodata
 800 00f2 00000000 		.align 8
 800      0000
 801              	.LC5:
 802 00f8 7573624F 		.string	"usbOpenDevice(): you forgot to call usbInitialise()!"
 802      70656E44 
 802      65766963 
 802      6528293A 
 802      20796F75 
 803 012d 000000   		.align 8
 804              	.LC6:
 805 0130 7573624F 		.string	"usbOpenDevice(): The supplied VID:PID:DID \"%s\" is invalid; it should look like 1D50:602
 805      70656E44 
 805      65766963 
 805      6528293A 
 805      20546865 
 806 019b 00000000 		.align 8
 806      00
 807              	.LC7:
 808 01a0 7573624F 		.string	"usbOpenDevice(): Out of memory!"
 808      70656E44 
 808      65766963 
 808      6528293A 
 808      204F7574 
 809              	.LC8:
 810 01c0 7573624F 		.string	"usbOpenDevice()"
 810      70656E44 
 810      65766963 
 810      65282900 
 811              	.LC9:
 812 01d0 7573624F 		.string	"usbOpenDevice(): %s"
 812      70656E44 
 812      65766963 
 812      6528293A 
 812      20257300 
 813              		.text
 814              		.globl	usbOpenDevice
 816              	usbOpenDevice:
 817              	.LFB26:
 213:libusbwrap.c  **** 
 214:libusbwrap.c  **** // Find the descriptor of the first occurance of the specified device
 215:libusbwrap.c  **** //
 216:libusbwrap.c  **** DLLEXPORT(USBStatus) usbOpenDevice(
 217:libusbwrap.c  **** 	const char *vp, int configuration, int iface, int altSetting,
 218:libusbwrap.c  **** 	struct USBDevice **devHandlePtr, const char **error)
 219:libusbwrap.c  **** {
 818              		.loc 3 219 0
 819              		.cfi_startproc
 820 06d6 55       		pushq	%rbp
 821              		.cfi_def_cfa_offset 16
 822              		.cfi_offset 6, -16
 823 06d7 4889E5   		movq	%rsp, %rbp
 824              		.cfi_def_cfa_register 6
 825 06da 4883EC50 		subq	$80, %rsp
 826 06de 48897DD8 		movq	%rdi, -40(%rbp)
 827 06e2 8975D4   		movl	%esi, -44(%rbp)
 828 06e5 8955D0   		movl	%edx, -48(%rbp)
 829 06e8 894DCC   		movl	%ecx, -52(%rbp)
 830 06eb 4C8945C0 		movq	%r8, -64(%rbp)
 831 06ef 4C894DB8 		movq	%r9, -72(%rbp)
 220:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 832              		.loc 3 220 0
 833 06f3 C745E800 		movl	$0, -24(%rbp)
 833      000000
 221:libusbwrap.c  **** 	uint16 vid, pid, did;
 222:libusbwrap.c  **** 	int status;
 223:libusbwrap.c  **** 	struct USBDevice *newWrapper;
 224:libusbwrap.c  **** 	struct libusb_device_handle *newHandle;
 225:libusbwrap.c  **** 	CHECK_STATUS(
 834              		.loc 3 225 0
 835 06fa 488B0500 		movq	m_ctx(%rip), %rax
 835      000000
 836 0701 4885C0   		testq	%rax, %rax
 837 0704 751F     		jne	.L67
 838              		.loc 3 225 0 is_stmt 0 discriminator 1
 839 0706 488B45B8 		movq	-72(%rbp), %rax
 840 070a 488D3500 		leaq	.LC5(%rip), %rsi
 840      000000
 841 0711 4889C7   		movq	%rax, %rdi
 842 0714 E8000000 		call	errPrefix@PLT
 842      00
 843 0719 C745E802 		movl	$2, -24(%rbp)
 843      000000
 844 0720 E9AA0200 		jmp	.L68
 844      00
 845              	.L67:
 226:libusbwrap.c  **** 		!m_ctx, USB_INIT, exit,
 227:libusbwrap.c  **** 		"usbOpenDevice(): you forgot to call usbInitialise()!");
 228:libusbwrap.c  **** 	CHECK_STATUS(
 846              		.loc 3 228 0 is_stmt 1
 847 0725 488B45D8 		movq	-40(%rbp), %rax
 848 0729 4889C7   		movq	%rax, %rdi
 849 072c E8000000 		call	usbValidateVidPid@PLT
 849      00
 850 0731 83F001   		xorl	$1, %eax
 851 0734 84C0     		testb	%al, %al
 852 0736 7428     		je	.L69
 853              		.loc 3 228 0 is_stmt 0 discriminator 1
 854 0738 488B55D8 		movq	-40(%rbp), %rdx
 855 073c 488B45B8 		movq	-72(%rbp), %rax
 856 0740 488D3500 		leaq	.LC6(%rip), %rsi
 856      000000
 857 0747 4889C7   		movq	%rax, %rdi
 858 074a B8000000 		movl	$0, %eax
 858      00
 859 074f E8000000 		call	errRender@PLT
 859      00
 860 0754 C745E801 		movl	$1, -24(%rbp)
 860      000000
 861 075b E96F0200 		jmp	.L68
 861      00
 862              	.L69:
 229:libusbwrap.c  **** 		!usbValidateVidPid(vp), USB_INVALID_VIDPID, exit,
 230:libusbwrap.c  **** 		"usbOpenDevice(): "FORMAT_ERR, vp);
 231:libusbwrap.c  **** 	vid = (uint16)strtoul(vp, NULL, 16);
 863              		.loc 3 231 0 is_stmt 1
 864 0760 488B45D8 		movq	-40(%rbp), %rax
 865 0764 BA100000 		movl	$16, %edx
 865      00
 866 0769 BE000000 		movl	$0, %esi
 866      00
 867 076e 4889C7   		movq	%rax, %rdi
 868 0771 E8000000 		call	strtoul@PLT
 868      00
 869 0776 668945E2 		movw	%ax, -30(%rbp)
 232:libusbwrap.c  **** 	pid = (uint16)strtoul(vp+5, NULL, 16);
 870              		.loc 3 232 0
 871 077a 488B45D8 		movq	-40(%rbp), %rax
 872 077e 4883C005 		addq	$5, %rax
 873 0782 BA100000 		movl	$16, %edx
 873      00
 874 0787 BE000000 		movl	$0, %esi
 874      00
 875 078c 4889C7   		movq	%rax, %rdi
 876 078f E8000000 		call	strtoul@PLT
 876      00
 877 0794 668945E4 		movw	%ax, -28(%rbp)
 233:libusbwrap.c  **** 	did = (uint16)((strlen(vp) == 14) ? strtoul(vp+10, NULL, 16) : 0x0000);
 878              		.loc 3 233 0
 879 0798 488B45D8 		movq	-40(%rbp), %rax
 880 079c 4889C7   		movq	%rax, %rdi
 881 079f E8000000 		call	strlen@PLT
 881      00
 882 07a4 4883F80E 		cmpq	$14, %rax
 883 07a8 751C     		jne	.L70
 884              		.loc 3 233 0 is_stmt 0 discriminator 1
 885 07aa 488B45D8 		movq	-40(%rbp), %rax
 886 07ae 4883C00A 		addq	$10, %rax
 887 07b2 BA100000 		movl	$16, %edx
 887      00
 888 07b7 BE000000 		movl	$0, %esi
 888      00
 889 07bc 4889C7   		movq	%rax, %rdi
 890 07bf E8000000 		call	strtoul@PLT
 890      00
 891 07c4 EB05     		jmp	.L71
 892              	.L70:
 893              		.loc 3 233 0 discriminator 2
 894 07c6 B8000000 		movl	$0, %eax
 894      00
 895              	.L71:
 896              		.loc 3 233 0 discriminator 3
 897 07cb 668945E6 		movw	%ax, -26(%rbp)
 234:libusbwrap.c  **** 	newWrapper = (struct USBDevice *)malloc(sizeof(struct USBDevice));
 898              		.loc 3 234 0 is_stmt 1 discriminator 3
 899 07cf BF400000 		movl	$64, %edi
 899      00
 900 07d4 E8000000 		call	malloc@PLT
 900      00
 901 07d9 488945F0 		movq	%rax, -16(%rbp)
 235:libusbwrap.c  **** 	CHECK_STATUS(newWrapper == NULL, USB_ALLOC_ERR, exit, "usbOpenDevice(): Out of memory!");
 902              		.loc 3 235 0 discriminator 3
 903 07dd 48837DF0 		cmpq	$0, -16(%rbp)
 903      00
 904 07e2 751F     		jne	.L72
 905              		.loc 3 235 0 is_stmt 0 discriminator 1
 906 07e4 488B45B8 		movq	-72(%rbp), %rax
 907 07e8 488D3500 		leaq	.LC7(%rip), %rsi
 907      000000
 908 07ef 4889C7   		movq	%rax, %rdi
 909 07f2 E8000000 		call	errPrefix@PLT
 909      00
 910 07f7 C745E80C 		movl	$12, -24(%rbp)
 910      000000
 911 07fe E9CC0100 		jmp	.L68
 911      00
 912              	.L72:
 236:libusbwrap.c  **** 	status = queueInit(&newWrapper->queue, 4, (CreateFunc)createTransfer, (DestroyFunc)destroyTransfer
 913              		.loc 3 236 0 is_stmt 1
 914 0803 488B45F0 		movq	-16(%rbp), %rax
 915 0807 488D7808 		leaq	8(%rax), %rdi
 916 080b 488D0D94 		leaq	destroyTransfer(%rip), %rcx
 916      FEFFFF
 917 0812 488B0500 		movq	createTransfer@GOTPCREL(%rip), %rax
 917      000000
 918 0819 4889C2   		movq	%rax, %rdx
 919 081c BE040000 		movl	$4, %esi
 919      00
 920 0821 E8000000 		call	queueInit@PLT
 920      00
 921 0826 8945EC   		movl	%eax, -20(%rbp)
 237:libusbwrap.c  **** 	CHECK_STATUS(status, USB_ALLOC_ERR, freeWrap, "usbOpenDevice(): Out of memory!");
 922              		.loc 3 237 0
 923 0829 837DEC00 		cmpl	$0, -20(%rbp)
 924 082d 741F     		je	.L73
 925              		.loc 3 237 0 is_stmt 0 discriminator 1
 926 082f 488B45B8 		movq	-72(%rbp), %rax
 927 0833 488D3500 		leaq	.LC7(%rip), %rsi
 927      000000
 928 083a 4889C7   		movq	%rax, %rdi
 929 083d E8000000 		call	errPrefix@PLT
 929      00
 930 0842 C745E80C 		movl	$12, -24(%rbp)
 930      000000
 931 0849 E9750100 		jmp	.L74
 931      00
 932              	.L73:
 238:libusbwrap.c  **** 	newHandle = libusbOpenWithVidPid(m_ctx, vid, pid, did, error);
 933              		.loc 3 238 0 is_stmt 1
 934 084e 0FB74DE6 		movzwl	-26(%rbp), %ecx
 935 0852 0FB755E4 		movzwl	-28(%rbp), %edx
 936 0856 0FB775E2 		movzwl	-30(%rbp), %esi
 937 085a 488B0500 		movq	m_ctx(%rip), %rax
 937      000000
 938 0861 488B7DB8 		movq	-72(%rbp), %rdi
 939 0865 4989F8   		movq	%rdi, %r8
 940 0868 4889C7   		movq	%rax, %rdi
 941 086b E817F8FF 		call	libusbOpenWithVidPid
 941      FF
 942 0870 488945F8 		movq	%rax, -8(%rbp)
 239:libusbwrap.c  **** 	CHECK_STATUS(!newHandle, USB_CANNOT_OPEN_DEVICE, freeQueue, "usbOpenDevice()");
 943              		.loc 3 239 0
 944 0874 48837DF8 		cmpq	$0, -8(%rbp)
 944      00
 945 0879 751F     		jne	.L75
 946              		.loc 3 239 0 is_stmt 0 discriminator 1
 947 087b 488B45B8 		movq	-72(%rbp), %rax
 948 087f 488D3500 		leaq	.LC8(%rip), %rsi
 948      000000
 949 0886 4889C7   		movq	%rax, %rdi
 950 0889 E8000000 		call	errPrefix@PLT
 950      00
 951 088e C745E805 		movl	$5, -24(%rbp)
 951      000000
 952 0895 E9190100 		jmp	.L76
 952      00
 953              	.L75:
 240:libusbwrap.c  **** 	status = libusb_set_configuration(newHandle, configuration);
 954              		.loc 3 240 0 is_stmt 1
 955 089a 8B55D4   		movl	-44(%rbp), %edx
 956 089d 488B45F8 		movq	-8(%rbp), %rax
 957 08a1 89D6     		movl	%edx, %esi
 958 08a3 4889C7   		movq	%rax, %rdi
 959 08a6 E8000000 		call	libusb_set_configuration@PLT
 959      00
 960 08ab 8945EC   		movl	%eax, -20(%rbp)
 241:libusbwrap.c  **** 	CHECK_STATUS(
 961              		.loc 3 241 0
 962 08ae 837DEC00 		cmpl	$0, -20(%rbp)
 963 08b2 7931     		jns	.L77
 964              		.loc 3 241 0 is_stmt 0 discriminator 1
 965 08b4 8B45EC   		movl	-20(%rbp), %eax
 966 08b7 89C7     		movl	%eax, %edi
 967 08b9 E8000000 		call	libusb_error_name@PLT
 967      00
 968 08be 4889C2   		movq	%rax, %rdx
 969 08c1 488B45B8 		movq	-72(%rbp), %rax
 970 08c5 488D3500 		leaq	.LC9(%rip), %rsi
 970      000000
 971 08cc 4889C7   		movq	%rax, %rdi
 972 08cf B8000000 		movl	$0, %eax
 972      00
 973 08d4 E8000000 		call	errRender@PLT
 973      00
 974 08d9 C745E806 		movl	$6, -24(%rbp)
 974      000000
 975 08e0 E9C20000 		jmp	.L78
 975      00
 976              	.L77:
 242:libusbwrap.c  **** 		status < 0, USB_CANNOT_SET_CONFIGURATION, closeDev,
 243:libusbwrap.c  **** 		"usbOpenDevice(): %s", libusb_error_name(status));
 244:libusbwrap.c  **** 	status = libusb_claim_interface(newHandle, iface);
 977              		.loc 3 244 0 is_stmt 1
 978 08e5 8B55D0   		movl	-48(%rbp), %edx
 979 08e8 488B45F8 		movq	-8(%rbp), %rax
 980 08ec 89D6     		movl	%edx, %esi
 981 08ee 4889C7   		movq	%rax, %rdi
 982 08f1 E8000000 		call	libusb_claim_interface@PLT
 982      00
 983 08f6 8945EC   		movl	%eax, -20(%rbp)
 245:libusbwrap.c  **** 	CHECK_STATUS(
 984              		.loc 3 245 0
 985 08f9 837DEC00 		cmpl	$0, -20(%rbp)
 986 08fd 792E     		jns	.L79
 987              		.loc 3 245 0 is_stmt 0 discriminator 1
 988 08ff 8B45EC   		movl	-20(%rbp), %eax
 989 0902 89C7     		movl	%eax, %edi
 990 0904 E8000000 		call	libusb_error_name@PLT
 990      00
 991 0909 4889C2   		movq	%rax, %rdx
 992 090c 488B45B8 		movq	-72(%rbp), %rax
 993 0910 488D3500 		leaq	.LC9(%rip), %rsi
 993      000000
 994 0917 4889C7   		movq	%rax, %rdi
 995 091a B8000000 		movl	$0, %eax
 995      00
 996 091f E8000000 		call	errRender@PLT
 996      00
 997 0924 C745E807 		movl	$7, -24(%rbp)
 997      000000
 998 092b EB7A     		jmp	.L78
 999              	.L79:
 246:libusbwrap.c  **** 		status < 0, USB_CANNOT_CLAIM_INTERFACE, closeDev,
 247:libusbwrap.c  **** 		"usbOpenDevice(): %s", libusb_error_name(status));
 248:libusbwrap.c  **** 	status = libusb_set_interface_alt_setting(newHandle, iface, altSetting);
 1000              		.loc 3 248 0 is_stmt 1
 1001 092d 8B55CC   		movl	-52(%rbp), %edx
 1002 0930 8B4DD0   		movl	-48(%rbp), %ecx
 1003 0933 488B45F8 		movq	-8(%rbp), %rax
 1004 0937 89CE     		movl	%ecx, %esi
 1005 0939 4889C7   		movq	%rax, %rdi
 1006 093c E8000000 		call	libusb_set_interface_alt_setting@PLT
 1006      00
 1007 0941 8945EC   		movl	%eax, -20(%rbp)
 249:libusbwrap.c  **** 	CHECK_STATUS(
 1008              		.loc 3 249 0
 1009 0944 837DEC00 		cmpl	$0, -20(%rbp)
 1010 0948 7940     		jns	.L80
 1011              		.loc 3 249 0 is_stmt 0 discriminator 1
 1012 094a 8B45EC   		movl	-20(%rbp), %eax
 1013 094d 89C7     		movl	%eax, %edi
 1014 094f E8000000 		call	libusb_error_name@PLT
 1014      00
 1015 0954 4889C2   		movq	%rax, %rdx
 1016 0957 488B45B8 		movq	-72(%rbp), %rax
 1017 095b 488D3500 		leaq	.LC9(%rip), %rsi
 1017      000000
 1018 0962 4889C7   		movq	%rax, %rdi
 1019 0965 B8000000 		movl	$0, %eax
 1019      00
 1020 096a E8000000 		call	errRender@PLT
 1020      00
 1021 096f C745E808 		movl	$8, -24(%rbp)
 1021      000000
 1022 0976 90       		nop
 1023              	.L81:
 250:libusbwrap.c  **** 		status < 0, USB_CANNOT_SET_ALTINT, release,
 251:libusbwrap.c  **** 		"usbOpenDevice(): %s", libusb_error_name(status));
 252:libusbwrap.c  **** 	newWrapper->handle = newHandle;	
 253:libusbwrap.c  **** 	*devHandlePtr = newWrapper;
 254:libusbwrap.c  **** 	return USB_SUCCESS;
 255:libusbwrap.c  **** release:
 256:libusbwrap.c  **** 	libusb_release_interface(newHandle, iface);
 1024              		.loc 3 256 0 is_stmt 1 discriminator 1
 1025 0977 8B55D0   		movl	-48(%rbp), %edx
 1026 097a 488B45F8 		movq	-8(%rbp), %rax
 1027 097e 89D6     		movl	%edx, %esi
 1028 0980 4889C7   		movq	%rax, %rdi
 1029 0983 E8000000 		call	libusb_release_interface@PLT
 1029      00
 1030 0988 EB1D     		jmp	.L78
 1031              	.L80:
 252:libusbwrap.c  **** 	*devHandlePtr = newWrapper;
 1032              		.loc 3 252 0
 1033 098a 488B45F0 		movq	-16(%rbp), %rax
 1034 098e 488B55F8 		movq	-8(%rbp), %rdx
 1035 0992 488910   		movq	%rdx, (%rax)
 253:libusbwrap.c  **** 	return USB_SUCCESS;
 1036              		.loc 3 253 0
 1037 0995 488B45C0 		movq	-64(%rbp), %rax
 1038 0999 488B55F0 		movq	-16(%rbp), %rdx
 1039 099d 488910   		movq	%rdx, (%rax)
 254:libusbwrap.c  **** release:
 1040              		.loc 3 254 0
 1041 09a0 B8000000 		movl	$0, %eax
 1041      00
 1042 09a5 EB36     		jmp	.L82
 1043              	.L78:
 257:libusbwrap.c  **** closeDev:
 258:libusbwrap.c  **** 	libusb_close(newHandle);	
 1044              		.loc 3 258 0
 1045 09a7 488B45F8 		movq	-8(%rbp), %rax
 1046 09ab 4889C7   		movq	%rax, %rdi
 1047 09ae E8000000 		call	libusb_close@PLT
 1047      00
 1048              	.L76:
 259:libusbwrap.c  **** freeQueue:
 260:libusbwrap.c  **** 	queueDestroy(&newWrapper->queue);
 1049              		.loc 3 260 0
 1050 09b3 488B45F0 		movq	-16(%rbp), %rax
 1051 09b7 4883C008 		addq	$8, %rax
 1052 09bb 4889C7   		movq	%rax, %rdi
 1053 09be E8000000 		call	queueDestroy@PLT
 1053      00
 1054              	.L74:
 261:libusbwrap.c  **** freeWrap:
 262:libusbwrap.c  **** 	free((void*)newWrapper);
 1055              		.loc 3 262 0
 1056 09c3 488B45F0 		movq	-16(%rbp), %rax
 1057 09c7 4889C7   		movq	%rax, %rdi
 1058 09ca E8000000 		call	free@PLT
 1058      00
 1059              	.L68:
 263:libusbwrap.c  **** exit:
 264:libusbwrap.c  **** 	*devHandlePtr = NULL;
 1060              		.loc 3 264 0
 1061 09cf 488B45C0 		movq	-64(%rbp), %rax
 1062 09d3 48C70000 		movq	$0, (%rax)
 1062      000000
 265:libusbwrap.c  **** 	return retVal;
 1063              		.loc 3 265 0
 1064 09da 8B45E8   		movl	-24(%rbp), %eax
 1065              	.L82:
 266:libusbwrap.c  **** }
 1066              		.loc 3 266 0
 1067 09dd C9       		leave
 1068              		.cfi_def_cfa 7, 8
 1069 09de C3       		ret
 1070              		.cfi_endproc
 1071              	.LFE26:
 1073              		.globl	usbCloseDevice
 1075              	usbCloseDevice:
 1076              	.LFB27:
 267:libusbwrap.c  **** 
 268:libusbwrap.c  **** DLLEXPORT(void) usbCloseDevice(struct USBDevice *dev, int iface) {
 1077              		.loc 3 268 0
 1078              		.cfi_startproc
 1079 09df 55       		pushq	%rbp
 1080              		.cfi_def_cfa_offset 16
 1081              		.cfi_offset 6, -16
 1082 09e0 4889E5   		movq	%rsp, %rbp
 1083              		.cfi_def_cfa_register 6
 1084 09e3 4883EC20 		subq	$32, %rsp
 1085 09e7 48897DE8 		movq	%rdi, -24(%rbp)
 1086 09eb 8975E4   		movl	%esi, -28(%rbp)
 269:libusbwrap.c  **** 	if ( dev ) {
 1087              		.loc 3 269 0
 1088 09ee 48837DE8 		cmpq	$0, -24(%rbp)
 1088      00
 1089 09f3 7444     		je	.L83
 1090              	.LBB3:
 270:libusbwrap.c  **** 		struct libusb_device_handle *ptr = dev->handle;
 1091              		.loc 3 270 0
 1092 09f5 488B45E8 		movq	-24(%rbp), %rax
 1093 09f9 488B00   		movq	(%rax), %rax
 1094 09fc 488945F8 		movq	%rax, -8(%rbp)
 271:libusbwrap.c  **** 		libusb_release_interface(ptr, iface);
 1095              		.loc 3 271 0
 1096 0a00 8B55E4   		movl	-28(%rbp), %edx
 1097 0a03 488B45F8 		movq	-8(%rbp), %rax
 1098 0a07 89D6     		movl	%edx, %esi
 1099 0a09 4889C7   		movq	%rax, %rdi
 1100 0a0c E8000000 		call	libusb_release_interface@PLT
 1100      00
 272:libusbwrap.c  **** 		libusb_close(ptr);
 1101              		.loc 3 272 0
 1102 0a11 488B45F8 		movq	-8(%rbp), %rax
 1103 0a15 4889C7   		movq	%rax, %rdi
 1104 0a18 E8000000 		call	libusb_close@PLT
 1104      00
 273:libusbwrap.c  **** 		queueDestroy(&dev->queue);
 1105              		.loc 3 273 0
 1106 0a1d 488B45E8 		movq	-24(%rbp), %rax
 1107 0a21 4883C008 		addq	$8, %rax
 1108 0a25 4889C7   		movq	%rax, %rdi
 1109 0a28 E8000000 		call	queueDestroy@PLT
 1109      00
 274:libusbwrap.c  **** 		free((void*)dev);
 1110              		.loc 3 274 0
 1111 0a2d 488B45E8 		movq	-24(%rbp), %rax
 1112 0a31 4889C7   		movq	%rax, %rdi
 1113 0a34 E8000000 		call	free@PLT
 1113      00
 1114              	.L83:
 1115              	.LBE3:
 275:libusbwrap.c  **** 	}
 276:libusbwrap.c  **** }
 1116              		.loc 3 276 0
 1117 0a39 C9       		leave
 1118              		.cfi_def_cfa 7, 8
 1119 0a3a C3       		ret
 1120              		.cfi_endproc
 1121              	.LFE27:
 1123              		.section	.rodata
 1124              	.LC10:
 1125 01e4 75736243 		.string	"usbControlRead(): Timeout!"
 1125      6F6E7472 
 1125      6F6C5265 
 1125      61642829 
 1125      3A205469 
 1126              	.LC11:
 1127 01ff 75736243 		.string	"usbControlRead(): %s"
 1127      6F6E7472 
 1127      6F6C5265 
 1127      61642829 
 1127      3A202573 
 1128 0214 00000000 		.align 8
 1129              	.LC12:
 1130 0218 75736243 		.string	"usbControlRead(): Expected to read %d bytes but actually read %d"
 1130      6F6E7472 
 1130      6F6C5265 
 1130      61642829 
 1130      3A204578 
 1131              		.text
 1132              		.globl	usbControlRead
 1134              	usbControlRead:
 1135              	.LFB28:
 277:libusbwrap.c  **** 
 278:libusbwrap.c  **** DLLEXPORT(USBStatus) usbControlRead(
 279:libusbwrap.c  **** 	struct USBDevice *dev, uint8 bRequest, uint16 wValue, uint16 wIndex,
 280:libusbwrap.c  **** 	uint8 *data, uint16 wLength,
 281:libusbwrap.c  **** 	uint32 timeout, const char **error)
 282:libusbwrap.c  **** {
 1136              		.loc 3 282 0
 1137              		.cfi_startproc
 1138 0a3b 55       		pushq	%rbp
 1139              		.cfi_def_cfa_offset 16
 1140              		.cfi_offset 6, -16
 1141 0a3c 4889E5   		movq	%rsp, %rbp
 1142              		.cfi_def_cfa_register 6
 1143 0a3f 4883EC40 		subq	$64, %rsp
 1144 0a43 48897DE8 		movq	%rdi, -24(%rbp)
 1145 0a47 89C8     		movl	%ecx, %eax
 1146 0a49 4C8945D0 		movq	%r8, -48(%rbp)
 1147 0a4d 4489C9   		movl	%r9d, %ecx
 1148 0a50 408875E4 		movb	%sil, -28(%rbp)
 1149 0a54 668955E0 		movw	%dx, -32(%rbp)
 1150 0a58 668945DC 		movw	%ax, -36(%rbp)
 1151 0a5c 66894DD8 		movw	%cx, -40(%rbp)
 283:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 1152              		.loc 3 283 0
 1153 0a60 C745F800 		movl	$0, -8(%rbp)
 1153      000000
 284:libusbwrap.c  **** 	int status = libusb_control_transfer(
 1154              		.loc 3 284 0
 1155 0a67 0FB775D8 		movzwl	-40(%rbp), %esi
 1156 0a6b 440FB745 		movzwl	-36(%rbp), %r8d
 1156      DC
 1157 0a70 0FB74DE0 		movzwl	-32(%rbp), %ecx
 1158 0a74 0FB655E4 		movzbl	-28(%rbp), %edx
 285:libusbwrap.c  **** 		dev->handle,
 1159              		.loc 3 285 0
 1160 0a78 488B45E8 		movq	-24(%rbp), %rax
 1161 0a7c 488B00   		movq	(%rax), %rax
 284:libusbwrap.c  **** 	int status = libusb_control_transfer(
 1162              		.loc 3 284 0
 1163 0a7f 4C8B4DD0 		movq	-48(%rbp), %r9
 1164 0a83 8B7D10   		movl	16(%rbp), %edi
 1165 0a86 897C2408 		movl	%edi, 8(%rsp)
 1166 0a8a 893424   		movl	%esi, (%rsp)
 1167 0a8d BEC00000 		movl	$192, %esi
 1167      00
 1168 0a92 4889C7   		movq	%rax, %rdi
 1169 0a95 E8000000 		call	libusb_control_transfer@PLT
 1169      00
 1170 0a9a 8945FC   		movl	%eax, -4(%rbp)
 286:libusbwrap.c  **** 		LIBUSB_ENDPOINT_IN | LIBUSB_REQUEST_TYPE_VENDOR | LIBUSB_RECIPIENT_DEVICE,
 287:libusbwrap.c  **** 		bRequest,
 288:libusbwrap.c  **** 		wValue,
 289:libusbwrap.c  **** 		wIndex,
 290:libusbwrap.c  **** 		(uint8 *)data,
 291:libusbwrap.c  **** 		wLength,
 292:libusbwrap.c  **** 		timeout
 293:libusbwrap.c  **** 	);
 294:libusbwrap.c  **** 	CHECK_STATUS(
 1171              		.loc 3 294 0
 1172 0a9d 837DFCF9 		cmpl	$-7, -4(%rbp)
 1173 0aa1 751C     		jne	.L86
 1174              		.loc 3 294 0 is_stmt 0 discriminator 1
 1175 0aa3 488B4518 		movq	24(%rbp), %rax
 1176 0aa7 488D3500 		leaq	.LC10(%rip), %rsi
 1176      000000
 1177 0aae 4889C7   		movq	%rax, %rdi
 1178 0ab1 E8000000 		call	errPrefix@PLT
 1178      00
 1179 0ab6 C745F812 		movl	$18, -8(%rbp)
 1179      000000
 1180 0abd EB64     		jmp	.L87
 1181              	.L86:
 295:libusbwrap.c  **** 		status == LIBUSB_ERROR_TIMEOUT, USB_TIMEOUT, cleanup,
 296:libusbwrap.c  **** 		"usbControlRead(): Timeout!");
 297:libusbwrap.c  **** 	CHECK_STATUS(
 1182              		.loc 3 297 0 is_stmt 1
 1183 0abf 837DFC00 		cmpl	$0, -4(%rbp)
 1184 0ac3 792E     		jns	.L88
 1185              		.loc 3 297 0 is_stmt 0 discriminator 1
 1186 0ac5 8B45FC   		movl	-4(%rbp), %eax
 1187 0ac8 89C7     		movl	%eax, %edi
 1188 0aca E8000000 		call	libusb_error_name@PLT
 1188      00
 1189 0acf 4889C2   		movq	%rax, %rdx
 1190 0ad2 488B4518 		movq	24(%rbp), %rax
 1191 0ad6 488D3500 		leaq	.LC11(%rip), %rsi
 1191      000000
 1192 0add 4889C7   		movq	%rax, %rdi
 1193 0ae0 B8000000 		movl	$0, %eax
 1193      00
 1194 0ae5 E8000000 		call	errRender@PLT
 1194      00
 1195 0aea C745F80A 		movl	$10, -8(%rbp)
 1195      000000
 1196 0af1 EB30     		jmp	.L87
 1197              	.L88:
 298:libusbwrap.c  **** 		status < 0, USB_CONTROL, cleanup,
 299:libusbwrap.c  **** 		"usbControlRead(): %s", libusb_error_name(status));
 300:libusbwrap.c  **** 	CHECK_STATUS(
 1198              		.loc 3 300 0 is_stmt 1
 1199 0af3 0FB745D8 		movzwl	-40(%rbp), %eax
 1200 0af7 3B45FC   		cmpl	-4(%rbp), %eax
 1201 0afa 7427     		je	.L87
 1202              		.loc 3 300 0 is_stmt 0 discriminator 1
 1203 0afc 0FB755D8 		movzwl	-40(%rbp), %edx
 1204 0b00 8B4DFC   		movl	-4(%rbp), %ecx
 1205 0b03 488B4518 		movq	24(%rbp), %rax
 1206 0b07 488D3500 		leaq	.LC12(%rip), %rsi
 1206      000000
 1207 0b0e 4889C7   		movq	%rax, %rdi
 1208 0b11 B8000000 		movl	$0, %eax
 1208      00
 1209 0b16 E8000000 		call	errRender@PLT
 1209      00
 1210 0b1b C745F80A 		movl	$10, -8(%rbp)
 1210      000000
 1211 0b22 90       		nop
 1212              	.L87:
 301:libusbwrap.c  **** 		status != wLength, USB_CONTROL, cleanup,
 302:libusbwrap.c  **** 		"usbControlRead(): Expected to read %d bytes but actually read %d", wLength, status);
 303:libusbwrap.c  **** cleanup:
 304:libusbwrap.c  **** 	return retVal;
 1213              		.loc 3 304 0 is_stmt 1
 1214 0b23 8B45F8   		movl	-8(%rbp), %eax
 305:libusbwrap.c  **** }
 1215              		.loc 3 305 0
 1216 0b26 C9       		leave
 1217              		.cfi_def_cfa 7, 8
 1218 0b27 C3       		ret
 1219              		.cfi_endproc
 1220              	.LFE28:
 1222              		.section	.rodata
 1223              	.LC13:
 1224 0259 75736243 		.string	"usbControlWrite(): Timeout"
 1224      6F6E7472 
 1224      6F6C5772 
 1224      69746528 
 1224      293A2054 
 1225              	.LC14:
 1226 0274 75736243 		.string	"usbControlWrite(): %s"
 1226      6F6E7472 
 1226      6F6C5772 
 1226      69746528 
 1226      293A2025 
 1227 028a 00000000 		.align 8
 1227      0000
 1228              	.LC15:
 1229 0290 75736243 		.string	"usbControlWrite(): Expected to write %d bytes but actually wrote %d"
 1229      6F6E7472 
 1229      6F6C5772 
 1229      69746528 
 1229      293A2045 
 1230              		.text
 1231              		.globl	usbControlWrite
 1233              	usbControlWrite:
 1234              	.LFB29:
 306:libusbwrap.c  **** 
 307:libusbwrap.c  **** DLLEXPORT(USBStatus) usbControlWrite(
 308:libusbwrap.c  **** 	struct USBDevice *dev, uint8 bRequest, uint16 wValue, uint16 wIndex,
 309:libusbwrap.c  **** 	const uint8 *data, uint16 wLength,
 310:libusbwrap.c  **** 	uint32 timeout, const char **error)
 311:libusbwrap.c  **** {
 1235              		.loc 3 311 0
 1236              		.cfi_startproc
 1237 0b28 55       		pushq	%rbp
 1238              		.cfi_def_cfa_offset 16
 1239              		.cfi_offset 6, -16
 1240 0b29 4889E5   		movq	%rsp, %rbp
 1241              		.cfi_def_cfa_register 6
 1242 0b2c 4883EC40 		subq	$64, %rsp
 1243 0b30 48897DE8 		movq	%rdi, -24(%rbp)
 1244 0b34 89C8     		movl	%ecx, %eax
 1245 0b36 4C8945D0 		movq	%r8, -48(%rbp)
 1246 0b3a 4489C9   		movl	%r9d, %ecx
 1247 0b3d 408875E4 		movb	%sil, -28(%rbp)
 1248 0b41 668955E0 		movw	%dx, -32(%rbp)
 1249 0b45 668945DC 		movw	%ax, -36(%rbp)
 1250 0b49 66894DD8 		movw	%cx, -40(%rbp)
 312:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 1251              		.loc 3 312 0
 1252 0b4d C745F800 		movl	$0, -8(%rbp)
 1252      000000
 313:libusbwrap.c  **** 	int status = libusb_control_transfer(
 1253              		.loc 3 313 0
 1254 0b54 0FB775D8 		movzwl	-40(%rbp), %esi
 1255 0b58 440FB745 		movzwl	-36(%rbp), %r8d
 1255      DC
 1256 0b5d 0FB74DE0 		movzwl	-32(%rbp), %ecx
 1257 0b61 0FB655E4 		movzbl	-28(%rbp), %edx
 314:libusbwrap.c  **** 		dev->handle,
 1258              		.loc 3 314 0
 1259 0b65 488B45E8 		movq	-24(%rbp), %rax
 1260 0b69 488B00   		movq	(%rax), %rax
 313:libusbwrap.c  **** 	int status = libusb_control_transfer(
 1261              		.loc 3 313 0
 1262 0b6c 4C8B4DD0 		movq	-48(%rbp), %r9
 1263 0b70 8B7D10   		movl	16(%rbp), %edi
 1264 0b73 897C2408 		movl	%edi, 8(%rsp)
 1265 0b77 893424   		movl	%esi, (%rsp)
 1266 0b7a BE400000 		movl	$64, %esi
 1266      00
 1267 0b7f 4889C7   		movq	%rax, %rdi
 1268 0b82 E8000000 		call	libusb_control_transfer@PLT
 1268      00
 1269 0b87 8945FC   		movl	%eax, -4(%rbp)
 315:libusbwrap.c  **** 		LIBUSB_ENDPOINT_OUT | LIBUSB_REQUEST_TYPE_VENDOR | LIBUSB_RECIPIENT_DEVICE,
 316:libusbwrap.c  **** 		bRequest,
 317:libusbwrap.c  **** 		wValue,
 318:libusbwrap.c  **** 		wIndex,
 319:libusbwrap.c  **** 		(uint8 *)data,
 320:libusbwrap.c  **** 		wLength,
 321:libusbwrap.c  **** 		timeout
 322:libusbwrap.c  **** 	);
 323:libusbwrap.c  **** 	CHECK_STATUS(
 1270              		.loc 3 323 0
 1271 0b8a 837DFCF9 		cmpl	$-7, -4(%rbp)
 1272 0b8e 751C     		jne	.L91
 1273              		.loc 3 323 0 is_stmt 0 discriminator 1
 1274 0b90 488B4518 		movq	24(%rbp), %rax
 1275 0b94 488D3500 		leaq	.LC13(%rip), %rsi
 1275      000000
 1276 0b9b 4889C7   		movq	%rax, %rdi
 1277 0b9e E8000000 		call	errPrefix@PLT
 1277      00
 1278 0ba3 C745F812 		movl	$18, -8(%rbp)
 1278      000000
 1279 0baa EB64     		jmp	.L92
 1280              	.L91:
 324:libusbwrap.c  **** 		status == LIBUSB_ERROR_TIMEOUT, USB_TIMEOUT, cleanup,
 325:libusbwrap.c  **** 		"usbControlWrite(): Timeout");
 326:libusbwrap.c  **** 	CHECK_STATUS(
 1281              		.loc 3 326 0 is_stmt 1
 1282 0bac 837DFC00 		cmpl	$0, -4(%rbp)
 1283 0bb0 792E     		jns	.L93
 1284              		.loc 3 326 0 is_stmt 0 discriminator 1
 1285 0bb2 8B45FC   		movl	-4(%rbp), %eax
 1286 0bb5 89C7     		movl	%eax, %edi
 1287 0bb7 E8000000 		call	libusb_error_name@PLT
 1287      00
 1288 0bbc 4889C2   		movq	%rax, %rdx
 1289 0bbf 488B4518 		movq	24(%rbp), %rax
 1290 0bc3 488D3500 		leaq	.LC14(%rip), %rsi
 1290      000000
 1291 0bca 4889C7   		movq	%rax, %rdi
 1292 0bcd B8000000 		movl	$0, %eax
 1292      00
 1293 0bd2 E8000000 		call	errRender@PLT
 1293      00
 1294 0bd7 C745F80A 		movl	$10, -8(%rbp)
 1294      000000
 1295 0bde EB30     		jmp	.L92
 1296              	.L93:
 327:libusbwrap.c  **** 		status < 0, USB_CONTROL, cleanup,
 328:libusbwrap.c  **** 		"usbControlWrite(): %s", libusb_error_name(status));
 329:libusbwrap.c  **** 	CHECK_STATUS(
 1297              		.loc 3 329 0 is_stmt 1
 1298 0be0 0FB745D8 		movzwl	-40(%rbp), %eax
 1299 0be4 3B45FC   		cmpl	-4(%rbp), %eax
 1300 0be7 7427     		je	.L92
 1301              		.loc 3 329 0 is_stmt 0 discriminator 1
 1302 0be9 0FB755D8 		movzwl	-40(%rbp), %edx
 1303 0bed 8B4DFC   		movl	-4(%rbp), %ecx
 1304 0bf0 488B4518 		movq	24(%rbp), %rax
 1305 0bf4 488D3500 		leaq	.LC15(%rip), %rsi
 1305      000000
 1306 0bfb 4889C7   		movq	%rax, %rdi
 1307 0bfe B8000000 		movl	$0, %eax
 1307      00
 1308 0c03 E8000000 		call	errRender@PLT
 1308      00
 1309 0c08 C745F80A 		movl	$10, -8(%rbp)
 1309      000000
 1310 0c0f 90       		nop
 1311              	.L92:
 330:libusbwrap.c  **** 		status != wLength, USB_CONTROL, cleanup,
 331:libusbwrap.c  **** 		"usbControlWrite(): Expected to write %d bytes but actually wrote %d", wLength, status);
 332:libusbwrap.c  **** cleanup:
 333:libusbwrap.c  **** 	return retVal;
 1312              		.loc 3 333 0 is_stmt 1
 1313 0c10 8B45F8   		movl	-8(%rbp), %eax
 334:libusbwrap.c  **** }
 1314              		.loc 3 334 0
 1315 0c13 C9       		leave
 1316              		.cfi_def_cfa 7, 8
 1317 0c14 C3       		ret
 1318              		.cfi_endproc
 1319              	.LFE29:
 1321              		.section	.rodata
 1322              	.LC16:
 1323 02d4 75736242 		.string	"usbBulkRead(): Timeout"
 1323      756C6B52 
 1323      65616428 
 1323      293A2054 
 1323      696D656F 
 1324              	.LC17:
 1325 02eb 75736242 		.string	"usbBulkRead(): %s"
 1325      756C6B52 
 1325      65616428 
 1325      293A2025 
 1325      7300
 1326 02fd 000000   		.align 8
 1327              	.LC18:
 1328 0300 75736242 		.string	"usbBulkRead(): Expected to read %d bytes but actually read %d (status = %d): %s"
 1328      756C6B52 
 1328      65616428 
 1328      293A2045 
 1328      78706563 
 1329              		.text
 1330              		.globl	usbBulkRead
 1332              	usbBulkRead:
 1333              	.LFB30:
 335:libusbwrap.c  **** 
 336:libusbwrap.c  **** DLLEXPORT(USBStatus) usbBulkRead(
 337:libusbwrap.c  **** 	struct USBDevice *dev, uint8 endpoint, uint8 *data, uint32 count,
 338:libusbwrap.c  **** 	uint32 timeout, const char **error)
 339:libusbwrap.c  **** {
 1334              		.loc 3 339 0
 1335              		.cfi_startproc
 1336 0c15 55       		pushq	%rbp
 1337              		.cfi_def_cfa_offset 16
 1338              		.cfi_offset 6, -16
 1339 0c16 4889E5   		movq	%rsp, %rbp
 1340              		.cfi_def_cfa_register 6
 1341 0c19 4883EC40 		subq	$64, %rsp
 1342 0c1d 48897DE8 		movq	%rdi, -24(%rbp)
 1343 0c21 89F0     		movl	%esi, %eax
 1344 0c23 488955D8 		movq	%rdx, -40(%rbp)
 1345 0c27 894DE0   		movl	%ecx, -32(%rbp)
 1346 0c2a 448945D4 		movl	%r8d, -44(%rbp)
 1347 0c2e 4C894DC8 		movq	%r9, -56(%rbp)
 1348 0c32 8845E4   		movb	%al, -28(%rbp)
 340:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 1349              		.loc 3 340 0
 1350 0c35 C745F800 		movl	$0, -8(%rbp)
 1350      000000
 341:libusbwrap.c  **** 	int numRead;
 342:libusbwrap.c  **** 	int status = libusb_bulk_transfer(
 1351              		.loc 3 342 0
 1352 0c3c 8B4DE0   		movl	-32(%rbp), %ecx
 1353 0c3f 0FB645E4 		movzbl	-28(%rbp), %eax
 1354 0c43 83C880   		orl	$-128, %eax
 1355 0c46 0FB6F0   		movzbl	%al, %esi
 343:libusbwrap.c  **** 		dev->handle,
 1356              		.loc 3 343 0
 1357 0c49 488B45E8 		movq	-24(%rbp), %rax
 1358 0c4d 488B00   		movq	(%rax), %rax
 342:libusbwrap.c  **** 		dev->handle,
 1359              		.loc 3 342 0
 1360 0c50 448B45D4 		movl	-44(%rbp), %r8d
 1361 0c54 488D7DF4 		leaq	-12(%rbp), %rdi
 1362 0c58 488B55D8 		movq	-40(%rbp), %rdx
 1363 0c5c 4589C1   		movl	%r8d, %r9d
 1364 0c5f 4989F8   		movq	%rdi, %r8
 1365 0c62 4889C7   		movq	%rax, %rdi
 1366 0c65 E8000000 		call	libusb_bulk_transfer@PLT
 1366      00
 1367 0c6a 8945FC   		movl	%eax, -4(%rbp)
 344:libusbwrap.c  **** 		LIBUSB_ENDPOINT_IN | endpoint,
 345:libusbwrap.c  **** 		data,
 346:libusbwrap.c  **** 		(int)count,
 347:libusbwrap.c  **** 		&numRead,
 348:libusbwrap.c  **** 		timeout
 349:libusbwrap.c  **** 	);
 350:libusbwrap.c  **** 	CHECK_STATUS(
 1368              		.loc 3 350 0
 1369 0c6d 837DFCF9 		cmpl	$-7, -4(%rbp)
 1370 0c71 751C     		jne	.L96
 1371              		.loc 3 350 0 is_stmt 0 discriminator 1
 1372 0c73 488B45C8 		movq	-56(%rbp), %rax
 1373 0c77 488D3500 		leaq	.LC16(%rip), %rsi
 1373      000000
 1374 0c7e 4889C7   		movq	%rax, %rdi
 1375 0c81 E8000000 		call	errPrefix@PLT
 1375      00
 1376 0c86 C745F812 		movl	$18, -8(%rbp)
 1376      000000
 1377 0c8d EB78     		jmp	.L97
 1378              	.L96:
 351:libusbwrap.c  **** 		status == LIBUSB_ERROR_TIMEOUT, USB_TIMEOUT, cleanup,
 352:libusbwrap.c  **** 		"usbBulkRead(): Timeout");
 353:libusbwrap.c  **** 	CHECK_STATUS(
 1379              		.loc 3 353 0 is_stmt 1
 1380 0c8f 837DFC00 		cmpl	$0, -4(%rbp)
 1381 0c93 792E     		jns	.L98
 1382              		.loc 3 353 0 is_stmt 0 discriminator 1
 1383 0c95 8B45FC   		movl	-4(%rbp), %eax
 1384 0c98 89C7     		movl	%eax, %edi
 1385 0c9a E8000000 		call	libusb_error_name@PLT
 1385      00
 1386 0c9f 4889C2   		movq	%rax, %rdx
 1387 0ca2 488B45C8 		movq	-56(%rbp), %rax
 1388 0ca6 488D3500 		leaq	.LC17(%rip), %rsi
 1388      000000
 1389 0cad 4889C7   		movq	%rax, %rdi
 1390 0cb0 B8000000 		movl	$0, %eax
 1390      00
 1391 0cb5 E8000000 		call	errRender@PLT
 1391      00
 1392 0cba C745F80B 		movl	$11, -8(%rbp)
 1392      000000
 1393 0cc1 EB44     		jmp	.L97
 1394              	.L98:
 354:libusbwrap.c  **** 		status < 0, USB_BULK, cleanup,
 355:libusbwrap.c  **** 		"usbBulkRead(): %s", libusb_error_name(status));
 356:libusbwrap.c  **** 	CHECK_STATUS(
 1395              		.loc 3 356 0 is_stmt 1
 1396 0cc3 8B45F4   		movl	-12(%rbp), %eax
 1397 0cc6 3B45E0   		cmpl	-32(%rbp), %eax
 1398 0cc9 743C     		je	.L97
 1399              		.loc 3 356 0 is_stmt 0 discriminator 1
 1400 0ccb 8B45FC   		movl	-4(%rbp), %eax
 1401 0cce 89C7     		movl	%eax, %edi
 1402 0cd0 E8000000 		call	libusb_error_name@PLT
 1402      00
 1403 0cd5 4889C6   		movq	%rax, %rsi
 1404 0cd8 8B4DF4   		movl	-12(%rbp), %ecx
 1405 0cdb 8B7DFC   		movl	-4(%rbp), %edi
 1406 0cde 8B55E0   		movl	-32(%rbp), %edx
 1407 0ce1 488B45C8 		movq	-56(%rbp), %rax
 1408 0ce5 4989F1   		movq	%rsi, %r9
 1409 0ce8 4189F8   		movl	%edi, %r8d
 1410 0ceb 488D3500 		leaq	.LC18(%rip), %rsi
 1410      000000
 1411 0cf2 4889C7   		movq	%rax, %rdi
 1412 0cf5 B8000000 		movl	$0, %eax
 1412      00
 1413 0cfa E8000000 		call	errRender@PLT
 1413      00
 1414 0cff C745F80B 		movl	$11, -8(%rbp)
 1414      000000
 1415 0d06 90       		nop
 1416              	.L97:
 357:libusbwrap.c  **** 		(uint32)numRead != count, USB_BULK, cleanup,
 358:libusbwrap.c  **** 		"usbBulkRead(): Expected to read %d bytes but actually read %d (status = %d): %s",
 359:libusbwrap.c  **** 		count, numRead, status, libusb_error_name(status));
 360:libusbwrap.c  **** cleanup:
 361:libusbwrap.c  **** 	return retVal;
 1417              		.loc 3 361 0 is_stmt 1
 1418 0d07 8B45F8   		movl	-8(%rbp), %eax
 362:libusbwrap.c  **** }
 1419              		.loc 3 362 0
 1420 0d0a C9       		leave
 1421              		.cfi_def_cfa 7, 8
 1422 0d0b C3       		ret
 1423              		.cfi_endproc
 1424              	.LFE30:
 1426              		.section	.rodata
 1427              	.LC19:
 1428 0350 75736242 		.string	"usbBulkWrite(): Timeout"
 1428      756C6B57 
 1428      72697465 
 1428      28293A20 
 1428      54696D65 
 1429              	.LC20:
 1430 0368 75736242 		.string	"usbBulkWrite(): %s"
 1430      756C6B57 
 1430      72697465 
 1430      28293A20 
 1430      257300
 1431 037b 00000000 		.align 8
 1431      00
 1432              	.LC21:
 1433 0380 75736242 		.string	"usbBulkWrite(): Expected to write %d bytes but actually wrote %d (status = %d): %s"
 1433      756C6B57 
 1433      72697465 
 1433      28293A20 
 1433      45787065 
 1434              		.text
 1435              		.globl	usbBulkWrite
 1437              	usbBulkWrite:
 1438              	.LFB31:
 363:libusbwrap.c  **** 
 364:libusbwrap.c  **** DLLEXPORT(USBStatus) usbBulkWrite(
 365:libusbwrap.c  **** 	struct USBDevice *dev, uint8 endpoint, const uint8 *data, uint32 count,
 366:libusbwrap.c  **** 	uint32 timeout, const char **error)
 367:libusbwrap.c  **** {
 1439              		.loc 3 367 0
 1440              		.cfi_startproc
 1441 0d0c 55       		pushq	%rbp
 1442              		.cfi_def_cfa_offset 16
 1443              		.cfi_offset 6, -16
 1444 0d0d 4889E5   		movq	%rsp, %rbp
 1445              		.cfi_def_cfa_register 6
 1446 0d10 4883EC40 		subq	$64, %rsp
 1447 0d14 48897DE8 		movq	%rdi, -24(%rbp)
 1448 0d18 89F0     		movl	%esi, %eax
 1449 0d1a 488955D8 		movq	%rdx, -40(%rbp)
 1450 0d1e 894DE0   		movl	%ecx, -32(%rbp)
 1451 0d21 448945D4 		movl	%r8d, -44(%rbp)
 1452 0d25 4C894DC8 		movq	%r9, -56(%rbp)
 1453 0d29 8845E4   		movb	%al, -28(%rbp)
 368:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 1454              		.loc 3 368 0
 1455 0d2c C745F800 		movl	$0, -8(%rbp)
 1455      000000
 369:libusbwrap.c  **** 	int numWritten;
 370:libusbwrap.c  **** 	int status = libusb_bulk_transfer(
 1456              		.loc 3 370 0
 1457 0d33 8B4DE0   		movl	-32(%rbp), %ecx
 1458 0d36 0FB675E4 		movzbl	-28(%rbp), %esi
 371:libusbwrap.c  **** 		dev->handle,
 1459              		.loc 3 371 0
 1460 0d3a 488B45E8 		movq	-24(%rbp), %rax
 1461 0d3e 488B00   		movq	(%rax), %rax
 370:libusbwrap.c  **** 		dev->handle,
 1462              		.loc 3 370 0
 1463 0d41 448B45D4 		movl	-44(%rbp), %r8d
 1464 0d45 488D7DF4 		leaq	-12(%rbp), %rdi
 1465 0d49 488B55D8 		movq	-40(%rbp), %rdx
 1466 0d4d 4589C1   		movl	%r8d, %r9d
 1467 0d50 4989F8   		movq	%rdi, %r8
 1468 0d53 4889C7   		movq	%rax, %rdi
 1469 0d56 E8000000 		call	libusb_bulk_transfer@PLT
 1469      00
 1470 0d5b 8945FC   		movl	%eax, -4(%rbp)
 372:libusbwrap.c  **** 		LIBUSB_ENDPOINT_OUT | endpoint,
 373:libusbwrap.c  **** 		(uint8 *)data,
 374:libusbwrap.c  **** 		(int)count,
 375:libusbwrap.c  **** 		&numWritten,
 376:libusbwrap.c  **** 		timeout
 377:libusbwrap.c  **** 	);
 378:libusbwrap.c  **** 	CHECK_STATUS(
 1471              		.loc 3 378 0
 1472 0d5e 837DFCF9 		cmpl	$-7, -4(%rbp)
 1473 0d62 751C     		jne	.L101
 1474              		.loc 3 378 0 is_stmt 0 discriminator 1
 1475 0d64 488B45C8 		movq	-56(%rbp), %rax
 1476 0d68 488D3500 		leaq	.LC19(%rip), %rsi
 1476      000000
 1477 0d6f 4889C7   		movq	%rax, %rdi
 1478 0d72 E8000000 		call	errPrefix@PLT
 1478      00
 1479 0d77 C745F812 		movl	$18, -8(%rbp)
 1479      000000
 1480 0d7e EB78     		jmp	.L102
 1481              	.L101:
 379:libusbwrap.c  **** 		status == LIBUSB_ERROR_TIMEOUT, USB_TIMEOUT, cleanup,
 380:libusbwrap.c  **** 		"usbBulkWrite(): Timeout");
 381:libusbwrap.c  **** 	CHECK_STATUS(
 1482              		.loc 3 381 0 is_stmt 1
 1483 0d80 837DFC00 		cmpl	$0, -4(%rbp)
 1484 0d84 792E     		jns	.L103
 1485              		.loc 3 381 0 is_stmt 0 discriminator 1
 1486 0d86 8B45FC   		movl	-4(%rbp), %eax
 1487 0d89 89C7     		movl	%eax, %edi
 1488 0d8b E8000000 		call	libusb_error_name@PLT
 1488      00
 1489 0d90 4889C2   		movq	%rax, %rdx
 1490 0d93 488B45C8 		movq	-56(%rbp), %rax
 1491 0d97 488D3500 		leaq	.LC20(%rip), %rsi
 1491      000000
 1492 0d9e 4889C7   		movq	%rax, %rdi
 1493 0da1 B8000000 		movl	$0, %eax
 1493      00
 1494 0da6 E8000000 		call	errRender@PLT
 1494      00
 1495 0dab C745F80B 		movl	$11, -8(%rbp)
 1495      000000
 1496 0db2 EB44     		jmp	.L102
 1497              	.L103:
 382:libusbwrap.c  **** 		status < 0, USB_BULK, cleanup,
 383:libusbwrap.c  **** 		"usbBulkWrite(): %s", libusb_error_name(status));
 384:libusbwrap.c  **** 	CHECK_STATUS(
 1498              		.loc 3 384 0 is_stmt 1
 1499 0db4 8B45F4   		movl	-12(%rbp), %eax
 1500 0db7 3B45E0   		cmpl	-32(%rbp), %eax
 1501 0dba 743C     		je	.L102
 1502              		.loc 3 384 0 is_stmt 0 discriminator 1
 1503 0dbc 8B45FC   		movl	-4(%rbp), %eax
 1504 0dbf 89C7     		movl	%eax, %edi
 1505 0dc1 E8000000 		call	libusb_error_name@PLT
 1505      00
 1506 0dc6 4889C6   		movq	%rax, %rsi
 1507 0dc9 8B4DF4   		movl	-12(%rbp), %ecx
 1508 0dcc 8B7DFC   		movl	-4(%rbp), %edi
 1509 0dcf 8B55E0   		movl	-32(%rbp), %edx
 1510 0dd2 488B45C8 		movq	-56(%rbp), %rax
 1511 0dd6 4989F1   		movq	%rsi, %r9
 1512 0dd9 4189F8   		movl	%edi, %r8d
 1513 0ddc 488D3500 		leaq	.LC21(%rip), %rsi
 1513      000000
 1514 0de3 4889C7   		movq	%rax, %rdi
 1515 0de6 B8000000 		movl	$0, %eax
 1515      00
 1516 0deb E8000000 		call	errRender@PLT
 1516      00
 1517 0df0 C745F80B 		movl	$11, -8(%rbp)
 1517      000000
 1518 0df7 90       		nop
 1519              	.L102:
 385:libusbwrap.c  **** 		(uint32)numWritten != count, USB_BULK, cleanup,
 386:libusbwrap.c  **** 		"usbBulkWrite(): Expected to write %d bytes but actually wrote %d (status = %d): %s",
 387:libusbwrap.c  **** 		count, numWritten, status, libusb_error_name(status));
 388:libusbwrap.c  **** cleanup:
 389:libusbwrap.c  **** 	return retVal;
 1520              		.loc 3 389 0 is_stmt 1
 1521 0df8 8B45F8   		movl	-8(%rbp), %eax
 390:libusbwrap.c  **** }
 1522              		.loc 3 390 0
 1523 0dfb C9       		leave
 1524              		.cfi_def_cfa 7, 8
 1525 0dfc C3       		ret
 1526              		.cfi_endproc
 1527              	.LFE31:
 1530              	bulk_transfer_cb:
 1531              	.LFB32:
 391:libusbwrap.c  **** 
 392:libusbwrap.c  **** static void LIBUSB_CALL bulk_transfer_cb(struct libusb_transfer *transfer) {
 1532              		.loc 3 392 0
 1533              		.cfi_startproc
 1534 0dfd 55       		pushq	%rbp
 1535              		.cfi_def_cfa_offset 16
 1536              		.cfi_offset 6, -16
 1537 0dfe 4889E5   		movq	%rsp, %rbp
 1538              		.cfi_def_cfa_register 6
 1539 0e01 48897DE8 		movq	%rdi, -24(%rbp)
 393:libusbwrap.c  **** 	int *completed = transfer->user_data;
 1540              		.loc 3 393 0
 1541 0e05 488B45E8 		movq	-24(%rbp), %rax
 1542 0e09 488B4028 		movq	40(%rax), %rax
 1543 0e0d 488945F8 		movq	%rax, -8(%rbp)
 394:libusbwrap.c  **** 	*completed = 1;
 1544              		.loc 3 394 0
 1545 0e11 488B45F8 		movq	-8(%rbp), %rax
 1546 0e15 C7000100 		movl	$1, (%rax)
 1546      0000
 395:libusbwrap.c  **** }
 1547              		.loc 3 395 0
 1548 0e1b 5D       		popq	%rbp
 1549              		.cfi_def_cfa 7, 8
 1550 0e1c C3       		ret
 1551              		.cfi_endproc
 1552              	.LFE32:
 1554              		.section	.rodata
 1555 03d3 00000000 		.align 8
 1555      00
 1556              	.LC22:
 1557 03d8 75736242 		.string	"usbBulkWriteAsync(): Submission error: %s"
 1557      756C6B57 
 1557      72697465 
 1557      4173796E 
 1557      6328293A 
 1558              		.text
 1559              		.globl	usbBulkWriteAsync
 1561              	usbBulkWriteAsync:
 1562              	.LFB33:
 396:libusbwrap.c  **** 
 397:libusbwrap.c  **** DLLEXPORT(USBStatus) usbBulkWriteAsync(
 398:libusbwrap.c  **** 	struct USBDevice *dev, uint8 endpoint, const uint8 *buffer, uint32 length, uint32 timeout,
 399:libusbwrap.c  **** 	const char **error)
 400:libusbwrap.c  **** {
 1563              		.loc 3 400 0
 1564              		.cfi_startproc
 1565 0e1d 55       		pushq	%rbp
 1566              		.cfi_def_cfa_offset 16
 1567              		.cfi_offset 6, -16
 1568 0e1e 4889E5   		movq	%rsp, %rbp
 1569              		.cfi_def_cfa_register 6
 1570 0e21 4883EC70 		subq	$112, %rsp
 1571 0e25 48897DC8 		movq	%rdi, -56(%rbp)
 1572 0e29 89F0     		movl	%esi, %eax
 1573 0e2b 488955B8 		movq	%rdx, -72(%rbp)
 1574 0e2f 894DC0   		movl	%ecx, -64(%rbp)
 1575 0e32 448945B4 		movl	%r8d, -76(%rbp)
 1576 0e36 4C894DA8 		movq	%r9, -88(%rbp)
 1577 0e3a 8845C4   		movb	%al, -60(%rbp)
 401:libusbwrap.c  **** 	int retVal = USB_SUCCESS;
 1578              		.loc 3 401 0
 1579 0e3d C745DC00 		movl	$0, -36(%rbp)
 1579      000000
 402:libusbwrap.c  **** 	struct TransferWrapper *wrapper;
 403:libusbwrap.c  **** 	struct libusb_transfer *transfer;
 404:libusbwrap.c  **** 	int *completed;
 405:libusbwrap.c  **** 	int iStatus;
 406:libusbwrap.c  **** 	USBStatus uStatus = queuePut(&dev->queue, (Item*)&wrapper);
 1580              		.loc 3 406 0
 1581 0e44 488B45C8 		movq	-56(%rbp), %rax
 1582 0e48 488D5008 		leaq	8(%rax), %rdx
 1583 0e4c 488D45E8 		leaq	-24(%rbp), %rax
 1584 0e50 4889C6   		movq	%rax, %rsi
 1585 0e53 4889D7   		movq	%rdx, %rdi
 1586 0e56 E8000000 		call	queuePut@PLT
 1586      00
 1587 0e5b 8945E0   		movl	%eax, -32(%rbp)
 407:libusbwrap.c  **** 	CHECK_STATUS(uStatus, uStatus, cleanup);
 1588              		.loc 3 407 0
 1589 0e5e 837DE000 		cmpl	$0, -32(%rbp)
 1590 0e62 740B     		je	.L107
 1591              		.loc 3 407 0 is_stmt 0 discriminator 1
 1592 0e64 8B45E0   		movl	-32(%rbp), %eax
 1593 0e67 8945DC   		movl	%eax, -36(%rbp)
 1594 0e6a E9BF0000 		jmp	.L108
 1594      00
 1595              	.L107:
 408:libusbwrap.c  **** 	transfer = wrapper->transfer;
 1596              		.loc 3 408 0 is_stmt 1
 1597 0e6f 488B45E8 		movq	-24(%rbp), %rax
 1598 0e73 488B00   		movq	(%rax), %rax
 1599 0e76 488945F0 		movq	%rax, -16(%rbp)
 409:libusbwrap.c  **** 	completed = &wrapper->completed;
 1600              		.loc 3 409 0
 1601 0e7a 488B45E8 		movq	-24(%rbp), %rax
 1602 0e7e 4883C008 		addq	$8, %rax
 1603 0e82 488945F8 		movq	%rax, -8(%rbp)
 410:libusbwrap.c  **** 	*completed = 0;
 1604              		.loc 3 410 0
 1605 0e86 488B45F8 		movq	-8(%rbp), %rax
 1606 0e8a C7000000 		movl	$0, (%rax)
 1606      0000
 411:libusbwrap.c  **** 	wrapper->flags.isRead = 0;
 1607              		.loc 3 411 0
 1608 0e90 488B45E8 		movq	-24(%rbp), %rax
 1609 0e94 0FB6500C 		movzbl	12(%rax), %edx
 1610 0e98 83E2FE   		andl	$-2, %edx
 1611 0e9b 88500C   		movb	%dl, 12(%rax)
 412:libusbwrap.c  **** 	libusb_fill_bulk_transfer(
 1612              		.loc 3 412 0
 1613 0e9e 448B45C0 		movl	-64(%rbp), %r8d
 1614 0ea2 0FB655C4 		movzbl	-60(%rbp), %edx
 413:libusbwrap.c  **** 		transfer, dev->handle, LIBUSB_ENDPOINT_OUT | endpoint, (uint8 *)buffer, (int)length,
 1615              		.loc 3 413 0
 1616 0ea6 488B45C8 		movq	-56(%rbp), %rax
 1617 0eaa 488B30   		movq	(%rax), %rsi
 412:libusbwrap.c  **** 	libusb_fill_bulk_transfer(
 1618              		.loc 3 412 0
 1619 0ead 488B4DB8 		movq	-72(%rbp), %rcx
 1620 0eb1 488B45F0 		movq	-16(%rbp), %rax
 1621 0eb5 8B7DB4   		movl	-76(%rbp), %edi
 1622 0eb8 897C2408 		movl	%edi, 8(%rsp)
 1623 0ebc 488B7DF8 		movq	-8(%rbp), %rdi
 1624 0ec0 48893C24 		movq	%rdi, (%rsp)
 1625 0ec4 4C8D0D32 		leaq	bulk_transfer_cb(%rip), %r9
 1625      FFFFFF
 1626 0ecb 4889C7   		movq	%rax, %rdi
 1627 0ece E83FF1FF 		call	libusb_fill_bulk_transfer
 1627      FF
 414:libusbwrap.c  **** 		bulk_transfer_cb, completed, timeout
 415:libusbwrap.c  **** 	);
 416:libusbwrap.c  **** 	transfer->type = LIBUSB_TRANSFER_TYPE_BULK;
 1628              		.loc 3 416 0
 1629 0ed3 488B45F0 		movq	-16(%rbp), %rax
 1630 0ed7 C6400A02 		movb	$2, 10(%rax)
 417:libusbwrap.c  **** 	iStatus = libusb_submit_transfer(transfer);
 1631              		.loc 3 417 0
 1632 0edb 488B45F0 		movq	-16(%rbp), %rax
 1633 0edf 4889C7   		movq	%rax, %rdi
 1634 0ee2 E8000000 		call	libusb_submit_transfer@PLT
 1634      00
 1635 0ee7 8945E4   		movl	%eax, -28(%rbp)
 418:libusbwrap.c  **** 	CHECK_STATUS(
 1636              		.loc 3 418 0
 1637 0eea 837DE400 		cmpl	$0, -28(%rbp)
 1638 0eee 742E     		je	.L109
 1639              		.loc 3 418 0 is_stmt 0 discriminator 1
 1640 0ef0 8B45E4   		movl	-28(%rbp), %eax
 1641 0ef3 89C7     		movl	%eax, %edi
 1642 0ef5 E8000000 		call	libusb_error_name@PLT
 1642      00
 1643 0efa 4889C2   		movq	%rax, %rdx
 1644 0efd 488B45A8 		movq	-88(%rbp), %rax
 1645 0f01 488D3500 		leaq	.LC22(%rip), %rsi
 1645      000000
 1646 0f08 4889C7   		movq	%rax, %rdi
 1647 0f0b B8000000 		movl	$0, %eax
 1647      00
 1648 0f10 E8000000 		call	errRender@PLT
 1648      00
 1649 0f15 C745DC0E 		movl	$14, -36(%rbp)
 1649      000000
 1650 0f1c EB10     		jmp	.L108
 1651              	.L109:
 419:libusbwrap.c  **** 		iStatus, USB_ASYNC_SUBMIT, cleanup,
 420:libusbwrap.c  **** 		"usbBulkWriteAsync(): Submission error: %s", libusb_error_name(iStatus)
 421:libusbwrap.c  **** 	);
 422:libusbwrap.c  **** 	queueCommitPut(&dev->queue);
 1652              		.loc 3 422 0 is_stmt 1
 1653 0f1e 488B45C8 		movq	-56(%rbp), %rax
 1654 0f22 4883C008 		addq	$8, %rax
 1655 0f26 4889C7   		movq	%rax, %rdi
 1656 0f29 E8000000 		call	queueCommitPut@PLT
 1656      00
 1657              	.L108:
 423:libusbwrap.c  **** cleanup:
 424:libusbwrap.c  **** 	return retVal;
 1658              		.loc 3 424 0
 1659 0f2e 8B45DC   		movl	-36(%rbp), %eax
 425:libusbwrap.c  **** }
 1660              		.loc 3 425 0
 1661 0f31 C9       		leave
 1662              		.cfi_def_cfa 7, 8
 1663 0f32 C3       		ret
 1664              		.cfi_endproc
 1665              	.LFE33:
 1667              		.section	.rodata
 1668 0402 00000000 		.align 8
 1668      0000
 1669              	.LC23:
 1670 0408 75736242 		.string	"usbBulkWriteAsyncPrepare(): Work queue insertion error"
 1670      756C6B57 
 1670      72697465 
 1670      4173796E 
 1670      63507265 
 1671              		.text
 1672              		.globl	usbBulkWriteAsyncPrepare
 1674              	usbBulkWriteAsyncPrepare:
 1675              	.LFB34:
 426:libusbwrap.c  **** 
 427:libusbwrap.c  **** DLLEXPORT(USBStatus) usbBulkWriteAsyncPrepare(
 428:libusbwrap.c  **** 	struct USBDevice *dev, uint8 **buffer, const char **error)
 429:libusbwrap.c  **** {
 1676              		.loc 3 429 0
 1677              		.cfi_startproc
 1678 0f33 55       		pushq	%rbp
 1679              		.cfi_def_cfa_offset 16
 1680              		.cfi_offset 6, -16
 1681 0f34 4889E5   		movq	%rsp, %rbp
 1682              		.cfi_def_cfa_register 6
 1683 0f37 4883EC30 		subq	$48, %rsp
 1684 0f3b 48897DE8 		movq	%rdi, -24(%rbp)
 1685 0f3f 488975E0 		movq	%rsi, -32(%rbp)
 1686 0f43 488955D8 		movq	%rdx, -40(%rbp)
 430:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 1687              		.loc 3 430 0
 1688 0f47 C745F000 		movl	$0, -16(%rbp)
 1688      000000
 431:libusbwrap.c  **** 	struct TransferWrapper *wrapper;
 432:libusbwrap.c  **** 	USBStatus status = queuePut(&dev->queue, (Item*)&wrapper);
 1689              		.loc 3 432 0
 1690 0f4e 488B45E8 		movq	-24(%rbp), %rax
 1691 0f52 488D5008 		leaq	8(%rax), %rdx
 1692 0f56 488D45F8 		leaq	-8(%rbp), %rax
 1693 0f5a 4889C6   		movq	%rax, %rsi
 1694 0f5d 4889D7   		movq	%rdx, %rdi
 1695 0f60 E8000000 		call	queuePut@PLT
 1695      00
 1696 0f65 8945F4   		movl	%eax, -12(%rbp)
 433:libusbwrap.c  **** 	CHECK_STATUS(status, status, cleanup, "usbBulkWriteAsyncPrepare(): Work queue insertion error");
 1697              		.loc 3 433 0
 1698 0f68 837DF400 		cmpl	$0, -12(%rbp)
 1699 0f6c 741B     		je	.L112
 1700              		.loc 3 433 0 is_stmt 0 discriminator 1
 1701 0f6e 488B45D8 		movq	-40(%rbp), %rax
 1702 0f72 488D3500 		leaq	.LC23(%rip), %rsi
 1702      000000
 1703 0f79 4889C7   		movq	%rax, %rdi
 1704 0f7c E8000000 		call	errPrefix@PLT
 1704      00
 1705 0f81 8B45F4   		movl	-12(%rbp), %eax
 1706 0f84 8945F0   		movl	%eax, -16(%rbp)
 1707 0f87 EB0F     		jmp	.L113
 1708              	.L112:
 434:libusbwrap.c  **** 	*buffer = wrapper->buffer;
 1709              		.loc 3 434 0 is_stmt 1
 1710 0f89 488B45F8 		movq	-8(%rbp), %rax
 1711 0f8d 488D5010 		leaq	16(%rax), %rdx
 1712 0f91 488B45E0 		movq	-32(%rbp), %rax
 1713 0f95 488910   		movq	%rdx, (%rax)
 1714              	.L113:
 435:libusbwrap.c  **** cleanup:
 436:libusbwrap.c  **** 	return retVal;
 1715              		.loc 3 436 0
 1716 0f98 8B45F0   		movl	-16(%rbp), %eax
 437:libusbwrap.c  **** }
 1717              		.loc 3 437 0
 1718 0f9b C9       		leave
 1719              		.cfi_def_cfa 7, 8
 1720 0f9c C3       		ret
 1721              		.cfi_endproc
 1722              	.LFE34:
 1724              		.section	.rodata
 1725 043f 00       		.align 8
 1726              	.LC24:
 1727 0440 75736242 		.string	"usbBulkWriteAsyncSubmit(): Transfer length exceeds 0x10000"
 1727      756C6B57 
 1727      72697465 
 1727      4173796E 
 1727      63537562 
 1728 047b 00000000 		.align 8
 1728      00
 1729              	.LC25:
 1730 0480 75736242 		.string	"usbBulkWriteAsyncSubmit(): Work queue insertion error"
 1730      756C6B57 
 1730      72697465 
 1730      4173796E 
 1730      63537562 
 1731 04b6 0000     		.align 8
 1732              	.LC26:
 1733 04b8 75736242 		.string	"usbBulkWriteAsyncSubmit(): Submission error: %s"
 1733      756C6B57 
 1733      72697465 
 1733      4173796E 
 1733      63537562 
 1734              		.text
 1735              		.globl	usbBulkWriteAsyncSubmit
 1737              	usbBulkWriteAsyncSubmit:
 1738              	.LFB35:
 438:libusbwrap.c  **** 
 439:libusbwrap.c  **** DLLEXPORT(USBStatus) usbBulkWriteAsyncSubmit(
 440:libusbwrap.c  **** 	struct USBDevice *dev, uint8 endpoint, uint32 length, uint32 timeout, const char **error)
 441:libusbwrap.c  **** {
 1739              		.loc 3 441 0
 1740              		.cfi_startproc
 1741 0f9d 55       		pushq	%rbp
 1742              		.cfi_def_cfa_offset 16
 1743              		.cfi_offset 6, -16
 1744 0f9e 4889E5   		movq	%rsp, %rbp
 1745              		.cfi_def_cfa_register 6
 1746 0fa1 4883EC60 		subq	$96, %rsp
 1747 0fa5 48897DC8 		movq	%rdi, -56(%rbp)
 1748 0fa9 89F0     		movl	%esi, %eax
 1749 0fab 8955C0   		movl	%edx, -64(%rbp)
 1750 0fae 894DBC   		movl	%ecx, -68(%rbp)
 1751 0fb1 4C8945B0 		movq	%r8, -80(%rbp)
 1752 0fb5 8845C4   		movb	%al, -60(%rbp)
 442:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 1753              		.loc 3 442 0
 1754 0fb8 C745DC00 		movl	$0, -36(%rbp)
 1754      000000
 443:libusbwrap.c  **** 	struct TransferWrapper *wrapper;
 444:libusbwrap.c  **** 	struct libusb_transfer *transfer;
 445:libusbwrap.c  **** 	int *completed;
 446:libusbwrap.c  **** 	USBStatus uStatus;
 447:libusbwrap.c  **** 	int iStatus;
 448:libusbwrap.c  **** 	CHECK_STATUS(
 1755              		.loc 3 448 0
 1756 0fbf 817DC000 		cmpl	$65536, -64(%rbp)
 1756      000100
 1757 0fc6 761F     		jbe	.L116
 1758              		.loc 3 448 0 is_stmt 0 discriminator 1
 1759 0fc8 488B45B0 		movq	-80(%rbp), %rax
 1760 0fcc 488D3500 		leaq	.LC24(%rip), %rsi
 1760      000000
 1761 0fd3 4889C7   		movq	%rax, %rdi
 1762 0fd6 E8000000 		call	errPrefix@PLT
 1762      00
 1763 0fdb C745DC11 		movl	$17, -36(%rbp)
 1763      000000
 1764 0fe2 E9040100 		jmp	.L117
 1764      00
 1765              	.L116:
 449:libusbwrap.c  **** 		length > 0x10000, USB_ASYNC_SIZE, cleanup,
 450:libusbwrap.c  **** 		"usbBulkWriteAsyncSubmit(): Transfer length exceeds 0x10000");
 451:libusbwrap.c  **** 	uStatus = queuePut(&dev->queue, (Item*)&wrapper);
 1766              		.loc 3 451 0 is_stmt 1
 1767 0fe7 488B45C8 		movq	-56(%rbp), %rax
 1768 0feb 488D5008 		leaq	8(%rax), %rdx
 1769 0fef 488D45E8 		leaq	-24(%rbp), %rax
 1770 0ff3 4889C6   		movq	%rax, %rsi
 1771 0ff6 4889D7   		movq	%rdx, %rdi
 1772 0ff9 E8000000 		call	queuePut@PLT
 1772      00
 1773 0ffe 8945E0   		movl	%eax, -32(%rbp)
 452:libusbwrap.c  **** 	CHECK_STATUS(uStatus, uStatus, cleanup, "usbBulkWriteAsyncSubmit(): Work queue insertion error");
 1774              		.loc 3 452 0
 1775 1001 837DE000 		cmpl	$0, -32(%rbp)
 1776 1005 741E     		je	.L118
 1777              		.loc 3 452 0 is_stmt 0 discriminator 1
 1778 1007 488B45B0 		movq	-80(%rbp), %rax
 1779 100b 488D3500 		leaq	.LC25(%rip), %rsi
 1779      000000
 1780 1012 4889C7   		movq	%rax, %rdi
 1781 1015 E8000000 		call	errPrefix@PLT
 1781      00
 1782 101a 8B45E0   		movl	-32(%rbp), %eax
 1783 101d 8945DC   		movl	%eax, -36(%rbp)
 1784 1020 E9C60000 		jmp	.L117
 1784      00
 1785              	.L118:
 453:libusbwrap.c  **** 	transfer = wrapper->transfer;
 1786              		.loc 3 453 0 is_stmt 1
 1787 1025 488B45E8 		movq	-24(%rbp), %rax
 1788 1029 488B00   		movq	(%rax), %rax
 1789 102c 488945F0 		movq	%rax, -16(%rbp)
 454:libusbwrap.c  **** 	completed = &wrapper->completed;
 1790              		.loc 3 454 0
 1791 1030 488B45E8 		movq	-24(%rbp), %rax
 1792 1034 4883C008 		addq	$8, %rax
 1793 1038 488945F8 		movq	%rax, -8(%rbp)
 455:libusbwrap.c  **** 	*completed = 0;
 1794              		.loc 3 455 0
 1795 103c 488B45F8 		movq	-8(%rbp), %rax
 1796 1040 C7000000 		movl	$0, (%rax)
 1796      0000
 456:libusbwrap.c  **** 	wrapper->flags.isRead = 0;
 1797              		.loc 3 456 0
 1798 1046 488B45E8 		movq	-24(%rbp), %rax
 1799 104a 0FB6500C 		movzbl	12(%rax), %edx
 1800 104e 83E2FE   		andl	$-2, %edx
 1801 1051 88500C   		movb	%dl, 12(%rax)
 457:libusbwrap.c  **** 	libusb_fill_bulk_transfer(
 1802              		.loc 3 457 0
 1803 1054 448B45C0 		movl	-64(%rbp), %r8d
 458:libusbwrap.c  **** 		transfer, dev->handle, LIBUSB_ENDPOINT_OUT | endpoint, wrapper->buffer, (int)length,
 1804              		.loc 3 458 0
 1805 1058 488B45E8 		movq	-24(%rbp), %rax
 1806 105c 488D7810 		leaq	16(%rax), %rdi
 457:libusbwrap.c  **** 	libusb_fill_bulk_transfer(
 1807              		.loc 3 457 0
 1808 1060 0FB655C4 		movzbl	-60(%rbp), %edx
 1809              		.loc 3 458 0
 1810 1064 488B45C8 		movq	-56(%rbp), %rax
 1811 1068 488B30   		movq	(%rax), %rsi
 457:libusbwrap.c  **** 	libusb_fill_bulk_transfer(
 1812              		.loc 3 457 0
 1813 106b 488B45F0 		movq	-16(%rbp), %rax
 1814 106f 8B4DBC   		movl	-68(%rbp), %ecx
 1815 1072 894C2408 		movl	%ecx, 8(%rsp)
 1816 1076 488B4DF8 		movq	-8(%rbp), %rcx
 1817 107a 48890C24 		movq	%rcx, (%rsp)
 1818 107e 4C8D0D78 		leaq	bulk_transfer_cb(%rip), %r9
 1818      FDFFFF
 1819 1085 4889F9   		movq	%rdi, %rcx
 1820 1088 4889C7   		movq	%rax, %rdi
 1821 108b E882EFFF 		call	libusb_fill_bulk_transfer
 1821      FF
 459:libusbwrap.c  **** 		bulk_transfer_cb, completed, timeout
 460:libusbwrap.c  **** 	);
 461:libusbwrap.c  **** 	transfer->type = LIBUSB_TRANSFER_TYPE_BULK;
 1822              		.loc 3 461 0
 1823 1090 488B45F0 		movq	-16(%rbp), %rax
 1824 1094 C6400A02 		movb	$2, 10(%rax)
 462:libusbwrap.c  **** 	iStatus = libusb_submit_transfer(transfer);
 1825              		.loc 3 462 0
 1826 1098 488B45F0 		movq	-16(%rbp), %rax
 1827 109c 4889C7   		movq	%rax, %rdi
 1828 109f E8000000 		call	libusb_submit_transfer@PLT
 1828      00
 1829 10a4 8945E4   		movl	%eax, -28(%rbp)
 463:libusbwrap.c  **** 	CHECK_STATUS(
 1830              		.loc 3 463 0
 1831 10a7 837DE400 		cmpl	$0, -28(%rbp)
 1832 10ab 742E     		je	.L119
 1833              		.loc 3 463 0 is_stmt 0 discriminator 1
 1834 10ad 8B45E4   		movl	-28(%rbp), %eax
 1835 10b0 89C7     		movl	%eax, %edi
 1836 10b2 E8000000 		call	libusb_error_name@PLT
 1836      00
 1837 10b7 4889C2   		movq	%rax, %rdx
 1838 10ba 488B45B0 		movq	-80(%rbp), %rax
 1839 10be 488D3500 		leaq	.LC26(%rip), %rsi
 1839      000000
 1840 10c5 4889C7   		movq	%rax, %rdi
 1841 10c8 B8000000 		movl	$0, %eax
 1841      00
 1842 10cd E8000000 		call	errRender@PLT
 1842      00
 1843 10d2 C745DC0E 		movl	$14, -36(%rbp)
 1843      000000
 1844 10d9 EB10     		jmp	.L117
 1845              	.L119:
 464:libusbwrap.c  **** 		iStatus, USB_ASYNC_SUBMIT, cleanup,
 465:libusbwrap.c  **** 		"usbBulkWriteAsyncSubmit(): Submission error: %s", libusb_error_name(iStatus));
 466:libusbwrap.c  **** 	queueCommitPut(&dev->queue);
 1846              		.loc 3 466 0 is_stmt 1
 1847 10db 488B45C8 		movq	-56(%rbp), %rax
 1848 10df 4883C008 		addq	$8, %rax
 1849 10e3 4889C7   		movq	%rax, %rdi
 1850 10e6 E8000000 		call	queueCommitPut@PLT
 1850      00
 1851              	.L117:
 467:libusbwrap.c  **** cleanup:
 468:libusbwrap.c  **** 	return retVal;
 1852              		.loc 3 468 0
 1853 10eb 8B45DC   		movl	-36(%rbp), %eax
 469:libusbwrap.c  **** }
 1854              		.loc 3 469 0
 1855 10ee C9       		leave
 1856              		.cfi_def_cfa 7, 8
 1857 10ef C3       		ret
 1858              		.cfi_endproc
 1859              	.LFE35:
 1861              		.section	.rodata
 1862              		.align 8
 1863              	.LC27:
 1864 04e8 75736242 		.string	"usbBulkReadAsync(): Transfer length exceeds 0x10000"
 1864      756C6B52 
 1864      65616441 
 1864      73796E63 
 1864      28293A20 
 1865 051c 00000000 		.align 8
 1866              	.LC28:
 1867 0520 75736242 		.string	"usbBulkReadAsync(): Work queue insertion error"
 1867      756C6B52 
 1867      65616441 
 1867      73796E63 
 1867      28293A20 
 1868 054f 00       		.align 8
 1869              	.LC29:
 1870 0550 75736242 		.string	"usbBulkReadAsync(): Submission error: %s"
 1870      756C6B52 
 1870      65616441 
 1870      73796E63 
 1870      28293A20 
 1871              		.text
 1872              		.globl	usbBulkReadAsync
 1874              	usbBulkReadAsync:
 1875              	.LFB36:
 470:libusbwrap.c  **** 
 471:libusbwrap.c  **** DLLEXPORT(USBStatus) usbBulkReadAsync(
 472:libusbwrap.c  **** 	struct USBDevice *dev, uint8 endpoint, uint8 *buffer, uint32 length, uint32 timeout, const char **
 473:libusbwrap.c  **** {
 1876              		.loc 3 473 0
 1877              		.cfi_startproc
 1878 10f0 55       		pushq	%rbp
 1879              		.cfi_def_cfa_offset 16
 1880              		.cfi_offset 6, -16
 1881 10f1 4889E5   		movq	%rsp, %rbp
 1882              		.cfi_def_cfa_register 6
 1883 10f4 4883EC70 		subq	$112, %rsp
 1884 10f8 48897DC8 		movq	%rdi, -56(%rbp)
 1885 10fc 89F0     		movl	%esi, %eax
 1886 10fe 488955B8 		movq	%rdx, -72(%rbp)
 1887 1102 894DC0   		movl	%ecx, -64(%rbp)
 1888 1105 448945B4 		movl	%r8d, -76(%rbp)
 1889 1109 4C894DA8 		movq	%r9, -88(%rbp)
 1890 110d 8845C4   		movb	%al, -60(%rbp)
 474:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 1891              		.loc 3 474 0
 1892 1110 C745DC00 		movl	$0, -36(%rbp)
 1892      000000
 475:libusbwrap.c  **** 	struct TransferWrapper *wrapper;
 476:libusbwrap.c  **** 	struct libusb_transfer *transfer;
 477:libusbwrap.c  **** 	int *completed;
 478:libusbwrap.c  **** 	USBStatus uStatus;
 479:libusbwrap.c  **** 	int iStatus;
 480:libusbwrap.c  **** 	CHECK_STATUS(
 1893              		.loc 3 480 0
 1894 1117 817DC000 		cmpl	$65536, -64(%rbp)
 1894      000100
 1895 111e 761F     		jbe	.L122
 1896              		.loc 3 480 0 is_stmt 0 discriminator 1
 1897 1120 488B45A8 		movq	-88(%rbp), %rax
 1898 1124 488D3500 		leaq	.LC27(%rip), %rsi
 1898      000000
 1899 112b 4889C7   		movq	%rax, %rdi
 1900 112e E8000000 		call	errPrefix@PLT
 1900      00
 1901 1133 C745DC11 		movl	$17, -36(%rbp)
 1901      000000
 1902 113a E9270100 		jmp	.L123
 1902      00
 1903              	.L122:
 481:libusbwrap.c  **** 		length > 0x10000, USB_ASYNC_SIZE, cleanup,
 482:libusbwrap.c  **** 		"usbBulkReadAsync(): Transfer length exceeds 0x10000");
 483:libusbwrap.c  **** 	uStatus = queuePut(&dev->queue, (Item*)&wrapper);
 1904              		.loc 3 483 0 is_stmt 1
 1905 113f 488B45C8 		movq	-56(%rbp), %rax
 1906 1143 488D5008 		leaq	8(%rax), %rdx
 1907 1147 488D45E8 		leaq	-24(%rbp), %rax
 1908 114b 4889C6   		movq	%rax, %rsi
 1909 114e 4889D7   		movq	%rdx, %rdi
 1910 1151 E8000000 		call	queuePut@PLT
 1910      00
 1911 1156 8945E0   		movl	%eax, -32(%rbp)
 484:libusbwrap.c  **** 	CHECK_STATUS(uStatus, uStatus, cleanup, "usbBulkReadAsync(): Work queue insertion error");
 1912              		.loc 3 484 0
 1913 1159 837DE000 		cmpl	$0, -32(%rbp)
 1914 115d 741E     		je	.L124
 1915              		.loc 3 484 0 is_stmt 0 discriminator 1
 1916 115f 488B45A8 		movq	-88(%rbp), %rax
 1917 1163 488D3500 		leaq	.LC28(%rip), %rsi
 1917      000000
 1918 116a 4889C7   		movq	%rax, %rdi
 1919 116d E8000000 		call	errPrefix@PLT
 1919      00
 1920 1172 8B45E0   		movl	-32(%rbp), %eax
 1921 1175 8945DC   		movl	%eax, -36(%rbp)
 1922 1178 E9E90000 		jmp	.L123
 1922      00
 1923              	.L124:
 485:libusbwrap.c  **** 	transfer = wrapper->transfer;
 1924              		.loc 3 485 0 is_stmt 1
 1925 117d 488B45E8 		movq	-24(%rbp), %rax
 1926 1181 488B00   		movq	(%rax), %rax
 1927 1184 488945F0 		movq	%rax, -16(%rbp)
 486:libusbwrap.c  **** 	completed = &wrapper->completed;
 1928              		.loc 3 486 0
 1929 1188 488B45E8 		movq	-24(%rbp), %rax
 1930 118c 4883C008 		addq	$8, %rax
 1931 1190 488945F8 		movq	%rax, -8(%rbp)
 487:libusbwrap.c  **** 	*completed = 0;
 1932              		.loc 3 487 0
 1933 1194 488B45F8 		movq	-8(%rbp), %rax
 1934 1198 C7000000 		movl	$0, (%rax)
 1934      0000
 488:libusbwrap.c  **** 	wrapper->flags.isRead = 1;
 1935              		.loc 3 488 0
 1936 119e 488B45E8 		movq	-24(%rbp), %rax
 1937 11a2 0FB6500C 		movzbl	12(%rax), %edx
 1938 11a6 83CA01   		orl	$1, %edx
 1939 11a9 88500C   		movb	%dl, 12(%rax)
 489:libusbwrap.c  **** 	if ( buffer ) {
 1940              		.loc 3 489 0
 1941 11ac 48837DB8 		cmpq	$0, -72(%rbp)
 1941      00
 1942 11b1 7411     		je	.L125
 490:libusbwrap.c  **** 		wrapper->bufPtr = buffer;
 1943              		.loc 3 490 0
 1944 11b3 488B45E8 		movq	-24(%rbp), %rax
 1945 11b7 488B55B8 		movq	-72(%rbp), %rdx
 1946 11bb 48899010 		movq	%rdx, 65552(%rax)
 1946      000100
 1947 11c2 EB0C     		jmp	.L126
 1948              	.L125:
 491:libusbwrap.c  **** 	} else {
 492:libusbwrap.c  **** 		buffer = wrapper->buffer;
 1949              		.loc 3 492 0
 1950 11c4 488B45E8 		movq	-24(%rbp), %rax
 1951 11c8 4883C010 		addq	$16, %rax
 1952 11cc 488945B8 		movq	%rax, -72(%rbp)
 1953              	.L126:
 493:libusbwrap.c  **** 	}
 494:libusbwrap.c  **** 	libusb_fill_bulk_transfer(
 1954              		.loc 3 494 0
 1955 11d0 448B45C0 		movl	-64(%rbp), %r8d
 1956 11d4 0FB645C4 		movzbl	-60(%rbp), %eax
 1957 11d8 83C880   		orl	$-128, %eax
 1958 11db 0FB6D0   		movzbl	%al, %edx
 495:libusbwrap.c  **** 		transfer, dev->handle, LIBUSB_ENDPOINT_IN | endpoint, buffer, (int)length,
 1959              		.loc 3 495 0
 1960 11de 488B45C8 		movq	-56(%rbp), %rax
 1961 11e2 488B30   		movq	(%rax), %rsi
 494:libusbwrap.c  **** 		transfer, dev->handle, LIBUSB_ENDPOINT_IN | endpoint, buffer, (int)length,
 1962              		.loc 3 494 0
 1963 11e5 488B4DB8 		movq	-72(%rbp), %rcx
 1964 11e9 488B45F0 		movq	-16(%rbp), %rax
 1965 11ed 8B7DB4   		movl	-76(%rbp), %edi
 1966 11f0 897C2408 		movl	%edi, 8(%rsp)
 1967 11f4 488B7DF8 		movq	-8(%rbp), %rdi
 1968 11f8 48893C24 		movq	%rdi, (%rsp)
 1969 11fc 4C8D0DFA 		leaq	bulk_transfer_cb(%rip), %r9
 1969      FBFFFF
 1970 1203 4889C7   		movq	%rax, %rdi
 1971 1206 E807EEFF 		call	libusb_fill_bulk_transfer
 1971      FF
 496:libusbwrap.c  **** 		bulk_transfer_cb, completed, timeout
 497:libusbwrap.c  **** 	);
 498:libusbwrap.c  **** 	transfer->type = LIBUSB_TRANSFER_TYPE_BULK;
 1972              		.loc 3 498 0
 1973 120b 488B45F0 		movq	-16(%rbp), %rax
 1974 120f C6400A02 		movb	$2, 10(%rax)
 499:libusbwrap.c  **** 	iStatus = libusb_submit_transfer(transfer);
 1975              		.loc 3 499 0
 1976 1213 488B45F0 		movq	-16(%rbp), %rax
 1977 1217 4889C7   		movq	%rax, %rdi
 1978 121a E8000000 		call	libusb_submit_transfer@PLT
 1978      00
 1979 121f 8945E4   		movl	%eax, -28(%rbp)
 500:libusbwrap.c  **** 	CHECK_STATUS(
 1980              		.loc 3 500 0
 1981 1222 837DE400 		cmpl	$0, -28(%rbp)
 1982 1226 742E     		je	.L127
 1983              		.loc 3 500 0 is_stmt 0 discriminator 1
 1984 1228 8B45E4   		movl	-28(%rbp), %eax
 1985 122b 89C7     		movl	%eax, %edi
 1986 122d E8000000 		call	libusb_error_name@PLT
 1986      00
 1987 1232 4889C2   		movq	%rax, %rdx
 1988 1235 488B45A8 		movq	-88(%rbp), %rax
 1989 1239 488D3500 		leaq	.LC29(%rip), %rsi
 1989      000000
 1990 1240 4889C7   		movq	%rax, %rdi
 1991 1243 B8000000 		movl	$0, %eax
 1991      00
 1992 1248 E8000000 		call	errRender@PLT
 1992      00
 1993 124d C745DC0E 		movl	$14, -36(%rbp)
 1993      000000
 1994 1254 EB10     		jmp	.L123
 1995              	.L127:
 501:libusbwrap.c  **** 		iStatus, USB_ASYNC_SUBMIT, cleanup,
 502:libusbwrap.c  **** 		"usbBulkReadAsync(): Submission error: %s", libusb_error_name(iStatus));
 503:libusbwrap.c  **** 	queueCommitPut(&dev->queue);
 1996              		.loc 3 503 0 is_stmt 1
 1997 1256 488B45C8 		movq	-56(%rbp), %rax
 1998 125a 4883C008 		addq	$8, %rax
 1999 125e 4889C7   		movq	%rax, %rdi
 2000 1261 E8000000 		call	queueCommitPut@PLT
 2000      00
 2001              	.L123:
 504:libusbwrap.c  **** cleanup:
 505:libusbwrap.c  **** 	return retVal;
 2002              		.loc 3 505 0
 2003 1266 8B45DC   		movl	-36(%rbp), %eax
 506:libusbwrap.c  **** }
 2004              		.loc 3 506 0
 2005 1269 C9       		leave
 2006              		.cfi_def_cfa 7, 8
 2007 126a C3       		ret
 2008              		.cfi_endproc
 2009              	.LFE36:
 2011              		.section	.rodata
 2012 0579 00000000 		.align 8
 2012      000000
 2013              	.LC30:
 2014 0580 75736242 		.string	"usbBulkAwaitCompletion(): Work queue fetch error"
 2014      756C6B41 
 2014      77616974 
 2014      436F6D70 
 2014      6C657469 
 2015 05b1 00000000 		.align 8
 2015      000000
 2016              	.LC31:
 2017 05b8 75736242 		.string	"usbBulkAwaitCompletion(): Event error: %s"
 2017      756C6B41 
 2017      77616974 
 2017      436F6D70 
 2017      6C657469 
 2018 05e2 00000000 		.align 8
 2018      0000
 2019              	.LC32:
 2020 05e8 75736242 		.string	"usbBulkAwaitCompletion(): Timeout"
 2020      756C6B41 
 2020      77616974 
 2020      436F6D70 
 2020      6C657469 
 2021 060a 00000000 		.align 8
 2021      0000
 2022              	.LC33:
 2023 0610 75736242 		.string	"usbBulkAwaitCompletion(): Transfer error: %s"
 2023      756C6B41 
 2023      77616974 
 2023      436F6D70 
 2023      6C657469 
 2024              		.text
 2025              		.globl	usbBulkAwaitCompletion
 2027              	usbBulkAwaitCompletion:
 2028              	.LFB37:
 507:libusbwrap.c  **** 
 508:libusbwrap.c  **** DLLEXPORT(USBStatus) usbBulkAwaitCompletion(
 509:libusbwrap.c  **** 	struct USBDevice *dev, struct CompletionReport *report, const char **error)
 510:libusbwrap.c  **** {
 2029              		.loc 3 510 0
 2030              		.cfi_startproc
 2031 126b 55       		pushq	%rbp
 2032              		.cfi_def_cfa_offset 16
 2033              		.cfi_offset 6, -16
 2034 126c 4889E5   		movq	%rsp, %rbp
 2035              		.cfi_def_cfa_register 6
 2036 126f 4883EC60 		subq	$96, %rsp
 2037 1273 48897DB8 		movq	%rdi, -72(%rbp)
 2038 1277 488975B0 		movq	%rsi, -80(%rbp)
 2039 127b 488955A8 		movq	%rdx, -88(%rbp)
 511:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 2040              		.loc 3 511 0
 2041 127f C745CC00 		movl	$0, -52(%rbp)
 2041      000000
 512:libusbwrap.c  **** 	struct TransferWrapper *wrapper;
 513:libusbwrap.c  **** 	struct libusb_transfer *transfer;
 514:libusbwrap.c  **** 	int *completed;
 515:libusbwrap.c  **** 	int iStatus;
 516:libusbwrap.c  **** 	struct timeval timeout = {UINT_MAX/1000, 1000*(UINT_MAX%1000)};
 2042              		.loc 3 516 0
 2043 1286 48C745F0 		movq	$4294967, -16(%rbp)
 2043      37894100 
 2044 128e 48C745F8 		movq	$295000, -8(%rbp)
 2044      58800400 
 517:libusbwrap.c  **** 	                         // This horrible thing should boil down to a call to poll() with
 518:libusbwrap.c  **** 	                         // timeout -1ms, which will be interpreted as "no timeout" on all
 519:libusbwrap.c  **** 	                         // platforms.
 520:libusbwrap.c  **** 	USBStatus uStatus = queueTake(&dev->queue, (Item*)&wrapper);
 2045              		.loc 3 520 0
 2046 1296 488B45B8 		movq	-72(%rbp), %rax
 2047 129a 488D5008 		leaq	8(%rax), %rdx
 2048 129e 488D45D8 		leaq	-40(%rbp), %rax
 2049 12a2 4889C6   		movq	%rax, %rsi
 2050 12a5 4889D7   		movq	%rdx, %rdi
 2051 12a8 E8000000 		call	queueTake@PLT
 2051      00
 2052 12ad 8945D4   		movl	%eax, -44(%rbp)
 521:libusbwrap.c  **** 	CHECK_STATUS(uStatus, uStatus, exit, "usbBulkAwaitCompletion(): Work queue fetch error");
 2053              		.loc 3 521 0
 2054 12b0 837DD400 		cmpl	$0, -44(%rbp)
 2055 12b4 741E     		je	.L130
 2056              		.loc 3 521 0 is_stmt 0 discriminator 1
 2057 12b6 488B45A8 		movq	-88(%rbp), %rax
 2058 12ba 488D3500 		leaq	.LC30(%rip), %rsi
 2058      000000
 2059 12c1 4889C7   		movq	%rax, %rdi
 2060 12c4 E8000000 		call	errPrefix@PLT
 2060      00
 2061 12c9 8B45D4   		movl	-44(%rbp), %eax
 2062 12cc 8945CC   		movl	%eax, -52(%rbp)
 2063 12cf E9E00100 		jmp	.L131
 2063      00
 2064              	.L130:
 522:libusbwrap.c  **** 	transfer = wrapper->transfer;
 2065              		.loc 3 522 0 is_stmt 1
 2066 12d4 488B45D8 		movq	-40(%rbp), %rax
 2067 12d8 488B00   		movq	(%rax), %rax
 2068 12db 488945E0 		movq	%rax, -32(%rbp)
 523:libusbwrap.c  **** 	completed = &wrapper->completed;
 2069              		.loc 3 523 0
 2070 12df 488B45D8 		movq	-40(%rbp), %rax
 2071 12e3 4883C008 		addq	$8, %rax
 2072 12e7 488945E8 		movq	%rax, -24(%rbp)
 524:libusbwrap.c  **** 	wrapper->bufPtr = NULL;
 2073              		.loc 3 524 0
 2074 12eb 488B45D8 		movq	-40(%rbp), %rax
 2075 12ef 48C78010 		movq	$0, 65552(%rax)
 2075      00010000 
 2075      000000
 525:libusbwrap.c  **** 	while ( *completed == 0 ) {
 2076              		.loc 3 525 0
 2077 12fa E9990000 		jmp	.L132
 2077      00
 2078              	.L138:
 526:libusbwrap.c  **** 		iStatus = libusb_handle_events_timeout_completed(m_ctx, &timeout, completed);
 2079              		.loc 3 526 0
 2080 12ff 488B0500 		movq	m_ctx(%rip), %rax
 2080      000000
 2081 1306 488B55E8 		movq	-24(%rbp), %rdx
 2082 130a 488D4DF0 		leaq	-16(%rbp), %rcx
 2083 130e 4889CE   		movq	%rcx, %rsi
 2084 1311 4889C7   		movq	%rax, %rdi
 2085 1314 E8000000 		call	libusb_handle_events_timeout_completed@PLT
 2085      00
 2086 1319 8945D0   		movl	%eax, -48(%rbp)
 527:libusbwrap.c  **** 		if ( iStatus < 0 ) {
 2087              		.loc 3 527 0
 2088 131c 837DD000 		cmpl	$0, -48(%rbp)
 2089 1320 7976     		jns	.L132
 528:libusbwrap.c  **** 			if ( iStatus == LIBUSB_ERROR_INTERRUPTED ) {
 2090              		.loc 3 528 0
 2091 1322 837DD0F6 		cmpl	$-10, -48(%rbp)
 2092 1326 7502     		jne	.L133
 529:libusbwrap.c  **** 				continue;
 2093              		.loc 3 529 0
 2094 1328 EB6E     		jmp	.L132
 2095              	.L133:
 530:libusbwrap.c  **** 			}
 531:libusbwrap.c  **** 			if ( libusb_cancel_transfer(transfer) == LIBUSB_SUCCESS ) {
 2096              		.loc 3 531 0
 2097 132a 488B45E0 		movq	-32(%rbp), %rax
 2098 132e 4889C7   		movq	%rax, %rdi
 2099 1331 E8000000 		call	libusb_cancel_transfer@PLT
 2099      00
 2100 1336 85C0     		testl	%eax, %eax
 2101 1338 752D     		jne	.L150
 532:libusbwrap.c  **** 				while ( *completed == 0 ) {
 2102              		.loc 3 532 0
 2103 133a EB21     		jmp	.L135
 2104              	.L136:
 533:libusbwrap.c  **** 					if ( libusb_handle_events_timeout_completed(m_ctx, &timeout, completed) < 0 ) {
 2105              		.loc 3 533 0
 2106 133c 488B0500 		movq	m_ctx(%rip), %rax
 2106      000000
 2107 1343 488B55E8 		movq	-24(%rbp), %rdx
 2108 1347 488D4DF0 		leaq	-16(%rbp), %rcx
 2109 134b 4889CE   		movq	%rcx, %rsi
 2110 134e 4889C7   		movq	%rax, %rdi
 2111 1351 E8000000 		call	libusb_handle_events_timeout_completed@PLT
 2111      00
 2112 1356 85C0     		testl	%eax, %eax
 2113 1358 7903     		jns	.L135
 534:libusbwrap.c  **** 						break;
 2114              		.loc 3 534 0
 2115 135a 90       		nop
 2116 135b EB0A     		jmp	.L150
 2117              	.L135:
 532:libusbwrap.c  **** 				while ( *completed == 0 ) {
 2118              		.loc 3 532 0 discriminator 1
 2119 135d 488B45E8 		movq	-24(%rbp), %rax
 2120 1361 8B00     		movl	(%rax), %eax
 2121 1363 85C0     		testl	%eax, %eax
 2122 1365 74D5     		je	.L136
 2123              	.L150:
 535:libusbwrap.c  **** 					}
 536:libusbwrap.c  **** 				}
 537:libusbwrap.c  **** 			}
 538:libusbwrap.c  **** 			CHECK_STATUS(
 2124              		.loc 3 538 0 discriminator 1
 2125 1367 8B45D0   		movl	-48(%rbp), %eax
 2126 136a 89C7     		movl	%eax, %edi
 2127 136c E8000000 		call	libusb_error_name@PLT
 2127      00
 2128 1371 4889C2   		movq	%rax, %rdx
 2129 1374 488B45A8 		movq	-88(%rbp), %rax
 2130 1378 488D3500 		leaq	.LC31(%rip), %rsi
 2130      000000
 2131 137f 4889C7   		movq	%rax, %rdi
 2132 1382 B8000000 		movl	$0, %eax
 2132      00
 2133 1387 E8000000 		call	errRender@PLT
 2133      00
 2134 138c C745CC0F 		movl	$15, -52(%rbp)
 2134      000000
 2135 1393 E90C0100 		jmp	.L137
 2135      00
 2136              	.L132:
 525:libusbwrap.c  **** 		iStatus = libusb_handle_events_timeout_completed(m_ctx, &timeout, completed);
 2137              		.loc 3 525 0 discriminator 1
 2138 1398 488B45E8 		movq	-24(%rbp), %rax
 2139 139c 8B00     		movl	(%rax), %eax
 2140 139e 85C0     		testl	%eax, %eax
 2141 13a0 0F8459FF 		je	.L138
 2141      FFFF
 539:libusbwrap.c  **** 				true, USB_ASYNC_EVENT, commit,
 540:libusbwrap.c  **** 				"usbBulkAwaitCompletion(): Event error: %s", libusb_error_name(iStatus));
 541:libusbwrap.c  **** 		}
 542:libusbwrap.c  **** 	}
 543:libusbwrap.c  **** 
 544:libusbwrap.c  **** 	report->buffer = transfer->buffer;
 2142              		.loc 3 544 0
 2143 13a6 488B45E0 		movq	-32(%rbp), %rax
 2144 13aa 488B5030 		movq	48(%rax), %rdx
 2145 13ae 488B45B0 		movq	-80(%rbp), %rax
 2146 13b2 488910   		movq	%rdx, (%rax)
 545:libusbwrap.c  **** 	report->requestLength = (uint32)transfer->length;
 2147              		.loc 3 545 0
 2148 13b5 488B45E0 		movq	-32(%rbp), %rax
 2149 13b9 8B4014   		movl	20(%rax), %eax
 2150 13bc 89C2     		movl	%eax, %edx
 2151 13be 488B45B0 		movq	-80(%rbp), %rax
 2152 13c2 895008   		movl	%edx, 8(%rax)
 546:libusbwrap.c  **** 	report->actualLength = (uint32)transfer->actual_length;
 2153              		.loc 3 546 0
 2154 13c5 488B45E0 		movq	-32(%rbp), %rax
 2155 13c9 8B4018   		movl	24(%rax), %eax
 2156 13cc 89C2     		movl	%eax, %edx
 2157 13ce 488B45B0 		movq	-80(%rbp), %rax
 2158 13d2 89500C   		movl	%edx, 12(%rax)
 547:libusbwrap.c  **** 	report->flags = wrapper->flags;
 2159              		.loc 3 547 0
 2160 13d5 488B55D8 		movq	-40(%rbp), %rdx
 2161 13d9 488B45B0 		movq	-80(%rbp), %rax
 2162 13dd 8B520C   		movl	12(%rdx), %edx
 2163 13e0 895010   		movl	%edx, 16(%rax)
 548:libusbwrap.c  **** 
 549:libusbwrap.c  **** 	switch ( transfer->status ) {
 2164              		.loc 3 549 0
 2165 13e3 488B45E0 		movq	-32(%rbp), %rax
 2166 13e7 8B4010   		movl	16(%rax), %eax
 2167 13ea 83F806   		cmpl	$6, %eax
 2168 13ed 7759     		ja	.L139
 2169 13ef 89C0     		movl	%eax, %eax
 2170 13f1 488D1485 		leaq	0(,%rax,4), %rdx
 2170      00000000 
 2171 13f9 488D0500 		leaq	.L141(%rip), %rax
 2171      000000
 2172 1400 8B0402   		movl	(%rdx,%rax), %eax
 2173 1403 4863D0   		movslq	%eax, %rdx
 2174 1406 488D0500 		leaq	.L141(%rip), %rax
 2174      000000
 2175 140d 4801D0   		addq	%rdx, %rax
 2176 1410 FFE0     		jmp	*%rax
 2177              		.section	.rodata
 2178 063d 000000   		.align 4
 2179              		.align 4
 2180              	.L141:
 2181 0640 00000000 		.long	.L140-.L141
 2182 0644 00000000 		.long	.L142-.L141
 2183 0648 00000000 		.long	.L143-.L141
 2184 064c 00000000 		.long	.L142-.L141
 2185 0650 00000000 		.long	.L144-.L141
 2186 0654 00000000 		.long	.L145-.L141
 2187 0658 00000000 		.long	.L146-.L141
 2188              		.text
 2189              	.L140:
 550:libusbwrap.c  **** 	case LIBUSB_TRANSFER_COMPLETED:
 551:libusbwrap.c  **** 		iStatus = 0;
 2190              		.loc 3 551 0
 2191 1412 C745D000 		movl	$0, -48(%rbp)
 2191      000000
 552:libusbwrap.c  **** 		break;
 2192              		.loc 3 552 0
 2193 1419 EB34     		jmp	.L147
 2194              	.L143:
 553:libusbwrap.c  **** 	case LIBUSB_TRANSFER_TIMED_OUT:
 554:libusbwrap.c  **** 		iStatus = LIBUSB_ERROR_TIMEOUT;
 2195              		.loc 3 554 0
 2196 141b C745D0F9 		movl	$-7, -48(%rbp)
 2196      FFFFFF
 555:libusbwrap.c  **** 		break;
 2197              		.loc 3 555 0
 2198 1422 EB2B     		jmp	.L147
 2199              	.L144:
 556:libusbwrap.c  **** 	case LIBUSB_TRANSFER_STALL:
 557:libusbwrap.c  **** 		iStatus = LIBUSB_ERROR_PIPE;
 2200              		.loc 3 557 0
 2201 1424 C745D0F7 		movl	$-9, -48(%rbp)
 2201      FFFFFF
 558:libusbwrap.c  **** 		break;
 2202              		.loc 3 558 0
 2203 142b EB22     		jmp	.L147
 2204              	.L146:
 559:libusbwrap.c  **** 	case LIBUSB_TRANSFER_OVERFLOW:
 560:libusbwrap.c  **** 		iStatus = LIBUSB_ERROR_OVERFLOW;
 2205              		.loc 3 560 0
 2206 142d C745D0F8 		movl	$-8, -48(%rbp)
 2206      FFFFFF
 561:libusbwrap.c  **** 		break;
 2207              		.loc 3 561 0
 2208 1434 EB19     		jmp	.L147
 2209              	.L145:
 562:libusbwrap.c  **** 	case LIBUSB_TRANSFER_NO_DEVICE:
 563:libusbwrap.c  **** 		iStatus = LIBUSB_ERROR_NO_DEVICE;
 2210              		.loc 3 563 0
 2211 1436 C745D0FC 		movl	$-4, -48(%rbp)
 2211      FFFFFF
 564:libusbwrap.c  **** 		break;
 2212              		.loc 3 564 0
 2213 143d EB10     		jmp	.L147
 2214              	.L142:
 565:libusbwrap.c  **** 	case LIBUSB_TRANSFER_ERROR:
 566:libusbwrap.c  **** 	case LIBUSB_TRANSFER_CANCELLED:
 567:libusbwrap.c  **** 		iStatus = LIBUSB_ERROR_IO;
 2215              		.loc 3 567 0
 2216 143f C745D0FF 		movl	$-1, -48(%rbp)
 2216      FFFFFF
 568:libusbwrap.c  **** 		break;
 2217              		.loc 3 568 0
 2218 1446 EB07     		jmp	.L147
 2219              	.L139:
 569:libusbwrap.c  **** 	default:
 570:libusbwrap.c  **** 		iStatus = LIBUSB_ERROR_OTHER;
 2220              		.loc 3 570 0
 2221 1448 C745D09D 		movl	$-99, -48(%rbp)
 2221      FFFFFF
 2222              	.L147:
 571:libusbwrap.c  **** 	}
 572:libusbwrap.c  **** 	CHECK_STATUS(
 2223              		.loc 3 572 0
 2224 144f 837DD0F9 		cmpl	$-7, -48(%rbp)
 2225 1453 751C     		jne	.L148
 2226              		.loc 3 572 0 is_stmt 0 discriminator 1
 2227 1455 488B45A8 		movq	-88(%rbp), %rax
 2228 1459 488D3500 		leaq	.LC32(%rip), %rsi
 2228      000000
 2229 1460 4889C7   		movq	%rax, %rdi
 2230 1463 E8000000 		call	errPrefix@PLT
 2230      00
 2231 1468 C745CC12 		movl	$18, -52(%rbp)
 2231      000000
 2232 146f EB33     		jmp	.L137
 2233              	.L148:
 573:libusbwrap.c  **** 		iStatus == LIBUSB_ERROR_TIMEOUT, USB_TIMEOUT, commit,
 574:libusbwrap.c  **** 		"usbBulkAwaitCompletion(): Timeout");
 575:libusbwrap.c  **** 	CHECK_STATUS(
 2234              		.loc 3 575 0 is_stmt 1
 2235 1471 837DD000 		cmpl	$0, -48(%rbp)
 2236 1475 742D     		je	.L137
 2237              		.loc 3 575 0 is_stmt 0 discriminator 1
 2238 1477 8B45D0   		movl	-48(%rbp), %eax
 2239 147a 89C7     		movl	%eax, %edi
 2240 147c E8000000 		call	libusb_error_name@PLT
 2240      00
 2241 1481 4889C2   		movq	%rax, %rdx
 2242 1484 488B45A8 		movq	-88(%rbp), %rax
 2243 1488 488D3500 		leaq	.LC33(%rip), %rsi
 2243      000000
 2244 148f 4889C7   		movq	%rax, %rdi
 2245 1492 B8000000 		movl	$0, %eax
 2245      00
 2246 1497 E8000000 		call	errRender@PLT
 2246      00
 2247 149c C745CC10 		movl	$16, -52(%rbp)
 2247      000000
 2248 14a3 90       		nop
 2249              	.L137:
 576:libusbwrap.c  **** 		iStatus, USB_ASYNC_TRANSFER, commit,
 577:libusbwrap.c  **** 		"usbBulkAwaitCompletion(): Transfer error: %s", libusb_error_name(iStatus));
 578:libusbwrap.c  **** commit:
 579:libusbwrap.c  **** 	queueCommitTake(&dev->queue);
 2250              		.loc 3 579 0 is_stmt 1
 2251 14a4 488B45B8 		movq	-72(%rbp), %rax
 2252 14a8 4883C008 		addq	$8, %rax
 2253 14ac 4889C7   		movq	%rax, %rdi
 2254 14af E8000000 		call	queueCommitTake@PLT
 2254      00
 2255              	.L131:
 580:libusbwrap.c  **** exit:
 581:libusbwrap.c  **** 	return retVal;
 2256              		.loc 3 581 0
 2257 14b4 8B45CC   		movl	-52(%rbp), %eax
 582:libusbwrap.c  **** }
 2258              		.loc 3 582 0
 2259 14b7 C9       		leave
 2260              		.cfi_def_cfa 7, 8
 2261 14b8 C3       		ret
 2262              		.cfi_endproc
 2263              	.LFE37:
 2265              		.globl	usbNumOutstandingRequests
 2267              	usbNumOutstandingRequests:
 2268              	.LFB38:
 583:libusbwrap.c  **** 
 584:libusbwrap.c  **** DLLEXPORT(size_t) usbNumOutstandingRequests(struct USBDevice *dev) {
 2269              		.loc 3 584 0
 2270              		.cfi_startproc
 2271 14b9 55       		pushq	%rbp
 2272              		.cfi_def_cfa_offset 16
 2273              		.cfi_offset 6, -16
 2274 14ba 4889E5   		movq	%rsp, %rbp
 2275              		.cfi_def_cfa_register 6
 2276 14bd 4883EC08 		subq	$8, %rsp
 2277 14c1 48897DF8 		movq	%rdi, -8(%rbp)
 585:libusbwrap.c  **** 	return queueSize(&dev->queue);
 2278              		.loc 3 585 0
 2279 14c5 488B45F8 		movq	-8(%rbp), %rax
 2280 14c9 4883C008 		addq	$8, %rax
 2281 14cd 4889C7   		movq	%rax, %rdi
 2282 14d0 E82BEBFF 		call	queueSize
 2282      FF
 586:libusbwrap.c  **** }
 2283              		.loc 3 586 0
 2284 14d5 C9       		leave
 2285              		.cfi_def_cfa 7, 8
 2286 14d6 C3       		ret
 2287              		.cfi_endproc
 2288              	.LFE38:
 2290              	.Letext0:
 2291              		.file 4 "/usr/include/x86_64-linux-gnu/bits/types.h"
 2292              		.file 5 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
 2293              		.file 6 "/usr/include/x86_64-linux-gnu/bits/time.h"
 2294              		.file 7 "/home/pandu/Desktop/DigitalLogicDesign/Lab/03-/makestuff/common/makestuff.h"
 2295              		.file 8 "libusbwrap.h"
 2296              		.file 9 "/usr/include/stdint.h"
 2297              		.file 10 "private.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 libusbwrap.c
     /tmp/ccEJEDuE.s:5      .text:0000000000000000 queueSize
     /tmp/ccEJEDuE.s:27     .text:0000000000000012 libusb_fill_bulk_transfer
     /tmp/ccEJEDuE.s:83     .bss:0000000000000000 m_ctx
     /tmp/ccEJEDuE.s:89     .text:0000000000000087 libusbOpenWithVidPid
     /tmp/ccEJEDuE.s:255    .text:000000000000023a usbValidateVidPid
     /tmp/ccEJEDuE.s:461    .text:00000000000003bc usbInitialise
     /tmp/ccEJEDuE.s:523    .text:000000000000042e usbIsDeviceAvailable
     /tmp/ccEJEDuE.s:711    .text:0000000000000639 createTransfer
     /tmp/ccEJEDuE.s:768    .text:00000000000006a6 destroyTransfer
     /tmp/ccEJEDuE.s:816    .text:00000000000006d6 usbOpenDevice
     /tmp/ccEJEDuE.s:1075   .text:00000000000009df usbCloseDevice
     /tmp/ccEJEDuE.s:1134   .text:0000000000000a3b usbControlRead
     /tmp/ccEJEDuE.s:1233   .text:0000000000000b28 usbControlWrite
     /tmp/ccEJEDuE.s:1332   .text:0000000000000c15 usbBulkRead
     /tmp/ccEJEDuE.s:1437   .text:0000000000000d0c usbBulkWrite
     /tmp/ccEJEDuE.s:1530   .text:0000000000000dfd bulk_transfer_cb
     /tmp/ccEJEDuE.s:1561   .text:0000000000000e1d usbBulkWriteAsync
     /tmp/ccEJEDuE.s:1674   .text:0000000000000f33 usbBulkWriteAsyncPrepare
     /tmp/ccEJEDuE.s:1737   .text:0000000000000f9d usbBulkWriteAsyncSubmit
     /tmp/ccEJEDuE.s:1874   .text:00000000000010f0 usbBulkReadAsync
     /tmp/ccEJEDuE.s:2027   .text:000000000000126b usbBulkAwaitCompletion
     /tmp/ccEJEDuE.s:2267   .text:00000000000014b9 usbNumOutstandingRequests

UNDEFINED SYMBOLS
_GLOBAL_OFFSET_TABLE_
libusb_get_device_list
libusb_error_name
errPrefix
libusb_get_device_descriptor
libusb_open
errRender
libusb_free_device_list
strlen
libusb_init
libusb_set_debug
strtoul
calloc
libusb_alloc_transfer
free
libusb_free_transfer
malloc
queueInit
libusb_set_configuration
libusb_claim_interface
libusb_set_interface_alt_setting
libusb_release_interface
libusb_close
queueDestroy
libusb_control_transfer
libusb_bulk_transfer
queuePut
libusb_submit_transfer
queueCommitPut
queueTake
libusb_handle_events_timeout_completed
libusb_cancel_transfer
queueCommitTake
