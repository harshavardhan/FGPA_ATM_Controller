   1              		.file	"main.c"
   2              		.text
   3              	.Ltext0:
   4              		.local	ptr
   5              		.comm	ptr,8,8
   6              		.local	enableBenchmarking
   7              		.comm	enableBenchmarking,1,1
   9              	isHexDigit:
  10              	.LFB4:
  11              		.file 1 "main.c"
   1:main.c        **** /* 
   2:main.c        ****  * Copyright (C) 2012-2014 Chris McClelland
   3:main.c        ****  *
   4:main.c        ****  * This program is free software: you can redistribute it and/or modify
   5:main.c        ****  * it under the terms of the GNU General Public License as published by
   6:main.c        ****  * the Free Software Foundation, either version 3 of the License, or
   7:main.c        ****  * (at your option) any later version.
   8:main.c        ****  *
   9:main.c        ****  * This program is distributed in the hope that it will be useful,
  10:main.c        ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:main.c        ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:main.c        ****  * GNU General Public License for more details.
  13:main.c        ****  *  
  14:main.c        ****  * You should have received a copy of the GNU General Public License
  15:main.c        ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:main.c        ****  */
  17:main.c        **** #include <stdio.h>
  18:main.c        **** #include <stdlib.h>
  19:main.c        **** #include <string.h>
  20:main.c        **** #include <errno.h>
  21:main.c        **** #include <makestuff.h>
  22:main.c        **** #include <libfpgalink.h>
  23:main.c        **** #include <libbuffer.h>
  24:main.c        **** #include <liberror.h>
  25:main.c        **** #include <libdump.h>
  26:main.c        **** #include <argtable2.h>
  27:main.c        **** #include <readline/readline.h>
  28:main.c        **** #include <readline/history.h>
  29:main.c        **** #ifdef WIN32
  30:main.c        **** #include <Windows.h>
  31:main.c        **** #else
  32:main.c        **** #include <sys/time.h>
  33:main.c        **** #endif
  34:main.c        **** 
  35:main.c        **** bool sigIsRaised(void);
  36:main.c        **** void sigRegisterHandler(void);
  37:main.c        **** 
  38:main.c        **** static const char *ptr;
  39:main.c        **** static bool enableBenchmarking = false;
  40:main.c        **** 
  41:main.c        **** static bool isHexDigit(char ch) {
  12              		.loc 1 41 0
  13              		.cfi_startproc
  14 0000 55       		pushq	%rbp
  15              		.cfi_def_cfa_offset 16
  16              		.cfi_offset 6, -16
  17 0001 4889E5   		movq	%rsp, %rbp
  18              		.cfi_def_cfa_register 6
  19 0004 89F8     		movl	%edi, %eax
  20 0006 8845FC   		movb	%al, -4(%rbp)
  42:main.c        **** 	return
  43:main.c        **** 		(ch >= '0' && ch <= '9') ||
  44:main.c        **** 		(ch >= 'a' && ch <= 'f') ||
  21              		.loc 1 44 0
  22 0009 807DFC2F 		cmpb	$47, -4(%rbp)
  23 000d 7E06     		jle	.L2
  43:main.c        **** 		(ch >= 'a' && ch <= 'f') ||
  24              		.loc 1 43 0
  25 000f 807DFC39 		cmpb	$57, -4(%rbp)
  26 0013 7E18     		jle	.L3
  27              	.L2:
  43:main.c        **** 		(ch >= 'a' && ch <= 'f') ||
  28              		.loc 1 43 0 is_stmt 0 discriminator 1
  29 0015 807DFC60 		cmpb	$96, -4(%rbp)
  30 0019 7E06     		jle	.L4
  31              		.loc 1 44 0 is_stmt 1
  32 001b 807DFC66 		cmpb	$102, -4(%rbp)
  33 001f 7E0C     		jle	.L3
  34              	.L4:
  35              		.loc 1 44 0 is_stmt 0 discriminator 2
  36 0021 807DFC40 		cmpb	$64, -4(%rbp)
  37 0025 7E0D     		jle	.L5
  45:main.c        **** 		(ch >= 'A' && ch <= 'F');
  38              		.loc 1 45 0 is_stmt 1
  39 0027 807DFC46 		cmpb	$70, -4(%rbp)
  40 002b 7F07     		jg	.L5
  41              	.L3:
  44:main.c        **** 		(ch >= 'A' && ch <= 'F');
  42              		.loc 1 44 0 discriminator 1
  43 002d B8010000 		movl	$1, %eax
  43      00
  44 0032 EB05     		jmp	.L6
  45              	.L5:
  46 0034 B8000000 		movl	$0, %eax
  46      00
  47              	.L6:
  42:main.c        **** 		(ch >= '0' && ch <= '9') ||
  48              		.loc 1 42 0
  49 0039 83E001   		andl	$1, %eax
  46:main.c        **** }
  50              		.loc 1 46 0
  51 003c 5D       		popq	%rbp
  52              		.cfi_def_cfa 7, 8
  53 003d C3       		ret
  54              		.cfi_endproc
  55              	.LFE4:
  58              	calcChecksum:
  59              	.LFB5:
  47:main.c        **** 
  48:main.c        **** static uint16 calcChecksum(const uint8 *data, size_t length) {
  60              		.loc 1 48 0
  61              		.cfi_startproc
  62 003e 55       		pushq	%rbp
  63              		.cfi_def_cfa_offset 16
  64              		.cfi_offset 6, -16
  65 003f 4889E5   		movq	%rsp, %rbp
  66              		.cfi_def_cfa_register 6
  67 0042 48897DE8 		movq	%rdi, -24(%rbp)
  68 0046 488975E0 		movq	%rsi, -32(%rbp)
  49:main.c        **** 	uint16 cksum = 0x0000;
  69              		.loc 1 49 0
  70 004a 66C745FE 		movw	$0, -2(%rbp)
  70      0000
  50:main.c        **** 	while ( length-- ) {
  71              		.loc 1 50 0
  72 0050 EB16     		jmp	.L9
  73              	.L10:
  51:main.c        **** 		cksum = (uint16)(cksum + *data++);
  74              		.loc 1 51 0
  75 0052 488B45E8 		movq	-24(%rbp), %rax
  76 0056 488D5001 		leaq	1(%rax), %rdx
  77 005a 488955E8 		movq	%rdx, -24(%rbp)
  78 005e 0FB600   		movzbl	(%rax), %eax
  79 0061 0FB6C0   		movzbl	%al, %eax
  80 0064 660145FE 		addw	%ax, -2(%rbp)
  81              	.L9:
  50:main.c        **** 	while ( length-- ) {
  82              		.loc 1 50 0 discriminator 1
  83 0068 488B45E0 		movq	-32(%rbp), %rax
  84 006c 488D50FF 		leaq	-1(%rax), %rdx
  85 0070 488955E0 		movq	%rdx, -32(%rbp)
  86 0074 4885C0   		testq	%rax, %rax
  87 0077 75D9     		jne	.L10
  52:main.c        **** 	}
  53:main.c        **** 	return cksum;
  88              		.loc 1 53 0
  89 0079 0FB745FE 		movzwl	-2(%rbp), %eax
  54:main.c        **** }
  90              		.loc 1 54 0
  91 007d 5D       		popq	%rbp
  92              		.cfi_def_cfa 7, 8
  93 007e C3       		ret
  94              		.cfi_endproc
  95              	.LFE5:
  98              	getHexNibble:
  99              	.LFB6:
  55:main.c        **** 
  56:main.c        **** static bool getHexNibble(char hexDigit, uint8 *nibble) {
 100              		.loc 1 56 0
 101              		.cfi_startproc
 102 007f 55       		pushq	%rbp
 103              		.cfi_def_cfa_offset 16
 104              		.cfi_offset 6, -16
 105 0080 4889E5   		movq	%rsp, %rbp
 106              		.cfi_def_cfa_register 6
 107 0083 89F8     		movl	%edi, %eax
 108 0085 488975F0 		movq	%rsi, -16(%rbp)
 109 0089 8845FC   		movb	%al, -4(%rbp)
  57:main.c        **** 	if ( hexDigit >= '0' && hexDigit <= '9' ) {
 110              		.loc 1 57 0
 111 008c 807DFC2F 		cmpb	$47, -4(%rbp)
 112 0090 7E1A     		jle	.L13
 113              		.loc 1 57 0 is_stmt 0 discriminator 1
 114 0092 807DFC39 		cmpb	$57, -4(%rbp)
 115 0096 7F14     		jg	.L13
  58:main.c        **** 		*nibble = (uint8)(hexDigit - '0');
 116              		.loc 1 58 0 is_stmt 1
 117 0098 0FB645FC 		movzbl	-4(%rbp), %eax
 118 009c 8D50D0   		leal	-48(%rax), %edx
 119 009f 488B45F0 		movq	-16(%rbp), %rax
 120 00a3 8810     		movb	%dl, (%rax)
  59:main.c        **** 		return false;
 121              		.loc 1 59 0
 122 00a5 B8000000 		movl	$0, %eax
 122      00
 123 00aa EB45     		jmp	.L14
 124              	.L13:
  60:main.c        **** 	} else if ( hexDigit >= 'a' && hexDigit <= 'f' ) {
 125              		.loc 1 60 0
 126 00ac 807DFC60 		cmpb	$96, -4(%rbp)
 127 00b0 7E1A     		jle	.L15
 128              		.loc 1 60 0 is_stmt 0 discriminator 1
 129 00b2 807DFC66 		cmpb	$102, -4(%rbp)
 130 00b6 7F14     		jg	.L15
  61:main.c        **** 		*nibble = (uint8)(hexDigit - 'a' + 10);
 131              		.loc 1 61 0 is_stmt 1
 132 00b8 0FB645FC 		movzbl	-4(%rbp), %eax
 133 00bc 8D50A9   		leal	-87(%rax), %edx
 134 00bf 488B45F0 		movq	-16(%rbp), %rax
 135 00c3 8810     		movb	%dl, (%rax)
  62:main.c        **** 		return false;
 136              		.loc 1 62 0
 137 00c5 B8000000 		movl	$0, %eax
 137      00
 138 00ca EB25     		jmp	.L14
 139              	.L15:
  63:main.c        **** 	} else if ( hexDigit >= 'A' && hexDigit <= 'F' ) {
 140              		.loc 1 63 0
 141 00cc 807DFC40 		cmpb	$64, -4(%rbp)
 142 00d0 7E1A     		jle	.L16
 143              		.loc 1 63 0 is_stmt 0 discriminator 1
 144 00d2 807DFC46 		cmpb	$70, -4(%rbp)
 145 00d6 7F14     		jg	.L16
  64:main.c        **** 		*nibble = (uint8)(hexDigit - 'A' + 10);
 146              		.loc 1 64 0 is_stmt 1
 147 00d8 0FB645FC 		movzbl	-4(%rbp), %eax
 148 00dc 8D50C9   		leal	-55(%rax), %edx
 149 00df 488B45F0 		movq	-16(%rbp), %rax
 150 00e3 8810     		movb	%dl, (%rax)
  65:main.c        **** 		return false;
 151              		.loc 1 65 0
 152 00e5 B8000000 		movl	$0, %eax
 152      00
 153 00ea EB05     		jmp	.L14
 154              	.L16:
  66:main.c        **** 	} else {
  67:main.c        **** 		return true;
 155              		.loc 1 67 0
 156 00ec B8010000 		movl	$1, %eax
 156      00
 157              	.L14:
  68:main.c        **** 	}
  69:main.c        **** }
 158              		.loc 1 69 0
 159 00f1 5D       		popq	%rbp
 160              		.cfi_def_cfa 7, 8
 161 00f2 C3       		ret
 162              		.cfi_endproc
 163              	.LFE6:
 166              	getHexByte:
 167              	.LFB7:
  70:main.c        **** 
  71:main.c        **** static int getHexByte(uint8 *byte) {
 168              		.loc 1 71 0
 169              		.cfi_startproc
 170 00f3 55       		pushq	%rbp
 171              		.cfi_def_cfa_offset 16
 172              		.cfi_offset 6, -16
 173 00f4 4889E5   		movq	%rsp, %rbp
 174              		.cfi_def_cfa_register 6
 175 00f7 4883EC18 		subq	$24, %rsp
 176 00fb 48897DE8 		movq	%rdi, -24(%rbp)
  72:main.c        **** 	uint8 upperNibble;
  73:main.c        **** 	uint8 lowerNibble;
  74:main.c        **** 	if ( !getHexNibble(ptr[0], &upperNibble) && !getHexNibble(ptr[1], &lowerNibble) ) {
 177              		.loc 1 74 0
 178 00ff 488B0500 		movq	ptr(%rip), %rax
 178      000000
 179 0106 0FB600   		movzbl	(%rax), %eax
 180 0109 0FBEC0   		movsbl	%al, %eax
 181 010c 488D55FE 		leaq	-2(%rbp), %rdx
 182 0110 4889D6   		movq	%rdx, %rsi
 183 0113 89C7     		movl	%eax, %edi
 184 0115 E865FFFF 		call	getHexNibble
 184      FF
 185 011a 83F001   		xorl	$1, %eax
 186 011d 84C0     		testb	%al, %al
 187 011f 744C     		je	.L18
 188              		.loc 1 74 0 is_stmt 0 discriminator 1
 189 0121 488B0500 		movq	ptr(%rip), %rax
 189      000000
 190 0128 4883C001 		addq	$1, %rax
 191 012c 0FB600   		movzbl	(%rax), %eax
 192 012f 0FBEC0   		movsbl	%al, %eax
 193 0132 488D55FF 		leaq	-1(%rbp), %rdx
 194 0136 4889D6   		movq	%rdx, %rsi
 195 0139 89C7     		movl	%eax, %edi
 196 013b E83FFFFF 		call	getHexNibble
 196      FF
 197 0140 83F001   		xorl	$1, %eax
 198 0143 84C0     		testb	%al, %al
 199 0145 7426     		je	.L18
  75:main.c        **** 		*byte = (uint8)((upperNibble << 4) | lowerNibble);
 200              		.loc 1 75 0 is_stmt 1
 201 0147 0FB645FE 		movzbl	-2(%rbp), %eax
 202 014b 0FB6C0   		movzbl	%al, %eax
 203 014e C1E004   		sall	$4, %eax
 204 0151 89C2     		movl	%eax, %edx
 205 0153 0FB645FF 		movzbl	-1(%rbp), %eax
 206 0157 09D0     		orl	%edx, %eax
 207 0159 89C2     		movl	%eax, %edx
 208 015b 488B45E8 		movq	-24(%rbp), %rax
 209 015f 8810     		movb	%dl, (%rax)
  76:main.c        **** 		byte += 2;
 210              		.loc 1 76 0
 211 0161 488345E8 		addq	$2, -24(%rbp)
 211      02
  77:main.c        **** 		return 0;
 212              		.loc 1 77 0
 213 0166 B8000000 		movl	$0, %eax
 213      00
 214 016b EB05     		jmp	.L20
 215              	.L18:
  78:main.c        **** 	} else {
  79:main.c        **** 		return 1;
 216              		.loc 1 79 0
 217 016d B8010000 		movl	$1, %eax
 217      00
 218              	.L20:
  80:main.c        **** 	}
  81:main.c        **** }
 219              		.loc 1 81 0
 220 0172 C9       		leave
 221              		.cfi_def_cfa 7, 8
 222 0173 C3       		ret
 223              		.cfi_endproc
 224              	.LFE7:
 226              		.section	.rodata
 227              	.LC0:
 228 0000 556E7061 		.string	"Unparseable hex number"
 228      72736561 
 228      626C6520 
 228      68657820 
 228      6E756D62 
 229              	.LC1:
 230 0017 4368616E 		.string	"Channel out of range"
 230      6E656C20 
 230      6F757420 
 230      6F662072 
 230      616E6765 
 231              	.LC2:
 232 002c 436F6E64 		.string	"Conduit out of range"
 232      75697420 
 232      6F757420 
 232      6F662072 
 232      616E6765 
 233              	.LC3:
 234 0041 496C6C65 		.string	"Illegal character"
 234      67616C20 
 234      63686172 
 234      61637465 
 234      7200
 235              	.LC4:
 236 0053 556E7465 		.string	"Unterminated string"
 236      726D696E 
 236      61746564 
 236      20737472 
 236      696E6700 
 237              	.LC5:
 238 0067 4E6F206D 		.string	"No memory"
 238      656D6F72 
 238      7900
 239              	.LC6:
 240 0071 456D7074 		.string	"Empty string"
 240      79207374 
 240      72696E67 
 240      00
 241              	.LC7:
 242 007e 4F646420 		.string	"Odd number of digits"
 242      6E756D62 
 242      6572206F 
 242      66206469 
 242      67697473 
 243              	.LC8:
 244 0093 43616E6E 		.string	"Cannot load file"
 244      6F74206C 
 244      6F616420 
 244      66696C65 
 244      00
 245              	.LC9:
 246 00a4 43616E6E 		.string	"Cannot save file"
 246      6F742073 
 246      61766520 
 246      66696C65 
 246      00
 247              	.LC10:
 248 00b5 42616420 		.string	"Bad arguments"
 248      61726775 
 248      6D656E74 
 248      7300
 249 00c3 00000000 		.align 32
 249      00000000 
 249      00000000 
 249      00000000 
 249      00000000 
 252              	errMessages:
 253 00e0 00000000 		.quad	0
 253      00000000 
 254 00e8 00000000 		.quad	0
 254      00000000 
 255 00f0 00000000 		.quad	.LC0
 255      00000000 
 256 00f8 00000000 		.quad	.LC1
 256      00000000 
 257 0100 00000000 		.quad	.LC2
 257      00000000 
 258 0108 00000000 		.quad	.LC3
 258      00000000 
 259 0110 00000000 		.quad	.LC4
 259      00000000 
 260 0118 00000000 		.quad	.LC5
 260      00000000 
 261 0120 00000000 		.quad	.LC6
 261      00000000 
 262 0128 00000000 		.quad	.LC7
 262      00000000 
 263 0130 00000000 		.quad	.LC8
 263      00000000 
 264 0138 00000000 		.quad	.LC9
 264      00000000 
 265 0140 00000000 		.quad	.LC10
 265      00000000 
 266              	.LC11:
 267 0148 646F5265 		.string	"doRead()"
 267      61642829 
 267      00
 268              		.text
 270              	doRead:
 271              	.LFB8:
  82:main.c        **** 
  83:main.c        **** static const char *const errMessages[] = {
  84:main.c        **** 	NULL,
  85:main.c        **** 	NULL,
  86:main.c        **** 	"Unparseable hex number",
  87:main.c        **** 	"Channel out of range",
  88:main.c        **** 	"Conduit out of range",
  89:main.c        **** 	"Illegal character",
  90:main.c        **** 	"Unterminated string",
  91:main.c        **** 	"No memory",
  92:main.c        **** 	"Empty string",
  93:main.c        **** 	"Odd number of digits",
  94:main.c        **** 	"Cannot load file",
  95:main.c        **** 	"Cannot save file",
  96:main.c        **** 	"Bad arguments"
  97:main.c        **** };
  98:main.c        **** 
  99:main.c        **** typedef enum {
 100:main.c        **** 	FLP_SUCCESS,
 101:main.c        **** 	FLP_LIBERR,
 102:main.c        **** 	FLP_BAD_HEX,
 103:main.c        **** 	FLP_CHAN_RANGE,
 104:main.c        **** 	FLP_CONDUIT_RANGE,
 105:main.c        **** 	FLP_ILL_CHAR,
 106:main.c        **** 	FLP_UNTERM_STRING,
 107:main.c        **** 	FLP_NO_MEMORY,
 108:main.c        **** 	FLP_EMPTY_STRING,
 109:main.c        **** 	FLP_ODD_DIGITS,
 110:main.c        **** 	FLP_CANNOT_LOAD,
 111:main.c        **** 	FLP_CANNOT_SAVE,
 112:main.c        **** 	FLP_ARGS
 113:main.c        **** } ReturnCode;
 114:main.c        **** 
 115:main.c        **** static ReturnCode doRead(
 116:main.c        **** 	struct FLContext *handle, uint8 chan, uint32 length, FILE *destFile, uint16 *checksum,
 117:main.c        **** 	const char **error)
 118:main.c        **** {
 272              		.loc 1 118 0
 273              		.cfi_startproc
 274 0174 55       		pushq	%rbp
 275              		.cfi_def_cfa_offset 16
 276              		.cfi_offset 6, -16
 277 0175 4889E5   		movq	%rsp, %rbp
 278              		.cfi_def_cfa_register 6
 279 0178 4883EC60 		subq	$96, %rsp
 280 017c 48897DC8 		movq	%rdi, -56(%rbp)
 281 0180 89F0     		movl	%esi, %eax
 282 0182 8955C0   		movl	%edx, -64(%rbp)
 283 0185 48894DB8 		movq	%rcx, -72(%rbp)
 284 0189 4C8945B0 		movq	%r8, -80(%rbp)
 285 018d 4C894DA8 		movq	%r9, -88(%rbp)
 286 0191 8845C4   		movb	%al, -60(%rbp)
 119:main.c        **** 	ReturnCode retVal = FLP_SUCCESS;
 287              		.loc 1 119 0
 288 0194 C745E000 		movl	$0, -32(%rbp)
 288      000000
 120:main.c        **** 	uint32 bytesWritten;
 121:main.c        **** 	FLStatus fStatus;
 122:main.c        **** 	uint32 chunkSize;
 123:main.c        **** 	const uint8 *recvData;
 124:main.c        **** 	uint32 actualLength;
 125:main.c        **** 	const uint8 *ptr;
 126:main.c        **** 	uint16 csVal = 0x0000;
 289              		.loc 1 126 0
 290 019b 66C745DA 		movw	$0, -38(%rbp)
 290      0000
 127:main.c        **** 	#define READ_MAX 65536
 128:main.c        **** 
 129:main.c        **** 	// Read first chunk
 130:main.c        **** 	chunkSize = length >= READ_MAX ? READ_MAX : length;
 291              		.loc 1 130 0
 292 01a1 B8000001 		movl	$65536, %eax
 292      00
 293 01a6 817DC000 		cmpl	$65536, -64(%rbp)
 293      000100
 294 01ad 0F4645C0 		cmovbe	-64(%rbp), %eax
 295 01b1 8945E4   		movl	%eax, -28(%rbp)
 131:main.c        **** 	fStatus = flReadChannelAsyncSubmit(handle, chan, chunkSize, NULL, error);
 296              		.loc 1 131 0
 297 01b4 0FB675C4 		movzbl	-60(%rbp), %esi
 298 01b8 488B4DA8 		movq	-88(%rbp), %rcx
 299 01bc 8B55E4   		movl	-28(%rbp), %edx
 300 01bf 488B45C8 		movq	-56(%rbp), %rax
 301 01c3 4989C8   		movq	%rcx, %r8
 302 01c6 B9000000 		movl	$0, %ecx
 302      00
 303 01cb 4889C7   		movq	%rax, %rdi
 304 01ce E8000000 		call	flReadChannelAsyncSubmit
 304      00
 305 01d3 8945E8   		movl	%eax, -24(%rbp)
 132:main.c        **** 	CHECK_STATUS(fStatus, FLP_LIBERR, cleanup, "doRead()");
 306              		.loc 1 132 0
 307 01d6 837DE800 		cmpl	$0, -24(%rbp)
 308 01da 741D     		je	.L22
 309              		.loc 1 132 0 is_stmt 0 discriminator 1
 310 01dc 488B45A8 		movq	-88(%rbp), %rax
 311 01e0 BE000000 		movl	$.LC11, %esi
 311      00
 312 01e5 4889C7   		movq	%rax, %rdi
 313 01e8 E8000000 		call	errPrefix
 313      00
 314 01ed C745E001 		movl	$1, -32(%rbp)
 314      000000
 315 01f4 E9EC0100 		jmp	.L23
 315      00
 316              	.L22:
 133:main.c        **** 	length = length - chunkSize;
 317              		.loc 1 133 0 is_stmt 1
 318 01f9 8B45E4   		movl	-28(%rbp), %eax
 319 01fc 2945C0   		subl	%eax, -64(%rbp)
 134:main.c        **** 
 135:main.c        **** 	while ( length ) {
 320              		.loc 1 135 0
 321 01ff E9180100 		jmp	.L24
 321      00
 322              	.L30:
 136:main.c        **** 		// Read chunk N
 137:main.c        **** 		chunkSize = length >= READ_MAX ? READ_MAX : length;
 323              		.loc 1 137 0
 324 0204 B8000001 		movl	$65536, %eax
 324      00
 325 0209 817DC000 		cmpl	$65536, -64(%rbp)
 325      000100
 326 0210 0F4645C0 		cmovbe	-64(%rbp), %eax
 327 0214 8945E4   		movl	%eax, -28(%rbp)
 138:main.c        **** 		fStatus = flReadChannelAsyncSubmit(handle, chan, chunkSize, NULL, error);
 328              		.loc 1 138 0
 329 0217 0FB675C4 		movzbl	-60(%rbp), %esi
 330 021b 488B4DA8 		movq	-88(%rbp), %rcx
 331 021f 8B55E4   		movl	-28(%rbp), %edx
 332 0222 488B45C8 		movq	-56(%rbp), %rax
 333 0226 4989C8   		movq	%rcx, %r8
 334 0229 B9000000 		movl	$0, %ecx
 334      00
 335 022e 4889C7   		movq	%rax, %rdi
 336 0231 E8000000 		call	flReadChannelAsyncSubmit
 336      00
 337 0236 8945E8   		movl	%eax, -24(%rbp)
 139:main.c        **** 		CHECK_STATUS(fStatus, FLP_LIBERR, cleanup, "doRead()");
 338              		.loc 1 139 0
 339 0239 837DE800 		cmpl	$0, -24(%rbp)
 340 023d 741D     		je	.L25
 341              		.loc 1 139 0 is_stmt 0 discriminator 1
 342 023f 488B45A8 		movq	-88(%rbp), %rax
 343 0243 BE000000 		movl	$.LC11, %esi
 343      00
 344 0248 4889C7   		movq	%rax, %rdi
 345 024b E8000000 		call	errPrefix
 345      00
 346 0250 C745E001 		movl	$1, -32(%rbp)
 346      000000
 347 0257 E9890100 		jmp	.L23
 347      00
 348              	.L25:
 140:main.c        **** 		length = length - chunkSize;
 349              		.loc 1 140 0 is_stmt 1
 350 025c 8B45E4   		movl	-28(%rbp), %eax
 351 025f 2945C0   		subl	%eax, -64(%rbp)
 141:main.c        **** 		
 142:main.c        **** 		// Await chunk N-1
 143:main.c        **** 		fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, error);
 352              		.loc 1 143 0
 353 0262 488B7DA8 		movq	-88(%rbp), %rdi
 354 0266 488D4DDC 		leaq	-36(%rbp), %rcx
 355 026a 488D55DC 		leaq	-36(%rbp), %rdx
 356 026e 488D75F0 		leaq	-16(%rbp), %rsi
 357 0272 488B45C8 		movq	-56(%rbp), %rax
 358 0276 4989F8   		movq	%rdi, %r8
 359 0279 4889C7   		movq	%rax, %rdi
 360 027c E8000000 		call	flReadChannelAsyncAwait
 360      00
 361 0281 8945E8   		movl	%eax, -24(%rbp)
 144:main.c        **** 		CHECK_STATUS(fStatus, FLP_LIBERR, cleanup, "doRead()");
 362              		.loc 1 144 0
 363 0284 837DE800 		cmpl	$0, -24(%rbp)
 364 0288 741D     		je	.L26
 365              		.loc 1 144 0 is_stmt 0 discriminator 1
 366 028a 488B45A8 		movq	-88(%rbp), %rax
 367 028e BE000000 		movl	$.LC11, %esi
 367      00
 368 0293 4889C7   		movq	%rax, %rdi
 369 0296 E8000000 		call	errPrefix
 369      00
 370 029b C745E001 		movl	$1, -32(%rbp)
 370      000000
 371 02a2 E93E0100 		jmp	.L23
 371      00
 372              	.L26:
 145:main.c        **** 
 146:main.c        **** 		// Write chunk N-1 to file
 147:main.c        **** 		bytesWritten = (uint32)fwrite(recvData, 1, actualLength, destFile);
 373              		.loc 1 147 0 is_stmt 1
 374 02a7 8B45DC   		movl	-36(%rbp), %eax
 375 02aa 89C2     		movl	%eax, %edx
 376 02ac 488B45F0 		movq	-16(%rbp), %rax
 377 02b0 488B4DB8 		movq	-72(%rbp), %rcx
 378 02b4 BE010000 		movl	$1, %esi
 378      00
 379 02b9 4889C7   		movq	%rax, %rdi
 380 02bc E8000000 		call	fwrite
 380      00
 381 02c1 8945EC   		movl	%eax, -20(%rbp)
 148:main.c        **** 		CHECK_STATUS(bytesWritten != actualLength, FLP_CANNOT_SAVE, cleanup, "doRead()");
 382              		.loc 1 148 0
 383 02c4 8B45DC   		movl	-36(%rbp), %eax
 384 02c7 3945EC   		cmpl	%eax, -20(%rbp)
 385 02ca 741D     		je	.L27
 386              		.loc 1 148 0 is_stmt 0 discriminator 1
 387 02cc 488B45A8 		movq	-88(%rbp), %rax
 388 02d0 BE000000 		movl	$.LC11, %esi
 388      00
 389 02d5 4889C7   		movq	%rax, %rdi
 390 02d8 E8000000 		call	errPrefix
 390      00
 391 02dd C745E00B 		movl	$11, -32(%rbp)
 391      000000
 392 02e4 E9FC0000 		jmp	.L23
 392      00
 393              	.L27:
 149:main.c        **** 
 150:main.c        **** 		// Checksum chunk N-1
 151:main.c        **** 		chunkSize = actualLength;
 394              		.loc 1 151 0 is_stmt 1
 395 02e9 8B45DC   		movl	-36(%rbp), %eax
 396 02ec 8945E4   		movl	%eax, -28(%rbp)
 152:main.c        **** 		ptr = recvData;
 397              		.loc 1 152 0
 398 02ef 488B45F0 		movq	-16(%rbp), %rax
 399 02f3 488945F8 		movq	%rax, -8(%rbp)
 153:main.c        **** 		while ( chunkSize-- ) {
 400              		.loc 1 153 0
 401 02f7 EB16     		jmp	.L28
 402              	.L29:
 154:main.c        **** 			csVal = (uint16)(csVal + *ptr++);
 403              		.loc 1 154 0
 404 02f9 488B45F8 		movq	-8(%rbp), %rax
 405 02fd 488D5001 		leaq	1(%rax), %rdx
 406 0301 488955F8 		movq	%rdx, -8(%rbp)
 407 0305 0FB600   		movzbl	(%rax), %eax
 408 0308 0FB6C0   		movzbl	%al, %eax
 409 030b 660145DA 		addw	%ax, -38(%rbp)
 410              	.L28:
 153:main.c        **** 		while ( chunkSize-- ) {
 411              		.loc 1 153 0 discriminator 1
 412 030f 8B45E4   		movl	-28(%rbp), %eax
 413 0312 8D50FF   		leal	-1(%rax), %edx
 414 0315 8955E4   		movl	%edx, -28(%rbp)
 415 0318 85C0     		testl	%eax, %eax
 416 031a 75DD     		jne	.L29
 417              	.L24:
 135:main.c        **** 		// Read chunk N
 418              		.loc 1 135 0 discriminator 1
 419 031c 837DC000 		cmpl	$0, -64(%rbp)
 420 0320 0F85DEFE 		jne	.L30
 420      FFFF
 155:main.c        **** 		}
 156:main.c        **** 	}
 157:main.c        **** 
 158:main.c        **** 	// Await last chunk
 159:main.c        **** 	fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, error);
 421              		.loc 1 159 0
 422 0326 488B7DA8 		movq	-88(%rbp), %rdi
 423 032a 488D4DDC 		leaq	-36(%rbp), %rcx
 424 032e 488D55DC 		leaq	-36(%rbp), %rdx
 425 0332 488D75F0 		leaq	-16(%rbp), %rsi
 426 0336 488B45C8 		movq	-56(%rbp), %rax
 427 033a 4989F8   		movq	%rdi, %r8
 428 033d 4889C7   		movq	%rax, %rdi
 429 0340 E8000000 		call	flReadChannelAsyncAwait
 429      00
 430 0345 8945E8   		movl	%eax, -24(%rbp)
 160:main.c        **** 	CHECK_STATUS(fStatus, FLP_LIBERR, cleanup, "doRead()");
 431              		.loc 1 160 0
 432 0348 837DE800 		cmpl	$0, -24(%rbp)
 433 034c 741A     		je	.L31
 434              		.loc 1 160 0 is_stmt 0 discriminator 1
 435 034e 488B45A8 		movq	-88(%rbp), %rax
 436 0352 BE000000 		movl	$.LC11, %esi
 436      00
 437 0357 4889C7   		movq	%rax, %rdi
 438 035a E8000000 		call	errPrefix
 438      00
 439 035f C745E001 		movl	$1, -32(%rbp)
 439      000000
 440 0366 EB7D     		jmp	.L23
 441              	.L31:
 161:main.c        **** 	
 162:main.c        **** 	// Write last chunk to file
 163:main.c        **** 	bytesWritten = (uint32)fwrite(recvData, 1, actualLength, destFile);
 442              		.loc 1 163 0 is_stmt 1
 443 0368 8B45DC   		movl	-36(%rbp), %eax
 444 036b 89C2     		movl	%eax, %edx
 445 036d 488B45F0 		movq	-16(%rbp), %rax
 446 0371 488B4DB8 		movq	-72(%rbp), %rcx
 447 0375 BE010000 		movl	$1, %esi
 447      00
 448 037a 4889C7   		movq	%rax, %rdi
 449 037d E8000000 		call	fwrite
 449      00
 450 0382 8945EC   		movl	%eax, -20(%rbp)
 164:main.c        **** 	CHECK_STATUS(bytesWritten != actualLength, FLP_CANNOT_SAVE, cleanup, "doRead()");
 451              		.loc 1 164 0
 452 0385 8B45DC   		movl	-36(%rbp), %eax
 453 0388 3945EC   		cmpl	%eax, -20(%rbp)
 454 038b 741A     		je	.L32
 455              		.loc 1 164 0 is_stmt 0 discriminator 1
 456 038d 488B45A8 		movq	-88(%rbp), %rax
 457 0391 BE000000 		movl	$.LC11, %esi
 457      00
 458 0396 4889C7   		movq	%rax, %rdi
 459 0399 E8000000 		call	errPrefix
 459      00
 460 039e C745E00B 		movl	$11, -32(%rbp)
 460      000000
 461 03a5 EB3E     		jmp	.L23
 462              	.L32:
 165:main.c        **** 
 166:main.c        **** 	// Checksum last chunk
 167:main.c        **** 	chunkSize = actualLength;
 463              		.loc 1 167 0 is_stmt 1
 464 03a7 8B45DC   		movl	-36(%rbp), %eax
 465 03aa 8945E4   		movl	%eax, -28(%rbp)
 168:main.c        **** 	ptr = recvData;
 466              		.loc 1 168 0
 467 03ad 488B45F0 		movq	-16(%rbp), %rax
 468 03b1 488945F8 		movq	%rax, -8(%rbp)
 169:main.c        **** 	while ( chunkSize-- ) {
 469              		.loc 1 169 0
 470 03b5 EB16     		jmp	.L33
 471              	.L34:
 170:main.c        **** 		csVal = (uint16)(csVal + *ptr++);
 472              		.loc 1 170 0
 473 03b7 488B45F8 		movq	-8(%rbp), %rax
 474 03bb 488D5001 		leaq	1(%rax), %rdx
 475 03bf 488955F8 		movq	%rdx, -8(%rbp)
 476 03c3 0FB600   		movzbl	(%rax), %eax
 477 03c6 0FB6C0   		movzbl	%al, %eax
 478 03c9 660145DA 		addw	%ax, -38(%rbp)
 479              	.L33:
 169:main.c        **** 	while ( chunkSize-- ) {
 480              		.loc 1 169 0 discriminator 1
 481 03cd 8B45E4   		movl	-28(%rbp), %eax
 482 03d0 8D50FF   		leal	-1(%rax), %edx
 483 03d3 8955E4   		movl	%edx, -28(%rbp)
 484 03d6 85C0     		testl	%eax, %eax
 485 03d8 75DD     		jne	.L34
 171:main.c        **** 	}
 172:main.c        **** 	
 173:main.c        **** 	// Return checksum to caller
 174:main.c        **** 	*checksum = csVal;
 486              		.loc 1 174 0
 487 03da 488B45B0 		movq	-80(%rbp), %rax
 488 03de 0FB755DA 		movzwl	-38(%rbp), %edx
 489 03e2 668910   		movw	%dx, (%rax)
 490              	.L23:
 175:main.c        **** cleanup:
 176:main.c        **** 	return retVal;
 491              		.loc 1 176 0
 492 03e5 8B45E0   		movl	-32(%rbp), %eax
 177:main.c        **** }
 493              		.loc 1 177 0
 494 03e8 C9       		leave
 495              		.cfi_def_cfa 7, 8
 496 03e9 C3       		ret
 497              		.cfi_endproc
 498              	.LFE8:
 500              		.section	.rodata
 501              	.LC12:
 502 0151 646F5772 		.string	"doWrite()"
 502      69746528 
 502      2900
 503              		.text
 505              	doWrite:
 506              	.LFB9:
 178:main.c        **** 
 179:main.c        **** static ReturnCode doWrite(
 180:main.c        **** 	struct FLContext *handle, uint8 chan, FILE *srcFile, size_t *length, uint16 *checksum,
 181:main.c        **** 	const char **error)
 182:main.c        **** {
 507              		.loc 1 182 0
 508              		.cfi_startproc
 509 03ea 55       		pushq	%rbp
 510              		.cfi_def_cfa_offset 16
 511              		.cfi_offset 6, -16
 512 03eb 4889E5   		movq	%rsp, %rbp
 513              		.cfi_def_cfa_register 6
 514 03ee 53       		pushq	%rbx
 515 03ef 4881EC78 		subq	$65656, %rsp
 515      000100
 516              		.cfi_offset 3, -24
 517 03f6 4889BDA8 		movq	%rdi, -65624(%rbp)
 517      FFFEFF
 518 03fd 89F0     		movl	%esi, %eax
 519 03ff 48899598 		movq	%rdx, -65640(%rbp)
 519      FFFEFF
 520 0406 48898D90 		movq	%rcx, -65648(%rbp)
 520      FFFEFF
 521 040d 4C898588 		movq	%r8, -65656(%rbp)
 521      FFFEFF
 522 0414 4C898D80 		movq	%r9, -65664(%rbp)
 522      FFFEFF
 523 041b 8885A4FF 		movb	%al, -65628(%rbp)
 523      FEFF
 524              		.loc 1 182 0
 525 0421 64488B04 		movq	%fs:40, %rax
 525      25280000 
 525      00
 526 042a 488945E8 		movq	%rax, -24(%rbp)
 527 042e 31C0     		xorl	%eax, %eax
 183:main.c        **** 	ReturnCode retVal = FLP_SUCCESS;
 528              		.loc 1 183 0
 529 0430 C785B8FF 		movl	$0, -65608(%rbp)
 529      FEFF0000 
 529      0000
 184:main.c        **** 	size_t bytesRead, i;
 185:main.c        **** 	FLStatus fStatus;
 186:main.c        **** 	const uint8 *ptr;
 187:main.c        **** 	uint16 csVal = 0x0000;
 530              		.loc 1 187 0
 531 043a 66C785B6 		movw	$0, -65610(%rbp)
 531      FFFEFF00 
 531      00
 188:main.c        **** 	size_t lenVal = 0;
 532              		.loc 1 188 0
 533 0443 48C785D0 		movq	$0, -65584(%rbp)
 533      FFFEFF00 
 533      000000
 534              	.L42:
 189:main.c        **** 	#define WRITE_MAX (65536 - 5)
 190:main.c        **** 	uint8 buffer[WRITE_MAX];
 191:main.c        **** 
 192:main.c        **** 	do {
 193:main.c        **** 		// Read Nth chunk
 194:main.c        **** 		bytesRead = fread(buffer, 1, WRITE_MAX, srcFile);
 535              		.loc 1 194 0
 536 044e 488B9598 		movq	-65640(%rbp), %rdx
 536      FFFEFF
 537 0455 488D85E0 		leaq	-65568(%rbp), %rax
 537      FFFEFF
 538 045c 4889D1   		movq	%rdx, %rcx
 539 045f BAFBFF00 		movl	$65531, %edx
 539      00
 540 0464 BE010000 		movl	$1, %esi
 540      00
 541 0469 4889C7   		movq	%rax, %rdi
 542 046c E8000000 		call	fread
 542      00
 543 0471 488985D8 		movq	%rax, -65576(%rbp)
 543      FFFEFF
 195:main.c        **** 		if ( bytesRead ) {
 544              		.loc 1 195 0
 545 0478 4883BDD8 		cmpq	$0, -65576(%rbp)
 545      FFFEFF00 
 546 0480 0F84C200 		je	.L37
 546      0000
 196:main.c        **** 			// Update running total
 197:main.c        **** 			lenVal = lenVal + bytesRead;
 547              		.loc 1 197 0
 548 0486 488B85D8 		movq	-65576(%rbp), %rax
 548      FFFEFF
 549 048d 480185D0 		addq	%rax, -65584(%rbp)
 549      FFFEFF
 198:main.c        **** 
 199:main.c        **** 			// Submit Nth chunk
 200:main.c        **** 			fStatus = flWriteChannelAsync(handle, chan, bytesRead, buffer, error);
 550              		.loc 1 200 0
 551 0494 0FB6B5A4 		movzbl	-65628(%rbp), %esi
 551      FFFEFF
 552 049b 488BBD80 		movq	-65664(%rbp), %rdi
 552      FFFEFF
 553 04a2 488D8DE0 		leaq	-65568(%rbp), %rcx
 553      FFFEFF
 554 04a9 488B95D8 		movq	-65576(%rbp), %rdx
 554      FFFEFF
 555 04b0 488B85A8 		movq	-65624(%rbp), %rax
 555      FFFEFF
 556 04b7 4989F8   		movq	%rdi, %r8
 557 04ba 4889C7   		movq	%rax, %rdi
 558 04bd E8000000 		call	flWriteChannelAsync
 558      00
 559 04c2 8985BCFF 		movl	%eax, -65604(%rbp)
 559      FEFF
 201:main.c        **** 			CHECK_STATUS(fStatus, FLP_LIBERR, cleanup, "doWrite()");
 560              		.loc 1 201 0
 561 04c8 83BDBCFF 		cmpl	$0, -65604(%rbp)
 561      FEFF00
 562 04cf 7423     		je	.L38
 563              		.loc 1 201 0 is_stmt 0 discriminator 1
 564 04d1 488B8580 		movq	-65664(%rbp), %rax
 564      FFFEFF
 565 04d8 BE000000 		movl	$.LC12, %esi
 565      00
 566 04dd 4889C7   		movq	%rax, %rdi
 567 04e0 E8000000 		call	errPrefix
 567      00
 568 04e5 C785B8FF 		movl	$1, -65608(%rbp)
 568      FEFF0100 
 568      0000
 569 04ef E9CF0000 		jmp	.L39
 569      00
 570              	.L38:
 202:main.c        **** 
 203:main.c        **** 			// Checksum Nth chunk
 204:main.c        **** 			i = bytesRead;
 571              		.loc 1 204 0 is_stmt 1
 572 04f4 488B85D8 		movq	-65576(%rbp), %rax
 572      FFFEFF
 573 04fb 488985C0 		movq	%rax, -65600(%rbp)
 573      FFFEFF
 205:main.c        **** 			ptr = buffer;
 574              		.loc 1 205 0
 575 0502 488D85E0 		leaq	-65568(%rbp), %rax
 575      FFFEFF
 576 0509 488985C8 		movq	%rax, -65592(%rbp)
 576      FFFEFF
 206:main.c        **** 			while ( i-- ) {
 577              		.loc 1 206 0
 578 0510 EB1F     		jmp	.L40
 579              	.L41:
 207:main.c        **** 				csVal = (uint16)(csVal + *ptr++);
 580              		.loc 1 207 0
 581 0512 488B85C8 		movq	-65592(%rbp), %rax
 581      FFFEFF
 582 0519 488D5001 		leaq	1(%rax), %rdx
 583 051d 488995C8 		movq	%rdx, -65592(%rbp)
 583      FFFEFF
 584 0524 0FB600   		movzbl	(%rax), %eax
 585 0527 0FB6C0   		movzbl	%al, %eax
 586 052a 660185B6 		addw	%ax, -65610(%rbp)
 586      FFFEFF
 587              	.L40:
 206:main.c        **** 			while ( i-- ) {
 588              		.loc 1 206 0 discriminator 1
 589 0531 488B85C0 		movq	-65600(%rbp), %rax
 589      FFFEFF
 590 0538 488D50FF 		leaq	-1(%rax), %rdx
 591 053c 488995C0 		movq	%rdx, -65600(%rbp)
 591      FFFEFF
 592 0543 4885C0   		testq	%rax, %rax
 593 0546 75CA     		jne	.L41
 594              	.L37:
 208:main.c        **** 			}
 209:main.c        **** 		}
 210:main.c        **** 	} while ( bytesRead == WRITE_MAX );
 595              		.loc 1 210 0
 596 0548 4881BDD8 		cmpq	$65531, -65576(%rbp)
 596      FFFEFFFB 
 596      FF0000
 597 0553 0F84F5FE 		je	.L42
 597      FFFF
 211:main.c        **** 
 212:main.c        **** 	// Wait for writes to be received. This is optional, but it's only fair if we're benchmarking to
 213:main.c        **** 	// actually wait for the work to be completed.
 214:main.c        **** 	fStatus = flAwaitAsyncWrites(handle, error);
 598              		.loc 1 214 0
 599 0559 488B9580 		movq	-65664(%rbp), %rdx
 599      FFFEFF
 600 0560 488B85A8 		movq	-65624(%rbp), %rax
 600      FFFEFF
 601 0567 4889D6   		movq	%rdx, %rsi
 602 056a 4889C7   		movq	%rax, %rdi
 603 056d E8000000 		call	flAwaitAsyncWrites
 603      00
 604 0572 8985BCFF 		movl	%eax, -65604(%rbp)
 604      FEFF
 215:main.c        **** 	CHECK_STATUS(fStatus, FLP_LIBERR, cleanup, "doWrite()");
 605              		.loc 1 215 0
 606 0578 83BDBCFF 		cmpl	$0, -65604(%rbp)
 606      FEFF00
 607 057f 7420     		je	.L43
 608              		.loc 1 215 0 is_stmt 0 discriminator 1
 609 0581 488B8580 		movq	-65664(%rbp), %rax
 609      FFFEFF
 610 0588 BE000000 		movl	$.LC12, %esi
 610      00
 611 058d 4889C7   		movq	%rax, %rdi
 612 0590 E8000000 		call	errPrefix
 612      00
 613 0595 C785B8FF 		movl	$1, -65608(%rbp)
 613      FEFF0100 
 613      0000
 614 059f EB22     		jmp	.L39
 615              	.L43:
 216:main.c        **** 
 217:main.c        **** 	// Return checksum & length to caller
 218:main.c        **** 	*checksum = csVal;
 616              		.loc 1 218 0 is_stmt 1
 617 05a1 488B8588 		movq	-65656(%rbp), %rax
 617      FFFEFF
 618 05a8 0FB795B6 		movzwl	-65610(%rbp), %edx
 618      FFFEFF
 619 05af 668910   		movw	%dx, (%rax)
 219:main.c        **** 	*length = lenVal;
 620              		.loc 1 219 0
 621 05b2 488B8590 		movq	-65648(%rbp), %rax
 621      FFFEFF
 622 05b9 488B95D0 		movq	-65584(%rbp), %rdx
 622      FFFEFF
 623 05c0 488910   		movq	%rdx, (%rax)
 624              	.L39:
 220:main.c        **** cleanup:
 221:main.c        **** 	return retVal;
 625              		.loc 1 221 0
 626 05c3 8B85B8FF 		movl	-65608(%rbp), %eax
 626      FEFF
 222:main.c        **** }
 627              		.loc 1 222 0
 628 05c9 488B5DE8 		movq	-24(%rbp), %rbx
 629 05cd 6448331C 		xorq	%fs:40, %rbx
 629      25280000 
 629      00
 630 05d6 7405     		je	.L45
 631 05d8 E8000000 		call	__stack_chk_fail
 631      00
 632              	.L45:
 633 05dd 4881C478 		addq	$65656, %rsp
 633      000100
 634 05e4 5B       		popq	%rbx
 635 05e5 5D       		popq	%rbp
 636              		.cfi_def_cfa 7, 8
 637 05e6 C3       		ret
 638              		.cfi_endproc
 639              	.LFE9:
 641              		.section	.rodata
 642              	.LC13:
 643 015b 776200   		.string	"wb"
 644 015e 0000     		.align 8
 645              	.LC16:
 646 0160 52656164 		.string	"Read %d bytes (checksum 0x%04X) from channel %d at %f MiB/s\n"
 646      20256420 
 646      62797465 
 646      73202863 
 646      6865636B 
 647              	.LC17:
 648 019d 726200   		.string	"rb"
 649              		.align 8
 650              	.LC18:
 651 01a0 57726F74 		.string	"Wrote %zu bytes (checksum 0x%04X) to channel %lu at %f MiB/s\n"
 651      6520257A 
 651      75206279 
 651      74657320 
 651      28636865 
 652              	.LC19:
 653 01de 25732061 		.string	"%s at column %d\n  %s\n  "
 653      7420636F 
 653      6C756D6E 
 653      2025640A 
 653      20202573 
 654              	.LC20:
 655 01f6 5E0A00   		.string	"^\n"
 656              		.text
 658              	parseLine:
 659              	.LFB10:
 223:main.c        **** 
 224:main.c        **** static int parseLine(struct FLContext *handle, const char *line, const char **error) {
 660              		.loc 1 224 0
 661              		.cfi_startproc
 662 05e7 55       		pushq	%rbp
 663              		.cfi_def_cfa_offset 16
 664              		.cfi_offset 6, -16
 665 05e8 4889E5   		movq	%rsp, %rbp
 666              		.cfi_def_cfa_register 6
 667 05eb 4881EC00 		subq	$256, %rsp
 667      010000
 668 05f2 4889BD18 		movq	%rdi, -232(%rbp)
 668      FFFFFF
 669 05f9 4889B510 		movq	%rsi, -240(%rbp)
 669      FFFFFF
 670 0600 48899508 		movq	%rdx, -248(%rbp)
 670      FFFFFF
 225:main.c        **** 	ReturnCode retVal = FLP_SUCCESS, status;
 671              		.loc 1 225 0
 672 0607 C78524FF 		movl	$0, -220(%rbp)
 672      FFFF0000 
 672      0000
 226:main.c        **** 	FLStatus fStatus;
 227:main.c        **** 	struct Buffer dataFromFPGA = {0,};
 673              		.loc 1 227 0
 674 0611 48C745E0 		movq	$0, -32(%rbp)
 674      00000000 
 675 0619 48C745E8 		movq	$0, -24(%rbp)
 675      00000000 
 676 0621 48C745F0 		movq	$0, -16(%rbp)
 676      00000000 
 677 0629 48C745F8 		movq	$0, -8(%rbp)
 677      00000000 
 228:main.c        **** 	BufferStatus bStatus;
 229:main.c        **** 	uint8 *data = NULL;
 678              		.loc 1 229 0
 679 0631 48C78558 		movq	$0, -168(%rbp)
 679      FFFFFF00 
 679      000000
 230:main.c        **** 	char *fileName = NULL;
 680              		.loc 1 230 0
 681 063c 48C78560 		movq	$0, -160(%rbp)
 681      FFFFFF00 
 681      000000
 231:main.c        **** 	FILE *file = NULL;
 682              		.loc 1 231 0
 683 0647 48C78568 		movq	$0, -152(%rbp)
 683      FFFFFF00 
 683      000000
 232:main.c        **** 	double totalTime, speed;
 233:main.c        **** 	#ifdef WIN32
 234:main.c        **** 		LARGE_INTEGER tvStart, tvEnd, freq;
 235:main.c        **** 		DWORD_PTR mask = 1;
 236:main.c        **** 		SetThreadAffinityMask(GetCurrentThread(), mask);
 237:main.c        **** 		QueryPerformanceFrequency(&freq);
 238:main.c        **** 	#else
 239:main.c        **** 		struct timeval tvStart, tvEnd;
 240:main.c        **** 		long long startTime, endTime;
 241:main.c        **** 	#endif
 242:main.c        **** 	bStatus = bufInitialise(&dataFromFPGA, 1024, 0x00, error);
 684              		.loc 1 242 0
 685 0652 488B9508 		movq	-248(%rbp), %rdx
 685      FFFFFF
 686 0659 488D45E0 		leaq	-32(%rbp), %rax
 687 065d 4889D1   		movq	%rdx, %rcx
 688 0660 BA000000 		movl	$0, %edx
 688      00
 689 0665 BE000400 		movl	$1024, %esi
 689      00
 690 066a 4889C7   		movq	%rax, %rdi
 691 066d E8000000 		call	bufInitialise
 691      00
 692 0672 898530FF 		movl	%eax, -208(%rbp)
 692      FFFF
 243:main.c        **** 	CHECK_STATUS(bStatus, FLP_LIBERR, cleanup);
 693              		.loc 1 243 0
 694 0678 83BD30FF 		cmpl	$0, -208(%rbp)
 694      FFFF00
 695 067f 740F     		je	.L47
 696              		.loc 1 243 0 is_stmt 0 discriminator 1
 697 0681 C78524FF 		movl	$1, -220(%rbp)
 697      FFFF0100 
 697      0000
 698 068b E9A10E00 		jmp	.L48
 698      00
 699              	.L47:
 244:main.c        **** 	ptr = line;
 700              		.loc 1 244 0 is_stmt 1
 701 0690 488B8510 		movq	-240(%rbp), %rax
 701      FFFFFF
 702 0697 48890500 		movq	%rax, ptr(%rip)
 702      000000
 245:main.c        **** 	do {
 246:main.c        **** 		while ( *ptr == ';' ) {
 703              		.loc 1 246 0
 704 069e EB14     		jmp	.L49
 705              	.L116:
 706 06a0 EB12     		jmp	.L49
 707              	.L50:
 247:main.c        **** 			ptr++;
 708              		.loc 1 247 0
 709 06a2 488B0500 		movq	ptr(%rip), %rax
 709      000000
 710 06a9 4883C001 		addq	$1, %rax
 711 06ad 48890500 		movq	%rax, ptr(%rip)
 711      000000
 712              	.L49:
 246:main.c        **** 			ptr++;
 713              		.loc 1 246 0 discriminator 1
 714 06b4 488B0500 		movq	ptr(%rip), %rax
 714      000000
 715 06bb 0FB600   		movzbl	(%rax), %eax
 716 06be 3C3B     		cmpb	$59, %al
 717 06c0 74E0     		je	.L50
 248:main.c        **** 		}
 249:main.c        **** 		switch ( *ptr ) {
 718              		.loc 1 249 0
 719 06c2 488B0500 		movq	ptr(%rip), %rax
 719      000000
 720 06c9 0FB600   		movzbl	(%rax), %eax
 721 06cc 0FBEC0   		movsbl	%al, %eax
 722 06cf 83F872   		cmpl	$114, %eax
 723 06d2 7417     		je	.L52
 724 06d4 83F877   		cmpl	$119, %eax
 725 06d7 0F84BC06 		je	.L53
 725      0000
 726 06dd 83F82B   		cmpl	$43, %eax
 727 06e0 0F84120D 		je	.L54
 727      0000
 728 06e6 E9F90D00 		jmp	.L123
 728      00
 729              	.L52:
 730              	.LBB2:
 250:main.c        **** 		case 'r':{
 251:main.c        **** 			uint32 chan;
 252:main.c        **** 			uint32 length = 1;
 731              		.loc 1 252 0
 732 06eb C78528FF 		movl	$1, -216(%rbp)
 732      FFFF0100 
 732      0000
 253:main.c        **** 			char *end;
 254:main.c        **** 			ptr++;
 733              		.loc 1 254 0
 734 06f5 488B0500 		movq	ptr(%rip), %rax
 734      000000
 735 06fc 4883C001 		addq	$1, %rax
 736 0700 48890500 		movq	%rax, ptr(%rip)
 736      000000
 255:main.c        **** 			
 256:main.c        **** 			// Get the channel to be read:
 257:main.c        **** 			errno = 0;
 737              		.loc 1 257 0
 738 0707 E8000000 		call	__errno_location
 738      00
 739 070c C7000000 		movl	$0, (%rax)
 739      0000
 258:main.c        **** 			chan = (uint32)strtoul(ptr, &end, 16);
 740              		.loc 1 258 0
 741 0712 488B0500 		movq	ptr(%rip), %rax
 741      000000
 742 0719 488D8D50 		leaq	-176(%rbp), %rcx
 742      FFFFFF
 743 0720 BA100000 		movl	$16, %edx
 743      00
 744 0725 4889CE   		movq	%rcx, %rsi
 745 0728 4889C7   		movq	%rax, %rdi
 746 072b E8000000 		call	strtoul
 746      00
 747 0730 898534FF 		movl	%eax, -204(%rbp)
 747      FFFF
 259:main.c        **** 			CHECK_STATUS(errno, FLP_BAD_HEX, cleanup);
 748              		.loc 1 259 0
 749 0736 E8000000 		call	__errno_location
 749      00
 750 073b 8B00     		movl	(%rax), %eax
 751 073d 85C0     		testl	%eax, %eax
 752 073f 740F     		je	.L55
 753              		.loc 1 259 0 is_stmt 0 discriminator 1
 754 0741 C78524FF 		movl	$2, -220(%rbp)
 754      FFFF0200 
 754      0000
 755 074b E9E10D00 		jmp	.L48
 755      00
 756              	.L55:
 260:main.c        **** 
 261:main.c        **** 			// Ensure that it's 0-127
 262:main.c        **** 			CHECK_STATUS(chan > 127, FLP_CHAN_RANGE, cleanup);
 757              		.loc 1 262 0 is_stmt 1
 758 0750 83BD34FF 		cmpl	$127, -204(%rbp)
 758      FFFF7F
 759 0757 760F     		jbe	.L57
 760              		.loc 1 262 0 is_stmt 0 discriminator 1
 761 0759 C78524FF 		movl	$3, -220(%rbp)
 761      FFFF0300 
 761      0000
 762 0763 E9C90D00 		jmp	.L48
 762      00
 763              	.L57:
 263:main.c        **** 			ptr = end;
 764              		.loc 1 263 0 is_stmt 1
 765 0768 488B8550 		movq	-176(%rbp), %rax
 765      FFFFFF
 766 076f 48890500 		movq	%rax, ptr(%rip)
 766      000000
 264:main.c        **** 
 265:main.c        **** 			// Only three valid chars at this point:
 266:main.c        **** 			CHECK_STATUS(*ptr != '\0' && *ptr != ';' && *ptr != ' ', FLP_ILL_CHAR, cleanup);
 767              		.loc 1 266 0
 768 0776 488B0500 		movq	ptr(%rip), %rax
 768      000000
 769 077d 0FB600   		movzbl	(%rax), %eax
 770 0780 84C0     		testb	%al, %al
 771 0782 742B     		je	.L58
 772              		.loc 1 266 0 is_stmt 0 discriminator 1
 773 0784 488B0500 		movq	ptr(%rip), %rax
 773      000000
 774 078b 0FB600   		movzbl	(%rax), %eax
 775 078e 3C3B     		cmpb	$59, %al
 776 0790 741D     		je	.L58
 777 0792 488B0500 		movq	ptr(%rip), %rax
 777      000000
 778 0799 0FB600   		movzbl	(%rax), %eax
 779 079c 3C20     		cmpb	$32, %al
 780 079e 740F     		je	.L58
 781 07a0 C78524FF 		movl	$5, -220(%rbp)
 781      FFFF0500 
 781      0000
 782 07aa E9820D00 		jmp	.L48
 782      00
 783              	.L58:
 267:main.c        **** 
 268:main.c        **** 			if ( *ptr == ' ' ) {
 784              		.loc 1 268 0 is_stmt 1
 785 07af 488B0500 		movq	ptr(%rip), %rax
 785      000000
 786 07b6 0FB600   		movzbl	(%rax), %eax
 787 07b9 3C20     		cmpb	$32, %al
 788 07bb 0F852602 		jne	.L59
 788      0000
 269:main.c        **** 				ptr++;
 789              		.loc 1 269 0
 790 07c1 488B0500 		movq	ptr(%rip), %rax
 790      000000
 791 07c8 4883C001 		addq	$1, %rax
 792 07cc 48890500 		movq	%rax, ptr(%rip)
 792      000000
 270:main.c        **** 
 271:main.c        **** 				// Get the read count:
 272:main.c        **** 				errno = 0;
 793              		.loc 1 272 0
 794 07d3 E8000000 		call	__errno_location
 794      00
 795 07d8 C7000000 		movl	$0, (%rax)
 795      0000
 273:main.c        **** 				length = (uint32)strtoul(ptr, &end, 16);
 796              		.loc 1 273 0
 797 07de 488B0500 		movq	ptr(%rip), %rax
 797      000000
 798 07e5 488D8D50 		leaq	-176(%rbp), %rcx
 798      FFFFFF
 799 07ec BA100000 		movl	$16, %edx
 799      00
 800 07f1 4889CE   		movq	%rcx, %rsi
 801 07f4 4889C7   		movq	%rax, %rdi
 802 07f7 E8000000 		call	strtoul
 802      00
 803 07fc 898528FF 		movl	%eax, -216(%rbp)
 803      FFFF
 274:main.c        **** 				CHECK_STATUS(errno, FLP_BAD_HEX, cleanup);
 804              		.loc 1 274 0
 805 0802 E8000000 		call	__errno_location
 805      00
 806 0807 8B00     		movl	(%rax), %eax
 807 0809 85C0     		testl	%eax, %eax
 808 080b 740F     		je	.L60
 809              		.loc 1 274 0 is_stmt 0 discriminator 1
 810 080d C78524FF 		movl	$2, -220(%rbp)
 810      FFFF0200 
 810      0000
 811 0817 E9150D00 		jmp	.L48
 811      00
 812              	.L60:
 275:main.c        **** 				ptr = end;
 813              		.loc 1 275 0 is_stmt 1
 814 081c 488B8550 		movq	-176(%rbp), %rax
 814      FFFFFF
 815 0823 48890500 		movq	%rax, ptr(%rip)
 815      000000
 276:main.c        **** 				
 277:main.c        **** 				// Only three valid chars at this point:
 278:main.c        **** 				CHECK_STATUS(*ptr != '\0' && *ptr != ';' && *ptr != ' ', FLP_ILL_CHAR, cleanup);
 816              		.loc 1 278 0
 817 082a 488B0500 		movq	ptr(%rip), %rax
 817      000000
 818 0831 0FB600   		movzbl	(%rax), %eax
 819 0834 84C0     		testb	%al, %al
 820 0836 742B     		je	.L61
 821              		.loc 1 278 0 is_stmt 0 discriminator 1
 822 0838 488B0500 		movq	ptr(%rip), %rax
 822      000000
 823 083f 0FB600   		movzbl	(%rax), %eax
 824 0842 3C3B     		cmpb	$59, %al
 825 0844 741D     		je	.L61
 826 0846 488B0500 		movq	ptr(%rip), %rax
 826      000000
 827 084d 0FB600   		movzbl	(%rax), %eax
 828 0850 3C20     		cmpb	$32, %al
 829 0852 740F     		je	.L61
 830 0854 C78524FF 		movl	$5, -220(%rbp)
 830      FFFF0500 
 830      0000
 831 085e E9CE0C00 		jmp	.L48
 831      00
 832              	.L61:
 279:main.c        **** 				if ( *ptr == ' ' ) {
 833              		.loc 1 279 0 is_stmt 1
 834 0863 488B0500 		movq	ptr(%rip), %rax
 834      000000
 835 086a 0FB600   		movzbl	(%rax), %eax
 836 086d 3C20     		cmpb	$32, %al
 837 086f 0F857201 		jne	.L59
 837      0000
 838              	.LBB3:
 280:main.c        **** 					const char *p;
 281:main.c        **** 					const char quoteChar = *++ptr;
 839              		.loc 1 281 0
 840 0875 488B0500 		movq	ptr(%rip), %rax
 840      000000
 841 087c 4883C001 		addq	$1, %rax
 842 0880 48890500 		movq	%rax, ptr(%rip)
 842      000000
 843 0887 488B0500 		movq	ptr(%rip), %rax
 843      000000
 844 088e 0FB600   		movzbl	(%rax), %eax
 845 0891 888520FF 		movb	%al, -224(%rbp)
 845      FFFF
 282:main.c        **** 					CHECK_STATUS(
 846              		.loc 1 282 0
 847 0897 80BD20FF 		cmpb	$34, -224(%rbp)
 847      FFFF22
 848 089e 7418     		je	.L62
 849              		.loc 1 282 0 is_stmt 0 discriminator 1
 850 08a0 80BD20FF 		cmpb	$39, -224(%rbp)
 850      FFFF27
 851 08a7 740F     		je	.L62
 852 08a9 C78524FF 		movl	$5, -220(%rbp)
 852      FFFF0500 
 852      0000
 853 08b3 E9790C00 		jmp	.L48
 853      00
 854              	.L62:
 283:main.c        **** 						(quoteChar != '"' && quoteChar != '\''),
 284:main.c        **** 						FLP_ILL_CHAR, cleanup);
 285:main.c        **** 					
 286:main.c        **** 					// Get the file to write bytes to:
 287:main.c        **** 					ptr++;
 855              		.loc 1 287 0 is_stmt 1
 856 08b8 488B0500 		movq	ptr(%rip), %rax
 856      000000
 857 08bf 4883C001 		addq	$1, %rax
 858 08c3 48890500 		movq	%rax, ptr(%rip)
 858      000000
 288:main.c        **** 					p = ptr;
 859              		.loc 1 288 0
 860 08ca 488B0500 		movq	ptr(%rip), %rax
 860      000000
 861 08d1 48898570 		movq	%rax, -144(%rbp)
 861      FFFFFF
 289:main.c        **** 					while ( *p != quoteChar && *p != '\0' ) {
 862              		.loc 1 289 0
 863 08d8 EB08     		jmp	.L63
 864              	.L65:
 290:main.c        **** 						p++;
 865              		.loc 1 290 0
 866 08da 48838570 		addq	$1, -144(%rbp)
 866      FFFFFF01 
 867              	.L63:
 289:main.c        **** 					while ( *p != quoteChar && *p != '\0' ) {
 868              		.loc 1 289 0 discriminator 1
 869 08e2 488B8570 		movq	-144(%rbp), %rax
 869      FFFFFF
 870 08e9 0FB600   		movzbl	(%rax), %eax
 871 08ec 3A8520FF 		cmpb	-224(%rbp), %al
 871      FFFF
 872 08f2 740E     		je	.L64
 289:main.c        **** 					while ( *p != quoteChar && *p != '\0' ) {
 873              		.loc 1 289 0 is_stmt 0 discriminator 2
 874 08f4 488B8570 		movq	-144(%rbp), %rax
 874      FFFFFF
 875 08fb 0FB600   		movzbl	(%rax), %eax
 876 08fe 84C0     		testb	%al, %al
 877 0900 75D8     		jne	.L65
 878              	.L64:
 291:main.c        **** 					}
 292:main.c        **** 					CHECK_STATUS(*p == '\0', FLP_UNTERM_STRING, cleanup);
 879              		.loc 1 292 0 is_stmt 1
 880 0902 488B8570 		movq	-144(%rbp), %rax
 880      FFFFFF
 881 0909 0FB600   		movzbl	(%rax), %eax
 882 090c 84C0     		testb	%al, %al
 883 090e 750F     		jne	.L66
 884              		.loc 1 292 0 is_stmt 0 discriminator 1
 885 0910 C78524FF 		movl	$6, -220(%rbp)
 885      FFFF0600 
 885      0000
 886 091a E9120C00 		jmp	.L48
 886      00
 887              	.L66:
 293:main.c        **** 					fileName = malloc((size_t)(p - ptr + 1));
 888              		.loc 1 293 0 is_stmt 1
 889 091f 488B9570 		movq	-144(%rbp), %rdx
 889      FFFFFF
 890 0926 488B0500 		movq	ptr(%rip), %rax
 890      000000
 891 092d 4829C2   		subq	%rax, %rdx
 892 0930 4889D0   		movq	%rdx, %rax
 893 0933 4883C001 		addq	$1, %rax
 894 0937 4889C7   		movq	%rax, %rdi
 895 093a E8000000 		call	malloc
 895      00
 896 093f 48898560 		movq	%rax, -160(%rbp)
 896      FFFFFF
 294:main.c        **** 					CHECK_STATUS(!fileName, FLP_NO_MEMORY, cleanup);
 897              		.loc 1 294 0
 898 0946 4883BD60 		cmpq	$0, -160(%rbp)
 898      FFFFFF00 
 899 094e 750F     		jne	.L67
 900              		.loc 1 294 0 is_stmt 0 discriminator 1
 901 0950 C78524FF 		movl	$7, -220(%rbp)
 901      FFFF0700 
 901      0000
 902 095a E9D20B00 		jmp	.L48
 902      00
 903              	.L67:
 295:main.c        **** 					CHECK_STATUS(p - ptr == 0, FLP_EMPTY_STRING, cleanup);
 904              		.loc 1 295 0 is_stmt 1
 905 095f 488B9570 		movq	-144(%rbp), %rdx
 905      FFFFFF
 906 0966 488B0500 		movq	ptr(%rip), %rax
 906      000000
 907 096d 4839C2   		cmpq	%rax, %rdx
 908 0970 750F     		jne	.L68
 909              		.loc 1 295 0 is_stmt 0 discriminator 1
 910 0972 C78524FF 		movl	$8, -220(%rbp)
 910      FFFF0800 
 910      0000
 911 097c E9B00B00 		jmp	.L48
 911      00
 912              	.L68:
 296:main.c        **** 					strncpy(fileName, ptr, (size_t)(p - ptr));
 913              		.loc 1 296 0 is_stmt 1
 914 0981 488B9570 		movq	-144(%rbp), %rdx
 914      FFFFFF
 915 0988 488B0500 		movq	ptr(%rip), %rax
 915      000000
 916 098f 4829C2   		subq	%rax, %rdx
 917 0992 4889D0   		movq	%rdx, %rax
 918 0995 4889C2   		movq	%rax, %rdx
 919 0998 488B0D00 		movq	ptr(%rip), %rcx
 919      000000
 920 099f 488B8560 		movq	-160(%rbp), %rax
 920      FFFFFF
 921 09a6 4889CE   		movq	%rcx, %rsi
 922 09a9 4889C7   		movq	%rax, %rdi
 923 09ac E8000000 		call	strncpy
 923      00
 297:main.c        **** 					fileName[p - ptr] = '\0';
 924              		.loc 1 297 0
 925 09b1 488B9570 		movq	-144(%rbp), %rdx
 925      FFFFFF
 926 09b8 488B0500 		movq	ptr(%rip), %rax
 926      000000
 927 09bf 4829C2   		subq	%rax, %rdx
 928 09c2 4889D0   		movq	%rdx, %rax
 929 09c5 4889C2   		movq	%rax, %rdx
 930 09c8 488B8560 		movq	-160(%rbp), %rax
 930      FFFFFF
 931 09cf 4801D0   		addq	%rdx, %rax
 932 09d2 C60000   		movb	$0, (%rax)
 298:main.c        **** 					ptr = p + 1;
 933              		.loc 1 298 0
 934 09d5 488B8570 		movq	-144(%rbp), %rax
 934      FFFFFF
 935 09dc 4883C001 		addq	$1, %rax
 936 09e0 48890500 		movq	%rax, ptr(%rip)
 936      000000
 937              	.L59:
 938              	.LBE3:
 299:main.c        **** 				}
 300:main.c        **** 			}
 301:main.c        **** 			if ( fileName ) {
 939              		.loc 1 301 0
 940 09e7 4883BD60 		cmpq	$0, -160(%rbp)
 940      FFFFFF00 
 941 09ef 0F84E201 		je	.L69
 941      0000
 942              	.LBB4:
 302:main.c        **** 				uint16 checksum = 0x0000;
 943              		.loc 1 302 0
 944 09f5 66C78548 		movw	$0, -184(%rbp)
 944      FFFFFF00 
 944      00
 303:main.c        **** 
 304:main.c        **** 				// Open file for writing
 305:main.c        **** 				file = fopen(fileName, "wb");
 945              		.loc 1 305 0
 946 09fe 488B8560 		movq	-160(%rbp), %rax
 946      FFFFFF
 947 0a05 BE000000 		movl	$.LC13, %esi
 947      00
 948 0a0a 4889C7   		movq	%rax, %rdi
 949 0a0d E8000000 		call	fopen
 949      00
 950 0a12 48898568 		movq	%rax, -152(%rbp)
 950      FFFFFF
 306:main.c        **** 				CHECK_STATUS(!file, FLP_CANNOT_SAVE, cleanup);
 951              		.loc 1 306 0
 952 0a19 4883BD68 		cmpq	$0, -152(%rbp)
 952      FFFFFF00 
 953 0a21 750F     		jne	.L70
 954              		.loc 1 306 0 is_stmt 0 discriminator 1
 955 0a23 C78524FF 		movl	$11, -220(%rbp)
 955      FFFF0B00 
 955      0000
 956 0a2d E9FF0A00 		jmp	.L48
 956      00
 957              	.L70:
 307:main.c        **** 				free(fileName);
 958              		.loc 1 307 0 is_stmt 1
 959 0a32 488B8560 		movq	-160(%rbp), %rax
 959      FFFFFF
 960 0a39 4889C7   		movq	%rax, %rdi
 961 0a3c E8000000 		call	free
 961      00
 308:main.c        **** 				fileName = NULL;
 962              		.loc 1 308 0
 963 0a41 48C78560 		movq	$0, -160(%rbp)
 963      FFFFFF00 
 963      000000
 309:main.c        **** 
 310:main.c        **** 				#ifdef WIN32
 311:main.c        **** 					QueryPerformanceCounter(&tvStart);
 312:main.c        **** 					status = doRead(handle, (uint8)chan, length, file, &checksum, error);
 313:main.c        **** 					QueryPerformanceCounter(&tvEnd);
 314:main.c        **** 					totalTime = (double)(tvEnd.QuadPart - tvStart.QuadPart);
 315:main.c        **** 					totalTime /= freq.QuadPart;
 316:main.c        **** 					speed = (double)length / (1024*1024*totalTime);
 317:main.c        **** 				#else
 318:main.c        **** 					gettimeofday(&tvStart, NULL);
 964              		.loc 1 318 0
 965 0a4c 488D45C0 		leaq	-64(%rbp), %rax
 966 0a50 BE000000 		movl	$0, %esi
 966      00
 967 0a55 4889C7   		movq	%rax, %rdi
 968 0a58 E8000000 		call	gettimeofday
 968      00
 319:main.c        **** 					status = doRead(handle, (uint8)chan, length, file, &checksum, error);
 969              		.loc 1 319 0
 970 0a5d 8B8534FF 		movl	-204(%rbp), %eax
 970      FFFF
 971 0a63 0FB6F0   		movzbl	%al, %esi
 972 0a66 4C8B8508 		movq	-248(%rbp), %r8
 972      FFFFFF
 973 0a6d 488DBD48 		leaq	-184(%rbp), %rdi
 973      FFFFFF
 974 0a74 488B8D68 		movq	-152(%rbp), %rcx
 974      FFFFFF
 975 0a7b 8B9528FF 		movl	-216(%rbp), %edx
 975      FFFF
 976 0a81 488B8518 		movq	-232(%rbp), %rax
 976      FFFFFF
 977 0a88 4D89C1   		movq	%r8, %r9
 978 0a8b 4989F8   		movq	%rdi, %r8
 979 0a8e 4889C7   		movq	%rax, %rdi
 980 0a91 E8DEF6FF 		call	doRead
 980      FF
 981 0a96 898538FF 		movl	%eax, -200(%rbp)
 981      FFFF
 320:main.c        **** 					gettimeofday(&tvEnd, NULL);
 982              		.loc 1 320 0
 983 0a9c 488D45D0 		leaq	-48(%rbp), %rax
 984 0aa0 BE000000 		movl	$0, %esi
 984      00
 985 0aa5 4889C7   		movq	%rax, %rdi
 986 0aa8 E8000000 		call	gettimeofday
 986      00
 321:main.c        **** 					startTime = tvStart.tv_sec;
 987              		.loc 1 321 0
 988 0aad 488B45C0 		movq	-64(%rbp), %rax
 989 0ab1 48894590 		movq	%rax, -112(%rbp)
 322:main.c        **** 					startTime *= 1000000;
 990              		.loc 1 322 0
 991 0ab5 488B4590 		movq	-112(%rbp), %rax
 992 0ab9 4869C040 		imulq	$1000000, %rax, %rax
 992      420F00
 993 0ac0 48894590 		movq	%rax, -112(%rbp)
 323:main.c        **** 					startTime += tvStart.tv_usec;
 994              		.loc 1 323 0
 995 0ac4 488B45C8 		movq	-56(%rbp), %rax
 996 0ac8 48014590 		addq	%rax, -112(%rbp)
 324:main.c        **** 					endTime = tvEnd.tv_sec;
 997              		.loc 1 324 0
 998 0acc 488B45D0 		movq	-48(%rbp), %rax
 999 0ad0 48894598 		movq	%rax, -104(%rbp)
 325:main.c        **** 					endTime *= 1000000;
 1000              		.loc 1 325 0
 1001 0ad4 488B4598 		movq	-104(%rbp), %rax
 1002 0ad8 4869C040 		imulq	$1000000, %rax, %rax
 1002      420F00
 1003 0adf 48894598 		movq	%rax, -104(%rbp)
 326:main.c        **** 					endTime += tvEnd.tv_usec;
 1004              		.loc 1 326 0
 1005 0ae3 488B45D8 		movq	-40(%rbp), %rax
 1006 0ae7 48014598 		addq	%rax, -104(%rbp)
 327:main.c        **** 					totalTime = (double)(endTime - startTime);
 1007              		.loc 1 327 0
 1008 0aeb 488B4590 		movq	-112(%rbp), %rax
 1009 0aef 488B5598 		movq	-104(%rbp), %rdx
 1010 0af3 4829C2   		subq	%rax, %rdx
 1011 0af6 4889D0   		movq	%rdx, %rax
 1012 0af9 F2480F2A 		cvtsi2sdq	%rax, %xmm0
 1012      C0
 1013 0afe F20F1145 		movsd	%xmm0, -96(%rbp)
 1013      A0
 328:main.c        **** 					totalTime /= 1000000;  // convert from uS to S.
 1014              		.loc 1 328 0
 1015 0b03 F20F1045 		movsd	-96(%rbp), %xmm0
 1015      A0
 1016 0b08 F20F100D 		movsd	.LC14(%rip), %xmm1
 1016      00000000 
 1017 0b10 F20F5EC1 		divsd	%xmm1, %xmm0
 1018 0b14 F20F1145 		movsd	%xmm0, -96(%rbp)
 1018      A0
 329:main.c        **** 					speed = (double)length / (1024*1024*totalTime);
 1019              		.loc 1 329 0
 1020 0b19 8B8528FF 		movl	-216(%rbp), %eax
 1020      FFFF
 1021 0b1f 4885C0   		testq	%rax, %rax
 1022 0b22 7807     		js	.L72
 1023 0b24 F2480F2A 		cvtsi2sdq	%rax, %xmm0
 1023      C0
 1024 0b29 EB15     		jmp	.L73
 1025              	.L72:
 1026 0b2b 4889C2   		movq	%rax, %rdx
 1027 0b2e 48D1EA   		shrq	%rdx
 1028 0b31 83E001   		andl	$1, %eax
 1029 0b34 4809C2   		orq	%rax, %rdx
 1030 0b37 F2480F2A 		cvtsi2sdq	%rdx, %xmm0
 1030      C2
 1031 0b3c F20F58C0 		addsd	%xmm0, %xmm0
 1032              	.L73:
 1033 0b40 F20F1055 		movsd	-96(%rbp), %xmm2
 1033      A0
 1034 0b45 F20F100D 		movsd	.LC15(%rip), %xmm1
 1034      00000000 
 1035 0b4d F20F59CA 		mulsd	%xmm2, %xmm1
 1036 0b51 F20F5EC1 		divsd	%xmm1, %xmm0
 1037 0b55 F20F1145 		movsd	%xmm0, -88(%rbp)
 1037      A8
 330:main.c        **** 				#endif
 331:main.c        **** 				if ( enableBenchmarking ) {
 1038              		.loc 1 331 0
 1039 0b5a 0FB60500 		movzbl	enableBenchmarking(%rip), %eax
 1039      000000
 1040 0b61 84C0     		testb	%al, %al
 1041 0b63 7438     		je	.L74
 332:main.c        **** 					printf(
 1042              		.loc 1 332 0
 1043 0b65 0FB78548 		movzwl	-184(%rbp), %eax
 1043      FFFFFF
 1044 0b6c 0FB7D0   		movzwl	%ax, %edx
 1045 0b6f 488B45A8 		movq	-88(%rbp), %rax
 1046 0b73 8B8D34FF 		movl	-204(%rbp), %ecx
 1046      FFFF
 1047 0b79 8BB528FF 		movl	-216(%rbp), %esi
 1047      FFFF
 1048 0b7f 48898500 		movq	%rax, -256(%rbp)
 1048      FFFFFF
 1049 0b86 F20F1085 		movsd	-256(%rbp), %xmm0
 1049      00FFFFFF 
 1050 0b8e BF000000 		movl	$.LC16, %edi
 1050      00
 1051 0b93 B8010000 		movl	$1, %eax
 1051      00
 1052 0b98 E8000000 		call	printf
 1052      00
 1053              	.L74:
 333:main.c        **** 						"Read %d bytes (checksum 0x%04X) from channel %d at %f MiB/s\n",
 334:main.c        **** 						length, checksum, chan, speed);
 335:main.c        **** 				}
 336:main.c        **** 				CHECK_STATUS(status, status, cleanup);
 1054              		.loc 1 336 0
 1055 0b9d 83BD38FF 		cmpl	$0, -200(%rbp)
 1055      FFFF00
 1056 0ba4 7412     		je	.L75
 1057              		.loc 1 336 0 is_stmt 0 discriminator 1
 1058 0ba6 8B8538FF 		movl	-200(%rbp), %eax
 1058      FFFF
 1059 0bac 898524FF 		movl	%eax, -220(%rbp)
 1059      FFFF
 1060 0bb2 90       		nop
 1061              	.LBE4:
 259:main.c        **** 
 1062              		.loc 1 259 0 is_stmt 1 discriminator 1
 1063 0bb3 E9790900 		jmp	.L48
 1063      00
 1064              	.L75:
 1065              	.LBB5:
 337:main.c        **** 
 338:main.c        **** 				// Close the file
 339:main.c        **** 				fclose(file);
 1066              		.loc 1 339 0
 1067 0bb8 488B8568 		movq	-152(%rbp), %rax
 1067      FFFFFF
 1068 0bbf 4889C7   		movq	%rax, %rdi
 1069 0bc2 E8000000 		call	fclose
 1069      00
 340:main.c        **** 				file = NULL;
 1070              		.loc 1 340 0
 1071 0bc7 48C78568 		movq	$0, -152(%rbp)
 1071      FFFFFF00 
 1071      000000
 1072              	.LBE5:
 1073 0bd2 E9190900 		jmp	.L81
 1073      00
 1074              	.L69:
 1075              	.LBB6:
 341:main.c        **** 			} else {
 342:main.c        **** 				size_t oldLength = dataFromFPGA.length;
 1076              		.loc 1 342 0
 1077 0bd7 488B45E8 		movq	-24(%rbp), %rax
 1078 0bdb 488945B0 		movq	%rax, -80(%rbp)
 343:main.c        **** 				bStatus = bufAppendConst(&dataFromFPGA, 0x00, length, error);
 1079              		.loc 1 343 0
 1080 0bdf 8B9528FF 		movl	-216(%rbp), %edx
 1080      FFFF
 1081 0be5 488B8D08 		movq	-248(%rbp), %rcx
 1081      FFFFFF
 1082 0bec 488D45E0 		leaq	-32(%rbp), %rax
 1083 0bf0 BE000000 		movl	$0, %esi
 1083      00
 1084 0bf5 4889C7   		movq	%rax, %rdi
 1085 0bf8 E8000000 		call	bufAppendConst
 1085      00
 1086 0bfd 898530FF 		movl	%eax, -208(%rbp)
 1086      FFFF
 344:main.c        **** 				CHECK_STATUS(bStatus, FLP_LIBERR, cleanup);
 1087              		.loc 1 344 0
 1088 0c03 83BD30FF 		cmpl	$0, -208(%rbp)
 1088      FFFF00
 1089 0c0a 740F     		je	.L77
 1090              		.loc 1 344 0 is_stmt 0 discriminator 1
 1091 0c0c C78524FF 		movl	$1, -220(%rbp)
 1091      FFFF0100 
 1091      0000
 1092 0c16 E9160900 		jmp	.L48
 1092      00
 1093              	.L77:
 345:main.c        **** 				#ifdef WIN32
 346:main.c        **** 					QueryPerformanceCounter(&tvStart);
 347:main.c        **** 					fStatus = flReadChannel(handle, (uint8)chan, length, dataFromFPGA.data + oldLength, error);
 348:main.c        **** 					QueryPerformanceCounter(&tvEnd);
 349:main.c        **** 					totalTime = (double)(tvEnd.QuadPart - tvStart.QuadPart);
 350:main.c        **** 					totalTime /= freq.QuadPart;
 351:main.c        **** 					speed = (double)length / (1024*1024*totalTime);
 352:main.c        **** 				#else
 353:main.c        **** 					gettimeofday(&tvStart, NULL);
 1094              		.loc 1 353 0 is_stmt 1
 1095 0c1b 488D45C0 		leaq	-64(%rbp), %rax
 1096 0c1f BE000000 		movl	$0, %esi
 1096      00
 1097 0c24 4889C7   		movq	%rax, %rdi
 1098 0c27 E8000000 		call	gettimeofday
 1098      00
 354:main.c        **** 					fStatus = flReadChannel(handle, (uint8)chan, length, dataFromFPGA.data + oldLength, error);
 1099              		.loc 1 354 0
 1100 0c2c 488B55E0 		movq	-32(%rbp), %rdx
 1101 0c30 488B45B0 		movq	-80(%rbp), %rax
 1102 0c34 488D0C02 		leaq	(%rdx,%rax), %rcx
 1103 0c38 8B9528FF 		movl	-216(%rbp), %edx
 1103      FFFF
 1104 0c3e 8B8534FF 		movl	-204(%rbp), %eax
 1104      FFFF
 1105 0c44 0FB6F0   		movzbl	%al, %esi
 1106 0c47 488BBD08 		movq	-248(%rbp), %rdi
 1106      FFFFFF
 1107 0c4e 488B8518 		movq	-232(%rbp), %rax
 1107      FFFFFF
 1108 0c55 4989F8   		movq	%rdi, %r8
 1109 0c58 4889C7   		movq	%rax, %rdi
 1110 0c5b E8000000 		call	flReadChannel
 1110      00
 1111 0c60 89853CFF 		movl	%eax, -196(%rbp)
 1111      FFFF
 355:main.c        **** 					gettimeofday(&tvEnd, NULL);
 1112              		.loc 1 355 0
 1113 0c66 488D45D0 		leaq	-48(%rbp), %rax
 1114 0c6a BE000000 		movl	$0, %esi
 1114      00
 1115 0c6f 4889C7   		movq	%rax, %rdi
 1116 0c72 E8000000 		call	gettimeofday
 1116      00
 356:main.c        **** 					startTime = tvStart.tv_sec;
 1117              		.loc 1 356 0
 1118 0c77 488B45C0 		movq	-64(%rbp), %rax
 1119 0c7b 48894590 		movq	%rax, -112(%rbp)
 357:main.c        **** 					startTime *= 1000000;
 1120              		.loc 1 357 0
 1121 0c7f 488B4590 		movq	-112(%rbp), %rax
 1122 0c83 4869C040 		imulq	$1000000, %rax, %rax
 1122      420F00
 1123 0c8a 48894590 		movq	%rax, -112(%rbp)
 358:main.c        **** 					startTime += tvStart.tv_usec;
 1124              		.loc 1 358 0
 1125 0c8e 488B45C8 		movq	-56(%rbp), %rax
 1126 0c92 48014590 		addq	%rax, -112(%rbp)
 359:main.c        **** 					endTime = tvEnd.tv_sec;
 1127              		.loc 1 359 0
 1128 0c96 488B45D0 		movq	-48(%rbp), %rax
 1129 0c9a 48894598 		movq	%rax, -104(%rbp)
 360:main.c        **** 					endTime *= 1000000;
 1130              		.loc 1 360 0
 1131 0c9e 488B4598 		movq	-104(%rbp), %rax
 1132 0ca2 4869C040 		imulq	$1000000, %rax, %rax
 1132      420F00
 1133 0ca9 48894598 		movq	%rax, -104(%rbp)
 361:main.c        **** 					endTime += tvEnd.tv_usec;
 1134              		.loc 1 361 0
 1135 0cad 488B45D8 		movq	-40(%rbp), %rax
 1136 0cb1 48014598 		addq	%rax, -104(%rbp)
 362:main.c        **** 					totalTime = (double)(endTime - startTime);
 1137              		.loc 1 362 0
 1138 0cb5 488B4590 		movq	-112(%rbp), %rax
 1139 0cb9 488B5598 		movq	-104(%rbp), %rdx
 1140 0cbd 4829C2   		subq	%rax, %rdx
 1141 0cc0 4889D0   		movq	%rdx, %rax
 1142 0cc3 F2480F2A 		cvtsi2sdq	%rax, %xmm0
 1142      C0
 1143 0cc8 F20F1145 		movsd	%xmm0, -96(%rbp)
 1143      A0
 363:main.c        **** 					totalTime /= 1000000;  // convert from uS to S.
 1144              		.loc 1 363 0
 1145 0ccd F20F1045 		movsd	-96(%rbp), %xmm0
 1145      A0
 1146 0cd2 F20F100D 		movsd	.LC14(%rip), %xmm1
 1146      00000000 
 1147 0cda F20F5EC1 		divsd	%xmm1, %xmm0
 1148 0cde F20F1145 		movsd	%xmm0, -96(%rbp)
 1148      A0
 364:main.c        **** 					speed = (double)length / (1024*1024*totalTime);
 1149              		.loc 1 364 0
 1150 0ce3 8B8528FF 		movl	-216(%rbp), %eax
 1150      FFFF
 1151 0ce9 4885C0   		testq	%rax, %rax
 1152 0cec 7807     		js	.L78
 1153 0cee F2480F2A 		cvtsi2sdq	%rax, %xmm0
 1153      C0
 1154 0cf3 EB15     		jmp	.L79
 1155              	.L78:
 1156 0cf5 4889C2   		movq	%rax, %rdx
 1157 0cf8 48D1EA   		shrq	%rdx
 1158 0cfb 83E001   		andl	$1, %eax
 1159 0cfe 4809C2   		orq	%rax, %rdx
 1160 0d01 F2480F2A 		cvtsi2sdq	%rdx, %xmm0
 1160      C2
 1161 0d06 F20F58C0 		addsd	%xmm0, %xmm0
 1162              	.L79:
 1163 0d0a F20F1055 		movsd	-96(%rbp), %xmm2
 1163      A0
 1164 0d0f F20F100D 		movsd	.LC15(%rip), %xmm1
 1164      00000000 
 1165 0d17 F20F59CA 		mulsd	%xmm2, %xmm1
 1166 0d1b F20F5EC1 		divsd	%xmm1, %xmm0
 1167 0d1f F20F1145 		movsd	%xmm0, -88(%rbp)
 1167      A8
 365:main.c        **** 				#endif
 366:main.c        **** 				if ( enableBenchmarking ) {
 1168              		.loc 1 366 0
 1169 0d24 0FB60500 		movzbl	enableBenchmarking(%rip), %eax
 1169      000000
 1170 0d2b 84C0     		testb	%al, %al
 1171 0d2d 744D     		je	.L80
 367:main.c        **** 					printf(
 368:main.c        **** 						"Read %d bytes (checksum 0x%04X) from channel %d at %f MiB/s\n",
 369:main.c        **** 						length, calcChecksum(dataFromFPGA.data + oldLength, length), chan, speed);
 1172              		.loc 1 369 0
 1173 0d2f 8B8528FF 		movl	-216(%rbp), %eax
 1173      FFFF
 1174 0d35 488B4DE0 		movq	-32(%rbp), %rcx
 1175 0d39 488B55B0 		movq	-80(%rbp), %rdx
 1176 0d3d 4801CA   		addq	%rcx, %rdx
 1177 0d40 4889C6   		movq	%rax, %rsi
 1178 0d43 4889D7   		movq	%rdx, %rdi
 1179 0d46 E8F3F2FF 		call	calcChecksum
 1179      FF
 367:main.c        **** 					printf(
 1180              		.loc 1 367 0
 1181 0d4b 0FB7D0   		movzwl	%ax, %edx
 1182 0d4e 488B45A8 		movq	-88(%rbp), %rax
 1183 0d52 8B8D34FF 		movl	-204(%rbp), %ecx
 1183      FFFF
 1184 0d58 8BB528FF 		movl	-216(%rbp), %esi
 1184      FFFF
 1185 0d5e 48898500 		movq	%rax, -256(%rbp)
 1185      FFFFFF
 1186 0d65 F20F1085 		movsd	-256(%rbp), %xmm0
 1186      00FFFFFF 
 1187 0d6d BF000000 		movl	$.LC16, %edi
 1187      00
 1188 0d72 B8010000 		movl	$1, %eax
 1188      00
 1189 0d77 E8000000 		call	printf
 1189      00
 1190              	.L80:
 370:main.c        **** 				}
 371:main.c        **** 				CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1191              		.loc 1 371 0
 1192 0d7c 83BD3CFF 		cmpl	$0, -196(%rbp)
 1192      FFFF00
 1193 0d83 0F846707 		je	.L81
 1193      0000
 1194              		.loc 1 371 0 is_stmt 0 discriminator 1
 1195 0d89 C78524FF 		movl	$1, -220(%rbp)
 1195      FFFF0100 
 1195      0000
 1196 0d93 90       		nop
 1197 0d94 E9980700 		jmp	.L48
 1197      00
 1198              	.L53:
 1199              	.LBE6:
 1200              	.LBE2:
 1201              	.LBB7:
 372:main.c        **** 			}
 373:main.c        **** 			break;
 374:main.c        **** 		}
 375:main.c        **** 		case 'w':{
 376:main.c        **** 			unsigned long int chan;
 377:main.c        **** 			size_t length = 1, i;
 1202              		.loc 1 377 0 is_stmt 1
 1203 0d99 48C78548 		movq	$1, -184(%rbp)
 1203      FFFFFF01 
 1203      000000
 378:main.c        **** 			char *end, ch;
 379:main.c        **** 			const char *p;
 380:main.c        **** 			ptr++;
 1204              		.loc 1 380 0
 1205 0da4 488B0500 		movq	ptr(%rip), %rax
 1205      000000
 1206 0dab 4883C001 		addq	$1, %rax
 1207 0daf 48890500 		movq	%rax, ptr(%rip)
 1207      000000
 381:main.c        **** 			
 382:main.c        **** 			// Get the channel to be written:
 383:main.c        **** 			errno = 0;
 1208              		.loc 1 383 0
 1209 0db6 E8000000 		call	__errno_location
 1209      00
 1210 0dbb C7000000 		movl	$0, (%rax)
 1210      0000
 384:main.c        **** 			chan = strtoul(ptr, &end, 16);
 1211              		.loc 1 384 0
 1212 0dc1 488B0500 		movq	ptr(%rip), %rax
 1212      000000
 1213 0dc8 488D8D50 		leaq	-176(%rbp), %rcx
 1213      FFFFFF
 1214 0dcf BA100000 		movl	$16, %edx
 1214      00
 1215 0dd4 4889CE   		movq	%rcx, %rsi
 1216 0dd7 4889C7   		movq	%rax, %rdi
 1217 0dda E8000000 		call	strtoul
 1217      00
 1218 0ddf 488945B8 		movq	%rax, -72(%rbp)
 385:main.c        **** 			CHECK_STATUS(errno, FLP_BAD_HEX, cleanup);
 1219              		.loc 1 385 0
 1220 0de3 E8000000 		call	__errno_location
 1220      00
 1221 0de8 8B00     		movl	(%rax), %eax
 1222 0dea 85C0     		testl	%eax, %eax
 1223 0dec 740F     		je	.L82
 1224              		.loc 1 385 0 is_stmt 0 discriminator 1
 1225 0dee C78524FF 		movl	$2, -220(%rbp)
 1225      FFFF0200 
 1225      0000
 1226 0df8 E9340700 		jmp	.L48
 1226      00
 1227              	.L82:
 386:main.c        **** 
 387:main.c        **** 			// Ensure that it's 0-127
 388:main.c        **** 			CHECK_STATUS(chan > 127, FLP_CHAN_RANGE, cleanup);
 1228              		.loc 1 388 0 is_stmt 1
 1229 0dfd 48837DB8 		cmpq	$127, -72(%rbp)
 1229      7F
 1230 0e02 760F     		jbe	.L84
 1231              		.loc 1 388 0 is_stmt 0 discriminator 1
 1232 0e04 C78524FF 		movl	$3, -220(%rbp)
 1232      FFFF0300 
 1232      0000
 1233 0e0e E91E0700 		jmp	.L48
 1233      00
 1234              	.L84:
 389:main.c        **** 			ptr = end;
 1235              		.loc 1 389 0 is_stmt 1
 1236 0e13 488B8550 		movq	-176(%rbp), %rax
 1236      FFFFFF
 1237 0e1a 48890500 		movq	%rax, ptr(%rip)
 1237      000000
 390:main.c        **** 
 391:main.c        **** 			// There must be a space now:
 392:main.c        **** 			CHECK_STATUS(*ptr != ' ', FLP_ILL_CHAR, cleanup);
 1238              		.loc 1 392 0
 1239 0e21 488B0500 		movq	ptr(%rip), %rax
 1239      000000
 1240 0e28 0FB600   		movzbl	(%rax), %eax
 1241 0e2b 3C20     		cmpb	$32, %al
 1242 0e2d 740F     		je	.L85
 1243              		.loc 1 392 0 is_stmt 0 discriminator 1
 1244 0e2f C78524FF 		movl	$5, -220(%rbp)
 1244      FFFF0500 
 1244      0000
 1245 0e39 E9F30600 		jmp	.L48
 1245      00
 1246              	.L85:
 393:main.c        **** 
 394:main.c        **** 			// Now either a quote or a hex digit
 395:main.c        **** 		   ch = *++ptr;
 1247              		.loc 1 395 0 is_stmt 1
 1248 0e3e 488B0500 		movq	ptr(%rip), %rax
 1248      000000
 1249 0e45 4883C001 		addq	$1, %rax
 1250 0e49 48890500 		movq	%rax, ptr(%rip)
 1250      000000
 1251 0e50 488B0500 		movq	ptr(%rip), %rax
 1251      000000
 1252 0e57 0FB600   		movzbl	(%rax), %eax
 1253 0e5a 888521FF 		movb	%al, -223(%rbp)
 1253      FFFF
 396:main.c        **** 			if ( ch == '"' || ch == '\'' ) {
 1254              		.loc 1 396 0
 1255 0e60 80BD21FF 		cmpb	$34, -223(%rbp)
 1255      FFFF22
 1256 0e67 740D     		je	.L86
 1257              		.loc 1 396 0 is_stmt 0 discriminator 1
 1258 0e69 80BD21FF 		cmpb	$39, -223(%rbp)
 1258      FFFF27
 1259 0e70 0F85F302 		jne	.L87
 1259      0000
 1260              	.L86:
 1261              	.LBB8:
 397:main.c        **** 				uint16 checksum = 0x0000;
 1262              		.loc 1 397 0 is_stmt 1
 1263 0e76 66C78522 		movw	$0, -222(%rbp)
 1263      FFFFFF00 
 1263      00
 398:main.c        **** 
 399:main.c        **** 				// Get the file to read bytes from:
 400:main.c        **** 				ptr++;
 1264              		.loc 1 400 0
 1265 0e7f 488B0500 		movq	ptr(%rip), %rax
 1265      000000
 1266 0e86 4883C001 		addq	$1, %rax
 1267 0e8a 48890500 		movq	%rax, ptr(%rip)
 1267      000000
 401:main.c        **** 				p = ptr;
 1268              		.loc 1 401 0
 1269 0e91 488B0500 		movq	ptr(%rip), %rax
 1269      000000
 1270 0e98 48894580 		movq	%rax, -128(%rbp)
 402:main.c        **** 				while ( *p != ch && *p != '\0' ) {
 1271              		.loc 1 402 0
 1272 0e9c EB05     		jmp	.L88
 1273              	.L90:
 403:main.c        **** 					p++;
 1274              		.loc 1 403 0
 1275 0e9e 48834580 		addq	$1, -128(%rbp)
 1275      01
 1276              	.L88:
 402:main.c        **** 				while ( *p != ch && *p != '\0' ) {
 1277              		.loc 1 402 0 discriminator 1
 1278 0ea3 488B4580 		movq	-128(%rbp), %rax
 1279 0ea7 0FB600   		movzbl	(%rax), %eax
 1280 0eaa 3A8521FF 		cmpb	-223(%rbp), %al
 1280      FFFF
 1281 0eb0 740B     		je	.L89
 402:main.c        **** 				while ( *p != ch && *p != '\0' ) {
 1282              		.loc 1 402 0 is_stmt 0 discriminator 2
 1283 0eb2 488B4580 		movq	-128(%rbp), %rax
 1284 0eb6 0FB600   		movzbl	(%rax), %eax
 1285 0eb9 84C0     		testb	%al, %al
 1286 0ebb 75E1     		jne	.L90
 1287              	.L89:
 404:main.c        **** 				}
 405:main.c        **** 				CHECK_STATUS(*p == '\0', FLP_UNTERM_STRING, cleanup);
 1288              		.loc 1 405 0 is_stmt 1
 1289 0ebd 488B4580 		movq	-128(%rbp), %rax
 1290 0ec1 0FB600   		movzbl	(%rax), %eax
 1291 0ec4 84C0     		testb	%al, %al
 1292 0ec6 750F     		jne	.L91
 1293              		.loc 1 405 0 is_stmt 0 discriminator 1
 1294 0ec8 C78524FF 		movl	$6, -220(%rbp)
 1294      FFFF0600 
 1294      0000
 1295 0ed2 E95A0600 		jmp	.L48
 1295      00
 1296              	.L91:
 406:main.c        **** 				fileName = malloc((size_t)(p - ptr + 1));
 1297              		.loc 1 406 0 is_stmt 1
 1298 0ed7 488B5580 		movq	-128(%rbp), %rdx
 1299 0edb 488B0500 		movq	ptr(%rip), %rax
 1299      000000
 1300 0ee2 4829C2   		subq	%rax, %rdx
 1301 0ee5 4889D0   		movq	%rdx, %rax
 1302 0ee8 4883C001 		addq	$1, %rax
 1303 0eec 4889C7   		movq	%rax, %rdi
 1304 0eef E8000000 		call	malloc
 1304      00
 1305 0ef4 48898560 		movq	%rax, -160(%rbp)
 1305      FFFFFF
 407:main.c        **** 				CHECK_STATUS(!fileName, FLP_NO_MEMORY, cleanup);
 1306              		.loc 1 407 0
 1307 0efb 4883BD60 		cmpq	$0, -160(%rbp)
 1307      FFFFFF00 
 1308 0f03 750F     		jne	.L93
 1309              		.loc 1 407 0 is_stmt 0 discriminator 1
 1310 0f05 C78524FF 		movl	$7, -220(%rbp)
 1310      FFFF0700 
 1310      0000
 1311 0f0f E9500200 		jmp	.L92
 1311      00
 1312              	.L93:
 408:main.c        **** 				CHECK_STATUS(p - ptr == 0, FLP_EMPTY_STRING, cleanup);
 1313              		.loc 1 408 0 is_stmt 1
 1314 0f14 488B5580 		movq	-128(%rbp), %rdx
 1315 0f18 488B0500 		movq	ptr(%rip), %rax
 1315      000000
 1316 0f1f 4839C2   		cmpq	%rax, %rdx
 1317 0f22 750F     		jne	.L94
 1318              		.loc 1 408 0 is_stmt 0 discriminator 1
 1319 0f24 C78524FF 		movl	$8, -220(%rbp)
 1319      FFFF0800 
 1319      0000
 1320 0f2e E9310200 		jmp	.L92
 1320      00
 1321              	.L94:
 409:main.c        **** 				strncpy(fileName, ptr, (size_t)(p - ptr));
 1322              		.loc 1 409 0 is_stmt 1
 1323 0f33 488B5580 		movq	-128(%rbp), %rdx
 1324 0f37 488B0500 		movq	ptr(%rip), %rax
 1324      000000
 1325 0f3e 4829C2   		subq	%rax, %rdx
 1326 0f41 4889D0   		movq	%rdx, %rax
 1327 0f44 4889C2   		movq	%rax, %rdx
 1328 0f47 488B0D00 		movq	ptr(%rip), %rcx
 1328      000000
 1329 0f4e 488B8560 		movq	-160(%rbp), %rax
 1329      FFFFFF
 1330 0f55 4889CE   		movq	%rcx, %rsi
 1331 0f58 4889C7   		movq	%rax, %rdi
 1332 0f5b E8000000 		call	strncpy
 1332      00
 410:main.c        **** 				fileName[p - ptr] = '\0';
 1333              		.loc 1 410 0
 1334 0f60 488B5580 		movq	-128(%rbp), %rdx
 1335 0f64 488B0500 		movq	ptr(%rip), %rax
 1335      000000
 1336 0f6b 4829C2   		subq	%rax, %rdx
 1337 0f6e 4889D0   		movq	%rdx, %rax
 1338 0f71 4889C2   		movq	%rax, %rdx
 1339 0f74 488B8560 		movq	-160(%rbp), %rax
 1339      FFFFFF
 1340 0f7b 4801D0   		addq	%rdx, %rax
 1341 0f7e C60000   		movb	$0, (%rax)
 411:main.c        **** 				ptr = p + 1;  // skip over closing quote
 1342              		.loc 1 411 0
 1343 0f81 488B4580 		movq	-128(%rbp), %rax
 1344 0f85 4883C001 		addq	$1, %rax
 1345 0f89 48890500 		movq	%rax, ptr(%rip)
 1345      000000
 412:main.c        **** 
 413:main.c        **** 				// Open file for reading
 414:main.c        **** 				file = fopen(fileName, "rb");
 1346              		.loc 1 414 0
 1347 0f90 488B8560 		movq	-160(%rbp), %rax
 1347      FFFFFF
 1348 0f97 BE000000 		movl	$.LC17, %esi
 1348      00
 1349 0f9c 4889C7   		movq	%rax, %rdi
 1350 0f9f E8000000 		call	fopen
 1350      00
 1351 0fa4 48898568 		movq	%rax, -152(%rbp)
 1351      FFFFFF
 415:main.c        **** 				CHECK_STATUS(!file, FLP_CANNOT_LOAD, cleanup);
 1352              		.loc 1 415 0
 1353 0fab 4883BD68 		cmpq	$0, -152(%rbp)
 1353      FFFFFF00 
 1354 0fb3 750F     		jne	.L95
 1355              		.loc 1 415 0 is_stmt 0 discriminator 1
 1356 0fb5 C78524FF 		movl	$10, -220(%rbp)
 1356      FFFF0A00 
 1356      0000
 1357 0fbf E9A00100 		jmp	.L92
 1357      00
 1358              	.L95:
 416:main.c        **** 				free(fileName);
 1359              		.loc 1 416 0 is_stmt 1
 1360 0fc4 488B8560 		movq	-160(%rbp), %rax
 1360      FFFFFF
 1361 0fcb 4889C7   		movq	%rax, %rdi
 1362 0fce E8000000 		call	free
 1362      00
 417:main.c        **** 				fileName = NULL;
 1363              		.loc 1 417 0
 1364 0fd3 48C78560 		movq	$0, -160(%rbp)
 1364      FFFFFF00 
 1364      000000
 418:main.c        **** 				
 419:main.c        **** 				#ifdef WIN32
 420:main.c        **** 					QueryPerformanceCounter(&tvStart);
 421:main.c        **** 					status = doWrite(handle, (uint8)chan, file, &length, &checksum, error);
 422:main.c        **** 					QueryPerformanceCounter(&tvEnd);
 423:main.c        **** 					totalTime = (double)(tvEnd.QuadPart - tvStart.QuadPart);
 424:main.c        **** 					totalTime /= freq.QuadPart;
 425:main.c        **** 					speed = (double)length / (1024*1024*totalTime);
 426:main.c        **** 				#else
 427:main.c        **** 					gettimeofday(&tvStart, NULL);
 1365              		.loc 1 427 0
 1366 0fde 488D45C0 		leaq	-64(%rbp), %rax
 1367 0fe2 BE000000 		movl	$0, %esi
 1367      00
 1368 0fe7 4889C7   		movq	%rax, %rdi
 1369 0fea E8000000 		call	gettimeofday
 1369      00
 428:main.c        **** 					status = doWrite(handle, (uint8)chan, file, &length, &checksum, error);
 1370              		.loc 1 428 0
 1371 0fef 488B45B8 		movq	-72(%rbp), %rax
 1372 0ff3 0FB6F0   		movzbl	%al, %esi
 1373 0ff6 4C8B8508 		movq	-248(%rbp), %r8
 1373      FFFFFF
 1374 0ffd 488DBD22 		leaq	-222(%rbp), %rdi
 1374      FFFFFF
 1375 1004 488D8D48 		leaq	-184(%rbp), %rcx
 1375      FFFFFF
 1376 100b 488B9568 		movq	-152(%rbp), %rdx
 1376      FFFFFF
 1377 1012 488B8518 		movq	-232(%rbp), %rax
 1377      FFFFFF
 1378 1019 4D89C1   		movq	%r8, %r9
 1379 101c 4989F8   		movq	%rdi, %r8
 1380 101f 4889C7   		movq	%rax, %rdi
 1381 1022 E8C3F3FF 		call	doWrite
 1381      FF
 1382 1027 898538FF 		movl	%eax, -200(%rbp)
 1382      FFFF
 429:main.c        **** 					gettimeofday(&tvEnd, NULL);
 1383              		.loc 1 429 0
 1384 102d 488D45D0 		leaq	-48(%rbp), %rax
 1385 1031 BE000000 		movl	$0, %esi
 1385      00
 1386 1036 4889C7   		movq	%rax, %rdi
 1387 1039 E8000000 		call	gettimeofday
 1387      00
 430:main.c        **** 					startTime = tvStart.tv_sec;
 1388              		.loc 1 430 0
 1389 103e 488B45C0 		movq	-64(%rbp), %rax
 1390 1042 48894590 		movq	%rax, -112(%rbp)
 431:main.c        **** 					startTime *= 1000000;
 1391              		.loc 1 431 0
 1392 1046 488B4590 		movq	-112(%rbp), %rax
 1393 104a 4869C040 		imulq	$1000000, %rax, %rax
 1393      420F00
 1394 1051 48894590 		movq	%rax, -112(%rbp)
 432:main.c        **** 					startTime += tvStart.tv_usec;
 1395              		.loc 1 432 0
 1396 1055 488B45C8 		movq	-56(%rbp), %rax
 1397 1059 48014590 		addq	%rax, -112(%rbp)
 433:main.c        **** 					endTime = tvEnd.tv_sec;
 1398              		.loc 1 433 0
 1399 105d 488B45D0 		movq	-48(%rbp), %rax
 1400 1061 48894598 		movq	%rax, -104(%rbp)
 434:main.c        **** 					endTime *= 1000000;
 1401              		.loc 1 434 0
 1402 1065 488B4598 		movq	-104(%rbp), %rax
 1403 1069 4869C040 		imulq	$1000000, %rax, %rax
 1403      420F00
 1404 1070 48894598 		movq	%rax, -104(%rbp)
 435:main.c        **** 					endTime += tvEnd.tv_usec;
 1405              		.loc 1 435 0
 1406 1074 488B45D8 		movq	-40(%rbp), %rax
 1407 1078 48014598 		addq	%rax, -104(%rbp)
 436:main.c        **** 					totalTime = (double)(endTime - startTime);
 1408              		.loc 1 436 0
 1409 107c 488B4590 		movq	-112(%rbp), %rax
 1410 1080 488B5598 		movq	-104(%rbp), %rdx
 1411 1084 4829C2   		subq	%rax, %rdx
 1412 1087 4889D0   		movq	%rdx, %rax
 1413 108a F2480F2A 		cvtsi2sdq	%rax, %xmm0
 1413      C0
 1414 108f F20F1145 		movsd	%xmm0, -96(%rbp)
 1414      A0
 437:main.c        **** 					totalTime /= 1000000;  // convert from uS to S.
 1415              		.loc 1 437 0
 1416 1094 F20F1045 		movsd	-96(%rbp), %xmm0
 1416      A0
 1417 1099 F20F100D 		movsd	.LC14(%rip), %xmm1
 1417      00000000 
 1418 10a1 F20F5EC1 		divsd	%xmm1, %xmm0
 1419 10a5 F20F1145 		movsd	%xmm0, -96(%rbp)
 1419      A0
 438:main.c        **** 					speed = (double)length / (1024*1024*totalTime);
 1420              		.loc 1 438 0
 1421 10aa 488B8548 		movq	-184(%rbp), %rax
 1421      FFFFFF
 1422 10b1 4885C0   		testq	%rax, %rax
 1423 10b4 7807     		js	.L96
 1424 10b6 F2480F2A 		cvtsi2sdq	%rax, %xmm0
 1424      C0
 1425 10bb EB15     		jmp	.L97
 1426              	.L96:
 1427 10bd 4889C2   		movq	%rax, %rdx
 1428 10c0 48D1EA   		shrq	%rdx
 1429 10c3 83E001   		andl	$1, %eax
 1430 10c6 4809C2   		orq	%rax, %rdx
 1431 10c9 F2480F2A 		cvtsi2sdq	%rdx, %xmm0
 1431      C2
 1432 10ce F20F58C0 		addsd	%xmm0, %xmm0
 1433              	.L97:
 1434 10d2 F20F1055 		movsd	-96(%rbp), %xmm2
 1434      A0
 1435 10d7 F20F100D 		movsd	.LC15(%rip), %xmm1
 1435      00000000 
 1436 10df F20F59CA 		mulsd	%xmm2, %xmm1
 1437 10e3 F20F5EC1 		divsd	%xmm1, %xmm0
 1438 10e7 F20F1145 		movsd	%xmm0, -88(%rbp)
 1438      A8
 439:main.c        **** 				#endif
 440:main.c        **** 				if ( enableBenchmarking ) {
 1439              		.loc 1 440 0
 1440 10ec 0FB60500 		movzbl	enableBenchmarking(%rip), %eax
 1440      000000
 1441 10f3 84C0     		testb	%al, %al
 1442 10f5 7437     		je	.L98
 441:main.c        **** 					printf(
 1443              		.loc 1 441 0
 1444 10f7 0FB78522 		movzwl	-222(%rbp), %eax
 1444      FFFFFF
 1445 10fe 0FB7D0   		movzwl	%ax, %edx
 1446 1101 488BB548 		movq	-184(%rbp), %rsi
 1446      FFFFFF
 1447 1108 488B45A8 		movq	-88(%rbp), %rax
 1448 110c 488B4DB8 		movq	-72(%rbp), %rcx
 1449 1110 48898500 		movq	%rax, -256(%rbp)
 1449      FFFFFF
 1450 1117 F20F1085 		movsd	-256(%rbp), %xmm0
 1450      00FFFFFF 
 1451 111f BF000000 		movl	$.LC18, %edi
 1451      00
 1452 1124 B8010000 		movl	$1, %eax
 1452      00
 1453 1129 E8000000 		call	printf
 1453      00
 1454              	.L98:
 442:main.c        **** 						"Wrote "PFSZD" bytes (checksum 0x%04X) to channel %lu at %f MiB/s\n",
 443:main.c        **** 						length, checksum, chan, speed);
 444:main.c        **** 				}
 445:main.c        **** 				CHECK_STATUS(status, status, cleanup);
 1455              		.loc 1 445 0
 1456 112e 83BD38FF 		cmpl	$0, -200(%rbp)
 1456      FFFF00
 1457 1135 740E     		je	.L99
 1458              		.loc 1 445 0 is_stmt 0 discriminator 1
 1459 1137 8B8538FF 		movl	-200(%rbp), %eax
 1459      FFFF
 1460 113d 898524FF 		movl	%eax, -220(%rbp)
 1460      FFFF
 1461 1143 EB1F     		jmp	.L92
 1462              	.L99:
 446:main.c        **** 
 447:main.c        **** 				// Close the file
 448:main.c        **** 				fclose(file);
 1463              		.loc 1 448 0 is_stmt 1
 1464 1145 488B8568 		movq	-152(%rbp), %rax
 1464      FFFFFF
 1465 114c 4889C7   		movq	%rax, %rdi
 1466 114f E8000000 		call	fclose
 1466      00
 449:main.c        **** 				file = NULL;
 1467              		.loc 1 449 0
 1468 1154 48C78568 		movq	$0, -152(%rbp)
 1468      FFFFFF00 
 1468      000000
 1469              	.LBE8:
 396:main.c        **** 				uint16 checksum = 0x0000;
 1470              		.loc 1 396 0
 1471 115f E98C0300 		jmp	.L81
 1471      00
 1472              	.L92:
 385:main.c        **** 
 1473              		.loc 1 385 0 discriminator 1
 1474 1164 E9C80300 		jmp	.L48
 1474      00
 1475              	.L87:
 450:main.c        **** 			} else if ( isHexDigit(ch) ) {
 1476              		.loc 1 450 0
 1477 1169 0FBE8521 		movsbl	-223(%rbp), %eax
 1477      FFFFFF
 1478 1170 89C7     		movl	%eax, %edi
 1479 1172 E889EEFF 		call	isHexDigit
 1479      FF
 1480 1177 84C0     		testb	%al, %al
 1481 1179 0F846902 		je	.L101
 1481      0000
 1482              	.LBB9:
 451:main.c        **** 				// Read a sequence of hex bytes to write
 452:main.c        **** 				uint8 *dataPtr;
 453:main.c        **** 				p = ptr + 1;
 1483              		.loc 1 453 0
 1484 117f 488B0500 		movq	ptr(%rip), %rax
 1484      000000
 1485 1186 4883C001 		addq	$1, %rax
 1486 118a 48894580 		movq	%rax, -128(%rbp)
 454:main.c        **** 				while ( isHexDigit(*p) ) {
 1487              		.loc 1 454 0
 1488 118e EB05     		jmp	.L102
 1489              	.L103:
 455:main.c        **** 					p++;
 1490              		.loc 1 455 0
 1491 1190 48834580 		addq	$1, -128(%rbp)
 1491      01
 1492              	.L102:
 454:main.c        **** 				while ( isHexDigit(*p) ) {
 1493              		.loc 1 454 0 discriminator 1
 1494 1195 488B4580 		movq	-128(%rbp), %rax
 1495 1199 0FB600   		movzbl	(%rax), %eax
 1496 119c 0FBEC0   		movsbl	%al, %eax
 1497 119f 89C7     		movl	%eax, %edi
 1498 11a1 E85AEEFF 		call	isHexDigit
 1498      FF
 1499 11a6 84C0     		testb	%al, %al
 1500 11a8 75E6     		jne	.L103
 456:main.c        **** 				}
 457:main.c        **** 				CHECK_STATUS((p - ptr) & 1, FLP_ODD_DIGITS, cleanup);
 1501              		.loc 1 457 0
 1502 11aa 488B5580 		movq	-128(%rbp), %rdx
 1503 11ae 488B0500 		movq	ptr(%rip), %rax
 1503      000000
 1504 11b5 4829C2   		subq	%rax, %rdx
 1505 11b8 4889D0   		movq	%rdx, %rax
 1506 11bb 83E001   		andl	$1, %eax
 1507 11be 4885C0   		testq	%rax, %rax
 1508 11c1 740F     		je	.L104
 1509              		.loc 1 457 0 is_stmt 0 discriminator 1
 1510 11c3 C78524FF 		movl	$9, -220(%rbp)
 1510      FFFF0900 
 1510      0000
 1511 11cd E95F0300 		jmp	.L48
 1511      00
 1512              	.L104:
 458:main.c        **** 				length = (size_t)(p - ptr) / 2;
 1513              		.loc 1 458 0 is_stmt 1
 1514 11d2 488B5580 		movq	-128(%rbp), %rdx
 1515 11d6 488B0500 		movq	ptr(%rip), %rax
 1515      000000
 1516 11dd 4829C2   		subq	%rax, %rdx
 1517 11e0 4889D0   		movq	%rdx, %rax
 1518 11e3 48D1E8   		shrq	%rax
 1519 11e6 48898548 		movq	%rax, -184(%rbp)
 1519      FFFFFF
 459:main.c        **** 				data = malloc(length);
 1520              		.loc 1 459 0
 1521 11ed 488B8548 		movq	-184(%rbp), %rax
 1521      FFFFFF
 1522 11f4 4889C7   		movq	%rax, %rdi
 1523 11f7 E8000000 		call	malloc
 1523      00
 1524 11fc 48898558 		movq	%rax, -168(%rbp)
 1524      FFFFFF
 460:main.c        **** 				dataPtr = data;
 1525              		.loc 1 460 0
 1526 1203 488B8558 		movq	-168(%rbp), %rax
 1526      FFFFFF
 1527 120a 48894588 		movq	%rax, -120(%rbp)
 461:main.c        **** 				for ( i = 0; i < length; i++ ) {
 1528              		.loc 1 461 0
 1529 120e 48C78578 		movq	$0, -136(%rbp)
 1529      FFFFFF00 
 1529      000000
 1530 1219 EB2E     		jmp	.L105
 1531              	.L106:
 462:main.c        **** 					getHexByte(dataPtr++);
 1532              		.loc 1 462 0 discriminator 2
 1533 121b 488B4588 		movq	-120(%rbp), %rax
 1534 121f 488D5001 		leaq	1(%rax), %rdx
 1535 1223 48895588 		movq	%rdx, -120(%rbp)
 1536 1227 4889C7   		movq	%rax, %rdi
 1537 122a E8C4EEFF 		call	getHexByte
 1537      FF
 463:main.c        **** 					ptr += 2;
 1538              		.loc 1 463 0 discriminator 2
 1539 122f 488B0500 		movq	ptr(%rip), %rax
 1539      000000
 1540 1236 4883C002 		addq	$2, %rax
 1541 123a 48890500 		movq	%rax, ptr(%rip)
 1541      000000
 461:main.c        **** 				for ( i = 0; i < length; i++ ) {
 1542              		.loc 1 461 0 discriminator 2
 1543 1241 48838578 		addq	$1, -136(%rbp)
 1543      FFFFFF01 
 1544              	.L105:
 461:main.c        **** 				for ( i = 0; i < length; i++ ) {
 1545              		.loc 1 461 0 is_stmt 0 discriminator 1
 1546 1249 488B8548 		movq	-184(%rbp), %rax
 1546      FFFFFF
 1547 1250 48398578 		cmpq	%rax, -136(%rbp)
 1547      FFFFFF
 1548 1257 72C2     		jb	.L106
 464:main.c        **** 				}
 465:main.c        **** 				#ifdef WIN32
 466:main.c        **** 					QueryPerformanceCounter(&tvStart);
 467:main.c        **** 					fStatus = flWriteChannel(handle, (uint8)chan, length, data, error);
 468:main.c        **** 					QueryPerformanceCounter(&tvEnd);
 469:main.c        **** 					totalTime = (double)(tvEnd.QuadPart - tvStart.QuadPart);
 470:main.c        **** 					totalTime /= freq.QuadPart;
 471:main.c        **** 					speed = (double)length / (1024*1024*totalTime);
 472:main.c        **** 				#else
 473:main.c        **** 					gettimeofday(&tvStart, NULL);
 1549              		.loc 1 473 0 is_stmt 1
 1550 1259 488D45C0 		leaq	-64(%rbp), %rax
 1551 125d BE000000 		movl	$0, %esi
 1551      00
 1552 1262 4889C7   		movq	%rax, %rdi
 1553 1265 E8000000 		call	gettimeofday
 1553      00
 474:main.c        **** 					fStatus = flWriteChannel(handle, (uint8)chan, length, data, error);
 1554              		.loc 1 474 0
 1555 126a 488B9548 		movq	-184(%rbp), %rdx
 1555      FFFFFF
 1556 1271 488B45B8 		movq	-72(%rbp), %rax
 1557 1275 0FB6F0   		movzbl	%al, %esi
 1558 1278 488BBD08 		movq	-248(%rbp), %rdi
 1558      FFFFFF
 1559 127f 488B8D58 		movq	-168(%rbp), %rcx
 1559      FFFFFF
 1560 1286 488B8518 		movq	-232(%rbp), %rax
 1560      FFFFFF
 1561 128d 4989F8   		movq	%rdi, %r8
 1562 1290 4889C7   		movq	%rax, %rdi
 1563 1293 E8000000 		call	flWriteChannel
 1563      00
 1564 1298 89853CFF 		movl	%eax, -196(%rbp)
 1564      FFFF
 475:main.c        **** 					gettimeofday(&tvEnd, NULL);
 1565              		.loc 1 475 0
 1566 129e 488D45D0 		leaq	-48(%rbp), %rax
 1567 12a2 BE000000 		movl	$0, %esi
 1567      00
 1568 12a7 4889C7   		movq	%rax, %rdi
 1569 12aa E8000000 		call	gettimeofday
 1569      00
 476:main.c        **** 					startTime = tvStart.tv_sec;
 1570              		.loc 1 476 0
 1571 12af 488B45C0 		movq	-64(%rbp), %rax
 1572 12b3 48894590 		movq	%rax, -112(%rbp)
 477:main.c        **** 					startTime *= 1000000;
 1573              		.loc 1 477 0
 1574 12b7 488B4590 		movq	-112(%rbp), %rax
 1575 12bb 4869C040 		imulq	$1000000, %rax, %rax
 1575      420F00
 1576 12c2 48894590 		movq	%rax, -112(%rbp)
 478:main.c        **** 					startTime += tvStart.tv_usec;
 1577              		.loc 1 478 0
 1578 12c6 488B45C8 		movq	-56(%rbp), %rax
 1579 12ca 48014590 		addq	%rax, -112(%rbp)
 479:main.c        **** 					endTime = tvEnd.tv_sec;
 1580              		.loc 1 479 0
 1581 12ce 488B45D0 		movq	-48(%rbp), %rax
 1582 12d2 48894598 		movq	%rax, -104(%rbp)
 480:main.c        **** 					endTime *= 1000000;
 1583              		.loc 1 480 0
 1584 12d6 488B4598 		movq	-104(%rbp), %rax
 1585 12da 4869C040 		imulq	$1000000, %rax, %rax
 1585      420F00
 1586 12e1 48894598 		movq	%rax, -104(%rbp)
 481:main.c        **** 					endTime += tvEnd.tv_usec;
 1587              		.loc 1 481 0
 1588 12e5 488B45D8 		movq	-40(%rbp), %rax
 1589 12e9 48014598 		addq	%rax, -104(%rbp)
 482:main.c        **** 					totalTime = (double)(endTime - startTime);
 1590              		.loc 1 482 0
 1591 12ed 488B4590 		movq	-112(%rbp), %rax
 1592 12f1 488B5598 		movq	-104(%rbp), %rdx
 1593 12f5 4829C2   		subq	%rax, %rdx
 1594 12f8 4889D0   		movq	%rdx, %rax
 1595 12fb F2480F2A 		cvtsi2sdq	%rax, %xmm0
 1595      C0
 1596 1300 F20F1145 		movsd	%xmm0, -96(%rbp)
 1596      A0
 483:main.c        **** 					totalTime /= 1000000;  // convert from uS to S.
 1597              		.loc 1 483 0
 1598 1305 F20F1045 		movsd	-96(%rbp), %xmm0
 1598      A0
 1599 130a F20F100D 		movsd	.LC14(%rip), %xmm1
 1599      00000000 
 1600 1312 F20F5EC1 		divsd	%xmm1, %xmm0
 1601 1316 F20F1145 		movsd	%xmm0, -96(%rbp)
 1601      A0
 484:main.c        **** 					speed = (double)length / (1024*1024*totalTime);
 1602              		.loc 1 484 0
 1603 131b 488B8548 		movq	-184(%rbp), %rax
 1603      FFFFFF
 1604 1322 4885C0   		testq	%rax, %rax
 1605 1325 7807     		js	.L107
 1606 1327 F2480F2A 		cvtsi2sdq	%rax, %xmm0
 1606      C0
 1607 132c EB15     		jmp	.L108
 1608              	.L107:
 1609 132e 4889C2   		movq	%rax, %rdx
 1610 1331 48D1EA   		shrq	%rdx
 1611 1334 83E001   		andl	$1, %eax
 1612 1337 4809C2   		orq	%rax, %rdx
 1613 133a F2480F2A 		cvtsi2sdq	%rdx, %xmm0
 1613      C2
 1614 133f F20F58C0 		addsd	%xmm0, %xmm0
 1615              	.L108:
 1616 1343 F20F1055 		movsd	-96(%rbp), %xmm2
 1616      A0
 1617 1348 F20F100D 		movsd	.LC15(%rip), %xmm1
 1617      00000000 
 1618 1350 F20F59CA 		mulsd	%xmm2, %xmm1
 1619 1354 F20F5EC1 		divsd	%xmm1, %xmm0
 1620 1358 F20F1145 		movsd	%xmm0, -88(%rbp)
 1620      A8
 485:main.c        **** 				#endif
 486:main.c        **** 				if ( enableBenchmarking ) {
 1621              		.loc 1 486 0
 1622 135d 0FB60500 		movzbl	enableBenchmarking(%rip), %eax
 1622      000000
 1623 1364 84C0     		testb	%al, %al
 1624 1366 7449     		je	.L109
 487:main.c        **** 					printf(
 488:main.c        **** 						"Wrote "PFSZD" bytes (checksum 0x%04X) to channel %lu at %f MiB/s\n",
 489:main.c        **** 						length, calcChecksum(data, length), chan, speed);
 1625              		.loc 1 489 0
 1626 1368 488B9548 		movq	-184(%rbp), %rdx
 1626      FFFFFF
 1627 136f 488B8558 		movq	-168(%rbp), %rax
 1627      FFFFFF
 1628 1376 4889D6   		movq	%rdx, %rsi
 1629 1379 4889C7   		movq	%rax, %rdi
 1630 137c E8BDECFF 		call	calcChecksum
 1630      FF
 487:main.c        **** 					printf(
 1631              		.loc 1 487 0
 1632 1381 0FB7D0   		movzwl	%ax, %edx
 1633 1384 488BB548 		movq	-184(%rbp), %rsi
 1633      FFFFFF
 1634 138b 488B45A8 		movq	-88(%rbp), %rax
 1635 138f 488B4DB8 		movq	-72(%rbp), %rcx
 1636 1393 48898500 		movq	%rax, -256(%rbp)
 1636      FFFFFF
 1637 139a F20F1085 		movsd	-256(%rbp), %xmm0
 1637      00FFFFFF 
 1638 13a2 BF000000 		movl	$.LC18, %edi
 1638      00
 1639 13a7 B8010000 		movl	$1, %eax
 1639      00
 1640 13ac E8000000 		call	printf
 1640      00
 1641              	.L109:
 490:main.c        **** 				}
 491:main.c        **** 				CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1642              		.loc 1 491 0
 1643 13b1 83BD3CFF 		cmpl	$0, -196(%rbp)
 1643      FFFF00
 1644 13b8 740F     		je	.L110
 1645              		.loc 1 491 0 is_stmt 0 discriminator 1
 1646 13ba C78524FF 		movl	$1, -220(%rbp)
 1646      FFFF0100 
 1646      0000
 1647 13c4 E9680100 		jmp	.L48
 1647      00
 1648              	.L110:
 492:main.c        **** 				free(data);
 1649              		.loc 1 492 0 is_stmt 1
 1650 13c9 488B8558 		movq	-168(%rbp), %rax
 1650      FFFFFF
 1651 13d0 4889C7   		movq	%rax, %rdi
 1652 13d3 E8000000 		call	free
 1652      00
 493:main.c        **** 				data = NULL;
 1653              		.loc 1 493 0
 1654 13d8 48C78558 		movq	$0, -168(%rbp)
 1654      FFFFFF00 
 1654      000000
 1655              	.LBE9:
 1656 13e3 E9080100 		jmp	.L81
 1656      00
 1657              	.L101:
 494:main.c        **** 			} else {
 495:main.c        **** 				FAIL(FLP_ILL_CHAR, cleanup);
 1658              		.loc 1 495 0
 1659 13e8 C78524FF 		movl	$5, -220(%rbp)
 1659      FFFF0500 
 1659      0000
 1660 13f2 90       		nop
 1661 13f3 E9390100 		jmp	.L48
 1661      00
 1662              	.L54:
 1663              	.LBE7:
 1664              	.LBB10:
 496:main.c        **** 			}
 497:main.c        **** 			break;
 498:main.c        **** 		}
 499:main.c        **** 		case '+':{
 500:main.c        **** 			uint32 conduit;
 501:main.c        **** 			char *end;
 502:main.c        **** 			ptr++;
 1665              		.loc 1 502 0
 1666 13f8 488B0500 		movq	ptr(%rip), %rax
 1666      000000
 1667 13ff 4883C001 		addq	$1, %rax
 1668 1403 48890500 		movq	%rax, ptr(%rip)
 1668      000000
 503:main.c        **** 
 504:main.c        **** 			// Get the conduit
 505:main.c        **** 			errno = 0;
 1669              		.loc 1 505 0
 1670 140a E8000000 		call	__errno_location
 1670      00
 1671 140f C7000000 		movl	$0, (%rax)
 1671      0000
 506:main.c        **** 			conduit = (uint32)strtoul(ptr, &end, 16);
 1672              		.loc 1 506 0
 1673 1415 488B0500 		movq	ptr(%rip), %rax
 1673      000000
 1674 141c 488D8D50 		leaq	-176(%rbp), %rcx
 1674      FFFFFF
 1675 1423 BA100000 		movl	$16, %edx
 1675      00
 1676 1428 4889CE   		movq	%rcx, %rsi
 1677 142b 4889C7   		movq	%rax, %rdi
 1678 142e E8000000 		call	strtoul
 1678      00
 1679 1433 898540FF 		movl	%eax, -192(%rbp)
 1679      FFFF
 507:main.c        **** 			CHECK_STATUS(errno, FLP_BAD_HEX, cleanup);
 1680              		.loc 1 507 0
 1681 1439 E8000000 		call	__errno_location
 1681      00
 1682 143e 8B00     		movl	(%rax), %eax
 1683 1440 85C0     		testl	%eax, %eax
 1684 1442 740F     		je	.L111
 1685              		.loc 1 507 0 is_stmt 0 discriminator 1
 1686 1444 C78524FF 		movl	$2, -220(%rbp)
 1686      FFFF0200 
 1686      0000
 1687 144e E9DE0000 		jmp	.L48
 1687      00
 1688              	.L111:
 508:main.c        **** 
 509:main.c        **** 			// Ensure that it's 0-127
 510:main.c        **** 			CHECK_STATUS(conduit > 255, FLP_CONDUIT_RANGE, cleanup);
 1689              		.loc 1 510 0 is_stmt 1
 1690 1453 81BD40FF 		cmpl	$255, -192(%rbp)
 1690      FFFFFF00 
 1690      0000
 1691 145d 760F     		jbe	.L113
 1692              		.loc 1 510 0 is_stmt 0 discriminator 1
 1693 145f C78524FF 		movl	$4, -220(%rbp)
 1693      FFFF0400 
 1693      0000
 1694 1469 E9C30000 		jmp	.L48
 1694      00
 1695              	.L113:
 511:main.c        **** 			ptr = end;
 1696              		.loc 1 511 0 is_stmt 1
 1697 146e 488B8550 		movq	-176(%rbp), %rax
 1697      FFFFFF
 1698 1475 48890500 		movq	%rax, ptr(%rip)
 1698      000000
 512:main.c        **** 
 513:main.c        **** 			// Only two valid chars at this point:
 514:main.c        **** 			CHECK_STATUS(*ptr != '\0' && *ptr != ';', FLP_ILL_CHAR, cleanup);
 1699              		.loc 1 514 0
 1700 147c 488B0500 		movq	ptr(%rip), %rax
 1700      000000
 1701 1483 0FB600   		movzbl	(%rax), %eax
 1702 1486 84C0     		testb	%al, %al
 1703 1488 741D     		je	.L114
 1704              		.loc 1 514 0 is_stmt 0 discriminator 1
 1705 148a 488B0500 		movq	ptr(%rip), %rax
 1705      000000
 1706 1491 0FB600   		movzbl	(%rax), %eax
 1707 1494 3C3B     		cmpb	$59, %al
 1708 1496 740F     		je	.L114
 1709 1498 C78524FF 		movl	$5, -220(%rbp)
 1709      FFFF0500 
 1709      0000
 1710 14a2 E98A0000 		jmp	.L48
 1710      00
 1711              	.L114:
 515:main.c        **** 
 516:main.c        **** 			fStatus = flSelectConduit(handle, (uint8)conduit, error);
 1712              		.loc 1 516 0 is_stmt 1
 1713 14a7 8B8540FF 		movl	-192(%rbp), %eax
 1713      FFFF
 1714 14ad 0FB6C8   		movzbl	%al, %ecx
 1715 14b0 488B9508 		movq	-248(%rbp), %rdx
 1715      FFFFFF
 1716 14b7 488B8518 		movq	-232(%rbp), %rax
 1716      FFFFFF
 1717 14be 89CE     		movl	%ecx, %esi
 1718 14c0 4889C7   		movq	%rax, %rdi
 1719 14c3 E8000000 		call	flSelectConduit
 1719      00
 1720 14c8 89853CFF 		movl	%eax, -196(%rbp)
 1720      FFFF
 517:main.c        **** 			CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 1721              		.loc 1 517 0
 1722 14ce 83BD3CFF 		cmpl	$0, -196(%rbp)
 1722      FFFF00
 1723 14d5 7419     		je	.L81
 1724              		.loc 1 517 0 is_stmt 0 discriminator 1
 1725 14d7 C78524FF 		movl	$1, -220(%rbp)
 1725      FFFF0100 
 1725      0000
 1726 14e1 90       		nop
 1727 14e2 EB4D     		jmp	.L48
 1728              	.L123:
 1729              	.LBE10:
 518:main.c        **** 			break;
 519:main.c        **** 		}
 520:main.c        **** 		default:
 521:main.c        **** 			FAIL(FLP_ILL_CHAR, cleanup);
 1730              		.loc 1 521 0 is_stmt 1
 1731 14e4 C78524FF 		movl	$5, -220(%rbp)
 1731      FFFF0500 
 1731      0000
 1732 14ee EB41     		jmp	.L48
 1733              	.L81:
 522:main.c        **** 		}
 523:main.c        **** 	} while ( *ptr == ';' );
 1734              		.loc 1 523 0
 1735 14f0 488B0500 		movq	ptr(%rip), %rax
 1735      000000
 1736 14f7 0FB600   		movzbl	(%rax), %eax
 1737 14fa 3C3B     		cmpb	$59, %al
 1738 14fc 0F849EF1 		je	.L116
 1738      FFFF
 524:main.c        **** 	CHECK_STATUS(*ptr != '\0', FLP_ILL_CHAR, cleanup);
 1739              		.loc 1 524 0
 1740 1502 488B0500 		movq	ptr(%rip), %rax
 1740      000000
 1741 1509 0FB600   		movzbl	(%rax), %eax
 1742 150c 84C0     		testb	%al, %al
 1743 150e 740C     		je	.L117
 1744              		.loc 1 524 0 is_stmt 0 discriminator 1
 1745 1510 C78524FF 		movl	$5, -220(%rbp)
 1745      FFFF0500 
 1745      0000
 1746 151a EB15     		jmp	.L48
 1747              	.L117:
 525:main.c        **** 
 526:main.c        **** 	dump(0x00000000, dataFromFPGA.data, dataFromFPGA.length);
 1748              		.loc 1 526 0 is_stmt 1
 1749 151c 488B55E8 		movq	-24(%rbp), %rdx
 1750 1520 488B45E0 		movq	-32(%rbp), %rax
 1751 1524 4889C6   		movq	%rax, %rsi
 1752 1527 BF000000 		movl	$0, %edi
 1752      00
 1753 152c E8000000 		call	dump
 1753      00
 1754              	.L48:
 527:main.c        **** 
 528:main.c        **** cleanup:
 529:main.c        **** 	bufDestroy(&dataFromFPGA);
 1755              		.loc 1 529 0
 1756 1531 488D45E0 		leaq	-32(%rbp), %rax
 1757 1535 4889C7   		movq	%rax, %rdi
 1758 1538 E8000000 		call	bufDestroy
 1758      00
 530:main.c        **** 	if ( file ) {
 1759              		.loc 1 530 0
 1760 153d 4883BD68 		cmpq	$0, -152(%rbp)
 1760      FFFFFF00 
 1761 1545 740F     		je	.L118
 531:main.c        **** 		fclose(file);
 1762              		.loc 1 531 0
 1763 1547 488B8568 		movq	-152(%rbp), %rax
 1763      FFFFFF
 1764 154e 4889C7   		movq	%rax, %rdi
 1765 1551 E8000000 		call	fclose
 1765      00
 1766              	.L118:
 532:main.c        **** 	}
 533:main.c        **** 	free(fileName);
 1767              		.loc 1 533 0
 1768 1556 488B8560 		movq	-160(%rbp), %rax
 1768      FFFFFF
 1769 155d 4889C7   		movq	%rax, %rdi
 1770 1560 E8000000 		call	free
 1770      00
 534:main.c        **** 	free(data);
 1771              		.loc 1 534 0
 1772 1565 488B8558 		movq	-168(%rbp), %rax
 1772      FFFFFF
 1773 156c 4889C7   		movq	%rax, %rdi
 1774 156f E8000000 		call	free
 1774      00
 535:main.c        **** 	if ( retVal > FLP_LIBERR ) {
 1775              		.loc 1 535 0
 1776 1574 83BD24FF 		cmpl	$1, -220(%rbp)
 1776      FFFF01
 1777 157b 0F86A700 		jbe	.L119
 1777      0000
 1778              	.LBB11:
 536:main.c        **** 		const int column = (int)(ptr - line);
 1779              		.loc 1 536 0
 1780 1581 488B0500 		movq	ptr(%rip), %rax
 1780      000000
 1781 1588 4889C2   		movq	%rax, %rdx
 1782 158b 488B8510 		movq	-240(%rbp), %rax
 1782      FFFFFF
 1783 1592 4829C2   		subq	%rax, %rdx
 1784 1595 4889D0   		movq	%rdx, %rax
 1785 1598 898544FF 		movl	%eax, -188(%rbp)
 1785      FFFF
 537:main.c        **** 		int i;
 538:main.c        **** 		fprintf(stderr, "%s at column %d\n  %s\n  ", errMessages[retVal], column, line);
 1786              		.loc 1 538 0
 1787 159e 8B8524FF 		movl	-220(%rbp), %eax
 1787      FFFF
 1788 15a4 488B14C5 		movq	errMessages(,%rax,8), %rdx
 1788      00000000 
 1789 15ac 488B0500 		movq	stderr(%rip), %rax
 1789      000000
 1790 15b3 488BB510 		movq	-240(%rbp), %rsi
 1790      FFFFFF
 1791 15ba 8B8D44FF 		movl	-188(%rbp), %ecx
 1791      FFFF
 1792 15c0 4989F0   		movq	%rsi, %r8
 1793 15c3 BE000000 		movl	$.LC19, %esi
 1793      00
 1794 15c8 4889C7   		movq	%rax, %rdi
 1795 15cb B8000000 		movl	$0, %eax
 1795      00
 1796 15d0 E8000000 		call	fprintf
 1796      00
 539:main.c        **** 		for ( i = 0; i < column; i++ ) {
 1797              		.loc 1 539 0
 1798 15d5 C7852CFF 		movl	$0, -212(%rbp)
 1798      FFFF0000 
 1798      0000
 1799 15df EB1B     		jmp	.L120
 1800              	.L121:
 540:main.c        **** 			fprintf(stderr, " ");
 1801              		.loc 1 540 0 discriminator 2
 1802 15e1 488B0500 		movq	stderr(%rip), %rax
 1802      000000
 1803 15e8 4889C6   		movq	%rax, %rsi
 1804 15eb BF200000 		movl	$32, %edi
 1804      00
 1805 15f0 E8000000 		call	fputc
 1805      00
 539:main.c        **** 		for ( i = 0; i < column; i++ ) {
 1806              		.loc 1 539 0 discriminator 2
 1807 15f5 83852CFF 		addl	$1, -212(%rbp)
 1807      FFFF01
 1808              	.L120:
 539:main.c        **** 		for ( i = 0; i < column; i++ ) {
 1809              		.loc 1 539 0 is_stmt 0 discriminator 1
 1810 15fc 8B852CFF 		movl	-212(%rbp), %eax
 1810      FFFF
 1811 1602 3B8544FF 		cmpl	-188(%rbp), %eax
 1811      FFFF
 1812 1608 7CD7     		jl	.L121
 541:main.c        **** 		}
 542:main.c        **** 		fprintf(stderr, "^\n");
 1813              		.loc 1 542 0 is_stmt 1
 1814 160a 488B0500 		movq	stderr(%rip), %rax
 1814      000000
 1815 1611 4889C1   		movq	%rax, %rcx
 1816 1614 BA020000 		movl	$2, %edx
 1816      00
 1817 1619 BE010000 		movl	$1, %esi
 1817      00
 1818 161e BF000000 		movl	$.LC20, %edi
 1818      00
 1819 1623 E8000000 		call	fwrite
 1819      00
 1820              	.L119:
 1821              	.LBE11:
 543:main.c        **** 	}
 544:main.c        **** 	return retVal;
 1822              		.loc 1 544 0
 1823 1628 8B8524FF 		movl	-220(%rbp), %eax
 1823      FFFF
 545:main.c        **** }
 1824              		.loc 1 545 0
 1825 162e C9       		leave
 1826              		.cfi_def_cfa 7, 8
 1827 162f C3       		ret
 1828              		.cfi_endproc
 1829              	.LFE10:
 1831              		.section	.rodata
 1832              	.LC21:
 1833 01f9 30303030 		.string	"0000"
 1833      00
 1834              	.LC22:
 1835 01fe 30303031 		.string	"0001"
 1835      00
 1836              	.LC23:
 1837 0203 30303130 		.string	"0010"
 1837      00
 1838              	.LC24:
 1839 0208 30303131 		.string	"0011"
 1839      00
 1840              	.LC25:
 1841 020d 30313030 		.string	"0100"
 1841      00
 1842              	.LC26:
 1843 0212 30313031 		.string	"0101"
 1843      00
 1844              	.LC27:
 1845 0217 30313130 		.string	"0110"
 1845      00
 1846              	.LC28:
 1847 021c 30313131 		.string	"0111"
 1847      00
 1848              	.LC29:
 1849 0221 31303030 		.string	"1000"
 1849      00
 1850              	.LC30:
 1851 0226 31303031 		.string	"1001"
 1851      00
 1852              	.LC31:
 1853 022b 58585858 		.string	"XXXX"
 1853      00
 1854              	.LC32:
 1855 0230 31303130 		.string	"1010"
 1855      00
 1856              	.LC33:
 1857 0235 31303131 		.string	"1011"
 1857      00
 1858              	.LC34:
 1859 023a 31313030 		.string	"1100"
 1859      00
 1860              	.LC35:
 1861 023f 31313031 		.string	"1101"
 1861      00
 1862              	.LC36:
 1863 0244 31313130 		.string	"1110"
 1863      00
 1864              	.LC37:
 1865 0249 31313131 		.string	"1111"
 1865      00
 1866              		.data
 1867              		.align 32
 1870              	nibbles:
 1871 0000 00000000 		.quad	.LC21
 1871      00000000 
 1872 0008 00000000 		.quad	.LC22
 1872      00000000 
 1873 0010 00000000 		.quad	.LC23
 1873      00000000 
 1874 0018 00000000 		.quad	.LC24
 1874      00000000 
 1875 0020 00000000 		.quad	.LC25
 1875      00000000 
 1876 0028 00000000 		.quad	.LC26
 1876      00000000 
 1877 0030 00000000 		.quad	.LC27
 1877      00000000 
 1878 0038 00000000 		.quad	.LC28
 1878      00000000 
 1879 0040 00000000 		.quad	.LC29
 1879      00000000 
 1880 0048 00000000 		.quad	.LC30
 1880      00000000 
 1881 0050 00000000 		.quad	.LC31
 1881      00000000 
 1882 0058 00000000 		.quad	.LC31
 1882      00000000 
 1883 0060 00000000 		.quad	.LC31
 1883      00000000 
 1884 0068 00000000 		.quad	.LC31
 1884      00000000 
 1885 0070 00000000 		.quad	.LC31
 1885      00000000 
 1886 0078 00000000 		.quad	.LC31
 1886      00000000 
 1887 0080 00000000 		.quad	.LC31
 1887      00000000 
 1888 0088 00000000 		.quad	.LC32
 1888      00000000 
 1889 0090 00000000 		.quad	.LC33
 1889      00000000 
 1890 0098 00000000 		.quad	.LC34
 1890      00000000 
 1891 00a0 00000000 		.quad	.LC35
 1891      00000000 
 1892 00a8 00000000 		.quad	.LC36
 1892      00000000 
 1893 00b0 00000000 		.quad	.LC37
 1893      00000000 
 1894              		.section	.rodata
 1895 024e 0000     		.align 8
 1896              	.LC38:
 1897 0250 20202020 		.string	"            vendor ID and product ID (e.g 04B4:8613)"
 1897      20202020 
 1897      20202020 
 1897      76656E64 
 1897      6F722049 
 1898              	.LC39:
 1899 0285 3C564944 		.string	"<VID:PID>"
 1899      3A504944 
 1899      3E00
 1900              	.LC40:
 1901 028f 69767000 		.string	"ivp"
 1902              	.LC41:
 1903 0293 6900     		.string	"i"
 1904 0295 000000   		.align 8
 1905              	.LC42:
 1906 0298 20202020 		.string	"       VID, PID and opt. dev ID (e.g 1D50:602B:0001)"
 1906      20202056 
 1906      49442C20 
 1906      50494420 
 1906      616E6420 
 1907              	.LC43:
 1908 02cd 3C564944 		.string	"<VID:PID[:DID]>"
 1908      3A504944 
 1908      5B3A4449 
 1908      445D3E00 
 1909              	.LC44:
 1910 02dd 767000   		.string	"vp"
 1911              	.LC45:
 1912 02e0 7600     		.string	"v"
 1913 02e2 00000000 		.align 8
 1913      0000
 1914              	.LC46:
 1915 02e8 20202020 		.string	"        firmware to RAM-load (or use std fw)"
 1915      20202020 
 1915      6669726D 
 1915      77617265 
 1915      20746F20 
 1916              	.LC47:
 1917 0315 3C666972 		.string	"<firmware.hex>"
 1917      6D776172 
 1917      652E6865 
 1917      783E00
 1918              	.LC48:
 1919 0324 667700   		.string	"fw"
 1920              	.LC49:
 1921 0327 6600     		.string	"f"
 1922 0329 00000000 		.align 8
 1922      000000
 1923              	.LC50:
 1924 0330 20726561 		.string	" read/write digital ports (e.g B13+,C1-,B2?)"
 1924      642F7772 
 1924      69746520 
 1924      64696769 
 1924      74616C20 
 1925              	.LC51:
 1926 035d 3C626974 		.string	"<bitCfg[,bitCfg]*>"
 1926      4366675B 
 1926      2C626974 
 1926      4366675D 
 1926      2A3E00
 1927              	.LC52:
 1928 0370 706F7274 		.string	"ports"
 1928      7300
 1929              	.LC53:
 1930 0376 6400     		.string	"d"
 1931              	.LC54:
 1932 0378 20202020 		.string	"         query the JTAG chain"
 1932      20202020 
 1932      20717565 
 1932      72792074 
 1932      6865204A 
 1933              	.LC55:
 1934 0396 3C6A7461 		.string	"<jtagBits>"
 1934      67426974 
 1934      733E00
 1935              	.LC56:
 1936 03a1 71756572 		.string	"query"
 1936      7900
 1937              	.LC57:
 1938 03a7 7100     		.string	"q"
 1939              	.LC58:
 1940 03a9 20202020 		.string	"         program a device"
 1940      20202020 
 1940      2070726F 
 1940      6772616D 
 1940      20612064 
 1941              	.LC59:
 1942 03c3 3C636F6E 		.string	"<config>"
 1942      6669673E 
 1942      00
 1943              	.LC60:
 1944 03cc 70726F67 		.string	"program"
 1944      72616D00 
 1945              	.LC61:
 1946 03d4 7000     		.string	"p"
 1947 03d6 0000     		.align 8
 1948              	.LC62:
 1949 03d8 20202020 		.string	"        which comm conduit to choose (default 0x01)"
 1949      20202020 
 1949      77686963 
 1949      6820636F 
 1949      6D6D2063 
 1950              	.LC63:
 1951 040c 3C636F6E 		.string	"<conduit>"
 1951      64756974 
 1951      3E00
 1952              	.LC64:
 1953 0416 636F6E64 		.string	"conduit"
 1953      75697400 
 1954              	.LC65:
 1955 041e 6300     		.string	"c"
 1956              		.align 8
 1957              	.LC66:
 1958 0420 20202020 		.string	"    a series of CommFPGA actions"
 1958      61207365 
 1958      72696573 
 1958      206F6620 
 1958      436F6D6D 
 1959              	.LC67:
 1960 0441 3C616374 		.string	"<actionString>"
 1960      696F6E53 
 1960      7472696E 
 1960      673E00
 1961              	.LC68:
 1962 0450 61637469 		.string	"action"
 1962      6F6E00
 1963              	.LC69:
 1964 0457 6100     		.string	"a"
 1965 0459 00000000 		.align 8
 1965      000000
 1966              	.LC70:
 1967 0460 20202020 		.string	"                    start up an interactive CommFPGA session"
 1967      20202020 
 1967      20202020 
 1967      20202020 
 1967      20202020 
 1968              	.LC71:
 1969 049d 7368656C 		.string	"shell"
 1969      6C00
 1970              	.LC72:
 1971 04a3 7300     		.string	"s"
 1972 04a5 000000   		.align 8
 1973              	.LC73:
 1974 04a8 20202020 		.string	"                enable benchmarking & checksumming"
 1974      20202020 
 1974      20202020 
 1974      20202020 
 1974      656E6162 
 1975              	.LC74:
 1976 04db 62656E63 		.string	"benchmark"
 1976      686D6172 
 1976      6B00
 1977              	.LC75:
 1978 04e5 6200     		.string	"b"
 1979 04e7 00       		.align 8
 1980              	.LC76:
 1981 04e8 20202020 		.string	"                    reset the bulk endpoints"
 1981      20202020 
 1981      20202020 
 1981      20202020 
 1981      20202020 
 1982              	.LC77:
 1983 0515 72657365 		.string	"reset"
 1983      7400
 1984              	.LC78:
 1985 051b 7200     		.string	"r"
 1986 051d 000000   		.align 8
 1987              	.LC79:
 1988 0520 20202077 		.string	"   write data from channel ch to file"
 1988      72697465 
 1988      20646174 
 1988      61206672 
 1988      6F6D2063 
 1989              	.LC80:
 1990 0546 3C63683A 		.string	"<ch:file.bin>"
 1990      66696C65 
 1990      2E62696E 
 1990      3E00
 1991              	.LC81:
 1992 0554 64756D70 		.string	"dumploop"
 1992      6C6F6F70 
 1992      00
 1993              	.LC82:
 1994 055d 6C00     		.string	"l"
 1995 055f 00       		.align 8
 1996              	.LC83:
 1997 0560 20202020 		.string	"                     print this help and exit"
 1997      20202020 
 1997      20202020 
 1997      20202020 
 1997      20202020 
 1998              	.LC84:
 1999 058e 68656C70 		.string	"help"
 1999      00
 2000              	.LC85:
 2001 0593 6800     		.string	"h"
 2002 0595 000000   		.align 8
 2003              	.LC86:
 2004 0598 20202077 		.string	"   write firmware to FX2's EEPROM (!!)"
 2004      72697465 
 2004      20666972 
 2004      6D776172 
 2004      6520746F 
 2005              	.LC87:
 2006 05bf 3C737464 		.string	"<std|fw.hex|fw.iic>"
 2006      7C66772E 
 2006      6865787C 
 2006      66772E69 
 2006      69633E00 
 2007              	.LC88:
 2008 05d3 65657072 		.string	"eeprom"
 2008      6F6D00
 2009 05da 00000000 		.align 8
 2009      0000
 2010              	.LC89:
 2011 05e0 20202020 		.string	"     backup FX2's EEPROM (e.g 128:fw.iic)\n"
 2011      20626163 
 2011      6B757020 
 2011      46583227 
 2011      73204545 
 2012              	.LC90:
 2013 060b 3C6B6269 		.string	"<kbitSize:fw.iic>"
 2013      7453697A 
 2013      653A6677 
 2013      2E696963 
 2013      3E00
 2014              	.LC91:
 2015 061d 6261636B 		.string	"backup"
 2015      757000
 2016              	.LC92:
 2017 0624 666C636C 		.string	"flcli"
 2017      6900
 2018              	.LC93:
 2019 062a 25733A20 		.string	"%s: insufficient memory\n"
 2019      696E7375 
 2019      66666963 
 2019      69656E74 
 2019      206D656D 
 2020 0643 00000000 		.align 8
 2020      00
 2021              	.LC94:
 2022 0648 46504741 		.string	"FPGALink Command-Line Interface Copyright (C) 2012-2014 Chris McClelland\n\nUsage: %s"
 2022      4C696E6B 
 2022      20436F6D 
 2022      6D616E64 
 2022      2D4C696E 
 2023              	.LC95:
 2024 069c 0A00     		.string	"\n"
 2025 069e 0000     		.align 8
 2026              	.LC96:
 2027 06a0 0A496E74 		.string	"\nInteract with an FPGALink device.\n"
 2027      65726163 
 2027      74207769 
 2027      74682061 
 2027      6E204650 
 2028              	.LC97:
 2029 06c4 2020252D 		.string	"  %-10s %s\n"
 2029      31307320 
 2029      25730A00 
 2030              		.align 8
 2031              	.LC98:
 2032 06d0 54727920 		.string	"Try '%s --help' for more information.\n"
 2032      27257320 
 2032      2D2D6865 
 2032      6C702720 
 2032      666F7220 
 2033 06f7 00       		.align 8
 2034              	.LC99:
 2035 06f8 41747465 		.string	"Attempting to open connection to FPGALink device %s...\n"
 2035      6D707469 
 2035      6E672074 
 2035      6F206F70 
 2035      656E2063 
 2036              	.LC100:
 2037 0730 4C6F6164 		.string	"Loading firmware into %s...\n"
 2037      696E6720 
 2037      6669726D 
 2037      77617265 
 2037      20696E74 
 2038              	.LC101:
 2039 074d 41776169 		.string	"Awaiting renumeration"
 2039      74696E67 
 2039      2072656E 
 2039      756D6572 
 2039      6174696F 
 2040 0763 00000000 		.align 8
 2040      00
 2041              	.LC102:
 2042 0768 46504741 		.string	"FPGALink device did not renumerate properly as %s\n"
 2042      4C696E6B 
 2042      20646576 
 2042      69636520 
 2042      64696420 
 2043 079b 00000000 		.align 8
 2043      00
 2044              	.LC103:
 2045 07a0 41747465 		.string	"Attempting to open connection to FPGLink device %s again...\n"
 2045      6D707469 
 2045      6E672074 
 2045      6F206F70 
 2045      656E2063 
 2046 07dd 000000   		.align 8
 2047              	.LC104:
 2048 07e0 436F756C 		.string	"Could not open FPGALink device at %s and no initial VID:PID was supplied\n"
 2048      64206E6F 
 2048      74206F70 
 2048      656E2046 
 2048      5047414C 
 2049 082a 00000000 		.align 8
 2049      0000
 2050              	.LC105:
 2051 0830 436F6E6E 		.string	"Connected to FPGALink device %s (firmwareID: 0x%04X, firmwareVersion: 0x%08X)\n"
 2051      65637465 
 2051      6420746F 
 2051      20465047 
 2051      414C696E 
 2052              	.LC106:
 2053 087f 73746400 		.string	"std"
 2054 0883 00000000 		.align 8
 2054      00
 2055              	.LC107:
 2056 0888 57726974 		.string	"Writing the standard FPGALink firmware to the FX2's EEPROM..."
 2056      696E6720 
 2056      74686520 
 2056      7374616E 
 2056      64617264 
 2057 08c6 0000     		.align 8
 2058              	.LC108:
 2059 08c8 57726974 		.string	"Writing custom FPGALink firmware from %s to the FX2's EEPROM...\n"
 2059      696E6720 
 2059      63757374 
 2059      6F6D2046 
 2059      5047414C 
 2060 0909 00000000 		.align 8
 2060      000000
 2061              	.LC109:
 2062 0910 25733A20 		.string	"%s: invalid argument to option --backup=<kbitSize:fw.iic>\n"
 2062      696E7661 
 2062      6C696420 
 2062      61726775 
 2062      6D656E74 
 2063 094b 00000000 		.align 8
 2063      00
 2064              	.LC110:
 2065 0950 53617669 		.string	"Saving a backup of %d kbit from the FX2's EEPROM to %s...\n"
 2065      6E672061 
 2065      20626163 
 2065      6B757020 
 2065      6F662025 
 2066              	.LC111:
 2067 098b 436F6E66 		.string	"Configuring ports..."
 2067      69677572 
 2067      696E6720 
 2067      706F7274 
 2067      732E2E2E 
 2068              	.LC112:
 2069 09a0 25303858 		.string	"%08X"
 2069      00
 2070 09a5 000000   		.align 8
 2071              	.LC113:
 2072 09a8 52656164 		.string	"Readback:   28   24   20   16    12    8    4    0\n          %s"
 2072      6261636B 
 2072      3A202020 
 2072      32382020 
 2072      20323420 
 2073              	.LC114:
 2074 09e8 20257300 		.string	" %s"
 2075              	.LC115:
 2076 09ec 20202573 		.string	"  %s"
 2076      00
 2077              	.LC116:
 2078 09f1 2025730A 		.string	" %s\n"
 2078      00
 2079 09f6 0000     		.align 8
 2080              	.LC117:
 2081 09f8 54686520 		.string	"The FPGALink device at %s scanned its JTAG chain, yielding:\n"
 2081      46504741 
 2081      4C696E6B 
 2081      20646576 
 2081      69636520 
 2082              	.LC118:
 2083 0a35 20203078 		.string	"  0x%08X\n"
 2083      25303858 
 2083      0A00
 2084 0a3f 00       		.align 8
 2085              	.LC119:
 2086 0a40 54686520 		.string	"The FPGALink device at %s scanned its JTAG chain but did not find any attached devices\n"
 2086      46504741 
 2086      4C696E6B 
 2086      20646576 
 2086      69636520 
 2087              		.align 8
 2088              	.LC120:
 2089 0a98 4A544147 		.string	"JTAG chain scan requested but FPGALink device at %s does not support NeroProg\n"
 2089      20636861 
 2089      696E2073 
 2089      63616E20 
 2089      72657175 
 2090              	.LC121:
 2091 0ae7 50726F67 		.string	"Programming device..."
 2091      72616D6D 
 2091      696E6720 
 2091      64657669 
 2091      63652E2E 
 2092 0afd 000000   		.align 8
 2093              	.LC122:
 2094 0b00 50726F67 		.string	"Program operation requested but device at %s does not support NeroProg\n"
 2094      72616D20 
 2094      6F706572 
 2094      6174696F 
 2094      6E207265 
 2095              		.align 8
 2096              	.LC123:
 2097 0b48 45786563 		.string	"Executing CommFPGA actions on FPGALink device %s...\n"
 2097      7574696E 
 2097      6720436F 
 2097      6D6D4650 
 2097      47412061 
 2098 0b7d 000000   		.align 8
 2099              	.LC124:
 2100 0b80 54686520 		.string	"The FPGALink device at %s is not ready to talk - did you forget --program?\n"
 2100      46504741 
 2100      4C696E6B 
 2100      20646576 
 2100      69636520 
 2101 0bcc 00000000 		.align 8
 2102              	.LC125:
 2103 0bd0 41637469 		.string	"Action requested but device at %s does not support CommFPGA\n"
 2103      6F6E2072 
 2103      65717565 
 2103      73746564 
 2103      20627574 
 2104 0c0d 000000   		.align 8
 2105              	.LC126:
 2106 0c10 25733A20 		.string	"%s: invalid argument to option -l|--dumploop=<ch:file.bin>\n"
 2106      696E7661 
 2106      6C696420 
 2106      61726775 
 2106      6D656E74 
 2107 0c4c 00000000 		.align 8
 2108              	.LC127:
 2109 0c50 436F7079 		.string	"Copying from channel %lu to %s"
 2109      696E6720 
 2109      66726F6D 
 2109      20636861 
 2109      6E6E656C 
 2110              	.LC128:
 2111 0c6f 0A436175 		.string	"\nCaught SIGINT, quitting..."
 2111      67687420 
 2111      53494749 
 2111      4E542C20 
 2111      71756974 
 2112 0c8b 00000000 		.align 8
 2112      00
 2113              	.LC129:
 2114 0c90 0A456E74 		.string	"\nEntering CommFPGA command-line mode:"
 2114      6572696E 
 2114      6720436F 
 2114      6D6D4650 
 2114      47412063 
 2115              	.LC130:
 2116 0cb6 3E2000   		.string	"> "
 2117 0cb9 00000000 		.align 8
 2117      000000
 2118              	.LC131:
 2119 0cc0 54686520 		.string	"The FPGALink device at %s is not ready to talk - did you forget --xsvf?\n"
 2119      46504741 
 2119      4C696E6B 
 2119      20646576 
 2119      69636520 
 2120 0d09 00000000 		.align 8
 2120      000000
 2121              	.LC132:
 2122 0d10 5368656C 		.string	"Shell requested but device at %s does not support CommFPGA\n"
 2122      6C207265 
 2122      71756573 
 2122      74656420 
 2122      62757420 
 2123              	.LC133:
 2124 0d4c 25730A00 		.string	"%s\n"
 2125              		.text
 2126              		.globl	main
 2128              	main:
 2129              	.LFB11:
 546:main.c        **** 
 547:main.c        **** static const char *nibbles[] = {
 548:main.c        **** 	"0000",  // '0'
 549:main.c        **** 	"0001",  // '1'
 550:main.c        **** 	"0010",  // '2'
 551:main.c        **** 	"0011",  // '3'
 552:main.c        **** 	"0100",  // '4'
 553:main.c        **** 	"0101",  // '5'
 554:main.c        **** 	"0110",  // '6'
 555:main.c        **** 	"0111",  // '7'
 556:main.c        **** 	"1000",  // '8'
 557:main.c        **** 	"1001",  // '9'
 558:main.c        **** 
 559:main.c        **** 	"XXXX",  // ':'
 560:main.c        **** 	"XXXX",  // ';'
 561:main.c        **** 	"XXXX",  // '<'
 562:main.c        **** 	"XXXX",  // '='
 563:main.c        **** 	"XXXX",  // '>'
 564:main.c        **** 	"XXXX",  // '?'
 565:main.c        **** 	"XXXX",  // '@'
 566:main.c        **** 
 567:main.c        **** 	"1010",  // 'A'
 568:main.c        **** 	"1011",  // 'B'
 569:main.c        **** 	"1100",  // 'C'
 570:main.c        **** 	"1101",  // 'D'
 571:main.c        **** 	"1110",  // 'E'
 572:main.c        **** 	"1111"   // 'F'
 573:main.c        **** };
 574:main.c        **** 
 575:main.c        **** int main(int argc, char *argv[]) {
 2130              		.loc 1 575 0
 2131              		.cfi_startproc
 2132 1630 55       		pushq	%rbp
 2133              		.cfi_def_cfa_offset 16
 2134              		.cfi_offset 6, -16
 2135 1631 4889E5   		movq	%rsp, %rbp
 2136              		.cfi_def_cfa_register 6
 2137 1634 53       		pushq	%rbx
 2138 1635 4881ECF8 		subq	$504, %rsp
 2138      010000
 2139              		.cfi_offset 3, -24
 2140 163c 89BD0CFE 		movl	%edi, -500(%rbp)
 2140      FFFF
 2141 1642 4889B500 		movq	%rsi, -512(%rbp)
 2141      FEFFFF
 2142              		.loc 1 575 0
 2143 1649 64488B04 		movq	%fs:40, %rax
 2143      25280000 
 2143      00
 2144 1652 488945E8 		movq	%rax, -24(%rbp)
 2145 1656 31C0     		xorl	%eax, %eax
 576:main.c        **** 	ReturnCode retVal = FLP_SUCCESS, pStatus;
 2146              		.loc 1 576 0
 2147 1658 C7851CFE 		movl	$0, -484(%rbp)
 2147      FFFF0000 
 2147      0000
 577:main.c        **** 	struct arg_str *ivpOpt = arg_str0("i", "ivp", "<VID:PID>", "            vendor ID and product ID (
 2148              		.loc 1 577 0
 2149 1662 B9000000 		movl	$.LC38, %ecx
 2149      00
 2150 1667 BA000000 		movl	$.LC39, %edx
 2150      00
 2151 166c BE000000 		movl	$.LC40, %esi
 2151      00
 2152 1671 BF000000 		movl	$.LC41, %edi
 2152      00
 2153 1676 E8000000 		call	arg_str0
 2153      00
 2154 167b 48898560 		movq	%rax, -416(%rbp)
 2154      FEFFFF
 578:main.c        **** 	struct arg_str *vpOpt = arg_str1("v", "vp", "<VID:PID[:DID]>", "       VID, PID and opt. dev ID (e
 2155              		.loc 1 578 0
 2156 1682 B9000000 		movl	$.LC42, %ecx
 2156      00
 2157 1687 BA000000 		movl	$.LC43, %edx
 2157      00
 2158 168c BE000000 		movl	$.LC44, %esi
 2158      00
 2159 1691 BF000000 		movl	$.LC45, %edi
 2159      00
 2160 1696 E8000000 		call	arg_str1
 2160      00
 2161 169b 48898568 		movq	%rax, -408(%rbp)
 2161      FEFFFF
 579:main.c        **** 	struct arg_str *fwOpt = arg_str0("f", "fw", "<firmware.hex>", "        firmware to RAM-load (or us
 2162              		.loc 1 579 0
 2163 16a2 B9000000 		movl	$.LC46, %ecx
 2163      00
 2164 16a7 BA000000 		movl	$.LC47, %edx
 2164      00
 2165 16ac BE000000 		movl	$.LC48, %esi
 2165      00
 2166 16b1 BF000000 		movl	$.LC49, %edi
 2166      00
 2167 16b6 E8000000 		call	arg_str0
 2167      00
 2168 16bb 48898570 		movq	%rax, -400(%rbp)
 2168      FEFFFF
 580:main.c        **** 	struct arg_str *portOpt = arg_str0("d", "ports", "<bitCfg[,bitCfg]*>", " read/write digital ports 
 2169              		.loc 1 580 0
 2170 16c2 B9000000 		movl	$.LC50, %ecx
 2170      00
 2171 16c7 BA000000 		movl	$.LC51, %edx
 2171      00
 2172 16cc BE000000 		movl	$.LC52, %esi
 2172      00
 2173 16d1 BF000000 		movl	$.LC53, %edi
 2173      00
 2174 16d6 E8000000 		call	arg_str0
 2174      00
 2175 16db 48898578 		movq	%rax, -392(%rbp)
 2175      FEFFFF
 581:main.c        **** 	struct arg_str *queryOpt = arg_str0("q", "query", "<jtagBits>", "         query the JTAG chain");
 2176              		.loc 1 581 0
 2177 16e2 B9000000 		movl	$.LC54, %ecx
 2177      00
 2178 16e7 BA000000 		movl	$.LC55, %edx
 2178      00
 2179 16ec BE000000 		movl	$.LC56, %esi
 2179      00
 2180 16f1 BF000000 		movl	$.LC57, %edi
 2180      00
 2181 16f6 E8000000 		call	arg_str0
 2181      00
 2182 16fb 48898580 		movq	%rax, -384(%rbp)
 2182      FEFFFF
 582:main.c        **** 	struct arg_str *progOpt = arg_str0("p", "program", "<config>", "         program a device");
 2183              		.loc 1 582 0
 2184 1702 B9000000 		movl	$.LC58, %ecx
 2184      00
 2185 1707 BA000000 		movl	$.LC59, %edx
 2185      00
 2186 170c BE000000 		movl	$.LC60, %esi
 2186      00
 2187 1711 BF000000 		movl	$.LC61, %edi
 2187      00
 2188 1716 E8000000 		call	arg_str0
 2188      00
 2189 171b 48898588 		movq	%rax, -376(%rbp)
 2189      FEFFFF
 583:main.c        **** 	struct arg_uint *conOpt = arg_uint0("c", "conduit", "<conduit>", "        which comm conduit to ch
 2190              		.loc 1 583 0
 2191 1722 B9000000 		movl	$.LC62, %ecx
 2191      00
 2192 1727 BA000000 		movl	$.LC63, %edx
 2192      00
 2193 172c BE000000 		movl	$.LC64, %esi
 2193      00
 2194 1731 BF000000 		movl	$.LC65, %edi
 2194      00
 2195 1736 E8000000 		call	arg_uint0
 2195      00
 2196 173b 48898590 		movq	%rax, -368(%rbp)
 2196      FEFFFF
 584:main.c        **** 	struct arg_str *actOpt = arg_str0("a", "action", "<actionString>", "    a series of CommFPGA actio
 2197              		.loc 1 584 0
 2198 1742 B9000000 		movl	$.LC66, %ecx
 2198      00
 2199 1747 BA000000 		movl	$.LC67, %edx
 2199      00
 2200 174c BE000000 		movl	$.LC68, %esi
 2200      00
 2201 1751 BF000000 		movl	$.LC69, %edi
 2201      00
 2202 1756 E8000000 		call	arg_str0
 2202      00
 2203 175b 48898598 		movq	%rax, -360(%rbp)
 2203      FEFFFF
 585:main.c        **** 	struct arg_lit *shellOpt  = arg_lit0("s", "shell", "                    start up an interactive Co
 2204              		.loc 1 585 0
 2205 1762 BA000000 		movl	$.LC70, %edx
 2205      00
 2206 1767 BE000000 		movl	$.LC71, %esi
 2206      00
 2207 176c BF000000 		movl	$.LC72, %edi
 2207      00
 2208 1771 E8000000 		call	arg_lit0
 2208      00
 2209 1776 488985A0 		movq	%rax, -352(%rbp)
 2209      FEFFFF
 586:main.c        **** 	struct arg_lit *benOpt  = arg_lit0("b", "benchmark", "                enable benchmarking & checks
 2210              		.loc 1 586 0
 2211 177d BA000000 		movl	$.LC73, %edx
 2211      00
 2212 1782 BE000000 		movl	$.LC74, %esi
 2212      00
 2213 1787 BF000000 		movl	$.LC75, %edi
 2213      00
 2214 178c E8000000 		call	arg_lit0
 2214      00
 2215 1791 488985A8 		movq	%rax, -344(%rbp)
 2215      FEFFFF
 587:main.c        **** 	struct arg_lit *rstOpt  = arg_lit0("r", "reset", "                    reset the bulk endpoints");
 2216              		.loc 1 587 0
 2217 1798 BA000000 		movl	$.LC76, %edx
 2217      00
 2218 179d BE000000 		movl	$.LC77, %esi
 2218      00
 2219 17a2 BF000000 		movl	$.LC78, %edi
 2219      00
 2220 17a7 E8000000 		call	arg_lit0
 2220      00
 2221 17ac 488985B0 		movq	%rax, -336(%rbp)
 2221      FEFFFF
 588:main.c        **** 	struct arg_str *dumpOpt = arg_str0("l", "dumploop", "<ch:file.bin>", "   write data from channel c
 2222              		.loc 1 588 0
 2223 17b3 B9000000 		movl	$.LC79, %ecx
 2223      00
 2224 17b8 BA000000 		movl	$.LC80, %edx
 2224      00
 2225 17bd BE000000 		movl	$.LC81, %esi
 2225      00
 2226 17c2 BF000000 		movl	$.LC82, %edi
 2226      00
 2227 17c7 E8000000 		call	arg_str0
 2227      00
 2228 17cc 488985B8 		movq	%rax, -328(%rbp)
 2228      FEFFFF
 589:main.c        **** 	struct arg_lit *helpOpt  = arg_lit0("h", "help", "                     print this help and exit");
 2229              		.loc 1 589 0
 2230 17d3 BA000000 		movl	$.LC83, %edx
 2230      00
 2231 17d8 BE000000 		movl	$.LC84, %esi
 2231      00
 2232 17dd BF000000 		movl	$.LC85, %edi
 2232      00
 2233 17e2 E8000000 		call	arg_lit0
 2233      00
 2234 17e7 488985C0 		movq	%rax, -320(%rbp)
 2234      FEFFFF
 590:main.c        **** 	struct arg_str *eepromOpt  = arg_str0(NULL, "eeprom", "<std|fw.hex|fw.iic>", "   write firmware to
 2235              		.loc 1 590 0
 2236 17ee B9000000 		movl	$.LC86, %ecx
 2236      00
 2237 17f3 BA000000 		movl	$.LC87, %edx
 2237      00
 2238 17f8 BE000000 		movl	$.LC88, %esi
 2238      00
 2239 17fd BF000000 		movl	$0, %edi
 2239      00
 2240 1802 E8000000 		call	arg_str0
 2240      00
 2241 1807 488985C8 		movq	%rax, -312(%rbp)
 2241      FEFFFF
 591:main.c        **** 	struct arg_str *backupOpt  = arg_str0(NULL, "backup", "<kbitSize:fw.iic>", "     backup FX2's EEPR
 2242              		.loc 1 591 0
 2243 180e B9000000 		movl	$.LC89, %ecx
 2243      00
 2244 1813 BA000000 		movl	$.LC90, %edx
 2244      00
 2245 1818 BE000000 		movl	$.LC91, %esi
 2245      00
 2246 181d BF000000 		movl	$0, %edi
 2246      00
 2247 1822 E8000000 		call	arg_str0
 2247      00
 2248 1827 488985D0 		movq	%rax, -304(%rbp)
 2248      FEFFFF
 592:main.c        **** 	struct arg_end *endOpt   = arg_end(20);
 2249              		.loc 1 592 0
 2250 182e BF140000 		movl	$20, %edi
 2250      00
 2251 1833 E8000000 		call	arg_end
 2251      00
 2252 1838 488985D8 		movq	%rax, -296(%rbp)
 2252      FEFFFF
 593:main.c        **** 	void *argTable[] = {
 2253              		.loc 1 593 0
 2254 183f 488B8560 		movq	-416(%rbp), %rax
 2254      FEFFFF
 2255 1846 48898550 		movq	%rax, -176(%rbp)
 2255      FFFFFF
 2256 184d 488B8568 		movq	-408(%rbp), %rax
 2256      FEFFFF
 2257 1854 48898558 		movq	%rax, -168(%rbp)
 2257      FFFFFF
 2258 185b 488B8570 		movq	-400(%rbp), %rax
 2258      FEFFFF
 2259 1862 48898560 		movq	%rax, -160(%rbp)
 2259      FFFFFF
 2260 1869 488B8578 		movq	-392(%rbp), %rax
 2260      FEFFFF
 2261 1870 48898568 		movq	%rax, -152(%rbp)
 2261      FFFFFF
 2262 1877 488B8580 		movq	-384(%rbp), %rax
 2262      FEFFFF
 2263 187e 48898570 		movq	%rax, -144(%rbp)
 2263      FFFFFF
 2264 1885 488B8588 		movq	-376(%rbp), %rax
 2264      FEFFFF
 2265 188c 48898578 		movq	%rax, -136(%rbp)
 2265      FFFFFF
 2266 1893 488B8590 		movq	-368(%rbp), %rax
 2266      FEFFFF
 2267 189a 48894580 		movq	%rax, -128(%rbp)
 2268 189e 488B8598 		movq	-360(%rbp), %rax
 2268      FEFFFF
 2269 18a5 48894588 		movq	%rax, -120(%rbp)
 2270 18a9 488B85A0 		movq	-352(%rbp), %rax
 2270      FEFFFF
 2271 18b0 48894590 		movq	%rax, -112(%rbp)
 2272 18b4 488B85A8 		movq	-344(%rbp), %rax
 2272      FEFFFF
 2273 18bb 48894598 		movq	%rax, -104(%rbp)
 2274 18bf 488B85B0 		movq	-336(%rbp), %rax
 2274      FEFFFF
 2275 18c6 488945A0 		movq	%rax, -96(%rbp)
 2276 18ca 488B85B8 		movq	-328(%rbp), %rax
 2276      FEFFFF
 2277 18d1 488945A8 		movq	%rax, -88(%rbp)
 2278 18d5 488B85C0 		movq	-320(%rbp), %rax
 2278      FEFFFF
 2279 18dc 488945B0 		movq	%rax, -80(%rbp)
 2280 18e0 488B85C8 		movq	-312(%rbp), %rax
 2280      FEFFFF
 2281 18e7 488945B8 		movq	%rax, -72(%rbp)
 2282 18eb 488B85D0 		movq	-304(%rbp), %rax
 2282      FEFFFF
 2283 18f2 488945C0 		movq	%rax, -64(%rbp)
 2284 18f6 488B85D8 		movq	-296(%rbp), %rax
 2284      FEFFFF
 2285 18fd 488945C8 		movq	%rax, -56(%rbp)
 594:main.c        **** 		ivpOpt, vpOpt, fwOpt, portOpt, queryOpt, progOpt, conOpt, actOpt,
 595:main.c        **** 		shellOpt, benOpt, rstOpt, dumpOpt, helpOpt, eepromOpt, backupOpt, endOpt
 596:main.c        **** 	};
 597:main.c        **** 	const char *progName = "flcli";
 2286              		.loc 1 597 0
 2287 1901 48C785E0 		movq	$.LC92, -288(%rbp)
 2287      FEFFFF00 
 2287      000000
 598:main.c        **** 	int numErrors;
 599:main.c        **** 	struct FLContext *handle = NULL;
 2288              		.loc 1 599 0
 2289 190c 48C78538 		movq	$0, -456(%rbp)
 2289      FEFFFF00 
 2289      000000
 600:main.c        **** 	FLStatus fStatus;
 601:main.c        **** 	const char *error = NULL;
 2290              		.loc 1 601 0
 2291 1917 48C78540 		movq	$0, -448(%rbp)
 2291      FEFFFF00 
 2291      000000
 602:main.c        **** 	const char *ivp = NULL;
 2292              		.loc 1 602 0
 2293 1922 48C785E8 		movq	$0, -280(%rbp)
 2293      FEFFFF00 
 2293      000000
 603:main.c        **** 	const char *vp = NULL;
 2294              		.loc 1 603 0
 2295 192d 48C785F0 		movq	$0, -272(%rbp)
 2295      FEFFFF00 
 2295      000000
 604:main.c        **** 	bool isNeroCapable, isCommCapable;
 605:main.c        **** 	uint32 numDevices, scanChain[16], i;
 606:main.c        **** 	const char *line = NULL;
 2296              		.loc 1 606 0
 2297 1938 48C78558 		movq	$0, -424(%rbp)
 2297      FEFFFF00 
 2297      000000
 607:main.c        **** 	uint8 conduit = 0x01;
 2298              		.loc 1 607 0
 2299 1943 C68511FE 		movb	$1, -495(%rbp)
 2299      FFFF01
 608:main.c        **** 
 609:main.c        **** 	if ( arg_nullcheck(argTable) != 0 ) {
 2300              		.loc 1 609 0
 2301 194a 488D8550 		leaq	-176(%rbp), %rax
 2301      FFFFFF
 2302 1951 4889C7   		movq	%rax, %rdi
 2303 1954 E8000000 		call	arg_nullcheck
 2303      00
 2304 1959 85C0     		testl	%eax, %eax
 2305 195b 742F     		je	.L125
 610:main.c        **** 		fprintf(stderr, "%s: insufficient memory\n", progName);
 2306              		.loc 1 610 0
 2307 195d 488B0500 		movq	stderr(%rip), %rax
 2307      000000
 2308 1964 488B95E0 		movq	-288(%rbp), %rdx
 2308      FEFFFF
 2309 196b BE000000 		movl	$.LC93, %esi
 2309      00
 2310 1970 4889C7   		movq	%rax, %rdi
 2311 1973 B8000000 		movl	$0, %eax
 2311      00
 2312 1978 E8000000 		call	fprintf
 2312      00
 611:main.c        **** 		FAIL(1, cleanup);
 2313              		.loc 1 611 0
 2314 197d C7851CFE 		movl	$1, -484(%rbp)
 2314      FFFF0100 
 2314      0000
 2315 1987 E9F61000 		jmp	.L126
 2315      00
 2316              	.L125:
 612:main.c        **** 	}
 613:main.c        **** 
 614:main.c        **** 	numErrors = arg_parse(argc, argv, argTable);
 2317              		.loc 1 614 0
 2318 198c 488D9550 		leaq	-176(%rbp), %rdx
 2318      FFFFFF
 2319 1993 488B8D00 		movq	-512(%rbp), %rcx
 2319      FEFFFF
 2320 199a 8B850CFE 		movl	-500(%rbp), %eax
 2320      FFFF
 2321 19a0 4889CE   		movq	%rcx, %rsi
 2322 19a3 89C7     		movl	%eax, %edi
 2323 19a5 E8000000 		call	arg_parse
 2323      00
 2324 19aa 89852CFE 		movl	%eax, -468(%rbp)
 2324      FFFF
 615:main.c        **** 
 616:main.c        **** 	if ( helpOpt->count > 0 ) {
 2325              		.loc 1 616 0
 2326 19b0 488B85C0 		movq	-320(%rbp), %rax
 2326      FEFFFF
 2327 19b7 8B4060   		movl	96(%rax), %eax
 2328 19ba 85C0     		testl	%eax, %eax
 2329 19bc 7E6E     		jle	.L127
 617:main.c        **** 		printf("FPGALink Command-Line Interface Copyright (C) 2012-2014 Chris McClelland\n\nUsage: %s", p
 2330              		.loc 1 617 0
 2331 19be 488B85E0 		movq	-288(%rbp), %rax
 2331      FEFFFF
 2332 19c5 4889C6   		movq	%rax, %rsi
 2333 19c8 BF000000 		movl	$.LC94, %edi
 2333      00
 2334 19cd B8000000 		movl	$0, %eax
 2334      00
 2335 19d2 E8000000 		call	printf
 2335      00
 618:main.c        **** 		arg_print_syntax(stdout, argTable, "\n");
 2336              		.loc 1 618 0
 2337 19d7 488B0500 		movq	stdout(%rip), %rax
 2337      000000
 2338 19de 488D8D50 		leaq	-176(%rbp), %rcx
 2338      FFFFFF
 2339 19e5 BA000000 		movl	$.LC95, %edx
 2339      00
 2340 19ea 4889CE   		movq	%rcx, %rsi
 2341 19ed 4889C7   		movq	%rax, %rdi
 2342 19f0 E8000000 		call	arg_print_syntax
 2342      00
 619:main.c        **** 		printf("\nInteract with an FPGALink device.\n\n");
 2343              		.loc 1 619 0
 2344 19f5 BF000000 		movl	$.LC96, %edi
 2344      00
 2345 19fa E8000000 		call	puts
 2345      00
 620:main.c        **** 		arg_print_glossary(stdout, argTable,"  %-10s %s\n");
 2346              		.loc 1 620 0
 2347 19ff 488B0500 		movq	stdout(%rip), %rax
 2347      000000
 2348 1a06 488D8D50 		leaq	-176(%rbp), %rcx
 2348      FFFFFF
 2349 1a0d BA000000 		movl	$.LC97, %edx
 2349      00
 2350 1a12 4889CE   		movq	%rcx, %rsi
 2351 1a15 4889C7   		movq	%rax, %rdi
 2352 1a18 E8000000 		call	arg_print_glossary
 2352      00
 621:main.c        **** 		FAIL(FLP_SUCCESS, cleanup);
 2353              		.loc 1 621 0
 2354 1a1d C7851CFE 		movl	$0, -484(%rbp)
 2354      FFFF0000 
 2354      0000
 2355 1a27 E9561000 		jmp	.L126
 2355      00
 2356              	.L127:
 622:main.c        **** 	}
 623:main.c        **** 
 624:main.c        **** 	if ( numErrors > 0 ) {
 2357              		.loc 1 624 0
 2358 1a2c 83BD2CFE 		cmpl	$0, -468(%rbp)
 2358      FFFF00
 2359 1a33 7E4F     		jle	.L128
 625:main.c        **** 		arg_print_errors(stdout, endOpt, progName);
 2360              		.loc 1 625 0
 2361 1a35 488B0500 		movq	stdout(%rip), %rax
 2361      000000
 2362 1a3c 488B95E0 		movq	-288(%rbp), %rdx
 2362      FEFFFF
 2363 1a43 488B8DD8 		movq	-296(%rbp), %rcx
 2363      FEFFFF
 2364 1a4a 4889CE   		movq	%rcx, %rsi
 2365 1a4d 4889C7   		movq	%rax, %rdi
 2366 1a50 E8000000 		call	arg_print_errors
 2366      00
 626:main.c        **** 		fprintf(stderr, "Try '%s --help' for more information.\n", progName);
 2367              		.loc 1 626 0
 2368 1a55 488B0500 		movq	stderr(%rip), %rax
 2368      000000
 2369 1a5c 488B95E0 		movq	-288(%rbp), %rdx
 2369      FEFFFF
 2370 1a63 BE000000 		movl	$.LC98, %esi
 2370      00
 2371 1a68 4889C7   		movq	%rax, %rdi
 2372 1a6b B8000000 		movl	$0, %eax
 2372      00
 2373 1a70 E8000000 		call	fprintf
 2373      00
 627:main.c        **** 		FAIL(FLP_ARGS, cleanup);
 2374              		.loc 1 627 0
 2375 1a75 C7851CFE 		movl	$12, -484(%rbp)
 2375      FFFF0C00 
 2375      0000
 2376 1a7f E9FE0F00 		jmp	.L126
 2376      00
 2377              	.L128:
 628:main.c        **** 	}
 629:main.c        **** 
 630:main.c        **** 	fStatus = flInitialise(0, &error);
 2378              		.loc 1 630 0
 2379 1a84 488D8540 		leaq	-448(%rbp), %rax
 2379      FEFFFF
 2380 1a8b 4889C6   		movq	%rax, %rsi
 2381 1a8e BF000000 		movl	$0, %edi
 2381      00
 2382 1a93 E8000000 		call	flInitialise
 2382      00
 2383 1a98 898520FE 		movl	%eax, -480(%rbp)
 2383      FFFF
 631:main.c        **** 	CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2384              		.loc 1 631 0
 2385 1a9e 83BD20FE 		cmpl	$0, -480(%rbp)
 2385      FFFF00
 2386 1aa5 740F     		je	.L129
 2387              		.loc 1 631 0 is_stmt 0 discriminator 1
 2388 1aa7 C7851CFE 		movl	$1, -484(%rbp)
 2388      FFFF0100 
 2388      0000
 2389 1ab1 E9CC0F00 		jmp	.L126
 2389      00
 2390              	.L129:
 632:main.c        **** 
 633:main.c        **** 	vp = vpOpt->sval[0];
 2391              		.loc 1 633 0 is_stmt 1
 2392 1ab6 488B8568 		movq	-408(%rbp), %rax
 2392      FEFFFF
 2393 1abd 488B4068 		movq	104(%rax), %rax
 2394 1ac1 488B00   		movq	(%rax), %rax
 2395 1ac4 488985F0 		movq	%rax, -272(%rbp)
 2395      FEFFFF
 634:main.c        **** 
 635:main.c        **** 	printf("Attempting to open connection to FPGALink device %s...\n", vp);
 2396              		.loc 1 635 0
 2397 1acb 488B85F0 		movq	-272(%rbp), %rax
 2397      FEFFFF
 2398 1ad2 4889C6   		movq	%rax, %rsi
 2399 1ad5 BF000000 		movl	$.LC99, %edi
 2399      00
 2400 1ada B8000000 		movl	$0, %eax
 2400      00
 2401 1adf E8000000 		call	printf
 2401      00
 636:main.c        **** 	fStatus = flOpen(vp, &handle, NULL);
 2402              		.loc 1 636 0
 2403 1ae4 488D8D38 		leaq	-456(%rbp), %rcx
 2403      FEFFFF
 2404 1aeb 488B85F0 		movq	-272(%rbp), %rax
 2404      FEFFFF
 2405 1af2 BA000000 		movl	$0, %edx
 2405      00
 2406 1af7 4889CE   		movq	%rcx, %rsi
 2407 1afa 4889C7   		movq	%rax, %rdi
 2408 1afd E8000000 		call	flOpen
 2408      00
 2409 1b02 898520FE 		movl	%eax, -480(%rbp)
 2409      FFFF
 637:main.c        **** 	if ( fStatus ) {
 2410              		.loc 1 637 0
 2411 1b08 83BD20FE 		cmpl	$0, -480(%rbp)
 2411      FFFF00
 2412 1b0f 0F842702 		je	.L130
 2412      0000
 638:main.c        **** 		if ( ivpOpt->count ) {
 2413              		.loc 1 638 0
 2414 1b15 488B8560 		movq	-416(%rbp), %rax
 2414      FEFFFF
 2415 1b1c 8B4060   		movl	96(%rax), %eax
 2416 1b1f 85C0     		testl	%eax, %eax
 2417 1b21 0F84E601 		je	.L131
 2417      0000
 2418              	.LBB12:
 639:main.c        **** 			int count = 60;
 2419              		.loc 1 639 0
 2420 1b27 C78528FE 		movl	$60, -472(%rbp)
 2420      FFFF3C00 
 2420      0000
 640:main.c        **** 			uint8 flag;
 641:main.c        **** 			ivp = ivpOpt->sval[0];
 2421              		.loc 1 641 0
 2422 1b31 488B8560 		movq	-416(%rbp), %rax
 2422      FEFFFF
 2423 1b38 488B4068 		movq	104(%rax), %rax
 2424 1b3c 488B00   		movq	(%rax), %rax
 2425 1b3f 488985E8 		movq	%rax, -280(%rbp)
 2425      FEFFFF
 642:main.c        **** 			printf("Loading firmware into %s...\n", ivp);
 2426              		.loc 1 642 0
 2427 1b46 488B85E8 		movq	-280(%rbp), %rax
 2427      FEFFFF
 2428 1b4d 4889C6   		movq	%rax, %rsi
 2429 1b50 BF000000 		movl	$.LC100, %edi
 2429      00
 2430 1b55 B8000000 		movl	$0, %eax
 2430      00
 2431 1b5a E8000000 		call	printf
 2431      00
 643:main.c        **** 			if ( fwOpt->count ) {
 2432              		.loc 1 643 0
 2433 1b5f 488B8570 		movq	-400(%rbp), %rax
 2433      FEFFFF
 2434 1b66 8B4060   		movl	96(%rax), %eax
 2435 1b69 85C0     		testl	%eax, %eax
 2436 1b6b 742F     		je	.L132
 644:main.c        **** 				fStatus = flLoadCustomFirmware(ivp, fwOpt->sval[0], &error);
 2437              		.loc 1 644 0
 2438 1b6d 488B8570 		movq	-400(%rbp), %rax
 2438      FEFFFF
 2439 1b74 488B4068 		movq	104(%rax), %rax
 2440 1b78 488B08   		movq	(%rax), %rcx
 2441 1b7b 488D9540 		leaq	-448(%rbp), %rdx
 2441      FEFFFF
 2442 1b82 488B85E8 		movq	-280(%rbp), %rax
 2442      FEFFFF
 2443 1b89 4889CE   		movq	%rcx, %rsi
 2444 1b8c 4889C7   		movq	%rax, %rdi
 2445 1b8f E8000000 		call	flLoadCustomFirmware
 2445      00
 2446 1b94 898520FE 		movl	%eax, -480(%rbp)
 2446      FFFF
 2447 1b9a EB26     		jmp	.L133
 2448              	.L132:
 645:main.c        **** 			} else {
 646:main.c        **** 				fStatus = flLoadStandardFirmware(ivp, vp, &error);
 2449              		.loc 1 646 0
 2450 1b9c 488D9540 		leaq	-448(%rbp), %rdx
 2450      FEFFFF
 2451 1ba3 488B8DF0 		movq	-272(%rbp), %rcx
 2451      FEFFFF
 2452 1baa 488B85E8 		movq	-280(%rbp), %rax
 2452      FEFFFF
 2453 1bb1 4889CE   		movq	%rcx, %rsi
 2454 1bb4 4889C7   		movq	%rax, %rdi
 2455 1bb7 E8000000 		call	flLoadStandardFirmware
 2455      00
 2456 1bbc 898520FE 		movl	%eax, -480(%rbp)
 2456      FFFF
 2457              	.L133:
 647:main.c        **** 			}
 648:main.c        **** 			CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2458              		.loc 1 648 0
 2459 1bc2 83BD20FE 		cmpl	$0, -480(%rbp)
 2459      FFFF00
 2460 1bc9 740F     		je	.L134
 2461              		.loc 1 648 0 is_stmt 0 discriminator 1
 2462 1bcb C7851CFE 		movl	$1, -484(%rbp)
 2462      FFFF0100 
 2462      0000
 2463 1bd5 E9A80E00 		jmp	.L126
 2463      00
 2464              	.L134:
 649:main.c        **** 			
 650:main.c        **** 			printf("Awaiting renumeration");
 2465              		.loc 1 650 0 is_stmt 1
 2466 1bda BF000000 		movl	$.LC101, %edi
 2466      00
 2467 1bdf B8000000 		movl	$0, %eax
 2467      00
 2468 1be4 E8000000 		call	printf
 2468      00
 651:main.c        **** 			flSleep(1000);
 2469              		.loc 1 651 0
 2470 1be9 BFE80300 		movl	$1000, %edi
 2470      00
 2471 1bee E8000000 		call	flSleep
 2471      00
 2472              	.L138:
 652:main.c        **** 			do {
 653:main.c        **** 				printf(".");
 2473              		.loc 1 653 0
 2474 1bf3 BF2E0000 		movl	$46, %edi
 2474      00
 2475 1bf8 E8000000 		call	putchar
 2475      00
 654:main.c        **** 				fflush(stdout);
 2476              		.loc 1 654 0
 2477 1bfd 488B0500 		movq	stdout(%rip), %rax
 2477      000000
 2478 1c04 4889C7   		movq	%rax, %rdi
 2479 1c07 E8000000 		call	fflush
 2479      00
 655:main.c        **** 				fStatus = flIsDeviceAvailable(vp, &flag, &error);
 2480              		.loc 1 655 0
 2481 1c0c 488D9540 		leaq	-448(%rbp), %rdx
 2481      FEFFFF
 2482 1c13 488D8D10 		leaq	-240(%rbp), %rcx
 2482      FFFFFF
 2483 1c1a 488B85F0 		movq	-272(%rbp), %rax
 2483      FEFFFF
 2484 1c21 4889CE   		movq	%rcx, %rsi
 2485 1c24 4889C7   		movq	%rax, %rdi
 2486 1c27 E8000000 		call	flIsDeviceAvailable
 2486      00
 2487 1c2c 898520FE 		movl	%eax, -480(%rbp)
 2487      FFFF
 656:main.c        **** 				CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2488              		.loc 1 656 0
 2489 1c32 83BD20FE 		cmpl	$0, -480(%rbp)
 2489      FFFF00
 2490 1c39 740F     		je	.L136
 2491              		.loc 1 656 0 is_stmt 0 discriminator 1
 2492 1c3b C7851CFE 		movl	$1, -484(%rbp)
 2492      FFFF0100 
 2492      0000
 2493 1c45 E9380E00 		jmp	.L126
 2493      00
 2494              	.L136:
 657:main.c        **** 				flSleep(250);
 2495              		.loc 1 657 0 is_stmt 1
 2496 1c4a BFFA0000 		movl	$250, %edi
 2496      00
 2497 1c4f E8000000 		call	flSleep
 2497      00
 658:main.c        **** 				count--;
 2498              		.loc 1 658 0
 2499 1c54 83AD28FE 		subl	$1, -472(%rbp)
 2499      FFFF01
 659:main.c        **** 			} while ( !flag && count );
 2500              		.loc 1 659 0
 2501 1c5b 0FB68510 		movzbl	-240(%rbp), %eax
 2501      FFFFFF
 2502 1c62 84C0     		testb	%al, %al
 2503 1c64 7509     		jne	.L137
 2504              		.loc 1 659 0 is_stmt 0 discriminator 1
 2505 1c66 83BD28FE 		cmpl	$0, -472(%rbp)
 2505      FFFF00
 2506 1c6d 7584     		jne	.L138
 2507              	.L137:
 660:main.c        **** 			printf("\n");
 2508              		.loc 1 660 0 is_stmt 1
 2509 1c6f BF0A0000 		movl	$10, %edi
 2509      00
 2510 1c74 E8000000 		call	putchar
 2510      00
 661:main.c        **** 			if ( !flag ) {
 2511              		.loc 1 661 0
 2512 1c79 0FB68510 		movzbl	-240(%rbp), %eax
 2512      FFFFFF
 2513 1c80 84C0     		testb	%al, %al
 2514 1c82 752F     		jne	.L139
 662:main.c        **** 				fprintf(stderr, "FPGALink device did not renumerate properly as %s\n", vp);
 2515              		.loc 1 662 0
 2516 1c84 488B0500 		movq	stderr(%rip), %rax
 2516      000000
 2517 1c8b 488B95F0 		movq	-272(%rbp), %rdx
 2517      FEFFFF
 2518 1c92 BE000000 		movl	$.LC102, %esi
 2518      00
 2519 1c97 4889C7   		movq	%rax, %rdi
 2520 1c9a B8000000 		movl	$0, %eax
 2520      00
 2521 1c9f E8000000 		call	fprintf
 2521      00
 663:main.c        **** 				FAIL(FLP_LIBERR, cleanup);
 2522              		.loc 1 663 0
 2523 1ca4 C7851CFE 		movl	$1, -484(%rbp)
 2523      FFFF0100 
 2523      0000
 2524 1cae E9CF0D00 		jmp	.L126
 2524      00
 2525              	.L139:
 664:main.c        **** 			}
 665:main.c        **** 
 666:main.c        **** 			printf("Attempting to open connection to FPGLink device %s again...\n", vp);
 2526              		.loc 1 666 0
 2527 1cb3 488B85F0 		movq	-272(%rbp), %rax
 2527      FEFFFF
 2528 1cba 4889C6   		movq	%rax, %rsi
 2529 1cbd BF000000 		movl	$.LC103, %edi
 2529      00
 2530 1cc2 B8000000 		movl	$0, %eax
 2530      00
 2531 1cc7 E8000000 		call	printf
 2531      00
 667:main.c        **** 			fStatus = flOpen(vp, &handle, &error);
 2532              		.loc 1 667 0
 2533 1ccc 488D9540 		leaq	-448(%rbp), %rdx
 2533      FEFFFF
 2534 1cd3 488D8D38 		leaq	-456(%rbp), %rcx
 2534      FEFFFF
 2535 1cda 488B85F0 		movq	-272(%rbp), %rax
 2535      FEFFFF
 2536 1ce1 4889CE   		movq	%rcx, %rsi
 2537 1ce4 4889C7   		movq	%rax, %rdi
 2538 1ce7 E8000000 		call	flOpen
 2538      00
 2539 1cec 898520FE 		movl	%eax, -480(%rbp)
 2539      FFFF
 668:main.c        **** 			CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2540              		.loc 1 668 0
 2541 1cf2 83BD20FE 		cmpl	$0, -480(%rbp)
 2541      FFFF00
 2542 1cf9 7410     		je	.L140
 2543              		.loc 1 668 0 is_stmt 0 discriminator 1
 2544 1cfb C7851CFE 		movl	$1, -484(%rbp)
 2544      FFFF0100 
 2544      0000
 2545 1d05 90       		nop
 2546 1d06 E9770D00 		jmp	.L126
 2546      00
 2547              	.L140:
 2548              	.LBE12:
 2549 1d0b EB2F     		jmp	.L130
 2550              	.L131:
 669:main.c        **** 		} else {
 670:main.c        **** 			fprintf(stderr, "Could not open FPGALink device at %s and no initial VID:PID was supplied\n", vp
 2551              		.loc 1 670 0 is_stmt 1
 2552 1d0d 488B0500 		movq	stderr(%rip), %rax
 2552      000000
 2553 1d14 488B95F0 		movq	-272(%rbp), %rdx
 2553      FEFFFF
 2554 1d1b BE000000 		movl	$.LC104, %esi
 2554      00
 2555 1d20 4889C7   		movq	%rax, %rdi
 2556 1d23 B8000000 		movl	$0, %eax
 2556      00
 2557 1d28 E8000000 		call	fprintf
 2557      00
 671:main.c        **** 			FAIL(FLP_ARGS, cleanup);
 2558              		.loc 1 671 0
 2559 1d2d C7851CFE 		movl	$12, -484(%rbp)
 2559      FFFF0C00 
 2559      0000
 2560 1d37 E9460D00 		jmp	.L126
 2560      00
 2561              	.L130:
 672:main.c        **** 		}
 673:main.c        **** 	}
 674:main.c        **** 
 675:main.c        **** 	printf(
 2562              		.loc 1 675 0
 2563 1d3c 488B8538 		movq	-456(%rbp), %rax
 2563      FEFFFF
 2564 1d43 4889C7   		movq	%rax, %rdi
 2565 1d46 E8000000 		call	flGetFirmwareVersion
 2565      00
 2566 1d4b 89C3     		movl	%eax, %ebx
 676:main.c        **** 		"Connected to FPGALink device %s (firmwareID: 0x%04X, firmwareVersion: 0x%08X)\n",
 677:main.c        **** 		vp, flGetFirmwareID(handle), flGetFirmwareVersion(handle)
 2567              		.loc 1 677 0
 2568 1d4d 488B8538 		movq	-456(%rbp), %rax
 2568      FEFFFF
 2569 1d54 4889C7   		movq	%rax, %rdi
 2570 1d57 E8000000 		call	flGetFirmwareID
 2570      00
 675:main.c        **** 		"Connected to FPGALink device %s (firmwareID: 0x%04X, firmwareVersion: 0x%08X)\n",
 2571              		.loc 1 675 0
 2572 1d5c 0FB7D0   		movzwl	%ax, %edx
 2573 1d5f 488B85F0 		movq	-272(%rbp), %rax
 2573      FEFFFF
 2574 1d66 89D9     		movl	%ebx, %ecx
 2575 1d68 4889C6   		movq	%rax, %rsi
 2576 1d6b BF000000 		movl	$.LC105, %edi
 2576      00
 2577 1d70 B8000000 		movl	$0, %eax
 2577      00
 2578 1d75 E8000000 		call	printf
 2578      00
 678:main.c        **** 	);
 679:main.c        **** 
 680:main.c        **** 	if ( eepromOpt->count ) {
 2579              		.loc 1 680 0
 2580 1d7a 488B85C8 		movq	-312(%rbp), %rax
 2580      FEFFFF
 2581 1d81 8B4060   		movl	96(%rax), %eax
 2582 1d84 85C0     		testl	%eax, %eax
 2583 1d86 0F84B600 		je	.L141
 2583      0000
 681:main.c        **** 		if ( !strcmp("std", eepromOpt->sval[0]) ) {
 2584              		.loc 1 681 0
 2585 1d8c 488B85C8 		movq	-312(%rbp), %rax
 2585      FEFFFF
 2586 1d93 488B4068 		movq	104(%rax), %rax
 2587 1d97 488B00   		movq	(%rax), %rax
 2588 1d9a 4889C6   		movq	%rax, %rsi
 2589 1d9d BF000000 		movl	$.LC106, %edi
 2589      00
 2590 1da2 E8000000 		call	strcmp
 2590      00
 2591 1da7 85C0     		testl	%eax, %eax
 2592 1da9 7532     		jne	.L142
 682:main.c        **** 			printf("Writing the standard FPGALink firmware to the FX2's EEPROM...\n");
 2593              		.loc 1 682 0
 2594 1dab BF000000 		movl	$.LC107, %edi
 2594      00
 2595 1db0 E8000000 		call	puts
 2595      00
 683:main.c        **** 			fStatus = flFlashStandardFirmware(handle, vp, &error);
 2596              		.loc 1 683 0
 2597 1db5 488B8538 		movq	-456(%rbp), %rax
 2597      FEFFFF
 2598 1dbc 488D9540 		leaq	-448(%rbp), %rdx
 2598      FEFFFF
 2599 1dc3 488B8DF0 		movq	-272(%rbp), %rcx
 2599      FEFFFF
 2600 1dca 4889CE   		movq	%rcx, %rsi
 2601 1dcd 4889C7   		movq	%rax, %rdi
 2602 1dd0 E8000000 		call	flFlashStandardFirmware
 2602      00
 2603 1dd5 898520FE 		movl	%eax, -480(%rbp)
 2603      FFFF
 2604 1ddb EB4D     		jmp	.L143
 2605              	.L142:
 684:main.c        **** 		} else {
 685:main.c        **** 			printf("Writing custom FPGALink firmware from %s to the FX2's EEPROM...\n", eepromOpt->sval[0]);
 2606              		.loc 1 685 0
 2607 1ddd 488B85C8 		movq	-312(%rbp), %rax
 2607      FEFFFF
 2608 1de4 488B4068 		movq	104(%rax), %rax
 2609 1de8 488B00   		movq	(%rax), %rax
 2610 1deb 4889C6   		movq	%rax, %rsi
 2611 1dee BF000000 		movl	$.LC108, %edi
 2611      00
 2612 1df3 B8000000 		movl	$0, %eax
 2612      00
 2613 1df8 E8000000 		call	printf
 2613      00
 686:main.c        **** 			fStatus = flFlashCustomFirmware(handle, eepromOpt->sval[0], &error);
 2614              		.loc 1 686 0
 2615 1dfd 488B85C8 		movq	-312(%rbp), %rax
 2615      FEFFFF
 2616 1e04 488B4068 		movq	104(%rax), %rax
 2617 1e08 488B08   		movq	(%rax), %rcx
 2618 1e0b 488B8538 		movq	-456(%rbp), %rax
 2618      FEFFFF
 2619 1e12 488D9540 		leaq	-448(%rbp), %rdx
 2619      FEFFFF
 2620 1e19 4889CE   		movq	%rcx, %rsi
 2621 1e1c 4889C7   		movq	%rax, %rdi
 2622 1e1f E8000000 		call	flFlashCustomFirmware
 2622      00
 2623 1e24 898520FE 		movl	%eax, -480(%rbp)
 2623      FFFF
 2624              	.L143:
 687:main.c        **** 		}
 688:main.c        **** 		CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2625              		.loc 1 688 0
 2626 1e2a 83BD20FE 		cmpl	$0, -480(%rbp)
 2626      FFFF00
 2627 1e31 740F     		je	.L141
 2628              		.loc 1 688 0 is_stmt 0 discriminator 1
 2629 1e33 C7851CFE 		movl	$1, -484(%rbp)
 2629      FFFF0100 
 2629      0000
 2630 1e3d E9400C00 		jmp	.L126
 2630      00
 2631              	.L141:
 689:main.c        **** 	}
 690:main.c        **** 
 691:main.c        **** 	if ( backupOpt->count ) {
 2632              		.loc 1 691 0 is_stmt 1
 2633 1e42 488B85D0 		movq	-304(%rbp), %rax
 2633      FEFFFF
 2634 1e49 8B4060   		movl	96(%rax), %eax
 2635 1e4c 85C0     		testl	%eax, %eax
 2636 1e4e 0F84DA00 		je	.L144
 2636      0000
 2637              	.LBB13:
 692:main.c        **** 		const char *fileName;
 693:main.c        **** 		const uint32 kbitSize = strtoul(backupOpt->sval[0], (char**)&fileName, 0);
 2638              		.loc 1 693 0
 2639 1e54 488B85D0 		movq	-304(%rbp), %rax
 2639      FEFFFF
 2640 1e5b 488B4068 		movq	104(%rax), %rax
 2641 1e5f 488B00   		movq	(%rax), %rax
 2642 1e62 488D8D10 		leaq	-240(%rbp), %rcx
 2642      FFFFFF
 2643 1e69 BA000000 		movl	$0, %edx
 2643      00
 2644 1e6e 4889CE   		movq	%rcx, %rsi
 2645 1e71 4889C7   		movq	%rax, %rdi
 2646 1e74 E8000000 		call	strtoul
 2646      00
 2647 1e79 898530FE 		movl	%eax, -464(%rbp)
 2647      FFFF
 694:main.c        **** 		if ( *fileName != ':' ) {
 2648              		.loc 1 694 0
 2649 1e7f 488B8510 		movq	-240(%rbp), %rax
 2649      FFFFFF
 2650 1e86 0FB600   		movzbl	(%rax), %eax
 2651 1e89 3C3A     		cmpb	$58, %al
 2652 1e8b 742F     		je	.L145
 695:main.c        **** 			fprintf(stderr, "%s: invalid argument to option --backup=<kbitSize:fw.iic>\n", progName);
 2653              		.loc 1 695 0
 2654 1e8d 488B0500 		movq	stderr(%rip), %rax
 2654      000000
 2655 1e94 488B95E0 		movq	-288(%rbp), %rdx
 2655      FEFFFF
 2656 1e9b BE000000 		movl	$.LC109, %esi
 2656      00
 2657 1ea0 4889C7   		movq	%rax, %rdi
 2658 1ea3 B8000000 		movl	$0, %eax
 2658      00
 2659 1ea8 E8000000 		call	fprintf
 2659      00
 696:main.c        **** 			FAIL(FLP_ARGS, cleanup);
 2660              		.loc 1 696 0
 2661 1ead C7851CFE 		movl	$12, -484(%rbp)
 2661      FFFF0C00 
 2661      0000
 2662 1eb7 E9C60B00 		jmp	.L126
 2662      00
 2663              	.L145:
 697:main.c        **** 		}
 698:main.c        **** 		fileName++;
 2664              		.loc 1 698 0
 2665 1ebc 488B8510 		movq	-240(%rbp), %rax
 2665      FFFFFF
 2666 1ec3 4883C001 		addq	$1, %rax
 2667 1ec7 48898510 		movq	%rax, -240(%rbp)
 2667      FFFFFF
 699:main.c        **** 		printf("Saving a backup of %d kbit from the FX2's EEPROM to %s...\n", kbitSize, fileName);
 2668              		.loc 1 699 0
 2669 1ece 488B9510 		movq	-240(%rbp), %rdx
 2669      FFFFFF
 2670 1ed5 8B8530FE 		movl	-464(%rbp), %eax
 2670      FFFF
 2671 1edb 89C6     		movl	%eax, %esi
 2672 1edd BF000000 		movl	$.LC110, %edi
 2672      00
 2673 1ee2 B8000000 		movl	$0, %eax
 2673      00
 2674 1ee7 E8000000 		call	printf
 2674      00
 700:main.c        **** 		fStatus = flSaveFirmware(handle, kbitSize, fileName, &error);
 2675              		.loc 1 700 0
 2676 1eec 488B9510 		movq	-240(%rbp), %rdx
 2676      FFFFFF
 2677 1ef3 488B8538 		movq	-456(%rbp), %rax
 2677      FEFFFF
 2678 1efa 488D8D40 		leaq	-448(%rbp), %rcx
 2678      FEFFFF
 2679 1f01 8BB530FE 		movl	-464(%rbp), %esi
 2679      FFFF
 2680 1f07 4889C7   		movq	%rax, %rdi
 2681 1f0a E8000000 		call	flSaveFirmware
 2681      00
 2682 1f0f 898520FE 		movl	%eax, -480(%rbp)
 2682      FFFF
 701:main.c        **** 		CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2683              		.loc 1 701 0
 2684 1f15 83BD20FE 		cmpl	$0, -480(%rbp)
 2684      FFFF00
 2685 1f1c 7410     		je	.L144
 2686              		.loc 1 701 0 is_stmt 0 discriminator 1
 2687 1f1e C7851CFE 		movl	$1, -484(%rbp)
 2687      FFFF0100 
 2687      0000
 2688 1f28 90       		nop
 2689 1f29 E9540B00 		jmp	.L126
 2689      00
 2690              	.L144:
 2691              	.LBE13:
 702:main.c        **** 	}
 703:main.c        **** 
 704:main.c        **** 	if ( rstOpt->count ) {
 2692              		.loc 1 704 0 is_stmt 1
 2693 1f2e 488B85B0 		movq	-336(%rbp), %rax
 2693      FEFFFF
 2694 1f35 8B4060   		movl	96(%rax), %eax
 2695 1f38 85C0     		testl	%eax, %eax
 2696 1f3a 7437     		je	.L148
 705:main.c        **** 		// Reset the bulk endpoints (only needed in some virtualised environments)
 706:main.c        **** 		fStatus = flResetToggle(handle, &error);
 2697              		.loc 1 706 0
 2698 1f3c 488B8538 		movq	-456(%rbp), %rax
 2698      FEFFFF
 2699 1f43 488D9540 		leaq	-448(%rbp), %rdx
 2699      FEFFFF
 2700 1f4a 4889D6   		movq	%rdx, %rsi
 2701 1f4d 4889C7   		movq	%rax, %rdi
 2702 1f50 E8000000 		call	flResetToggle
 2702      00
 2703 1f55 898520FE 		movl	%eax, -480(%rbp)
 2703      FFFF
 707:main.c        **** 		CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2704              		.loc 1 707 0
 2705 1f5b 83BD20FE 		cmpl	$0, -480(%rbp)
 2705      FFFF00
 2706 1f62 740F     		je	.L148
 2707              		.loc 1 707 0 is_stmt 0 discriminator 1
 2708 1f64 C7851CFE 		movl	$1, -484(%rbp)
 2708      FFFF0100 
 2708      0000
 2709 1f6e E90F0B00 		jmp	.L126
 2709      00
 2710              	.L148:
 708:main.c        **** 	}
 709:main.c        **** 
 710:main.c        **** 	if ( conOpt->count ) {
 2711              		.loc 1 710 0 is_stmt 1
 2712 1f73 488B8590 		movq	-368(%rbp), %rax
 2712      FEFFFF
 2713 1f7a 8B4060   		movl	96(%rax), %eax
 2714 1f7d 85C0     		testl	%eax, %eax
 2715 1f7f 7413     		je	.L149
 711:main.c        **** 		conduit = (uint8)conOpt->ival[0];
 2716              		.loc 1 711 0
 2717 1f81 488B8590 		movq	-368(%rbp), %rax
 2717      FEFFFF
 2718 1f88 488B4068 		movq	104(%rax), %rax
 2719 1f8c 8B00     		movl	(%rax), %eax
 2720 1f8e 888511FE 		movb	%al, -495(%rbp)
 2720      FFFF
 2721              	.L149:
 712:main.c        **** 	}
 713:main.c        **** 
 714:main.c        **** 	isNeroCapable = flIsNeroCapable(handle);
 2722              		.loc 1 714 0
 2723 1f94 488B8538 		movq	-456(%rbp), %rax
 2723      FEFFFF
 2724 1f9b 4889C7   		movq	%rax, %rdi
 2725 1f9e E8000000 		call	flIsNeroCapable
 2725      00
 2726 1fa3 84C0     		testb	%al, %al
 2727 1fa5 0F95C0   		setne	%al
 2728 1fa8 888512FE 		movb	%al, -494(%rbp)
 2728      FFFF
 715:main.c        **** 	isCommCapable = flIsCommCapable(handle, conduit);
 2729              		.loc 1 715 0
 2730 1fae 0FB69511 		movzbl	-495(%rbp), %edx
 2730      FEFFFF
 2731 1fb5 488B8538 		movq	-456(%rbp), %rax
 2731      FEFFFF
 2732 1fbc 89D6     		movl	%edx, %esi
 2733 1fbe 4889C7   		movq	%rax, %rdi
 2734 1fc1 E8000000 		call	flIsCommCapable
 2734      00
 2735 1fc6 84C0     		testb	%al, %al
 2736 1fc8 0F95C0   		setne	%al
 2737 1fcb 888513FE 		movb	%al, -493(%rbp)
 2737      FFFF
 716:main.c        **** 
 717:main.c        **** 	if ( portOpt->count ) {
 2738              		.loc 1 717 0
 2739 1fd1 488B8578 		movq	-392(%rbp), %rax
 2739      FEFFFF
 2740 1fd8 8B4060   		movl	96(%rax), %eax
 2741 1fdb 85C0     		testl	%eax, %eax
 2742 1fdd 0F843C02 		je	.L150
 2742      0000
 2743              	.LBB14:
 718:main.c        **** 		uint32 readState;
 719:main.c        **** 		char hex[9];
 720:main.c        **** 		const uint8 *p = (const uint8 *)hex;
 2744              		.loc 1 720 0
 2745 1fe3 488D45D0 		leaq	-48(%rbp), %rax
 2746 1fe7 488985F8 		movq	%rax, -264(%rbp)
 2746      FEFFFF
 721:main.c        **** 		printf("Configuring ports...\n");
 2747              		.loc 1 721 0
 2748 1fee BF000000 		movl	$.LC111, %edi
 2748      00
 2749 1ff3 E8000000 		call	puts
 2749      00
 722:main.c        **** 		fStatus = flMultiBitPortAccess(handle, portOpt->sval[0], &readState, &error);
 2750              		.loc 1 722 0
 2751 1ff8 488B8578 		movq	-392(%rbp), %rax
 2751      FEFFFF
 2752 1fff 488B4068 		movq	104(%rax), %rax
 2753 2003 488B30   		movq	(%rax), %rsi
 2754 2006 488B8538 		movq	-456(%rbp), %rax
 2754      FEFFFF
 2755 200d 488D8D40 		leaq	-448(%rbp), %rcx
 2755      FEFFFF
 2756 2014 488D9510 		leaq	-240(%rbp), %rdx
 2756      FFFFFF
 2757 201b 4889C7   		movq	%rax, %rdi
 2758 201e E8000000 		call	flMultiBitPortAccess
 2758      00
 2759 2023 898520FE 		movl	%eax, -480(%rbp)
 2759      FFFF
 723:main.c        **** 		CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2760              		.loc 1 723 0
 2761 2029 83BD20FE 		cmpl	$0, -480(%rbp)
 2761      FFFF00
 2762 2030 740F     		je	.L151
 2763              		.loc 1 723 0 is_stmt 0 discriminator 1
 2764 2032 C7851CFE 		movl	$1, -484(%rbp)
 2764      FFFF0100 
 2764      0000
 2765 203c E9410A00 		jmp	.L126
 2765      00
 2766              	.L151:
 724:main.c        **** 		sprintf(hex, "%08X", readState);
 2767              		.loc 1 724 0 is_stmt 1
 2768 2041 8B9510FF 		movl	-240(%rbp), %edx
 2768      FFFF
 2769 2047 488D45D0 		leaq	-48(%rbp), %rax
 2770 204b BE000000 		movl	$.LC112, %esi
 2770      00
 2771 2050 4889C7   		movq	%rax, %rdi
 2772 2053 B8000000 		movl	$0, %eax
 2772      00
 2773 2058 E8000000 		call	sprintf
 2773      00
 725:main.c        **** 		printf("Readback:   28   24   20   16    12    8    4    0\n          %s", nibbles[*p++ - '0']);
 2774              		.loc 1 725 0
 2775 205d 488B85F8 		movq	-264(%rbp), %rax
 2775      FEFFFF
 2776 2064 488D5001 		leaq	1(%rax), %rdx
 2777 2068 488995F8 		movq	%rdx, -264(%rbp)
 2777      FEFFFF
 2778 206f 0FB600   		movzbl	(%rax), %eax
 2779 2072 0FB6C0   		movzbl	%al, %eax
 2780 2075 83E830   		subl	$48, %eax
 2781 2078 4898     		cltq
 2782 207a 488B04C5 		movq	nibbles(,%rax,8), %rax
 2782      00000000 
 2783 2082 4889C6   		movq	%rax, %rsi
 2784 2085 BF000000 		movl	$.LC113, %edi
 2784      00
 2785 208a B8000000 		movl	$0, %eax
 2785      00
 2786 208f E8000000 		call	printf
 2786      00
 726:main.c        **** 		printf(" %s", nibbles[*p++ - '0']);
 2787              		.loc 1 726 0
 2788 2094 488B85F8 		movq	-264(%rbp), %rax
 2788      FEFFFF
 2789 209b 488D5001 		leaq	1(%rax), %rdx
 2790 209f 488995F8 		movq	%rdx, -264(%rbp)
 2790      FEFFFF
 2791 20a6 0FB600   		movzbl	(%rax), %eax
 2792 20a9 0FB6C0   		movzbl	%al, %eax
 2793 20ac 83E830   		subl	$48, %eax
 2794 20af 4898     		cltq
 2795 20b1 488B04C5 		movq	nibbles(,%rax,8), %rax
 2795      00000000 
 2796 20b9 4889C6   		movq	%rax, %rsi
 2797 20bc BF000000 		movl	$.LC114, %edi
 2797      00
 2798 20c1 B8000000 		movl	$0, %eax
 2798      00
 2799 20c6 E8000000 		call	printf
 2799      00
 727:main.c        **** 		printf(" %s", nibbles[*p++ - '0']);
 2800              		.loc 1 727 0
 2801 20cb 488B85F8 		movq	-264(%rbp), %rax
 2801      FEFFFF
 2802 20d2 488D5001 		leaq	1(%rax), %rdx
 2803 20d6 488995F8 		movq	%rdx, -264(%rbp)
 2803      FEFFFF
 2804 20dd 0FB600   		movzbl	(%rax), %eax
 2805 20e0 0FB6C0   		movzbl	%al, %eax
 2806 20e3 83E830   		subl	$48, %eax
 2807 20e6 4898     		cltq
 2808 20e8 488B04C5 		movq	nibbles(,%rax,8), %rax
 2808      00000000 
 2809 20f0 4889C6   		movq	%rax, %rsi
 2810 20f3 BF000000 		movl	$.LC114, %edi
 2810      00
 2811 20f8 B8000000 		movl	$0, %eax
 2811      00
 2812 20fd E8000000 		call	printf
 2812      00
 728:main.c        **** 		printf(" %s", nibbles[*p++ - '0']);
 2813              		.loc 1 728 0
 2814 2102 488B85F8 		movq	-264(%rbp), %rax
 2814      FEFFFF
 2815 2109 488D5001 		leaq	1(%rax), %rdx
 2816 210d 488995F8 		movq	%rdx, -264(%rbp)
 2816      FEFFFF
 2817 2114 0FB600   		movzbl	(%rax), %eax
 2818 2117 0FB6C0   		movzbl	%al, %eax
 2819 211a 83E830   		subl	$48, %eax
 2820 211d 4898     		cltq
 2821 211f 488B04C5 		movq	nibbles(,%rax,8), %rax
 2821      00000000 
 2822 2127 4889C6   		movq	%rax, %rsi
 2823 212a BF000000 		movl	$.LC114, %edi
 2823      00
 2824 212f B8000000 		movl	$0, %eax
 2824      00
 2825 2134 E8000000 		call	printf
 2825      00
 729:main.c        **** 		printf("  %s", nibbles[*p++ - '0']);
 2826              		.loc 1 729 0
 2827 2139 488B85F8 		movq	-264(%rbp), %rax
 2827      FEFFFF
 2828 2140 488D5001 		leaq	1(%rax), %rdx
 2829 2144 488995F8 		movq	%rdx, -264(%rbp)
 2829      FEFFFF
 2830 214b 0FB600   		movzbl	(%rax), %eax
 2831 214e 0FB6C0   		movzbl	%al, %eax
 2832 2151 83E830   		subl	$48, %eax
 2833 2154 4898     		cltq
 2834 2156 488B04C5 		movq	nibbles(,%rax,8), %rax
 2834      00000000 
 2835 215e 4889C6   		movq	%rax, %rsi
 2836 2161 BF000000 		movl	$.LC115, %edi
 2836      00
 2837 2166 B8000000 		movl	$0, %eax
 2837      00
 2838 216b E8000000 		call	printf
 2838      00
 730:main.c        **** 		printf(" %s", nibbles[*p++ - '0']);
 2839              		.loc 1 730 0
 2840 2170 488B85F8 		movq	-264(%rbp), %rax
 2840      FEFFFF
 2841 2177 488D5001 		leaq	1(%rax), %rdx
 2842 217b 488995F8 		movq	%rdx, -264(%rbp)
 2842      FEFFFF
 2843 2182 0FB600   		movzbl	(%rax), %eax
 2844 2185 0FB6C0   		movzbl	%al, %eax
 2845 2188 83E830   		subl	$48, %eax
 2846 218b 4898     		cltq
 2847 218d 488B04C5 		movq	nibbles(,%rax,8), %rax
 2847      00000000 
 2848 2195 4889C6   		movq	%rax, %rsi
 2849 2198 BF000000 		movl	$.LC114, %edi
 2849      00
 2850 219d B8000000 		movl	$0, %eax
 2850      00
 2851 21a2 E8000000 		call	printf
 2851      00
 731:main.c        **** 		printf(" %s", nibbles[*p++ - '0']);
 2852              		.loc 1 731 0
 2853 21a7 488B85F8 		movq	-264(%rbp), %rax
 2853      FEFFFF
 2854 21ae 488D5001 		leaq	1(%rax), %rdx
 2855 21b2 488995F8 		movq	%rdx, -264(%rbp)
 2855      FEFFFF
 2856 21b9 0FB600   		movzbl	(%rax), %eax
 2857 21bc 0FB6C0   		movzbl	%al, %eax
 2858 21bf 83E830   		subl	$48, %eax
 2859 21c2 4898     		cltq
 2860 21c4 488B04C5 		movq	nibbles(,%rax,8), %rax
 2860      00000000 
 2861 21cc 4889C6   		movq	%rax, %rsi
 2862 21cf BF000000 		movl	$.LC114, %edi
 2862      00
 2863 21d4 B8000000 		movl	$0, %eax
 2863      00
 2864 21d9 E8000000 		call	printf
 2864      00
 732:main.c        **** 		printf(" %s\n", nibbles[*p++ - '0']);
 2865              		.loc 1 732 0
 2866 21de 488B85F8 		movq	-264(%rbp), %rax
 2866      FEFFFF
 2867 21e5 488D5001 		leaq	1(%rax), %rdx
 2868 21e9 488995F8 		movq	%rdx, -264(%rbp)
 2868      FEFFFF
 2869 21f0 0FB600   		movzbl	(%rax), %eax
 2870 21f3 0FB6C0   		movzbl	%al, %eax
 2871 21f6 83E830   		subl	$48, %eax
 2872 21f9 4898     		cltq
 2873 21fb 488B04C5 		movq	nibbles(,%rax,8), %rax
 2873      00000000 
 2874 2203 4889C6   		movq	%rax, %rsi
 2875 2206 BF000000 		movl	$.LC116, %edi
 2875      00
 2876 220b B8000000 		movl	$0, %eax
 2876      00
 2877 2210 E8000000 		call	printf
 2877      00
 733:main.c        **** 		flSleep(100);
 2878              		.loc 1 733 0
 2879 2215 BF640000 		movl	$100, %edi
 2879      00
 2880 221a E8000000 		call	flSleep
 2880      00
 2881              	.L150:
 2882              	.LBE14:
 734:main.c        **** 	}
 735:main.c        **** 
 736:main.c        **** 	if ( queryOpt->count ) {
 2883              		.loc 1 736 0
 2884 221f 488B8580 		movq	-384(%rbp), %rax
 2884      FEFFFF
 2885 2226 8B4060   		movl	96(%rax), %eax
 2886 2229 85C0     		testl	%eax, %eax
 2887 222b 0F844D01 		je	.L152
 2887      0000
 737:main.c        **** 		if ( isNeroCapable ) {
 2888              		.loc 1 737 0
 2889 2231 80BD12FE 		cmpb	$0, -494(%rbp)
 2889      FFFF00
 2890 2238 0F841101 		je	.L153
 2890      0000
 738:main.c        **** 			fStatus = flSelectConduit(handle, 0x00, &error);
 2891              		.loc 1 738 0
 2892 223e 488B8538 		movq	-456(%rbp), %rax
 2892      FEFFFF
 2893 2245 488D9540 		leaq	-448(%rbp), %rdx
 2893      FEFFFF
 2894 224c BE000000 		movl	$0, %esi
 2894      00
 2895 2251 4889C7   		movq	%rax, %rdi
 2896 2254 E8000000 		call	flSelectConduit
 2896      00
 2897 2259 898520FE 		movl	%eax, -480(%rbp)
 2897      FFFF
 739:main.c        **** 			CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2898              		.loc 1 739 0
 2899 225f 83BD20FE 		cmpl	$0, -480(%rbp)
 2899      FFFF00
 2900 2266 740F     		je	.L154
 2901              		.loc 1 739 0 is_stmt 0 discriminator 1
 2902 2268 C7851CFE 		movl	$1, -484(%rbp)
 2902      FFFF0100 
 2902      0000
 2903 2272 E90B0800 		jmp	.L126
 2903      00
 2904              	.L154:
 740:main.c        **** 			fStatus = jtagScanChain(handle, queryOpt->sval[0], &numDevices, scanChain, 16, &error);
 2905              		.loc 1 740 0 is_stmt 1
 2906 2277 488B8580 		movq	-384(%rbp), %rax
 2906      FEFFFF
 2907 227e 488B4068 		movq	104(%rax), %rax
 2908 2282 488B30   		movq	(%rax), %rsi
 2909 2285 488B8538 		movq	-456(%rbp), %rax
 2909      FEFFFF
 2910 228c 488DBD40 		leaq	-448(%rbp), %rdi
 2910      FEFFFF
 2911 2293 488D8D10 		leaq	-240(%rbp), %rcx
 2911      FFFFFF
 2912 229a 488D9514 		leaq	-492(%rbp), %rdx
 2912      FEFFFF
 2913 22a1 4989F9   		movq	%rdi, %r9
 2914 22a4 41B81000 		movl	$16, %r8d
 2914      0000
 2915 22aa 4889C7   		movq	%rax, %rdi
 2916 22ad E8000000 		call	jtagScanChain
 2916      00
 2917 22b2 898520FE 		movl	%eax, -480(%rbp)
 2917      FFFF
 741:main.c        **** 			CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2918              		.loc 1 741 0
 2919 22b8 83BD20FE 		cmpl	$0, -480(%rbp)
 2919      FFFF00
 2920 22bf 740F     		je	.L155
 2921              		.loc 1 741 0 is_stmt 0 discriminator 1
 2922 22c1 C7851CFE 		movl	$1, -484(%rbp)
 2922      FFFF0100 
 2922      0000
 2923 22cb E9B20700 		jmp	.L126
 2923      00
 2924              	.L155:
 742:main.c        **** 			if ( numDevices ) {
 2925              		.loc 1 742 0 is_stmt 1
 2926 22d0 8B8514FE 		movl	-492(%rbp), %eax
 2926      FFFF
 2927 22d6 85C0     		testl	%eax, %eax
 2928 22d8 745A     		je	.L156
 743:main.c        **** 				printf("The FPGALink device at %s scanned its JTAG chain, yielding:\n", vp);
 2929              		.loc 1 743 0
 2930 22da 488B85F0 		movq	-272(%rbp), %rax
 2930      FEFFFF
 2931 22e1 4889C6   		movq	%rax, %rsi
 2932 22e4 BF000000 		movl	$.LC117, %edi
 2932      00
 2933 22e9 B8000000 		movl	$0, %eax
 2933      00
 2934 22ee E8000000 		call	printf
 2934      00
 744:main.c        **** 				for ( i = 0; i < numDevices; i++ ) {
 2935              		.loc 1 744 0
 2936 22f3 C78524FE 		movl	$0, -476(%rbp)
 2936      FFFF0000 
 2936      0000
 2937 22fd EB25     		jmp	.L157
 2938              	.L158:
 745:main.c        **** 					printf("  0x%08X\n", scanChain[i]);
 2939              		.loc 1 745 0 discriminator 2
 2940 22ff 8B8524FE 		movl	-476(%rbp), %eax
 2940      FFFF
 2941 2305 8B848510 		movl	-240(%rbp,%rax,4), %eax
 2941      FFFFFF
 2942 230c 89C6     		movl	%eax, %esi
 2943 230e BF000000 		movl	$.LC118, %edi
 2943      00
 2944 2313 B8000000 		movl	$0, %eax
 2944      00
 2945 2318 E8000000 		call	printf
 2945      00
 744:main.c        **** 				for ( i = 0; i < numDevices; i++ ) {
 2946              		.loc 1 744 0 discriminator 2
 2947 231d 838524FE 		addl	$1, -476(%rbp)
 2947      FFFF01
 2948              	.L157:
 744:main.c        **** 				for ( i = 0; i < numDevices; i++ ) {
 2949              		.loc 1 744 0 is_stmt 0 discriminator 1
 2950 2324 8B8514FE 		movl	-492(%rbp), %eax
 2950      FFFF
 2951 232a 398524FE 		cmpl	%eax, -476(%rbp)
 2951      FFFF
 2952 2330 72CD     		jb	.L158
 2953 2332 EB4A     		jmp	.L152
 2954              	.L156:
 746:main.c        **** 				}
 747:main.c        **** 			} else {
 748:main.c        **** 				printf("The FPGALink device at %s scanned its JTAG chain but did not find any attached devices\
 2955              		.loc 1 748 0 is_stmt 1
 2956 2334 488B85F0 		movq	-272(%rbp), %rax
 2956      FEFFFF
 2957 233b 4889C6   		movq	%rax, %rsi
 2958 233e BF000000 		movl	$.LC119, %edi
 2958      00
 2959 2343 B8000000 		movl	$0, %eax
 2959      00
 2960 2348 E8000000 		call	printf
 2960      00
 2961 234d EB2F     		jmp	.L152
 2962              	.L153:
 749:main.c        **** 			}
 750:main.c        **** 		} else {
 751:main.c        **** 			fprintf(stderr, "JTAG chain scan requested but FPGALink device at %s does not support NeroProg\n
 2963              		.loc 1 751 0
 2964 234f 488B0500 		movq	stderr(%rip), %rax
 2964      000000
 2965 2356 488B95F0 		movq	-272(%rbp), %rdx
 2965      FEFFFF
 2966 235d BE000000 		movl	$.LC120, %esi
 2966      00
 2967 2362 4889C7   		movq	%rax, %rdi
 2968 2365 B8000000 		movl	$0, %eax
 2968      00
 2969 236a E8000000 		call	fprintf
 2969      00
 752:main.c        **** 			FAIL(FLP_ARGS, cleanup);
 2970              		.loc 1 752 0
 2971 236f C7851CFE 		movl	$12, -484(%rbp)
 2971      FFFF0C00 
 2971      0000
 2972 2379 E9040700 		jmp	.L126
 2972      00
 2973              	.L152:
 753:main.c        **** 		}
 754:main.c        **** 	}
 755:main.c        **** 
 756:main.c        **** 	if ( progOpt->count ) {
 2974              		.loc 1 756 0
 2975 237e 488B8588 		movq	-376(%rbp), %rax
 2975      FEFFFF
 2976 2385 8B4060   		movl	96(%rax), %eax
 2977 2388 85C0     		testl	%eax, %eax
 2978 238a 0F84C900 		je	.L160
 2978      0000
 757:main.c        **** 		printf("Programming device...\n");
 2979              		.loc 1 757 0
 2980 2390 BF000000 		movl	$.LC121, %edi
 2980      00
 2981 2395 E8000000 		call	puts
 2981      00
 758:main.c        **** 		if ( isNeroCapable ) {
 2982              		.loc 1 758 0
 2983 239a 80BD12FE 		cmpb	$0, -494(%rbp)
 2983      FFFF00
 2984 23a1 0F848300 		je	.L161
 2984      0000
 759:main.c        **** 			fStatus = flSelectConduit(handle, 0x00, &error);
 2985              		.loc 1 759 0
 2986 23a7 488B8538 		movq	-456(%rbp), %rax
 2986      FEFFFF
 2987 23ae 488D9540 		leaq	-448(%rbp), %rdx
 2987      FEFFFF
 2988 23b5 BE000000 		movl	$0, %esi
 2988      00
 2989 23ba 4889C7   		movq	%rax, %rdi
 2990 23bd E8000000 		call	flSelectConduit
 2990      00
 2991 23c2 898520FE 		movl	%eax, -480(%rbp)
 2991      FFFF
 760:main.c        **** 			CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 2992              		.loc 1 760 0
 2993 23c8 83BD20FE 		cmpl	$0, -480(%rbp)
 2993      FFFF00
 2994 23cf 740F     		je	.L162
 2995              		.loc 1 760 0 is_stmt 0 discriminator 1
 2996 23d1 C7851CFE 		movl	$1, -484(%rbp)
 2996      FFFF0100 
 2996      0000
 2997 23db E9A20600 		jmp	.L126
 2997      00
 2998              	.L162:
 761:main.c        **** 			fStatus = flProgram(handle, progOpt->sval[0], NULL, &error);
 2999              		.loc 1 761 0 is_stmt 1
 3000 23e0 488B8588 		movq	-376(%rbp), %rax
 3000      FEFFFF
 3001 23e7 488B4068 		movq	104(%rax), %rax
 3002 23eb 488B30   		movq	(%rax), %rsi
 3003 23ee 488B8538 		movq	-456(%rbp), %rax
 3003      FEFFFF
 3004 23f5 488D9540 		leaq	-448(%rbp), %rdx
 3004      FEFFFF
 3005 23fc 4889D1   		movq	%rdx, %rcx
 3006 23ff BA000000 		movl	$0, %edx
 3006      00
 3007 2404 4889C7   		movq	%rax, %rdi
 3008 2407 E8000000 		call	flProgram
 3008      00
 3009 240c 898520FE 		movl	%eax, -480(%rbp)
 3009      FFFF
 762:main.c        **** 			CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 3010              		.loc 1 762 0
 3011 2412 83BD20FE 		cmpl	$0, -480(%rbp)
 3011      FFFF00
 3012 2419 743E     		je	.L160
 3013              		.loc 1 762 0 is_stmt 0 discriminator 1
 3014 241b C7851CFE 		movl	$1, -484(%rbp)
 3014      FFFF0100 
 3014      0000
 3015 2425 E9580600 		jmp	.L126
 3015      00
 3016              	.L161:
 763:main.c        **** 		} else {
 764:main.c        **** 			fprintf(stderr, "Program operation requested but device at %s does not support NeroProg\n", vp);
 3017              		.loc 1 764 0 is_stmt 1
 3018 242a 488B0500 		movq	stderr(%rip), %rax
 3018      000000
 3019 2431 488B95F0 		movq	-272(%rbp), %rdx
 3019      FEFFFF
 3020 2438 BE000000 		movl	$.LC122, %esi
 3020      00
 3021 243d 4889C7   		movq	%rax, %rdi
 3022 2440 B8000000 		movl	$0, %eax
 3022      00
 3023 2445 E8000000 		call	fprintf
 3023      00
 765:main.c        **** 			FAIL(FLP_ARGS, cleanup);
 3024              		.loc 1 765 0
 3025 244a C7851CFE 		movl	$12, -484(%rbp)
 3025      FFFF0C00 
 3025      0000
 3026 2454 E9290600 		jmp	.L126
 3026      00
 3027              	.L160:
 766:main.c        **** 		}
 767:main.c        **** 	}
 768:main.c        **** 
 769:main.c        **** 	if ( benOpt->count ) {
 3028              		.loc 1 769 0
 3029 2459 488B85A8 		movq	-344(%rbp), %rax
 3029      FEFFFF
 3030 2460 8B4060   		movl	96(%rax), %eax
 3031 2463 85C0     		testl	%eax, %eax
 3032 2465 7407     		je	.L163
 770:main.c        **** 		enableBenchmarking = true;
 3033              		.loc 1 770 0
 3034 2467 C6050000 		movb	$1, enableBenchmarking(%rip)
 3034      000001
 3035              	.L163:
 771:main.c        **** 	}
 772:main.c        **** 	
 773:main.c        **** 	if ( actOpt->count ) {
 3036              		.loc 1 773 0
 3037 246e 488B8598 		movq	-360(%rbp), %rax
 3037      FEFFFF
 3038 2475 8B4060   		movl	96(%rax), %eax
 3039 2478 85C0     		testl	%eax, %eax
 3040 247a 0F845401 		je	.L164
 3040      0000
 774:main.c        **** 		printf("Executing CommFPGA actions on FPGALink device %s...\n", vp);
 3041              		.loc 1 774 0
 3042 2480 488B85F0 		movq	-272(%rbp), %rax
 3042      FEFFFF
 3043 2487 4889C6   		movq	%rax, %rsi
 3044 248a BF000000 		movl	$.LC123, %edi
 3044      00
 3045 248f B8000000 		movl	$0, %eax
 3045      00
 3046 2494 E8000000 		call	printf
 3046      00
 775:main.c        **** 		if ( isCommCapable ) {
 3047              		.loc 1 775 0
 3048 2499 80BD13FE 		cmpb	$0, -493(%rbp)
 3048      FFFF00
 3049 24a0 0F84FF00 		je	.L165
 3049      0000
 3050              	.LBB15:
 776:main.c        **** 			uint8 isRunning;
 777:main.c        **** 			fStatus = flSelectConduit(handle, conduit, &error);
 3051              		.loc 1 777 0
 3052 24a6 0FB68D11 		movzbl	-495(%rbp), %ecx
 3052      FEFFFF
 3053 24ad 488B8538 		movq	-456(%rbp), %rax
 3053      FEFFFF
 3054 24b4 488D9540 		leaq	-448(%rbp), %rdx
 3054      FEFFFF
 3055 24bb 89CE     		movl	%ecx, %esi
 3056 24bd 4889C7   		movq	%rax, %rdi
 3057 24c0 E8000000 		call	flSelectConduit
 3057      00
 3058 24c5 898520FE 		movl	%eax, -480(%rbp)
 3058      FFFF
 778:main.c        **** 			CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 3059              		.loc 1 778 0
 3060 24cb 83BD20FE 		cmpl	$0, -480(%rbp)
 3060      FFFF00
 3061 24d2 740F     		je	.L166
 3062              		.loc 1 778 0 is_stmt 0 discriminator 1
 3063 24d4 C7851CFE 		movl	$1, -484(%rbp)
 3063      FFFF0100 
 3063      0000
 3064 24de E99F0500 		jmp	.L126
 3064      00
 3065              	.L166:
 779:main.c        **** 			fStatus = flIsFPGARunning(handle, &isRunning, &error);
 3066              		.loc 1 779 0 is_stmt 1
 3067 24e3 488B8538 		movq	-456(%rbp), %rax
 3067      FEFFFF
 3068 24ea 488D9540 		leaq	-448(%rbp), %rdx
 3068      FEFFFF
 3069 24f1 488D8D50 		leaq	-432(%rbp), %rcx
 3069      FEFFFF
 3070 24f8 4889CE   		movq	%rcx, %rsi
 3071 24fb 4889C7   		movq	%rax, %rdi
 3072 24fe E8000000 		call	flIsFPGARunning
 3072      00
 3073 2503 898520FE 		movl	%eax, -480(%rbp)
 3073      FFFF
 780:main.c        **** 			CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 3074              		.loc 1 780 0
 3075 2509 83BD20FE 		cmpl	$0, -480(%rbp)
 3075      FFFF00
 3076 2510 740F     		je	.L168
 3077              		.loc 1 780 0 is_stmt 0 discriminator 1
 3078 2512 C7851CFE 		movl	$1, -484(%rbp)
 3078      FFFF0100 
 3078      0000
 3079 251c E9610500 		jmp	.L126
 3079      00
 3080              	.L168:
 781:main.c        **** 			if ( isRunning ) {
 3081              		.loc 1 781 0 is_stmt 1
 3082 2521 0FB68550 		movzbl	-432(%rbp), %eax
 3082      FEFFFF
 3083 2528 84C0     		testb	%al, %al
 3084 252a 7447     		je	.L169
 782:main.c        **** 				pStatus = parseLine(handle, actOpt->sval[0], &error);
 3085              		.loc 1 782 0
 3086 252c 488B8598 		movq	-360(%rbp), %rax
 3086      FEFFFF
 3087 2533 488B4068 		movq	104(%rax), %rax
 3088 2537 488B08   		movq	(%rax), %rcx
 3089 253a 488B8538 		movq	-456(%rbp), %rax
 3089      FEFFFF
 3090 2541 488D9540 		leaq	-448(%rbp), %rdx
 3090      FEFFFF
 3091 2548 4889CE   		movq	%rcx, %rsi
 3092 254b 4889C7   		movq	%rax, %rdi
 3093 254e E894E0FF 		call	parseLine
 3093      FF
 3094 2553 898534FE 		movl	%eax, -460(%rbp)
 3094      FFFF
 783:main.c        **** 				CHECK_STATUS(pStatus, pStatus, cleanup);
 3095              		.loc 1 783 0
 3096 2559 83BD34FE 		cmpl	$0, -460(%rbp)
 3096      FFFF00
 3097 2560 7441     		je	.L170
 3098              		.loc 1 783 0 is_stmt 0 discriminator 1
 3099 2562 8B8534FE 		movl	-460(%rbp), %eax
 3099      FFFF
 3100 2568 89851CFE 		movl	%eax, -484(%rbp)
 3100      FFFF
 3101 256e E90F0500 		jmp	.L126
 3101      00
 3102              	.L169:
 784:main.c        **** 			} else {
 785:main.c        **** 				fprintf(stderr, "The FPGALink device at %s is not ready to talk - did you forget --program?\n",
 3103              		.loc 1 785 0 is_stmt 1
 3104 2573 488B0500 		movq	stderr(%rip), %rax
 3104      000000
 3105 257a 488B95F0 		movq	-272(%rbp), %rdx
 3105      FEFFFF
 3106 2581 BE000000 		movl	$.LC124, %esi
 3106      00
 3107 2586 4889C7   		movq	%rax, %rdi
 3108 2589 B8000000 		movl	$0, %eax
 3108      00
 3109 258e E8000000 		call	fprintf
 3109      00
 786:main.c        **** 				FAIL(FLP_ARGS, cleanup);
 3110              		.loc 1 786 0
 3111 2593 C7851CFE 		movl	$12, -484(%rbp)
 3111      FFFF0C00 
 3111      0000
 3112 259d 90       		nop
 3113 259e E9DF0400 		jmp	.L126
 3113      00
 3114              	.L170:
 3115              	.LBE15:
 3116 25a3 EB2F     		jmp	.L164
 3117              	.L165:
 787:main.c        **** 			}
 788:main.c        **** 		} else {
 789:main.c        **** 			fprintf(stderr, "Action requested but device at %s does not support CommFPGA\n", vp);
 3118              		.loc 1 789 0
 3119 25a5 488B0500 		movq	stderr(%rip), %rax
 3119      000000
 3120 25ac 488B95F0 		movq	-272(%rbp), %rdx
 3120      FEFFFF
 3121 25b3 BE000000 		movl	$.LC125, %esi
 3121      00
 3122 25b8 4889C7   		movq	%rax, %rdi
 3123 25bb B8000000 		movl	$0, %eax
 3123      00
 3124 25c0 E8000000 		call	fprintf
 3124      00
 790:main.c        **** 			FAIL(FLP_ARGS, cleanup);
 3125              		.loc 1 790 0
 3126 25c5 C7851CFE 		movl	$12, -484(%rbp)
 3126      FFFF0C00 
 3126      0000
 3127 25cf E9AE0400 		jmp	.L126
 3127      00
 3128              	.L164:
 791:main.c        **** 		}
 792:main.c        **** 	}
 793:main.c        **** 
 794:main.c        **** 	if ( dumpOpt->count ) {
 3129              		.loc 1 794 0
 3130 25d4 488B85B8 		movq	-328(%rbp), %rax
 3130      FEFFFF
 3131 25db 8B4060   		movl	96(%rax), %eax
 3132 25de 85C0     		testl	%eax, %eax
 3133 25e0 0F84C402 		je	.L171
 3133      0000
 3134              	.LBB16:
 795:main.c        **** 		const char *fileName;
 796:main.c        **** 		unsigned long chan = strtoul(dumpOpt->sval[0], (char**)&fileName, 10);
 3135              		.loc 1 796 0
 3136 25e6 488B85B8 		movq	-328(%rbp), %rax
 3136      FEFFFF
 3137 25ed 488B4068 		movq	104(%rax), %rax
 3138 25f1 488B00   		movq	(%rax), %rax
 3139 25f4 488D8D48 		leaq	-440(%rbp), %rcx
 3139      FEFFFF
 3140 25fb BA0A0000 		movl	$10, %edx
 3140      00
 3141 2600 4889CE   		movq	%rcx, %rsi
 3142 2603 4889C7   		movq	%rax, %rdi
 3143 2606 E8000000 		call	strtoul
 3143      00
 3144 260b 48898500 		movq	%rax, -256(%rbp)
 3144      FFFFFF
 797:main.c        **** 		FILE *file = NULL;
 3145              		.loc 1 797 0
 3146 2612 48C78508 		movq	$0, -248(%rbp)
 3146      FFFFFF00 
 3146      000000
 798:main.c        **** 		const uint8 *recvData;
 799:main.c        **** 		uint32 actualLength;
 800:main.c        **** 		if ( *fileName != ':' ) {
 3147              		.loc 1 800 0
 3148 261d 488B8548 		movq	-440(%rbp), %rax
 3148      FEFFFF
 3149 2624 0FB600   		movzbl	(%rax), %eax
 3150 2627 3C3A     		cmpb	$58, %al
 3151 2629 742F     		je	.L172
 801:main.c        **** 			fprintf(stderr, "%s: invalid argument to option -l|--dumploop=<ch:file.bin>\n", progName);
 3152              		.loc 1 801 0
 3153 262b 488B0500 		movq	stderr(%rip), %rax
 3153      000000
 3154 2632 488B95E0 		movq	-288(%rbp), %rdx
 3154      FEFFFF
 3155 2639 BE000000 		movl	$.LC126, %esi
 3155      00
 3156 263e 4889C7   		movq	%rax, %rdi
 3157 2641 B8000000 		movl	$0, %eax
 3157      00
 3158 2646 E8000000 		call	fprintf
 3158      00
 802:main.c        **** 			FAIL(FLP_ARGS, cleanup);
 3159              		.loc 1 802 0
 3160 264b C7851CFE 		movl	$12, -484(%rbp)
 3160      FFFF0C00 
 3160      0000
 3161 2655 E9280400 		jmp	.L126
 3161      00
 3162              	.L172:
 803:main.c        **** 		}
 804:main.c        **** 		fileName++;
 3163              		.loc 1 804 0
 3164 265a 488B8548 		movq	-440(%rbp), %rax
 3164      FEFFFF
 3165 2661 4883C001 		addq	$1, %rax
 3166 2665 48898548 		movq	%rax, -440(%rbp)
 3166      FEFFFF
 805:main.c        **** 		printf("Copying from channel %lu to %s", chan, fileName);
 3167              		.loc 1 805 0
 3168 266c 488B9548 		movq	-440(%rbp), %rdx
 3168      FEFFFF
 3169 2673 488B8500 		movq	-256(%rbp), %rax
 3169      FFFFFF
 3170 267a 4889C6   		movq	%rax, %rsi
 3171 267d BF000000 		movl	$.LC127, %edi
 3171      00
 3172 2682 B8000000 		movl	$0, %eax
 3172      00
 3173 2687 E8000000 		call	printf
 3173      00
 806:main.c        **** 		file = fopen(fileName, "wb");
 3174              		.loc 1 806 0
 3175 268c 488B8548 		movq	-440(%rbp), %rax
 3175      FEFFFF
 3176 2693 BE000000 		movl	$.LC13, %esi
 3176      00
 3177 2698 4889C7   		movq	%rax, %rdi
 3178 269b E8000000 		call	fopen
 3178      00
 3179 26a0 48898508 		movq	%rax, -248(%rbp)
 3179      FFFFFF
 807:main.c        **** 		CHECK_STATUS(!file, FLP_CANNOT_SAVE, cleanup);
 3180              		.loc 1 807 0
 3181 26a7 4883BD08 		cmpq	$0, -248(%rbp)
 3181      FFFFFF00 
 3182 26af 750F     		jne	.L174
 3183              		.loc 1 807 0 is_stmt 0 discriminator 1
 3184 26b1 C7851CFE 		movl	$11, -484(%rbp)
 3184      FFFF0B00 
 3184      0000
 3185 26bb E9C20300 		jmp	.L126
 3185      00
 3186              	.L174:
 808:main.c        **** 		sigRegisterHandler();
 3187              		.loc 1 808 0 is_stmt 1
 3188 26c0 E8000000 		call	sigRegisterHandler
 3188      00
 809:main.c        **** 		fStatus = flSelectConduit(handle, conduit, &error);
 3189              		.loc 1 809 0
 3190 26c5 0FB68D11 		movzbl	-495(%rbp), %ecx
 3190      FEFFFF
 3191 26cc 488B8538 		movq	-456(%rbp), %rax
 3191      FEFFFF
 3192 26d3 488D9540 		leaq	-448(%rbp), %rdx
 3192      FEFFFF
 3193 26da 89CE     		movl	%ecx, %esi
 3194 26dc 4889C7   		movq	%rax, %rdi
 3195 26df E8000000 		call	flSelectConduit
 3195      00
 3196 26e4 898520FE 		movl	%eax, -480(%rbp)
 3196      FFFF
 810:main.c        **** 		CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 3197              		.loc 1 810 0
 3198 26ea 83BD20FE 		cmpl	$0, -480(%rbp)
 3198      FFFF00
 3199 26f1 740F     		je	.L175
 3200              		.loc 1 810 0 is_stmt 0 discriminator 1
 3201 26f3 C7851CFE 		movl	$1, -484(%rbp)
 3201      FFFF0100 
 3201      0000
 3202 26fd E9800300 		jmp	.L126
 3202      00
 3203              	.L175:
 811:main.c        **** 		fStatus = flReadChannelAsyncSubmit(handle, (uint8)chan, 22528, NULL, &error);
 3204              		.loc 1 811 0 is_stmt 1
 3205 2702 488B8500 		movq	-256(%rbp), %rax
 3205      FFFFFF
 3206 2709 0FB6F0   		movzbl	%al, %esi
 3207 270c 488B8538 		movq	-456(%rbp), %rax
 3207      FEFFFF
 3208 2713 488D9540 		leaq	-448(%rbp), %rdx
 3208      FEFFFF
 3209 271a 4989D0   		movq	%rdx, %r8
 3210 271d B9000000 		movl	$0, %ecx
 3210      00
 3211 2722 BA005800 		movl	$22528, %edx
 3211      00
 3212 2727 4889C7   		movq	%rax, %rdi
 3213 272a E8000000 		call	flReadChannelAsyncSubmit
 3213      00
 3214 272f 898520FE 		movl	%eax, -480(%rbp)
 3214      FFFF
 812:main.c        **** 		CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 3215              		.loc 1 812 0
 3216 2735 83BD20FE 		cmpl	$0, -480(%rbp)
 3216      FFFF00
 3217 273c 740F     		je	.L176
 3218              		.loc 1 812 0 is_stmt 0 discriminator 1
 3219 273e C7851CFE 		movl	$1, -484(%rbp)
 3219      FFFF0100 
 3219      0000
 3220 2748 E9350300 		jmp	.L126
 3220      00
 3221              	.L176:
 813:main.c        **** 		do {
 814:main.c        **** 			fStatus = flReadChannelAsyncSubmit(handle, (uint8)chan, 22528, NULL, &error);
 3222              		.loc 1 814 0 is_stmt 1
 3223 274d 488B8500 		movq	-256(%rbp), %rax
 3223      FFFFFF
 3224 2754 0FB6F0   		movzbl	%al, %esi
 3225 2757 488B8538 		movq	-456(%rbp), %rax
 3225      FEFFFF
 3226 275e 488D9540 		leaq	-448(%rbp), %rdx
 3226      FEFFFF
 3227 2765 4989D0   		movq	%rdx, %r8
 3228 2768 B9000000 		movl	$0, %ecx
 3228      00
 3229 276d BA005800 		movl	$22528, %edx
 3229      00
 3230 2772 4889C7   		movq	%rax, %rdi
 3231 2775 E8000000 		call	flReadChannelAsyncSubmit
 3231      00
 3232 277a 898520FE 		movl	%eax, -480(%rbp)
 3232      FFFF
 815:main.c        **** 			CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 3233              		.loc 1 815 0
 3234 2780 83BD20FE 		cmpl	$0, -480(%rbp)
 3234      FFFF00
 3235 2787 740F     		je	.L177
 3236              		.loc 1 815 0 is_stmt 0 discriminator 1
 3237 2789 C7851CFE 		movl	$1, -484(%rbp)
 3237      FFFF0100 
 3237      0000
 3238 2793 E9EA0200 		jmp	.L126
 3238      00
 3239              	.L177:
 816:main.c        **** 			fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, &error);
 3240              		.loc 1 816 0 is_stmt 1
 3241 2798 488B8538 		movq	-456(%rbp), %rax
 3241      FEFFFF
 3242 279f 488DBD40 		leaq	-448(%rbp), %rdi
 3242      FEFFFF
 3243 27a6 488D8D18 		leaq	-488(%rbp), %rcx
 3243      FEFFFF
 3244 27ad 488D9518 		leaq	-488(%rbp), %rdx
 3244      FEFFFF
 3245 27b4 488DB550 		leaq	-432(%rbp), %rsi
 3245      FEFFFF
 3246 27bb 4989F8   		movq	%rdi, %r8
 3247 27be 4889C7   		movq	%rax, %rdi
 3248 27c1 E8000000 		call	flReadChannelAsyncAwait
 3248      00
 3249 27c6 898520FE 		movl	%eax, -480(%rbp)
 3249      FFFF
 817:main.c        **** 			CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 3250              		.loc 1 817 0
 3251 27cc 83BD20FE 		cmpl	$0, -480(%rbp)
 3251      FFFF00
 3252 27d3 740F     		je	.L178
 3253              		.loc 1 817 0 is_stmt 0 discriminator 1
 3254 27d5 C7851CFE 		movl	$1, -484(%rbp)
 3254      FFFF0100 
 3254      0000
 3255 27df E99E0200 		jmp	.L126
 3255      00
 3256              	.L178:
 818:main.c        **** 			fwrite(recvData, 1, actualLength, file);
 3257              		.loc 1 818 0 is_stmt 1
 3258 27e4 8B8518FE 		movl	-488(%rbp), %eax
 3258      FFFF
 3259 27ea 89C2     		movl	%eax, %edx
 3260 27ec 488B8550 		movq	-432(%rbp), %rax
 3260      FEFFFF
 3261 27f3 488B8D08 		movq	-248(%rbp), %rcx
 3261      FFFFFF
 3262 27fa BE010000 		movl	$1, %esi
 3262      00
 3263 27ff 4889C7   		movq	%rax, %rdi
 3264 2802 E8000000 		call	fwrite
 3264      00
 819:main.c        **** 			printf(".");
 3265              		.loc 1 819 0
 3266 2807 BF2E0000 		movl	$46, %edi
 3266      00
 3267 280c E8000000 		call	putchar
 3267      00
 820:main.c        **** 		} while ( !sigIsRaised() );
 3268              		.loc 1 820 0
 3269 2811 E8000000 		call	sigIsRaised
 3269      00
 3270 2816 83F001   		xorl	$1, %eax
 3271 2819 84C0     		testb	%al, %al
 3272 281b 0F852CFF 		jne	.L176
 3272      FFFF
 821:main.c        **** 		printf("\nCaught SIGINT, quitting...\n");
 3273              		.loc 1 821 0
 3274 2821 BF000000 		movl	$.LC128, %edi
 3274      00
 3275 2826 E8000000 		call	puts
 3275      00
 822:main.c        **** 		fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, &error);
 3276              		.loc 1 822 0
 3277 282b 488B8538 		movq	-456(%rbp), %rax
 3277      FEFFFF
 3278 2832 488DBD40 		leaq	-448(%rbp), %rdi
 3278      FEFFFF
 3279 2839 488D8D18 		leaq	-488(%rbp), %rcx
 3279      FEFFFF
 3280 2840 488D9518 		leaq	-488(%rbp), %rdx
 3280      FEFFFF
 3281 2847 488DB550 		leaq	-432(%rbp), %rsi
 3281      FEFFFF
 3282 284e 4989F8   		movq	%rdi, %r8
 3283 2851 4889C7   		movq	%rax, %rdi
 3284 2854 E8000000 		call	flReadChannelAsyncAwait
 3284      00
 3285 2859 898520FE 		movl	%eax, -480(%rbp)
 3285      FFFF
 823:main.c        **** 		CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 3286              		.loc 1 823 0
 3287 285f 83BD20FE 		cmpl	$0, -480(%rbp)
 3287      FFFF00
 3288 2866 7410     		je	.L179
 3289              		.loc 1 823 0 is_stmt 0 discriminator 1
 3290 2868 C7851CFE 		movl	$1, -484(%rbp)
 3290      FFFF0100 
 3290      0000
 3291 2872 90       		nop
 3292 2873 E90A0200 		jmp	.L126
 3292      00
 3293              	.L179:
 824:main.c        **** 		fwrite(recvData, 1, actualLength, file);
 3294              		.loc 1 824 0 is_stmt 1
 3295 2878 8B8518FE 		movl	-488(%rbp), %eax
 3295      FFFF
 3296 287e 89C2     		movl	%eax, %edx
 3297 2880 488B8550 		movq	-432(%rbp), %rax
 3297      FEFFFF
 3298 2887 488B8D08 		movq	-248(%rbp), %rcx
 3298      FFFFFF
 3299 288e BE010000 		movl	$1, %esi
 3299      00
 3300 2893 4889C7   		movq	%rax, %rdi
 3301 2896 E8000000 		call	fwrite
 3301      00
 825:main.c        **** 		fclose(file);
 3302              		.loc 1 825 0
 3303 289b 488B8508 		movq	-248(%rbp), %rax
 3303      FFFFFF
 3304 28a2 4889C7   		movq	%rax, %rdi
 3305 28a5 E8000000 		call	fclose
 3305      00
 3306              	.L171:
 3307              	.LBE16:
 826:main.c        **** 	}
 827:main.c        **** 
 828:main.c        **** 	if ( shellOpt->count ) {
 3308              		.loc 1 828 0
 3309 28aa 488B85A0 		movq	-352(%rbp), %rax
 3309      FEFFFF
 3310 28b1 8B4060   		movl	96(%rax), %eax
 3311 28b4 85C0     		testl	%eax, %eax
 3312 28b6 0F84C601 		je	.L126
 3312      0000
 829:main.c        **** 		printf("\nEntering CommFPGA command-line mode:\n");
 3313              		.loc 1 829 0
 3314 28bc BF000000 		movl	$.LC129, %edi
 3314      00
 3315 28c1 E8000000 		call	puts
 3315      00
 830:main.c        **** 		if ( isCommCapable ) {
 3316              		.loc 1 830 0
 3317 28c6 80BD13FE 		cmpb	$0, -493(%rbp)
 3317      FFFF00
 3318 28cd 0F848401 		je	.L180
 3318      0000
 3319              	.LBB17:
 831:main.c        **** 		   uint8 isRunning;
 832:main.c        **** 			fStatus = flSelectConduit(handle, conduit, &error);
 3320              		.loc 1 832 0
 3321 28d3 0FB68D11 		movzbl	-495(%rbp), %ecx
 3321      FEFFFF
 3322 28da 488B8538 		movq	-456(%rbp), %rax
 3322      FEFFFF
 3323 28e1 488D9540 		leaq	-448(%rbp), %rdx
 3323      FEFFFF
 3324 28e8 89CE     		movl	%ecx, %esi
 3325 28ea 4889C7   		movq	%rax, %rdi
 3326 28ed E8000000 		call	flSelectConduit
 3326      00
 3327 28f2 898520FE 		movl	%eax, -480(%rbp)
 3327      FFFF
 833:main.c        **** 			CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 3328              		.loc 1 833 0
 3329 28f8 83BD20FE 		cmpl	$0, -480(%rbp)
 3329      FFFF00
 3330 28ff 740F     		je	.L181
 3331              		.loc 1 833 0 is_stmt 0 discriminator 1
 3332 2901 C7851CFE 		movl	$1, -484(%rbp)
 3332      FFFF0100 
 3332      0000
 3333 290b E9720100 		jmp	.L126
 3333      00
 3334              	.L181:
 834:main.c        **** 			fStatus = flIsFPGARunning(handle, &isRunning, &error);
 3335              		.loc 1 834 0 is_stmt 1
 3336 2910 488B8538 		movq	-456(%rbp), %rax
 3336      FEFFFF
 3337 2917 488D9540 		leaq	-448(%rbp), %rdx
 3337      FEFFFF
 3338 291e 488D8D50 		leaq	-432(%rbp), %rcx
 3338      FEFFFF
 3339 2925 4889CE   		movq	%rcx, %rsi
 3340 2928 4889C7   		movq	%rax, %rdi
 3341 292b E8000000 		call	flIsFPGARunning
 3341      00
 3342 2930 898520FE 		movl	%eax, -480(%rbp)
 3342      FFFF
 835:main.c        **** 			CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 3343              		.loc 1 835 0
 3344 2936 83BD20FE 		cmpl	$0, -480(%rbp)
 3344      FFFF00
 3345 293d 740F     		je	.L183
 3346              		.loc 1 835 0 is_stmt 0 discriminator 1
 3347 293f C7851CFE 		movl	$1, -484(%rbp)
 3347      FFFF0100 
 3347      0000
 3348 2949 E9340100 		jmp	.L126
 3348      00
 3349              	.L183:
 836:main.c        **** 			if ( isRunning ) {
 3350              		.loc 1 836 0 is_stmt 1
 3351 294e 0FB68550 		movzbl	-432(%rbp), %eax
 3351      FEFFFF
 3352 2955 84C0     		testb	%al, %al
 3353 2957 0F84CB00 		je	.L184
 3353      0000
 3354              	.L186:
 837:main.c        **** 				do {
 838:main.c        **** 					do {
 839:main.c        **** 						line = readline("> ");
 3355              		.loc 1 839 0 discriminator 1
 3356 295d BF000000 		movl	$.LC130, %edi
 3356      00
 3357 2962 E8000000 		call	readline
 3357      00
 3358 2967 48898558 		movq	%rax, -424(%rbp)
 3358      FEFFFF
 840:main.c        **** 					} while ( line && !line[0] );
 3359              		.loc 1 840 0 discriminator 1
 3360 296e 4883BD58 		cmpq	$0, -424(%rbp)
 3360      FEFFFF00 
 3361 2976 740E     		je	.L185
 3362 2978 488B8558 		movq	-424(%rbp), %rax
 3362      FEFFFF
 3363 297f 0FB600   		movzbl	(%rax), %eax
 3364 2982 84C0     		testb	%al, %al
 3365 2984 74D7     		je	.L186
 3366              	.L185:
 841:main.c        **** 					if ( line && line[0] && line[0] != 'q' ) {
 3367              		.loc 1 841 0
 3368 2986 4883BD58 		cmpq	$0, -424(%rbp)
 3368      FEFFFF00 
 3369 298e 747A     		je	.L187
 3370              		.loc 1 841 0 is_stmt 0 discriminator 1
 3371 2990 488B8558 		movq	-424(%rbp), %rax
 3371      FEFFFF
 3372 2997 0FB600   		movzbl	(%rax), %eax
 3373 299a 84C0     		testb	%al, %al
 3374 299c 746C     		je	.L187
 3375 299e 488B8558 		movq	-424(%rbp), %rax
 3375      FEFFFF
 3376 29a5 0FB600   		movzbl	(%rax), %eax
 3377 29a8 3C71     		cmpb	$113, %al
 3378 29aa 745E     		je	.L187
 842:main.c        **** 						add_history(line);
 3379              		.loc 1 842 0 is_stmt 1
 3380 29ac 488B8558 		movq	-424(%rbp), %rax
 3380      FEFFFF
 3381 29b3 4889C7   		movq	%rax, %rdi
 3382 29b6 E8000000 		call	add_history
 3382      00
 843:main.c        **** 						pStatus = parseLine(handle, line, &error);
 3383              		.loc 1 843 0
 3384 29bb 488B8538 		movq	-456(%rbp), %rax
 3384      FEFFFF
 3385 29c2 488D9540 		leaq	-448(%rbp), %rdx
 3385      FEFFFF
 3386 29c9 488B8D58 		movq	-424(%rbp), %rcx
 3386      FEFFFF
 3387 29d0 4889CE   		movq	%rcx, %rsi
 3388 29d3 4889C7   		movq	%rax, %rdi
 3389 29d6 E80CDCFF 		call	parseLine
 3389      FF
 3390 29db 898534FE 		movl	%eax, -460(%rbp)
 3390      FFFF
 844:main.c        **** 						CHECK_STATUS(pStatus, pStatus, cleanup);
 3391              		.loc 1 844 0
 3392 29e1 83BD34FE 		cmpl	$0, -460(%rbp)
 3392      FFFF00
 3393 29e8 7411     		je	.L188
 3394              		.loc 1 844 0 is_stmt 0 discriminator 1
 3395 29ea 8B8534FE 		movl	-460(%rbp), %eax
 3395      FFFF
 3396 29f0 89851CFE 		movl	%eax, -484(%rbp)
 3396      FFFF
 3397 29f6 E9870000 		jmp	.L126
 3397      00
 3398              	.L188:
 845:main.c        **** 						free((void*)line);
 3399              		.loc 1 845 0 is_stmt 1
 3400 29fb 488B8558 		movq	-424(%rbp), %rax
 3400      FEFFFF
 3401 2a02 4889C7   		movq	%rax, %rdi
 3402 2a05 E8000000 		call	free
 3402      00
 3403              	.L187:
 846:main.c        **** 					}
 847:main.c        **** 				} while ( line && line[0] != 'q' );
 3404              		.loc 1 847 0
 3405 2a0a 4883BD58 		cmpq	$0, -424(%rbp)
 3405      FEFFFF00 
 3406 2a12 7441     		je	.L189
 3407              		.loc 1 847 0 is_stmt 0 discriminator 1
 3408 2a14 488B8558 		movq	-424(%rbp), %rax
 3408      FEFFFF
 3409 2a1b 0FB600   		movzbl	(%rax), %eax
 3410 2a1e 3C71     		cmpb	$113, %al
 3411 2a20 0F8537FF 		jne	.L186
 3411      FFFF
 3412              	.LBE17:
 3413 2a26 EB5A     		jmp	.L126
 3414              	.L184:
 3415              	.LBB18:
 848:main.c        **** 			} else {
 849:main.c        **** 				fprintf(stderr, "The FPGALink device at %s is not ready to talk - did you forget --xsvf?\n", vp
 3416              		.loc 1 849 0 is_stmt 1
 3417 2a28 488B0500 		movq	stderr(%rip), %rax
 3417      000000
 3418 2a2f 488B95F0 		movq	-272(%rbp), %rdx
 3418      FEFFFF
 3419 2a36 BE000000 		movl	$.LC131, %esi
 3419      00
 3420 2a3b 4889C7   		movq	%rax, %rdi
 3421 2a3e B8000000 		movl	$0, %eax
 3421      00
 3422 2a43 E8000000 		call	fprintf
 3422      00
 850:main.c        **** 				FAIL(FLP_ARGS, cleanup);
 3423              		.loc 1 850 0
 3424 2a48 C7851CFE 		movl	$12, -484(%rbp)
 3424      FFFF0C00 
 3424      0000
 3425 2a52 90       		nop
 3426 2a53 EB2D     		jmp	.L126
 3427              	.L189:
 3428              	.LBE18:
 3429 2a55 EB2B     		jmp	.L126
 3430              	.L180:
 851:main.c        **** 			}
 852:main.c        **** 		} else {
 853:main.c        **** 			fprintf(stderr, "Shell requested but device at %s does not support CommFPGA\n", vp);
 3431              		.loc 1 853 0
 3432 2a57 488B0500 		movq	stderr(%rip), %rax
 3432      000000
 3433 2a5e 488B95F0 		movq	-272(%rbp), %rdx
 3433      FEFFFF
 3434 2a65 BE000000 		movl	$.LC132, %esi
 3434      00
 3435 2a6a 4889C7   		movq	%rax, %rdi
 3436 2a6d B8000000 		movl	$0, %eax
 3436      00
 3437 2a72 E8000000 		call	fprintf
 3437      00
 854:main.c        **** 			FAIL(FLP_ARGS, cleanup);
 3438              		.loc 1 854 0
 3439 2a77 C7851CFE 		movl	$12, -484(%rbp)
 3439      FFFF0C00 
 3439      0000
 3440 2a81 90       		nop
 3441              	.L126:
 855:main.c        **** 		}
 856:main.c        **** 	}
 857:main.c        **** 
 858:main.c        **** cleanup:
 859:main.c        **** 	free((void*)line);
 3442              		.loc 1 859 0
 3443 2a82 488B8558 		movq	-424(%rbp), %rax
 3443      FEFFFF
 3444 2a89 4889C7   		movq	%rax, %rdi
 3445 2a8c E8000000 		call	free
 3445      00
 860:main.c        **** 	flClose(handle);
 3446              		.loc 1 860 0
 3447 2a91 488B8538 		movq	-456(%rbp), %rax
 3447      FEFFFF
 3448 2a98 4889C7   		movq	%rax, %rdi
 3449 2a9b E8000000 		call	flClose
 3449      00
 861:main.c        **** 	if ( error ) {
 3450              		.loc 1 861 0
 3451 2aa0 488B8540 		movq	-448(%rbp), %rax
 3451      FEFFFF
 3452 2aa7 4885C0   		testq	%rax, %rax
 3453 2aaa 742F     		je	.L190
 862:main.c        **** 		fprintf(stderr, "%s\n", error);
 3454              		.loc 1 862 0
 3455 2aac 488B9540 		movq	-448(%rbp), %rdx
 3455      FEFFFF
 3456 2ab3 488B0500 		movq	stderr(%rip), %rax
 3456      000000
 3457 2aba BE000000 		movl	$.LC133, %esi
 3457      00
 3458 2abf 4889C7   		movq	%rax, %rdi
 3459 2ac2 B8000000 		movl	$0, %eax
 3459      00
 3460 2ac7 E8000000 		call	fprintf
 3460      00
 863:main.c        **** 		flFreeError(error);
 3461              		.loc 1 863 0
 3462 2acc 488B8540 		movq	-448(%rbp), %rax
 3462      FEFFFF
 3463 2ad3 4889C7   		movq	%rax, %rdi
 3464 2ad6 E8000000 		call	flFreeError
 3464      00
 3465              	.L190:
 864:main.c        **** 	}
 865:main.c        **** 	return retVal;
 3466              		.loc 1 865 0
 3467 2adb 8B851CFE 		movl	-484(%rbp), %eax
 3467      FFFF
 866:main.c        **** }
 3468              		.loc 1 866 0
 3469 2ae1 488B5DE8 		movq	-24(%rbp), %rbx
 3470 2ae5 6448331C 		xorq	%fs:40, %rbx
 3470      25280000 
 3470      00
 3471 2aee 7405     		je	.L192
 3472 2af0 E8000000 		call	__stack_chk_fail
 3472      00
 3473              	.L192:
 3474 2af5 4881C4F8 		addq	$504, %rsp
 3474      010000
 3475 2afc 5B       		popq	%rbx
 3476 2afd 5D       		popq	%rbp
 3477              		.cfi_def_cfa 7, 8
 3478 2afe C3       		ret
 3479              		.cfi_endproc
 3480              	.LFE11:
 3482              		.section	.rodata
 3483              		.align 8
 3484              	.LC14:
 3485 0d50 00000000 		.long	0
 3486 0d54 80842E41 		.long	1093567616
 3487              		.align 8
 3488              	.LC15:
 3489 0d58 00000000 		.long	0
 3490 0d5c 00003041 		.long	1093664768
 3491              		.text
 3492              	.Letext0:
 3493              		.file 2 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
 3494              		.file 3 "/usr/include/x86_64-linux-gnu/bits/types.h"
 3495              		.file 4 "/usr/include/stdio.h"
 3496              		.file 5 "/usr/include/libio.h"
 3497              		.file 6 "/home/pandu/Desktop/DigitalLogicDesign/Lab/03-/makestuff/common/makestuff.h"
 3498              		.file 7 "/home/pandu/Desktop/DigitalLogicDesign/Lab/03-/makestuff/libs/libfpgalink/libfpgalink.h"
 3499              		.file 8 "/home/pandu/Desktop/DigitalLogicDesign/Lab/03-/makestuff/libs/libbuffer/libbuffer.h"
 3500              		.file 9 "/home/pandu/Desktop/DigitalLogicDesign/Lab/03-/makestuff/libs/libargtable2/argtable2.h"
 3501              		.file 10 "/usr/include/x86_64-linux-gnu/bits/time.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccbdKk47.s:5      .bss:0000000000000000 ptr
     /tmp/ccbdKk47.s:5      .bss:0000000000000008 enableBenchmarking
     /tmp/ccbdKk47.s:9      .text:0000000000000000 isHexDigit
     /tmp/ccbdKk47.s:58     .text:000000000000003e calcChecksum
     /tmp/ccbdKk47.s:98     .text:000000000000007f getHexNibble
     /tmp/ccbdKk47.s:166    .text:00000000000000f3 getHexByte
     /tmp/ccbdKk47.s:252    .rodata:00000000000000e0 errMessages
     /tmp/ccbdKk47.s:270    .text:0000000000000174 doRead
     /tmp/ccbdKk47.s:505    .text:00000000000003ea doWrite
     /tmp/ccbdKk47.s:658    .text:00000000000005e7 parseLine
     /tmp/ccbdKk47.s:1870   .data:0000000000000000 nibbles
     /tmp/ccbdKk47.s:2128   .text:0000000000001630 main

UNDEFINED SYMBOLS
flReadChannelAsyncSubmit
errPrefix
flReadChannelAsyncAwait
fwrite
fread
flWriteChannelAsync
flAwaitAsyncWrites
__stack_chk_fail
bufInitialise
__errno_location
strtoul
malloc
strncpy
fopen
free
gettimeofday
printf
fclose
bufAppendConst
flReadChannel
flWriteChannel
flSelectConduit
dump
bufDestroy
stderr
fprintf
fputc
arg_str0
arg_str1
arg_uint0
arg_lit0
arg_end
arg_nullcheck
arg_parse
stdout
arg_print_syntax
puts
arg_print_glossary
arg_print_errors
flInitialise
flOpen
flLoadCustomFirmware
flLoadStandardFirmware
flSleep
putchar
fflush
flIsDeviceAvailable
flGetFirmwareVersion
flGetFirmwareID
strcmp
flFlashStandardFirmware
flFlashCustomFirmware
flSaveFirmware
flResetToggle
flIsNeroCapable
flIsCommCapable
flMultiBitPortAccess
sprintf
jtagScanChain
flProgram
flIsFPGARunning
sigRegisterHandler
sigIsRaised
readline
add_history
flClose
flFreeError
